"use strict"
const version = "Beta 1.1.1"
let win, isNode = false
try{
win = window
}catch{
win = module.exports
isNode = true
}
let workerCount, workerURL
if(isNode){
workerCount = 1//require("os").cpus()
workerURL = __dirname+"/worker.js"
win.Worker = require("worker_threads").Worker
}else{
workerCount = navigator.hardwareConcurrency
workerURL = URL.createObjectURL(new Blob([document.querySelector("#workerCode").text], { type: "text/javascript" }))
}
win.version = version
workerCount = (workerCount || 4) - 1 || 1
{
// I'm throwing stuff in the window scope since I can't be bothered to figure out how all this fancy import export stuff works
let workers = win.workers = []
let allWorkers = win.allWorkers = []
let waitingJobs = [], waitingMsgs = []
for (let i = 0, count = workerCount; i < count; i++) { // Generate between 1 and (processors - 1) workers.
let worker = new win.Worker(workerURL)
worker.id = i
let doNewJob = function(){
workers.push(worker)
if(waitingMsgs[worker.id].length){
waitingMsgs[worker.id].shift()()
}else if(waitingJobs.length){
waitingJobs.shift()()
}
}
let onmessage = function(e){
let data = isNode ? e : e.data
if(data === "started") return doNewJob()
let [promise, resolve, onProgress] = worker.theJob
if(data.progress){
return onProgress(data.progress)
}
resolve(data)
doNewJob()
}
if(isNode) worker.on("message",onmessage)
else worker.onmessage = onmessage
//workers.push(worker)//done when started
allWorkers.push(worker)
waitingMsgs.push([])
}
win.doWork = function(data,onProgress) {
let job = []
let promise = new Promise(resolve => {
job[1] = resolve
let worker = workers.shift()
if(!worker){
waitingJobs.push(() => {
worker = workers.shift()
worker.theJob = job
worker.postMessage(data)
})
}else{
worker.theJob = job
worker.postMessage(data)
}
})
job[0] = promise
job[2] = onProgress
return promise
}
function sendMsg(data,id){
let job = []
let promise = new Promise(resolve => {
job[1] = resolve
let worker = allWorkers[id]
if(!workers.includes(worker)){
waitingMsgs[id].push(() => {
worker = allWorkers[id]
workers.splice(workers.indexOf(worker),1)
worker.theJob = job
worker.postMessage(data)
})
}else{
workers.splice(workers.indexOf(worker),1)
worker.theJob = job
worker.postMessage(data)
}
})
job[0] = promise
return promise
}
win.sendAllWorkers = async function(msg){
let p = []
for(let i=0; i<allWorkers.length; i++){
p.push(sendMsg(msg,i))
}
await Promise.all(p)
}
}
const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2, tan } = Math;
const rand = function(a,b){
if(arguments.length === 2){
return (Math.random()*(b-a))+a
}else if(arguments.length === 1){
return Math.random()*a
}else return Math.random()
}
const avg = function(){
var res = 0, c = 0
for(var i=0; i<arguments.length; i++){
if(!arguments[i] && arguments[i] !== 0) continue
res += arguments[i]
c++
}
res /= c
return res
}
/*const divideWithRemainder = function(a,b){
var n=a/b
var f=floor(n)
var r=n-f
n=f
r=floor(r*b)
return {n,r}
}*/
const mod = function(a,b){
return a - floor(a/b)*b
}
Math.PI2 = Math.PI / 2
Math.PI4 = Math.PI / 4
Math.PId = Math.PI * 2
function xyArrayHas(arr,arr2,x,y,z,arrLen=arr.length,arr2Len=arr2&&arr2.length){
for(var i=0; i<arrLen; i+=4){
if(arr[i] === x && arr[i+1] === y && arr[i+2] === z){
return true
}
}
if(arr2){
for(var i=0; i<arr2Len; i+=4){
if(arr2[i] === x && arr2[i+1] === y && arr2[i+2] === z){
return true
}
}
}
}
//from https://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers
function insertSorted(array, value) {
let low = 0,
high = array.length;
while (low < high) {
let mid = (low + high) >>> 1;
if (array[mid] < value) low = mid + 1;
else high = mid;
}
array.splice(low,0,value)
return array
}
function emptyIfNullish(v){
return v||v===0 ? v : ""
}
// Shh don't tell anyone I'm override native objects
String.prototype.hashCode = function() {
var hash = 0, i, chr;
if (this.length === 0) return hash;
for (i = 0; i < this.length; i++) {
chr   = this.charCodeAt(i);
hash  = ((hash << 5) - hash) + chr;
hash |= 0; // Convert to 32bit integer
}
return hash;
}
Uint8Array.prototype.toString = function() {
let str = ""
for (let i = 0; i < this.length; i++) {
str += String.fromCharCode(this[i])
}
return btoa(str)
}
/*Uint8Array.prototype.toJSON = function(){
return "BitArray("+this.length*8+")"
}*/
function atoarr(data){
let bytes = atob(data)
let arr = new Uint8Array(bytes.length)
for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i)
return arr
}
function chunkString (str, len) {
const size = Math.ceil(str.length/len)
const r = Array(size)
let offset = 0
for (let i = 0; i < size; i++) {
r[i] = str.substr(offset, len)
offset += len
}
return r
}
function chunkArray(array,chunkSize){
let chunks = []
for (let i = 0; i < array.length; i += chunkSize) {
const chunk = array.slice(i, i + chunkSize);
chunks.push(chunk)
}
return chunks
}
function hex2bin(hex){//from https://stackoverflow.com/questions/45053624/convert-hex-to-binary-in-javascript
hex = hex.toLowerCase()
var out = "";
for(var c of hex) {
switch(c) {
case '0': out += "0000"; break;
case '1': out += "0001"; break;
case '2': out += "0010"; break;
case '3': out += "0011"; break;
case '4': out += "0100"; break;
case '5': out += "0101"; break;
case '6': out += "0110"; break;
case '7': out += "0111"; break;
case '8': out += "1000"; break;
case '9': out += "1001"; break;
case 'a': out += "1010"; break;
case 'b': out += "1011"; break;
case 'c': out += "1100"; break;
case 'd': out += "1101"; break;
case 'e': out += "1110"; break;
case 'f': out += "1111"; break;
default: return "";
}
}
return out;
}
function sleep(ms) {
return new Promise(resolve => setTimeout(resolve, ms))
}
const generateID = () => "" + Date.now().toString(36) + (Math.random() * 1000000 | 0).toString(36)
function map(v, min, max, min2, max2){
return min2 + (max2 - min2) * ((v - min) / (max - min));
}
function mapFrom(v, min, max){
return (v - min) / (max - min)
}
function mapClamped(v, min, max){
return Math.min(Math.max(((v - min) / (max - min)),0),1);
}
function lerp(t, a, b) {
return a + t * (b - a);
}
function dist2(x,y,x2,y2){
let xDist = x - x2
let yDist = y - y2
return sqrt((xDist*xDist)+(yDist*yDist))
}
function dist3(x,y,z,x2,y2,z2){
let xDist = x - x2
let yDist = y - y2
let zDist = z - z2
return sqrt((xDist*xDist)+(yDist*yDist)+(zDist*zDist))
}
function dist3Sq(x,y,z,x2,y2,z2){
let xDist = x - x2
let yDist = y - y2
let zDist = z - z2
return (xDist*xDist)+(yDist*yDist)+(zDist*zDist)
}
function mag(x,y,z) {
return sqrt(x * x + y * y + z * z)
}
function angleOf(x,y,fromx,fromy){
let a = atan2(x - fromx, y - fromy)
if(a<0) a+=Math.PId
return a
}
function line3DConncected(endX, endY, endZ, startX, startY, startZ, array){
var x1 = Math.round(endX), y1 = Math.round(endY), z1 = Math.round(endZ), x0 = Math.round(startX), y0 = Math.round(startY), z0 = Math.round(startZ);
var dx = Math.abs(x1 - x0);
var dy = Math.abs(y1 - y0);
var dz = Math.abs(z1 - z0);
var stepX = x0 < x1 ? 1 : -1;
var stepY = y0 < y1 ? 1 : -1;
var stepZ = z0 < z1 ? 1 : -1;
var hypotenuse = Math.sqrt(dx*dx + dy*dy + dz*dz);
var tMaxX = hypotenuse*0.5 / dx;
var tMaxY = hypotenuse*0.5 / dy;
var tMaxZ = hypotenuse*0.5 / dz;
var tDeltaX = hypotenuse / dx;
var tDeltaY = hypotenuse / dy;
var tDeltaZ = hypotenuse / dz;
while (x0 !== x1 || y0 !== y1 || z0 !== z1){
if (tMaxX < tMaxY) {
if (tMaxX < tMaxZ) {
x0 = x0 + stepX;
tMaxX = tMaxX + tDeltaX;
} else if (tMaxX > tMaxZ){
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
} else{
x0 = x0 + stepX;
tMaxX = tMaxX + tDeltaX;
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
}
} else if (tMaxX > tMaxY){
if (tMaxY < tMaxZ) {
y0 = y0 + stepY;
tMaxY = tMaxY + tDeltaY;
} else if (tMaxY > tMaxZ){
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
} else{
y0 = y0 + stepY;
tMaxY = tMaxY + tDeltaY;
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
}
} else{
if (tMaxY < tMaxZ) {
y0 = y0 + stepY;
tMaxY = tMaxY + tDeltaY;
x0 = x0 + stepX;
tMaxX = tMaxX + tDeltaX;
} else if (tMaxY > tMaxZ){
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
} else{
x0 = x0 + stepX;
tMaxX = tMaxX + tDeltaX;
y0 = y0 + stepY;
tMaxY = tMaxY + tDeltaY;
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
}
}
array.push(x0, y0, z0);
}
}
//https://www.geeksforgeeks.org/bresenhams-algorithm-for-3-d-line-drawing/
function line3D(x2, y2, z2, x1, y1, z1, array){
x1 = round(x1)
y1 = round(y1)
z1 = round(z1)
x2 = round(x2)
y2 = round(y2)
z2 = round(z2)
array.push(x1, y1, z1);
let dx = abs(x2 - x1);
let dy = abs(y2 - y1);
let dz = abs(z2 - z1);
let xs;
let ys;
let zs;
if (x2 > x1) {
xs = 1;
} else {
xs = -1;
}
if (y2 > y1) {
ys = 1;
} else {
ys = -1;
}
if (z2 > z1) {
zs = 1;
} else {
zs = -1;
}
// Driving axis is X-axis"
if (dx >= dy && dx >= dz) {
let p1 = 2 * dy - dx;
let p2 = 2 * dz - dx;
while (x1 != x2) {
x1 += xs;
if (p1 >= 0) {
y1 += ys;
p1 -= 2 * dx;
}
if (p2 >= 0) {
z1 += zs;
p2 -= 2 * dx;
}
p1 += 2 * dy;
p2 += 2 * dz;
array.push(x1, y1, z1);
}
// Driving axis is Y-axis"
} else if (dy >= dx && dy >= dz) {
let p1 = 2 * dx - dy;
let p2 = 2 * dz - dy;
while (y1 != y2) {
y1 += ys;
if (p1 >= 0) {
x1 += xs;
p1 -= 2 * dy;
}
if (p2 >= 0) {
z1 += zs;
p2 -= 2 * dy;
}
p1 += 2 * dx;
p2 += 2 * dz;
array.push(x1, y1, z1);
}
// Driving axis is Z-axis"
} else {
let p1 = 2 * dy - dz;
let p2 = 2 * dx - dz;
while (z1 != z2) {
z1 += zs;
if (p1 >= 0) {
y1 += ys;
p1 -= 2 * dz;
}
if (p2 >= 0) {
x1 += xs;
p2 -= 2 * dz;
}
p1 += 2 * dy;
p2 += 2 * dx;
array.push(x1, y1, z1);
}
}
}
let emptyFunc = function(){}
// await window.yieldThread() will pause the current task until the event loop is cleared
{
const channel = new MessageChannel()
let toYield = {}, toYieldId = 0
channel.port1.onmessage = e => {
toYield[e.data]()
delete toYield[e.data]
}
win.yieldThread = function() {
return new Promise(resolve => {
let id = toYieldId++
toYield[id] = resolve
channel.port2.postMessage(id)
})
}
}
function mapFrom(v, min, max){
return ((v - min) / (max - min))
}
function preferMiddle(x,middle,resMin,resMax){
//x is 0 to 1
//middle is a big number between resMin and resMax
let prevMiddle = middle
middle = mapFrom(middle,resMin,resMax)
if(x>middle){
x = mapFrom(x,middle,1)
x **= 2
x = lerp(x,prevMiddle,resMax)
}else{
x = mapFrom(x,middle,0)
x **= 2
x = lerp(x,prevMiddle,resMin)
}
return x
}
function preferMiddleSimple(x){
let px = x
x = (x-0.5)*2
x**=3
x = x/2+0.5
return x
}
{//Begin
let tickSpeed = 20
let tickTime = 1000/tickSpeed
function fillTextureArray(textures){
if (textures.length === 3) {
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
} else if (textures.length === 2) {
// Top and bottom are the first texture, sides are the second.
textures[2] = textures[1];
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
textures[1] = textures[0];
}else if(textures.length === 4){
textures[4] = textures[5] = textures[3]
textures[3] = textures[2]
}
return textures
}
let sit
let generator = {
height: 80, // Height of the hills
smooth: 0.01, // Smoothness of the terrain
extra: 30, // Extra height added to the world.
caveSize: 0.00, // Redefined right above where it's used
biomeSmooth: 0.007, // Smoothness of biomes
}
win.generator = generator //for mods
const {doWork, sendAllWorkers, yieldThread} = win
const maxHeight = 319
const minHeight = -64
const weatherHeight = 192
const minEntityY = minHeight-40
const netherHeight = 127
const waterHeight = 62
const blockData = [
{
name: "air",
id: 0,
textures: new Array(6).fill("none"),
transparent: true,
shadow: false,
hidden: true
},
{
name: "grass",
Name: "Grass Block",
textures: [ "dirt", "grassTop", "grassSide" ],
hardness: 0.6,
blastResistance:0.6,
drop:"dirt",
type:"ground",
grassSound: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isSnow = blockData[top].name === "snow" || blockData[top].name === "snowBlock"
if(b === blockIds.grass && isSnow){
world.setBlock(x,y,z,blockIds.grass | CROSS,false,false,false,false,dimension)
}else if(b === (blockIds.grass | CROSS) && !isSnow){
world.setBlock(x,y,z,blockIds.grass,false,false,false,false,dimension)
}
},
compostChance:0.3,
category:"nature",
craftSlabs:true, craftStairs:true,
},
{ name: "dirt", Name:"Dirt", hardness:0.5, blastResistance:0.5, type:"ground",category:"nature",
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
},
{ name: "stone", Name:"Stone", drop:"cobblestone", type:"rock1",category:"nature", hardness:5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "bedrock", Name:"Bedrock", category:"nature", hardness:1000, blastResistance:3600000, stoneSound:true, pistonPush:false, pistonPull:false},
{ name: "sand", Name:"Sand", hardness:0.5, blastResistance:0.5,fallingDust:[212/255, 195/255, 148/255], category:"nature",
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
digSound: ["sand.dig1", "sand.dig2", "sand.dig3", "sand.dig4"],
stepSound: ["sand.step1", "sand.step2","sand.step3","sand.step4","sand.step5"]},
{ name: "gravel", Name:"Gravel", hardness:0.6, blastResistance:0.6, type:"ground",category:"nature",fallingDust:[132/255, 126/255, 124/255],
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
drop: function(){
if(round(random(10)) === 1) return "flint"
else return "gravel"
},
digSound: ["gravel.dig1", "gravel.dig2", "gravel.dig3", "gravel.dig4"],
stepSound: ["gravel.step1", "gravel.step2","gravel.step3","gravel.step4"]},
{
name: "leaves",
Name: "Leaves",
transparent: true,
shadow:false,
cullFace:"never",
hardness: 0.2,
blastResistance:0.2,
type:"plant2",
category:"nature",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "oakSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
decreaseLight:1
},
{
name: "glass",
Name:"Glass",
transparent: true,
shadow: false,
hardness: 0.3,
blastResistance:0.3,
type: "glass",
category:"build",
glassSound: true
},
{ name: "cobblestone", Name:"Cobblestone", hardness:2, blastResistance:6, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "mossyCobble", Name:"Mossy Cobblestone", hardness:2, blastResistance:6, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "stoneBricks", Name:"Stone Bricks", hardness:1.5, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "mossyStoneBricks", Name:"Mossy Stone Bricks", hardness:1.5, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "bricks", Name:"Bricks", hardness:2, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "coalOre", Name:"Coal Ore", hardness:3, type:"rock1",category:"nature", drop:"coal", stoneSound:true, experience:0.1},
{ name: "ironOre", Name:"Iron Ore", hardness:3, type:"rock2",category:"nature", drop:"rawIron", stoneSound:true, dropAmount:[1,3]},
{ name: "goldOre", Name:"Gold Ore", hardness:3, type:"rock3",category:"nature", drop:"rawGold", stoneSound:true, dropAmount:[1,3]},
{ name: "diamondOre", Name:"Diamond Ore", hardness:3, type:"rock3",category:"nature", drop:"diamond", stoneSound:true, experience:1, dropAmount:[1,3]},
{ name: "redstoneOre", Name:"Redstone Ore", hardness:3, type:"rock3",category:"nature", stoneSound:true, drop:"redstone", dropAmount:[6,9], experience:0.3},
{ name: "lapisOre", Name:"Lapis Lazuli Ore", hardness:3, type:"rock2",category:"nature", drop:"lapisLazuli", stoneSound:true, experience:0.5, dropAmount:[1,3]},
{ name: "emeraldOre", Name:"Emerald Ore", hardness:3, type:"rock3",category:"nature", drop:"emerald", stoneSound:true, experience:1.5, dropAmount:[1,3]},
{ name: "coalBlock", Name:"Block of Coal", hardness:5, type:"rock1",category:"build", stoneSound:true, burnChance:0.4, burnTime:50},
{ name: "ironBlock", Name:"Block of Iron", hardness:5, type:"metal2",category:"build", stoneSound:true},
{ name: "goldBlock", Name:"Block of Gold", hardness:3, type:"metal3",category:"build", stoneSound:true},
{ name: "diamondBlock", Name:"Block of Diamond", hardness:3, type:"metal3",category:"build", stoneSound:true},
{
name: "redstoneBlock", Name:"Block of Redstone", hardness:5, type:"metal1",category:"redstone", stoneSound:true,
onset:function(x,y,z,dimension,world){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z, 16,dimension)
},
ondelete: function(x,y,z,prevTags,prev,dimension,world){
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z, 16,false,dimension)
},
damage:1,
dieMessage: () => username+" died from radiation from block of redstone."
},
{ name: "lapisBlock", Name:"Block of Lapis Lazuli", hardness:3, type:"metal2",category:"build", stoneSound:true},
{ name: "emeraldBlock", Name:"Block of Emerald", hardness:5, type:"metal3",category:"build", stoneSound:true},
{ name: "oakPlanks", Name:"Oak Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "oakLog",
Name:"Oak Log",
textures: [ "logTop", "logSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "acaciaPlanks", Name:"Acacia Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "acaciaLog",
Name:"Acacia Log",
textures: [ "acaciaLogTop", "acaciaLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "birchPlanks", Name:"Birch Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "birchLog",
Name:"Birch Log",
textures: [ "birchLogTop", "birchLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "darkOakPlanks", Name:"Dark Oak Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "darkOakLog",
Name:"Dark Oak Log",
textures: [ "darkOakLogTop", "darkOakLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "junglePlanks", Name:"Jungle Planks", type:"wood",category:"build", hardness:2,woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "jungleLog",
Name:"Jungle Log",
textures: [ "jungleLogTop", "jungleLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "sprucePlanks", Name:"Spruce Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "spruceLog",
Name:"Spruce Log",
textures: [ "spruceLogTop", "spruceLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "whiteWool", Name:"White Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "orangeWool", Name:"Orange Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "magentaWool", Name:"Magenta Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "lightBlueWool", Name:"Light Blue Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "yellowWool", Name:"Yellow Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "limeWool", Name:"Lime Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "pinkWool", Name:"Pink Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "grayWool", Name:"Gray Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "lightGrayWool", Name:"Light Gray Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "cyanWool", Name:"Cyan Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "purpleWool", Name:"Purple Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "blueWool", Name:"Blue Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "brownWool", Name:"Brown Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "greenWool", Name:"Green Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "redWool", Name:"Red Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "blackWool", Name:"Black Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "whiteConcrete", Name:"White Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "orangeConcrete", Name:"Orange Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "magentaConcrete", Name:"Magenta Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "lightBlueConcrete", Name:"Light Blue Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "yellowConcrete", Name:"Yellow Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "limeConcrete", Name:"Lime Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "pinkConcrete", Name:"Pink Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "grayConcrete", Name:"Gray Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "lightGrayConcrete", Name:"Light Gray Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "cyanConcrete", Name:"Cyan Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "purpleConcrete", Name:"Purple Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "blueConcrete", Name:"Blue Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "brownConcrete", Name:"Brown Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "greenConcrete", Name:"Green Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "redConcrete", Name:"Red Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "blackConcrete", Name:"Black Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{
name: "bookshelf",
Name:"Bookshelf",
textures: [ "oakPlanks", "bookshelf" ],
stoneSound: true,
type:"wood",
category:"decoration",
burnChance:0.4,
burnTime:30
},
{ name: "netherrack",
Name:"Netherrack",
hardness:0.4,
type:"rock1",
category:"nature",
burnTime:Infinity,
digSound: ["netherrack.dig1", "netherrack.dig2", "netherrack.dig3", "netherrack.dig4", "netherrack.dig5", "netherrack.dig6"],
stepSound: ["netherrack.step1", "netherrack.step2","netherrack.step3","netherrack.step4","netherrack.step5","netherrack.step6"],
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "soulSand",
Name:"Soul Sand",
category:"nature",
speedFactor: 0.5,
canHaveSoulFire: true,
digSound: ["soul_sand.dig1", "soul_sand.dig2", "soul_sand.dig3", "soul_sand.dig4", "soul_sand.dig5", "soul_sand.dig6","soul_sand.step7","soul_sand.step8","soul_sand.step9"],
stepSound: ["soul_sand.step1", "soul_sand.step2","soul_sand.step3","soul_sand.step4","soul_sand.step5","soul_sand.step6"],
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name: "glowstone",
Name:"Glowstone",
hardness:0.3,
type:"rock1",
category:"decoration",
lightLevel: 15,
glassSound: true,
shadow:false,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "netherBricks",
Name:"Nether Bricks",
category:"build",
craftSlabs:true, craftStairs:true,
digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
{ name: "redNetherBricks",
Name:"Red Nether Bricks",
category:"build",
craftSlabs:true, craftStairs:true,
digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
{
name: "netherQuartzOre", 
Name:"Nether Quartz Ore",
category:"nature",
digSound: ["nether_ore.dig1", "nether_ore.dig2", "nether_ore.dig3", "nether_ore.dig4"],
stepSound: ["nether_ore.step1", "nether_ore.step2","nether_ore.step3","nether_ore.step4","nether_ore.step5"],
drop: "quartz",
dropAmount: [1,2],
hardness:3,
blastResistance:3,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name: "quartzBlock",
Name:"Block of Quartz",
category:"build",
textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"],
stoneSound: true,
hardness:1.5,
blastResistance:6,
craftSlabs:true, craftStairs:true,
},
{
name: "quartzPillar",
Name:"Pillar",
category:"build",
textures: ["quartzPillarTop", "quartzPillar"],
stoneSound: true,
hardness:1.5,
blastResistance:6
},
{
name: "chiseledQuartzBlock",
Name:"Chiseled Quartz Block",
category:"build",
textures: ["chiseledQuartzBlockTop", "chiseledQuartzBlock"],
stoneSound: true,
hardness:1.5,
blastResistance:6
},
{ name: "chiseledStoneBricks", Name:"Chiseled Stone Bricks",category:"build", hardness:1.5, blastResistance:6, stoneSound:true},
{ name: "smoothStone", Name:"Smooth Stone",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{ name: "andesite", Name:"Andesite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{ name: "polishedAndesite", Name:"Polished Andesite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "diorite", Name:"Diorite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{ name: "polishedDiorite", Name:"Polished Diorite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "granite", Name:"Granite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{ name: "polishedGranite", Name:"Polished Granite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
{ // I swear, if y'all don't stop asking about TNT every 5 minutes!
name: "tnt",
Name:"TNT",
textures: ["tntBottom", "tntTop", "tntSides"],
superTntTextures: ["superTntBottom","superTntTop","superTnt"],
ultraTntTextures: ["ultraTntBottom","ultraTntTop","ultraTnt"],
//onupdate: function(x,y,z){
//  explode(x,y,z,5)
//}, flint and steel explodes it
explode: function(x,y,z, how,dimension,world){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
var e = new entities[entityIds.PrimedTNT](x,y,z)
world.addEntity(e,false,dimension)
world.playSound(x,y,z, "random.fuse")
switch(how){
case "explosion":
e.timeLimit = rand(10,30)
}
},
superTntExplode: function(x,y,z,dimension,world){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
var e = new entities[entityIds.PrimedSuperTNT](x,y,z)
world.addEntity(e,false,dimension)
world.playSound(x,y,z, "random.fuse")
},
ultraTntExplode: function(x,y,z,dimension,world){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
var e = new entities[entityIds.PrimedUltraTNT](x,y,z)
world.addEntity(e,false,dimension)
world.playSound(x,y,z, "random.fuse")
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension)
if(power > 0) this.explode(x,y,z,null,dimension,world)
},
onset:function(x,y,z,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension)
if(power > 0) this.explode(x,y,z,null,dimension,world)
},
burnChance:0.6,
onburn:function(x,y,z,dimension,world){
this.explode(x,y,z,null,dimension,world)
},
category:"redstone",
grassSound: true
},
{
name: "portal",
solid:false,
shadow: false,
portal: true,
transparent:true,
cullFace:"same",
lightLevel: 11,
flatIcon:true,
drop:"air",
glassSound: true,
ambientSound:"portal.portal",
pistonPush:false,
pistonPull:false,
hidden:true,
ontouch: function(x,y,z,dimension,ent){
ent.portalEffect += 2.5
if(ent.portalEffect >= 100 && ent.portalFadeOutEffect <= 0){
if(ent.type === "Player") ent.connection.send({type:"portalOut"})
ent.portalFadeOutEffect = 100
if(ent.dimension === ""){
ent.x /= 8, ent.z /= 8
}else{
ent.x *= 8, ent.z *= 8
}
ent.tp(ent.x,ent.y,ent.z,ent.dimension === "nether" ? "" : "nether")
ent.doingPortal = blockIds.portal
ent.world.playSound(x,y,z,"portal.travel")
if(ent.type === "Player") ent.addAchievment("Into the Nether")
}
},
searchForPortal:function(x,y,z,dimension,world){
for(let x2=0; x2<128; x2++) for(let y2=0; y2<128; y2++) for(let z2=0; z2<128; z2++) {
let x3 = x+((x2%2)?-(x2+1)/2:x2/2)//alternate back and forth, example: 0, -1, 1, -2, 2
let y3 = y+((y2%2)?-(y2+1)/2:y2/2)
let z3 = z+((z2%2)?-(z2+1)/2:z2/2)
if(blockData[world.getBlock(x3,y3,z3,dimension)].name === "portal") return [x3,y3,z3]
}
},
doneLoading:function(p,world){
let portal = this.searchForPortal(round(p.x),round(p.y),round(p.z),p.dimension,world)
if(portal){
p.tp(portal[0],portal[1]-0.5+p.height*0.5,portal[2])
p.lastY = p.y
}else{
let portalFill = 0, px = round(p.x), py = round(p.y), pz = round(p.z) //cant use p2 because just finished loading
let dy = 32
mainLoop:for(let y = 32; y<128; y++){
for(let x=px-2; x<px+2; x++) for(let z=pz-2; z<pz+2; z++){
if(blockData[world.getBlock(x,y,z,p.dimension)].solid){
portalFill = 0
continue mainLoop
}
}
portalFill++, dy = y
if(portalFill === 6) break mainLoop
}
if(portalFill === 6){
let x = px, z = pz, y = dy
if(rand() > 0.5){
world.setBlock(x-2,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x+1,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
//layer2
world.setBlock(x-2,y-4,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-4,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x,y-4,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x+1,y-4,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-2,y-3,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-3,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x+1,y-3,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-2,y-2,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-2,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x+1,y-2,z,blockIds.obsidian,false,false,false,false,p.dimension)
//layer5
world.setBlock(x-2,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x+1,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
}else{
world.setBlock(x,y-5,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-5,z-1,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-5,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
//layer2
world.setBlock(x,y-4,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-4,z-1,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-4,z,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-4,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z-1,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z-1,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
//layer5
world.setBlock(x,y-1,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-1,z-1,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-1,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
}
p.tp(x,dy-5+0.5+p.height*0.5,z)
p.lastY = p.y
}else world.sendAll({type:"message",fromServer:true,data:"§cFailed to find and place portal"})
}
}
},
{ name: "obsidian", Name:"Obsidian", stoneSound:true, type:"rock4",category:"nature", hardness:50, blastResistance:1200, pistonPush:false, pistonPull:false, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
//the old redstone dust added before this version of minekhan was public (early 2021)
/*{
name:"redstoneDust",
onupdate: function(x,y,z){
var neigbors = [
world.getBlock(x+1,y,z),
world.getBlock(x-1,y,z),
world.getBlock(x,y,z+1),
world.getBlock(x,y,z-1),
world.getBlock(x,y+1,z),
world.getBlock(x,y-1,z)
];
if(neigbors.includes(blockIds.redstoneBlock) || neigbors.includes(blockIds.redstoneDustOn)){
world.setBlock(x,y,z, blockIds.redstoneDustOn, false, true)
}
}
},
{
name:"redstoneDustOn",
hidden: true,
onupdate: function(x,y,z){
var checked = []
function touchingSource(x,y,z, t){
t = t || 0;
t ++;
var neighbors = [
[x+1,y,z],
[x-1,y,z],
[x,y,z+1],
[x,y,z-1],
[x,y+1,z],
[x,y-1,z]
];
for(var i=0; i<neighbors.length; i++){
var value = neighbors[i];
var block = world.getBlock(value[0], value[1], value[2])
if(block === blockIds.redstoneBlock){
return true;
}
if(t<10){
if( !(checked.includes[value]) && (block === blockIds.redstoneDust || block === blockIds.buffer) && touchingSource(value[0], value[1], value[2], t)){
checked.push(value);
return true
};
}
}
return false;
}
if(!touchingSource(x,y,z)){
world.setBlock(x,y,z, blockIds.redstoneDust);
}
//world.setBlock(x,y,z, blockIds.redstoneDust);
}
},*/
{
name:"redstone",
Name:"Redstone Dust",
item:true,
useAs:"redstoneDust",
category:"redstone",
},
{
name:"redstoneDust",
textures:"redstoneDustDot",
shadow:false,
transparent:true,
solid:false,
hidden:true,
smoothLight:false,
damage:(x,y,z,dimension,world) => world.getPower(x,y,z,dimension)/15,
dieMessage: () => username+" died from radiation from redstone dust.",
drop: "redstone",
carryRedstone:true,
tagBits:{
north:[0,1],
south:[1,1],
east:[2,1],
west:[3,1],
northUp:[4,1],
southUp:[5,1],
eastUp:[6,1],
westUp:[7,1],
northDown:[8,1],
southDown:[9,1],
eastDown:[10,1],
westDown:[11,1],
up:[12,1],
down:[13,1]
},
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
let tags = world.getTags(x,y,z,dimension)
let north, south, east, west
let northUp = getTagBits(tags,"northUp",this.id), southUp = getTagBits(tags,"southUp",this.id), eastUp = getTagBits(tags,"eastUp",this.id), westUp = getTagBits(tags,"westUp",this.id)
let northDown = getTagBits(tags,"northDown",this.id), southDown = getTagBits(tags,"southDown",this.id), eastDown = getTagBits(tags,"eastDown",this.id), westDown = getTagBits(tags,"westDown",this.id)
let up, down
let pnorthUp = northUp, psouthUp = southUp, peastUp = eastUp, pwestUp = westUp,
pnorthDown = northDown, psouthDown = southDown, peastDown = eastDown, pwestDown = westDown
let above = world.getBlock(x,y+1,z)
if(above && !blockData[above].transparent){
westUp = eastUp = southUp = northUp = up = false
}else{
westUp = this.connectable(x+1,y+1,z,"westUp",dimension,b,world)
eastUp = this.connectable(x-1,y+1,z,"eastUp",dimension,b,world)
southUp = this.connectable(x,y+1,z-1,"southUp",dimension,b,world)
northUp = this.connectable(x,y+1,z+1,"northUp",dimension,b,world)
up = this.connectable(x,y+1,z,"up",dimension,b,world)
}
westDown = this.connectable(x+1,y-1,z,"westDown",dimension,b,world)
eastDown = this.connectable(x-1,y-1,z,"eastDown",dimension,b,world)
southDown = this.connectable(x,y-1,z-1,"southDown",dimension,b,world)
northDown = this.connectable(x,y-1,z+1,"northDown",dimension,b,world)
down = this.connectable(x,y-1,z,"down",dimension,b,world)
west = westUp || westDown || this.connectable(x+1,y,z,"west",dimension,b,world)
east = eastUp || eastDown || this.connectable(x-1,y,z,"east",dimension,b,world)
south = southUp || southDown || this.connectable(x,y,z-1,"south",dimension,b,world)
north = northUp || northDown || this.connectable(x,y,z+1,"north",dimension,b,world)
if(north + south + east + west === 1){
//make it a line. it can't be half of a line
if(north) south = true
if(south) north = true
if(east) west = true
if(west) east = true
}
if(up || down){
north = south = east = west = true
}
world.setTagByName(x,y,z,"north",north,true,dimension,true)
world.setTagByName(x,y,z,"south",south,true,dimension,true)
world.setTagByName(x,y,z,"east",east,true,dimension,true)
world.setTagByName(x,y,z,"west",west,true,dimension,true)
world.setTagByName(x,y,z,"northUp",northUp,true,dimension,true)
world.setTagByName(x,y,z,"southUp",southUp,true,dimension,true)
world.setTagByName(x,y,z,"eastUp",eastUp,true,dimension,true)
world.setTagByName(x,y,z,"westUp",westUp,true,dimension,true)
world.setTagByName(x,y,z,"northDown",northDown,true,dimension,true)
world.setTagByName(x,y,z,"southDown",southDown,true,dimension,true)
world.setTagByName(x,y,z,"eastDown",eastDown,true,dimension,true)
world.setTagByName(x,y,z,"westDown",westDown,true,dimension,true)
world.setTagByName(x,y,z,"up",up,true,dimension,true)
world.setTagByName(x,y,z,"down",down,false,dimension,false)//notice last one not lazy and not remote
//set texture and stuff
let sum = north + south + east + west
let block = this.id //dot
if(sum === 2){
if(north && west) block = this.id | STAIR | EAST
else if(west && south) block = this.id | STAIR | SOUTH
else if(south && east) block = this.id | STAIR | WEST
else if(east && north) block = this.id | STAIR | NORTH
else{
if(north || south) block = this.id | SLAB | NORTH
if(east || west) block = this.id | SLAB | EAST
}
}else if(sum === 3){
if(east && west){
if(north) block = this.id | DOOR | NORTH
else block = this.id | DOOR | SOUTH
}else if(north && south){
if(east) block = this.id | DOOR | WEST
else block = this.id | DOOR | EAST
}
}else if(sum === 4) block = this.id | PANE
if((b & FLIP) === FLIP) block |= FLIP //blue redstone
if(world.getBlock(x,y,z,dimension) !== block){
world.setBlock(x,y,z,block,false,false,false,true,dimension)
//world.updateBlock(x,y,z,false,false,null,null,null,dimension)
}
if(pnorthUp != northUp) world.updateBlock(x,y+1,z+1,false,false,null,null,null,dimension), world.unspreadPower(x,y+1,z+1,world.getPower(x,y+1,z+1,dimension), true,dimension)
if(psouthUp != southUp) world.updateBlock(x,y+1,z-1,false,false,null,null,null,dimension), world.unspreadPower(x,y+1,z-1,world.getPower(x,y+1,z-1,dimension), true,dimension)
if(pwestUp != westUp) world.updateBlock(x+1,y+1,z,false,false,null,null,null,dimension), world.unspreadPower(x+1,y+1,z,world.getPower(x+1,y+1,z,dimension), true,dimension)
if(peastUp != eastUp) world.updateBlock(x-1,y+1,z,false,false,null,null,null,dimension), world.unspreadPower(x-1,y+1,z,world.getPower(x-1,y+1,z,dimension), true,dimension)
if(pnorthDown != northDown) world.updateBlock(x,y-1,z+1,false,false,null,null,null,dimension), world.unspreadPower(x,y-1,z+1,world.getPower(x,y-1,z+1,dimension), true,dimension)
if(psouthDown != southDown) world.updateBlock(x,y-1,z-1,false,false,null,null,null,dimension), world.unspreadPower(x,y-1,z-1,world.getPower(x,y-1,z-1,dimension), true,dimension)
if(pwestDown != westDown) world.updateBlock(x+1,y-1,z,false,false,null,null,null,dimension), world.unspreadPower(x+1,y-1,z,world.getPower(x+1,y-1,z,dimension), true,dimension)
if(peastDown != eastDown) world.updateBlock(x-1,y-1,z,false,false,null,null,null,dimension), world.unspreadPower(x-1,y-1,z,world.getPower(x-1,y-1,z,dimension), true,dimension)
//above: number != boolean
this.onpowerupdate(x,y,z,x,y,z,false,dimension,world)
},
onset:function(x,y,z,dimension,world){
//this.onupdate(x,y,z,null,null,null,null,null,dimension)
let power = world.getRedstoneWirePower(x,y,z,dimension)
var strong = world.getSurroundingBlockPower(x,y,z,dimension) === "strong"
if(strong) power = 15
world.setTagByName(x,y,z,"power",power,false,dimension)
if(power) world.spreadPower(x,y,z,power,dimension)
},
ondelete:function(x,y,z,tags,prev,dimension,world){
const power = getTagBits(tags,"power",this.id)
if(power) world.unspreadPower(x,y,z,power,false,dimension)
if(getTagBits(tags,"north",this.id)){
var block = world.getBlock(x,y,z+1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z+1, null, "south",dimension)
}
}
if(getTagBits(tags,"south",this.id)){
var block = world.getBlock(x,y,z-1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z-1, null, "north",dimension)
}
}
if(getTagBits(tags,"west",this.id)){
var block = world.getBlock(x+1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x+1,y,z, null, "east",dimension)
}
}
if(getTagBits(tags,"east",this.id)){
var block = world.getBlock(x-1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x-1,y,z, null, "west",dimension)
}
}
var block = world.getBlock(x,y-1,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y-1,z, null, "top",dimension)
}
//update the diagnolly connecting redstone
if(getTagBits(tags,"northUp",this.id)) world.updateBlock(x,y+1,z+1,false,false,null,null,null,dimension), world.unspreadPower(x,y+1,z+1,world.getPower(x,y+1,z+1,dimension), true,dimension)
if(getTagBits(tags,"southUp",this.id)) world.updateBlock(x,y+1,z-1,false,false,null,null,null,dimension), world.unspreadPower(x,y+1,z-1,world.getPower(x,y+1,z-1,dimension), true,dimension)
if(getTagBits(tags,"westUp",this.id)) world.updateBlock(x+1,y+1,z,false,false,null,null,null,dimension), world.unspreadPower(x+1,y+1,z,world.getPower(x+1,y+1,z,dimension), true,dimension)
if(getTagBits(tags,"eastUp",this.id)) world.updateBlock(x-1,y+1,z,false,false,null,null,null,dimension), world.unspreadPower(x-1,y+1,z,world.getPower(x-1,y+1,z,dimension), true,dimension)
if(getTagBits(tags,"northDown",this.id)) world.updateBlock(x,y-1,z+1,false,false,null,null,null,dimension), world.unspreadPower(x,y-1,z+1,world.getPower(x,y-1,z+1,dimension), true,dimension)
if(getTagBits(tags,"southDown",this.id)) world.updateBlock(x,y-1,z-1,false,false,null,null,null,dimension), world.unspreadPower(x,y-1,z-1,world.getPower(x,y-1,z-1,dimension), true,dimension)
if(getTagBits(tags,"westDown",this.id)) world.updateBlock(x+1,y-1,z,false,false,null,null,null,dimension), world.unspreadPower(x+1,y-1,z,world.getPower(x+1,y-1,z,dimension), true,dimension)
if(getTagBits(tags,"eastDown",this.id)) world.updateBlock(x-1,y-1,z,false,false,null,null,null,dimension), world.unspreadPower(x-1,y-1,z,world.getPower(x-1,y-1,z,dimension), true,dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
if(x===sx && y===sy && z===sz && !blockPowerChanged){
var tags = world.getTags(x,y,z,dimension)
if(getTagBits(tags,"power",this.id)){
if(getTagBits(tags,"north",this.id) && world.getBlockPower(x,y,z+1, "south",dimension) !== "weak"){
var block = world.getBlock(x,y,z+1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z+1, "weak", "south",dimension)
}
}
if(getTagBits(tags,"south",this.id) && world.getBlockPower(x,y,z-1, "north",dimension) !== "weak"){
var block = world.getBlock(x,y,z-1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z-1, "weak", "north",dimension)
}
}
if(getTagBits(tags,"west",this.id) && world.getBlockPower(x+1,y,z, "east",dimension) !== "weak"){
var block = world.getBlock(x+1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x+1,y,z, "weak", "east",dimension)
}
}
if(getTagBits(tags,"east",this.id) && world.getBlockPower(x-1,y,z, "west",dimension) !== "weak"){
var block = world.getBlock(x-1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x-1,y,z, "weak", "west",dimension)
}
}
}else{
if(world.getBlockPower(x,y,z+1, "south",dimension)){
var block = world.getBlock(x,y,z+1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z+1, null, "south",dimension)
}
}
if(world.getBlockPower(x,y,z-1, "north",dimension)){
block = world.getBlock(x,y,z-1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z-1, null, "north",dimension)
}
}
if(world.getBlockPower(x+1,y,z, "east",dimension)){
block = world.getBlock(x+1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x+1,y,z, null, "east",dimension)
}
}
if(world.getBlockPower(x-1,y,z, "west",dimension)){
block = world.getBlock(x-1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x-1,y,z, null, "west",dimension)
}
}
}
var target = getTagBits(tags,"power",this.id) ? "weak" : null
if(target !== world.getBlockPower(x,y-1,z, "top",dimension)){
var block = world.getBlock(x,y-1,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y-1,z, target, "top",dimension)
}
}
}else if(blockPowerChanged){
var shouldBeOn = /*world.getRedstoneWirePower(x,y,z) || */world.getSurroundingBlockPower(x,y,z,dimension) === "strong"
var power = world.getPower(x,y,z,dimension)
if(shouldBeOn && !power){
world.setPower(x,y,z,15,false,dimension)
world.spreadPower(x,y,z,15,dimension)
}else if(!shouldBeOn && power){
world.unspreadPower(x,y,z,15,true,dimension)
}
}
},
connectables: ["redstoneBlock", "redstoneLamp", "tnt", "redstoneTorch", "lever", "redstoneConnector","is:button", "piston","pistonSticky","is:pressurePlate","dropper","dispenser","target","is:coloredRedstoneLamp","noteBlock", "daylightDetector","is:commandBlock"],
connectable: function(x,y,z, d,dimension, b,world) {
var id = world.getBlock(x,y,z,dimension)
if(!id) return false
var up = false, down = false
switch(d){
case "northUp":
case "southUp":
case "eastUp":
case "westUp":
case "up":
up = true
break
case "northDown":
case "southDown":
case "eastDown":
case "westDown":
case "down":
down = true
break
}
if(down && d !== "down"){
var block = world.getBlock(x,y+1,z,dimension)
if(block && !blockData[block].transparent) return false
}
if(up || down) return blockData[id].name === "redstoneDust" && (id & FLIP) === (b & FLIP)
if(blockData[id].name === "redstoneDust" && (id & FLIP) === (b & FLIP)) return true
if(this.connectables.includes(blockData[id].name)) return true
for(var i of this.connectables){
if(i.startsWith("is:")){
if(blockData[id][i.replace("is:","")]) return true
}
}
if(blockData[id].name === "repeater" || blockData[id].name === "notGate"){
var canIt = false
var facing = blockData[id].getFacing(x,y,z,dimension,world)
switch(facing){
case "north":
case "south":
canIt = d === "north" || d === "south"
break
case "east":
case "west":
canIt = d === "east" || d === "west"
}
return canIt
}else if(blockData[id].name === "observer"){
var facing = blockData[id].getFacing(x,y,z,dimension,world)
switch(facing){
case "east":
return d === "east"
case "west":
return d === "west"
case "north":
return d === "south"
case "south":
return d === "north"
}
}else if(blockData[id].logicGate){
var facing = blockData[id].getFacing(x,y,z,dimension,world)
switch(facing){
case "east":
return d === "east" || d === "north" || d === "south"
case "west":
return d === "west" || d === "north" || d === "south"
case "north":
return d === "south" || d === "east" || d === "west"
case "south":
return d === "north" || d === "east" || d === "west"
}
}else if(blockData[id].name === "comparator"){
var facing = blockData[id].getFacing(x,y,z,dimension,world)
var canIt
switch(facing){
case "east":
canIt = canIt || d === "east" || d === "north" || d === "south"
case "west":
canIt = canIt || d === "west" || d === "north" || d === "south"
case "north":
canIt = canIt || d === "south" || d === "east" || d === "west"
case "south":
canIt = canIt || d === "north" || d === "east" || d === "west"
}
switch(facing){
case "north":
case "south":
canIt = canIt || d === "north" || d === "south"
break
case "east":
case "west":
canIt = canIt || d === "east" || d === "west"
}
return canIt
}
return false
}
},
/*{
name: "buffer",
textures: ["bufferTop", "bufferMiddle"],
category:"redstone",
onupdate: function(x,y,z){
setTimeout(() => {
var isOn = world.getBlock(x,y+1,z);
isOn = isOn === blockIds.redstoneDustOn || isOn === blockIds.redstoneBlock;
if(isOn && world.getBlock(x,y-1,z) === blockIds.redstoneDust ){
setTimeout(function(){world.setBlock(x,y-1,z, blockIds.redstoneDustOn)}, 500);
}
}, 10)
}
},*/
{
name:"blueRedstone",
Name:"Blue Redstone Dust",
item:true,
useAs:() => blockIds.redstoneDust | FLIP,
category:"redstone",
},
{ name: "soup",category:"food"},
{ name: "soup2",category:"food"},
{
name: "soup3",
transparent:true,
category:"food"
},
{ name: "soup4",category:"food"},
{ name: "randomSoup",category:"food"},
{
name: "redStain",
transparent: true,
},
{
name:"poision potion",
transparent:true,
crossShape:true,
},
{
name: "light",
textures: "none",
transparent:true,
lightLevel: 15,
solid: false,
iconTexture: "light_15",
flatIcon: true,
shadow: false,
noHitbox:true,
pistonPush:false,
pistonPull:false,
rarity:"epic"
},
{
name: "autumnLeaves",
transparent: true,
cullFace:"never",
burnChance: 0.2,
burnTime: 30,
category:"nature",
decreaseLight:1
},
{
name: "darkLeaves",
transparent: true,
cullFace:"never",
burnChance: 0.2,
burnTime: 30,
category:"nature",
hardness: 0.2,
blastResistance:0.2,
type:"plant2",
drop: function(){
if(rand() > 0.8) return "stick"
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
compostChance:0.3,
grassSound: true,
decreaseLight:1
},
{
name: "redBerryLeaves",
transparent: true,
cullFace:"never",
burnChance: 0.2,
burnTime: 30,
category:"nature",
hardness: 0.2,
blastResistance:0.2,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "greenGrapes"
else if(r === 1) return "purpleGrapes"
else return "stick"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
compostChance:0.3,
grassSound: true,
decreaseLight:1
},
{
name: "blueBerryLeaves",
transparent: true,
cullFace:"never",
burnChance: 0.2,
burnTime: 30,
category:"nature",
hardness: 0.2,
blastResistance:0.2,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "greenGrapes"
else if(r === 1) return "purpleGrapes"
else return "stick"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
compostChance:0.3,
grassSound: true,
decreaseLight:1
},
{
name: "yellowLeaves",
transparent: true,
cullFace:0,
burnChance: 0.2,
burnTime: 30,
category:"nature",
decreaseLight:1,
hardness: 0.2,
},
{ name: "lilyOftheValley",
Name:"Lily of The Valley",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "poppy",
Name:"Poppy",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "dandelion",
Name:"Dandelion",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "blueOrchid",
Name:"Blue Orchid",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
potCross:true
},
{ name: "pinkTulip",
Name:"Pink Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "orangeTulip",
Name:"Orange Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "redTulip",
Name:"Red Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "whiteTulip",
Name:"White Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "azureBluet",
Name:"Azure Bluet",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "cornFlower",
Name:"Cornflower",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "purpleFlower",
Name:"Purple Flower (i don't think this exsists in minecraft)",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
hidden:true
},
{ name: "allium",
Name:"Allium",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "oxeyeDaisy",
Name:"Oxeye Daisy",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "lilac",
Name:"Lilac",
solid: false,
transparent: true,
shadow: false,
textures: "lilacTop",
tallcrossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "roseBush",
Name:"Rose Bush",
solid: false,
transparent: true,
shadow: false,
textures: "roseBushTop",
tallcrossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "peony",
Name:"Peony",
solid: false,
transparent: true,
shadow: false,
textures: "peonyTop",
tallcrossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "witherRose",
Name:"Wither Rose",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
ontouch: (x,y,z,dimension,ent) => ent.applyEffect("wither",1,2,false),
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name: "TallGrass",
Name:"Grass",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
drop: "wheatSeeds",
dropAmount:[0,1],
dropSelfWhenSheared:true,
shearDropAmount:1,
compostChance:0.5,
liquidBreakable:"drop",
category:"nature"
},
{ 
name: "oakDoor",
Name:"Oak Door",
transparent: true,
shadow: false,
textures: "oakDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "spruceDoor",
Name:"Spruce Door",
transparent: true,
shadow: false,
textures:"spruceDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "ironDoor",
Name:"Iron Door",
transparent: true,
shadow: false,
textures:"ironDoorBottom",
door:true,
stoneSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "darkOakDoor",
Name:"Dark Oak Door",
transparent: true,
shadow: false,
textures:"darkOakDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "birchDoor",
Name:"Birch Door",
transparent: true,
shadow: false,
textures:"birchDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "jungleDoor",
Name:"Jungle Door",
transparent: true,
shadow: false,
textures:"jungleDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "acaciaDoor",
Name:"Acacia Door",
transparent: true,
shadow: false,
textures:"acaciaDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "warpedDoor",
Name:"Warped Door",
transparent: true,
shadow: false,
textures:"warpedDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "crimsonDoor",
Name:"Crimson Door",
transparent: true,
shadow: false,
textures:"crimsonDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "torch",
Name:"Torch",
transparent: true,
shadow: false,
torch: true,
lightLevel: 13,
woodSound:true,
solid:false,
category:"decoration"
},
{
name: "soulTorch",
Name:"Soul Torch",
transparent: true,
shadow: false,
torch: true,
lightLevel: 10,
woodSound:true,
solid:false,
category:"decoration"
},
{
name: "lantern",
Name:"Lantern",
transparent: true,
shadow: false,
lightLevel: 13,
iconTexture: "lanternIcon",
lantern: true,
category:"decoration",
digSound: ["lantern.dig1", "lantern.dig2", "lantern.dig3", "lantern.dig4", "lantern.dig5", "lantern.dig6"],
placeSound: ["lantern.place1", "lantern.place2","lantern.place3","lantern.place4","lantern.place5","lantern.place6"]
},
{
name: "soulLantern",
Name:"Soul Lantern",
transparent: true,
shadow: false,
lightLevel: 10,
iconTexture:"soulLanternIcon",
lantern: true,
category:"decoration",
digSound: ["lantern.dig1", "lantern.dig2", "lantern.dig3", "lantern.dig4", "lantern.dig5", "lantern.dig6"],
placeSound: ["lantern.place1", "lantern.place2","lantern.place3","lantern.place4","lantern.place5","lantern.place6"]
},
{
name: "beacon",
Name:"Beacon",
hardness:3,
transparent: true,
shadow: false,
beacon: true,
lightLevel: 15,
glassSound: true,
pistonPush:false,
pistonPull:false,
category:"decoration",
rarity:"rare",
tagBits:null,
beaconBlocks:["ironBlock","goldBlock","emeraldBlock","diamondBlock","netheriteBlock"],
getSize:function(x,y,z,dimension,world){
let minSize
sizeLoop:for(let size=1; size<4; size++){
for(let x2=x-size; x2<=x+size; x2++) for(let z2=z-size; z2<=z+size; z2++){
let block2 = world.getBlock(x2,y-size,z2)
if(!this.beaconBlocks.includes(blockData[block2].name)) break sizeLoop
}
minSize = size
}
return minSize
},
update: function(x,y,z,dimension,world){
let minSize = this.getSize(x,y,z,dimension,world), block = world.getBlock(x,y,z,dimension)
if(minSize){
if(block !== (this.id | BEACON)){
world.setBlock(x,y,z,this.id|BEACON,false,false,false,true,dimension)
}
}else if(block !== this.id) world.setBlock(x,y,z,this.id,false,false,false,true,dimension)
return minSize
},
onplace: function(x,y,z, dimension, player,world){
this.update(x,y,z,dimension,world)
}
},
{
name: "cactus",
Name:"Cactus",
textures: ["cactusBottom", "cactusTop", "cactusSide"],
transparent: true,
cactus: true,
damage: 1,
potCross: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.5,
liquidBreakable:"drop",
category:"nature"
},
{
name: "glassPane",
Name:"Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["glassPaneTop","glassPaneTop","glass","glass","glassPaneSide","glassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "ladder",
Name:"Ladder",
transparent: true,
shadow: false,
wallFlat: true,ladder:true,
hardness:0.4,
type:"wood",
category:"decoration"
},
{
name: "vine",
Name:"Vine",
transparent: true,
shadow: false,
wallFlat: true,ladder:true,
drop:"air",
dropSelfWhenSheared:true,
shearBreakTime:0.35,
liquidBreakable:"drop",
solid:false,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var fx = x, fz = z
switch(b){
case this.id | WALLFLAT | NORTH:
fz++
break
case this.id | WALLFLAT | SOUTH:
fz--
break
case this.id | WALLFLAT | EAST:
fx++
break
case this.id | WALLFLAT | WEST:
fx--
break
}
var block = world.getBlock(fx,y,fz,dimension)
var above = world.getBlock(x,y+1,z,dimension)
if(!world.settings.blocksFall || block && blockData[block].solid || above === b) return
world.setTimeout(function(){
var block = world.getBlock(fx,y,fz,dimension)
var above = world.getBlock(x,y+1,z,dimension)
if(block && blockData[block].solid || above === b) return
world.setBlock(x,y,z, 0,false,false,false,false,dimension)
world.addItems(x,y,z,dimension,0,0,0,b&isCube,true)
world.blockParticles(b,x,y,z,30, "break",dimension)
world.blockSound(b, "dig", x,y,z)
},tickTime,x,y,z,dimension)
},
compostChance:0.5,
category:"nature"
},
{
name: "Water",
textures:["Water","waterFlow"],
transparent: true,
liquid: true,
wet:true,
solid:false,
shadow: false,
cullFace:"never",
blastResistance:100,
hidden:true,
dripThroughBlocks:[43/255, 63/255, 213/255],
getLevelDifference:function(level){return level-1},
canDuplicate:true,
drop:"air",
density:1,
inLiquid:1,
flowSound:"liquid.water",
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var block = world.getBlock(x,y+1,z,dimension)
if (block && blockData[block].name === "Lava") {
return world.setBlock(x,y,z,blockIds.stone,false,false,false,false,dimension)
}
var n = world.getBlock(x,y,z+1,dimension)
var s = world.getBlock(x,y,z-1,dimension)
var e = world.getBlock(x+1,y,z,dimension)
var w = world.getBlock(x-1,y,z,dimension)
if (n && blockData[n].name === "Lava" || s && blockData[s].name === "Lava" || e && blockData[e].name === "Lava" || w && blockData[w].name === "Lava") {
return world.setBlock(x,y,z,blockIds.cobblestone,false,false,false,false,dimension)
}
if(!world.settings.blocksFall) return
var me = this
world.setTimeout(() => me.flow(x,y,z,dimension,world), tickTime*5, x,y,z,dimension)
},
getY:function(x,y,z,dimension){
var block = world.getBlock(x,y,z,dimension)
return (min((this.getLevel(block) || (block ? 8 : 0))*2,14.5)/16)-0.5
},
decreaseLight:1,
},
{
name: "Lava",
textures:["Lava","lavaFlow"],
transparent: true,
liquid: true,
solid:false,
lightLevel:15,
damage:4,
burnEnt:true,
dieMessage: () => username+" tried to swim in lava.",
shadow: false,
blastResistance:100,
hidden:true,
temperature:25,
dripThroughBlocks:[210/255, 59/255, 17/255],
drop:"air",
density:2,
inLiquid:2,
flowSound:"liquid.lava",
getLevelDifference:function(level,dimension){return dimension === "nether" ? level-1 : level-2},
tick:function(x,y,z,dimension,world){
blockData[blockIds.fire].spread(x,y,z,dimension,world)
},
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
let block = world.getBlock(x,y+1,z,dimension)
if (block && blockData[block].name === "Water") {
return world.setBlock(x,y,z,blockIds.obsidian,false,false,false,false,dimension)
}
const under = world.getBlock(x,y-1,z,dimension)
const n = world.getBlock(x,y,z+1,dimension)
const s = world.getBlock(x,y,z-1,dimension)
const e = world.getBlock(x+1,y,z,dimension)
const w = world.getBlock(x-1,y,z,dimension)
if(blockData[under].name === "soulSoil"){
if (blockData[n].name === "ice" || blockData[n].name === "packedIce" || blockData[n].name === "blueIce" || blockData[s].name === "ice" || blockData[s].name === "packedIce" || blockData[s].name === "blueIce" || blockData[e].name === "ice" || blockData[e].name === "packedIce" || blockData[e].name === "blueIce" || blockData[w].name === "ice" || blockData[w].name === "packedIce" || blockData[w].name === "blueIce") {
return world.setBlock(x,y,z,blockIds.basalt,false,false,false,false,dimension)
}
}
if(blockData[under].name === "honeyBlock" || blockData[n].name === "honeyBlock" || blockData[s].name === "honeyBlock" || blockData[e].name === "honeyBlock" || blockData[w].name === "honeyBlock"){
return world.setBlock(x,y,z,blockIds.limestone,false,false,false,false,dimension)
}
if(!world.settings.blocksFall) return
var me = this
world.setTimeout(() => me.flow(x,y,z,dimension,world), tickTime*(dimension === "nether" ? 10 : 30), x,y,z,dimension)
},
getY:function(x,y,z,dimension){
var block = world.getBlock(x,y,z,dimension)
return (min((this.getLevel(block))*2,14.5)/16)-0.5
},
onspawnflow:function(x,y,z,dimension,world){
const under = world.getBlock(x,y-1,z,dimension)
if(under === blockIds.Water){
world.spawnBlock(x,y-1,z,blockIds.stone,dimension,true)
return true
}
},
},
{
name: "craftingTable",
Name:"Crafting Table",
textures: ["oakPlanks","craftingTableTop","craftingTableFront","craftingTableSide"],
onclientclick: () => {changeScene("crafting"); releasePointer()},
woodSound: true,
hardness:2.5,
type:"wood",
category:"items"
},
{
name: "crimsonNylium",
Name:"Crimson Nylium",
textures: ["netherrack", "crimsonNyliumTop", "crimsonNyliumSide"],
nyliumSound: true,
category:"nature",
hardness:0.4,
blastResistance:0.4,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true
},
{
name: "warpedNylium",
Name:"Warped Nylium",
textures: ["netherrack", "warpedNyliumTop", "warpedNyliumSide"],
nyliumSound: true,
category:"nature",
hardness:0.4,
blastResistance:0.4,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true
},
{
name: "crimsonStem",
Name:"Crimson Stem",
textures: ["crimsonStemTop", "crimsonStemSide"],
stemSound: true,
hardness:2,
blastResistance:2,
type:"wood",
category:"nature"
},
{
name: "warpedStem",
Name:"Warped Stem",
textures: ["warpedStemTop", "warpedStemSide"],
stemSound: true,
hardness:2,
blastResistance:2,
type:"wood",
category:"nature"
},
{ name: "netherWartBlock",
Name:"Nether Wart Block",hardness:1,compostChance:0.85,category:"nature",
digSound: ["netherwart.dig1", "netherwart.dig2", "netherwart.dig3", "netherwart.dig4", "netherwart.dig5", "netherwart.dig6"],
stepSound: ["netherwart.step1", "netherwart.step2","netherwart.step3","netherwart.step4","netherwart.step5"],
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "warpedWartBlock",
Name:"Warped Wart Block",hardness:1,compostChance:0.85,category:"nature",
digSound: ["netherwart.dig1", "netherwart.dig2", "netherwart.dig3", "netherwart.dig4", "netherwart.dig5", "netherwart.dig6"],
stepSound: ["netherwart.step1", "netherwart.step2","netherwart.step3","netherwart.step4","netherwart.step5"],
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "shroomlight", lightLevel:15,Name:"Shroomlight",hardness:1,compostChance:0.65,category:"nature",
digSound: ["shroomlight.dig1", "shroomlight.dig2", "shroomlight.dig3", "shroomlight.dig4", "shroomlight.dig5"],
stepSound: ["shroomlight.step1", "shroomlight.step2","shroomlight.step3","shroomlight.step4","shroomlight.step5","shroomlight.step6"]},
{ 
name: "warpedFungus",
Name:"Warped Fungus",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
potCross: true,
compostChance:0.65,
category:"nature",
digSound: ["fungus.dig1", "fungus.dig2", "fungus.dig3", "fungus.dig4", "fungus.dig5", "fungus.dig6"],
growBonemeal: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnNetherMushroom(x&15,y-1,z&15,x,z,"warpedForest")
win.serverRestoreWorldGen()
}
},
{
name: "blackstone",
Name:"Blackstone",
textures: ["blackstoneTop", "blackstone" ],
stoneSound: true,
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true,
},
{ name: "gildedBlackstone", Name:"Gilded Blackstone", category:"nature",stoneSound: true, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
{ name: "polishedBlackstoneBricks", Name:"Polished Blackstone Bricks", category:"build",stoneSound: true, craftSlabs:true, craftStairs:true},
{ name: "chiseledPolishedBlackstone", Name:"Chiseled Polished Blackstone", category:"build",stoneSound: true},
{
name: "netheriteBlock",
Name:"Netherite Block",
type:"rock4",
category:"build",
hardness:50,
blastResistance:1200,
digSound: ["netherite.dig1", "netherite.dig2", "netherite.dig3", "netherite.dig4"],
stepSound: ["netherite.step1", "netherite.step2","netherite.step3","netherite.step4","netherite.step5","netherite.step6"]
},
{
name: "basalt",
Name: "Basalt",
category:"nature",
textures: [ "basaltTop", "basaltSide" ],
basaltSound: true,
hardness:1.25
},
{
name: "polishedBasalt",
Name: "Polished Basalt",
category:"build",
textures: [ "polishedBasaltTop", "polishedBasaltSide" ],
basaltSound: true,
hardness:1.25
},
{ name: "chain", Name:"Chain", category:"build",transparent:true, shadow:false, chain:true, iconTexture:"chainIcon",
digSound: ["chain.dig1", "chain.dig2", "chain.dig3", "chain.dig4"],
stepSound: ["chain.step1", "chain.step2","chain.step3","chain.step4","chain.step5","chain.step6"]},
{ name: "warpedPlanks", Name:"Warped Planks", hardness:2, type:"wood",category:"build", woodSound:true, craftSlabs:true, craftStairs:true},
{ 
name: "warpedTrapdoor",
Name: "Warped Trapdoor",
transparent: true,
shadow: false,
trapdoor: true,
woodSound:true,
category:"build"
},
{
name: "magma", Name:"Magma Block", lightLevel:15,hardness:0.5, type:"rock1",
damage:1,
dieMessage: () => username+" discovered the floor was lava.",
burnTime:Infinity,
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name: "crimsonFungus",
Name: "Crimson Fungus",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
potCross: true,
compostChance:0.65,
category:"nature",
digSound: ["fungus.dig1", "fungus.dig2", "fungus.dig3", "fungus.dig4", "fungus.dig5", "fungus.dig6"],
growBonemeal: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnNetherMushroom(x&15,y-1,z&15,x,z,"crimsonForest")
win.serverRestoreWorldGen()
}
},
{ 
name: "warpedRoots",
Name: "Warped Roots",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
rootSound: true,
compostChance:0.65,
category:"nature",
potCross:true,
potCrossTexture:"warpedRootsPot"
},
{ 
name: "crimsonRoots",
Name: "Crimson Roots",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
rootSound: true,
compostChance:0.65,
category:"nature",
potCross:true,
potCrossTexture:"crimsonRootsPot"
},
{ 
name: "twistingVines",
transparent: true,
solid: false,
shadow: false,
transparent: true,
crossShape: true,
ladder:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isIt = blockData[top].name === "twistingVines" || blockData[top].name === "twistingVinesPlant"
if(isIt){
world.setBlock(x,y,z,blockIds.twistingVinesPlant | CROSS,false,false,false,false,dimension)
}
},
hidden:true,
drop:"twistinVinesPlant"
},
{
name: "twistingVinesPlant",
Name: "Twisting Vines",
transparent: true,
solid: false,
shadow: false,
transparent: true,
crossShape: true,
ladder:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isIt = blockData[top].name === "twistingVines" || blockData[top].name === "twistingVinesPlant"
if(!isIt){
world.setBlock(x,y,z,blockIds.twistingVines | CROSS,false,false,false,false,dimension)
}
},
category:"nature",
},
{
name: "weepingVines",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
ladder:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "weepingVines" || blockData[top].name === "weepingVinesPlant"
if(isIt){
world.setBlock(x,y,z,blockIds.weepingVinesPlant | CROSS,false,false,false,false,dimension)
}
},
hidden:true,
drop:"weepingVinesPlant"
},
{
name: "weepingVinesPlant",
Name:"Weeping Vines",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
ladder:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "weepingVines" || blockData[top].name === "weepingVinesPlant"
if(!isIt){
world.setBlock(x,y,z,blockIds.weepingVines | CROSS,false,false,false,false,dimension)
}
},
category:"nature"
},
{ 
name: "netherSprouts",
Name: "Nether Sprouts",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
compostChance:0.5,
category:"nature",
digSound: ["nether_sprouts.dig1", "nether_sprouts.dig2", "nether_sprouts.dig3", "nether_sprouts.dig4"],
stepSound: ["nether_sprouts.step1", "nether_sprouts.step2","nether_sprouts.step3","nether_sprouts.step4","nether_sprouts.step5"]
},
{ name: "stoneButton", Name:"Stone Button", textures:"stone", category:"redstone",button:true, transparent: true, shadow:false, stone:true },
{ 
name: "RespawnAnchorOff",
category:"items",
textures: ["respawnAnchorBottom", "respawnAnchorTopOff", "respawnAnchorSide0"],
//onupdate: (x,y,z) => {if(world.type !== "nether"){explode(x,y,z,2)}}
},
{ 
name: "RespawnAnchor1",
textures: ["respawnAnchorBottom", "respawnAnchorTop1", "respawnAnchorSide1"],
hidden: true
},
{ 
name: "RespawnAnchor2",
textures: ["respawnAnchorBottom", "respawnAnchorTop2", "respawnAnchorSide2"],
hidden: true
},
{ 
name: "RespawnAnchor3",
textures: ["respawnAnchorBottom", "respawnAnchorTop3", "respawnAnchorSide3"],
hidden: true
},
{ 
name: "RespawnAnchor",
textures: ["respawnAnchorBottom", "respawnAnchorTop", "respawnAnchorSide4"],
hidden: true
},
{
name:"redBed",
Name:"Red Bed",
textures: "bedbottom",
iconTexture: "bedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name: "flintAndSteel",
Name:"Flint & Steel",
textures: "flintAndSteel",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(block === blockIds.tnt){
blockData[blockIds.tnt].explode(x,y,z,null,dimension,world)
item.durability--
}else if(block === (blockIds.tnt | SLAB)){
blockData[blockIds.tnt].superTntExplode(x,y,z,dimension,world)
item.durability--
}else if(block === (blockIds.tnt | STAIR)){
blockData[blockIds.tnt].ultraTntExplode(x,y,z,dimension,world)
item.durability--
}else if(block === blockIds.untnt){
blockData[blockIds.untnt].explode(x,y,z,null,dimension,world)
item.durability--
}else{
var attached = world.getBlock(x,y,z,dimension)
var b = blockIds.fire
if(attached && blockData[attached].canHaveSoulFire) b = blockIds.soulFire
;([x,y,z] = movePositionByFace(face,x,y,z))
switch(face){
case "bottom": b |= STAIR; break
case "north": b |= SLAB | SOUTH; break
case "south": b |= SLAB | NORTH; break
case "east": b |= SLAB | WEST; break
case "west": b |= SLAB | EAST; break
}
item.durability--
if(block === blockIds.obsidian && blockData[blockIds.fire].tryCreatePortal(x,y,z,dimension)) return
world.setBlock(x,y,z,b,false,false,false,false,dimension)
world.playSound(x,y,z, "fire.ignite")
}
},
durability:64,
stackSize:1,
category:"items"
},
{
name: "barrier",
Name:"That Invisible Block with a 🚫 Icon",
textures: "none",
iconTexture: "barrier",
flatIcon:true,
transparent:true,
hardness:Infinity,
pistonPush:false,
pistonPull:false,
category:"items",
rarity:"epic"
},
{
name: "oakSapling",
Name:"Oak Sapling",
crossShape: true,
potCross: true,
transparent: true,
solid: false,
shadow:false,
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnSmallTree(x&15,y-1,z&15,x,z,false)
win.serverRestoreWorldGen()
},
compostChance:0.3,
category:"nature"
},
{ 
name: "crimsonTrapdoor",
Name:"Crimson Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "oakTrapdoor",
Name:"Oak Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "spruceTrapdoor",
Name:"Spruce Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "darkOakTrapdoor",
Name:"Dark Oak Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "birchTrapdoor",
Name:"Birck Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "jungleTrapdoor",
Name:"Jungle Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "acaciaTrapdoor",
Name:"Acaica Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "ironTrapdoor",
Name:"Iron Trapdoor",
transparent: true,
trapdoor: true,
stoneSound: true,
category:"build"
},
{ 
name: "cryingObsidian",
Name:"Obsidian: 😢",
shadow: false,
lightLevel: 10,
stoneSound:true,
type:"rock4",
hardness:50,
blastResistance:1200,
pistonPush:false,
pistonPull:false,
drip:[106/255, 6/255, 187/255],
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "netherGoldOre",
Name:"Nether Gold Ore",
digSound: ["nether_ore.dig1", "nether_ore.dig2", "nether_ore.dig3", "nether_ore.dig4"],
stepSound: ["nether_ore.step1", "nether_ore.step2","nether_ore.step3","nether_ore.step4","nether_ore.step5"],
drop: "goldNugget",
dropAmount: [1,3],
category:"nature",
hardness:3,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name: "flowerPot",
Name:"Flower Pot",
transparent: true,
shadow: false,
pot: true,
iconTexture:"flowerPotIcon",
flatIcon:true,
category:"decoration",
liquidBreakable:"drop"
},
{
name: "acaciaSapling",
Name:"Acacia Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
compostChance:0.3,
category:"nature",
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnAcacia(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
},
},
{
name: "birchSapling",
Name:"Birch Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
category:"nature",
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnSmallTree(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
},
compostChance:0.3
},
{
name: "darkOakSapling",
Name:"Dark Oak Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
compostChance:0.3,
category:"nature",
liquidBreakable:"drop"
},
{
name: "jungleSapling",
Name:"Jungle Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
compostChance:0.3,
category:"nature",
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnCocoaTree(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
}
},
{
name: "spruceSapling",
Name:"Spruce Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
compostChance:0.3,
category:"nature",
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnSpruce(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
}
},
{
name: "unused_blueOrchidPot",
textures:"error",
transparent: true,
shadow: false,
solid: false,
potCross: true,
hidden:true
},
{
name: "unused_warpedRoots",
textures:"error",
transparent: true,
shadow: false,
solid: false,
potCross: true,
hidden:true,
drop:"warpedRoots",
liquidBreakable:"drop"
},
{
name: "unused_crimsonRoots",
textures:"error",
transparent: true,
shadow: false,
solid: false,
potCross: true,
hidden:true,
drop:"crimsonRoots",
liquidBreakable:"drop"
},
{ name: "whiteCarpet", Name: "White Carpet", textures: "whiteWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "orangeCarpet", Name: "Orange Carpet", textures: "orangeWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "magentaCarpet", Name: "Magenta Carpet", textures: "magentaWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "lightBlueCarpet", Name: "Light Blue Carpet", textures: "lightBlueWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "yellowCarpet", Name: "Yellow Carpet", textures: "yellowWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "limeCarpet", Name: "Lime Carpet", textures: "limeWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "pinkCarpet", Name: "Pink Carpet", textures: "pinkWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "grayCarpet", Name: "Gray Carpet", textures: "grayWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "lightGrayCarpet", Name: "Light Gray Carpet", textures: "lightGrayWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "cyanCarpet", Name: "Cyan Carpet", textures: "cyanWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "purpleCarpet", Name: "Purple Carpet", textures: "purpleWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "blueCarpet", Name: "Blue Carpet", textures: "blueWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "brownCarpet", Name: "Brown Carpet", textures: "brownWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "greenCarpet", Name: "Green Carpet", textures: "greenWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "redCarpet", Name: "Red Carpet", textures: "redWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "blackCarpet", Name: "Black Carpet", textures: "blackWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "polishedBlackstone", Name: "Polished Blackstone", category:"build",stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "chiseledNetherBricks",
Name: "Chiseled Nether Bricks",
category:"build",
digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
{ name: "crackedNetherBricks",
Name:"Cracked Nether Bricks",
category:"build",
digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
{ name: "smoothBasalt", Name: "Smooth Basalt", basaltSound: true},
{
name: "oakLogSW",
textures: ["logSide","logSide","logTop","logSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "acaciaLogSW",
textures: ["acaciaLogSide","acaciaLogSide","acaciaLogTop","acaciaLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "birchLogSW",
textures: ["birchLogSide","birchLogSide","birchLogTop","birchLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "darkOakLogSW",
textures: ["darkOakLogSide","darkOakLogSide","darkOakLogTop","darkOakLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "jungleLogSW",
textures: ["jungleLogSide","jungleLogSide","jungleLogTop","jungleLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "spruceLogSW",
textures: ["spruceLogSide","spruceLogSide","spruceLogTop","spruceLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "crimsonStemSW",
textures: ["crimsonStemSide","crimsonStemSide","crimsonStemTop","crimsonStemSide"],
SW: true, stemSound:true, hidden:true
},
{
name: "warpedStemSW",
textures: ["warpedStemSide","warpedStemSide","warpedStemTop","warpedStemSide"],
SW: true, stemSound:true, hidden:true
},
{
name: "basaltSW",
textures: ["basaltSide","basaltSide","basaltTop","basaltSide"],
SW: true, basaltSound:true, hidden:true
},
{
name: "polishedBasaltSW",
textures: ["polishedBasaltSide","polishedBasaltSide","polishedBasaltTop","polishedBasaltSide"],
SW: true, basaltSound: true, hidden:true
},
{ name:"crimsonPlanks", Name: "Crimson Planks", woodSound:true, hardness:2, type:"wood",category:"build", craftSlabs:true, craftStairs:true },
{
name:"deadBush",
Name:"Dead Bush",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
drop: "stick",
dropAmount: [0,2],
dropSelfWhenSheared:true,
shearDropAmount:1,
liquidBreakable:"drop",
category:"nature",
},
{ name:"stick", Name:"Stick", category:"items",item:true },
{ name:"coal", Name:"Coal", category:"items",item:true },
{ name:"ironIngot", Name:"Iron Ingot", category:"items",item:true },
{ name:"copperIngot", Name:"Copper Ingot", category:"items",item:true },
{ name:"goldIngot", Name:"Gold Ingot", category:"items",item:true },
{ name:"diamond", Name:"Diamond", category:"items",item:true },
{ name:"lapisLazuli", Name:"Lapis Lazuli", category:"items",item:true },
{ name:"emerald", Name:"Emerald", category:"items",item:true },
{ name:"copperOre", Name:"Copper Ore", hardness:3, drop:"rawCopper", dropAmount:[2,5], type:"rock2",category:"nature", stoneSound:true },
{ name:"rawIron", Name:"Raw Iron", category:"items",item:true },
{ name:"rawCopper", Name:"Raw Copper", category:"items",item:true },
{ name:"rawGold", Name:"Raw Gold", category:"items",item:true },
{
name: "netherWart",
Name:"Nether Wart",
transparent: true,
shadow: false,
solid: false,
crop: true,
flatIcon:true,
iconTexture:"netherWartIcon",
compostChance:0.65,
category:"nature",
},
{
name: "wheat",
Name:"Wheat",
transparent: true,
shadow: false,
solid: false,
crop: true,
flatIcon:true,
iconTexture:"wheatIcon",
fullDrop:["wheat","wheatSeeds"],
drop:"wheatSeeds",
liquidBreakable:"drop",
textures:new Array(6).fill('wheatStage0'),
textures1:new Array(6).fill('wheatStage1'),
textures2:new Array(6).fill('wheatStage2'),
textures3:new Array(6).fill('wheatStage3'),
textures4:new Array(6).fill('wheatStage4'),
textures5:new Array(6).fill('wheatStage5'),
textures6:new Array(6).fill('wheatStage6'),
textures7:new Array(6).fill('wheat'),
compostChance:0.65,
category:"nature",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|LANTERN,false,false,false,false,dimension)
}
},
{
name: "lodestone",
Name:"Lodestone",
textures: ["lodestoneTop", "lodestoneSide"]
},
{
name: "anvil",
Name:"Anvil",
transparent: true,
anvil: true,
digSound: "anvil.land",
stepSound: ["stone.step1", "stone.step2","stone.step3","stone.step4","stone.step5","stone.step6"],
onclientclick:function(x,y,z,dimension){
changeScene("anvil")
releasePointer()
},
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
category:"items",
},
{
name: "slimeBlock",
Name:"Slime Block",
transparent: true,
shadow: false,
bounciness: 1,
speedFactor: 0.5,
shapeName:"slimeBlock",
category:"build",
sticky:true,
damageResistance:1,
},
{ 
name:"soulSoil",
Name:"Soul Soil",
speedFactor: 0.5,
canHaveSoulFire: true,
category:"nature",
},
{ name:"blueIce", Name:"Blue Ice", category:"nature",slide:0.9, glassSound: true, temperature:3},
{ name:"ice", Name:"Ice", category:"nature",transparent:true, shadow:false, slide:0.9, glassSound: true, temperature:3},
{ name:"packedIce", Name:"Packed Ice", category:"nature",slide:0.9, glassSound: true, temperature:3},
{ name:"calcite", Name:"Calcite", category:"nature" },
{
name:"furnace",
Name:"Furnace",
textures: ["furnaceTop","furnaceTop","furnaceSide","furnaceFront","furnaceSide","furnaceSide"],
SW: true,
tagBits: null,
setContents: function(x,y,z,dimension,world){
var data = {furnace:true, input:0, fuel:0, output:0, smeltStart:0, burnStart:0, canBurn:false, smelting:false, xp:0}
world.setTags(x, y, z, data,false,dimension)
return data
},
update:function(x,y,z,dimension,world){
let data = world.getTags(x,y,z,dimension)
if(!data) return
let prevSmelting = data.smelting
data.smelting = false
let smeltTo, fuel
if(data.input && data.fuel){
smeltTo = smelts[data.input.id]
fuel = smeltFuel[data.fuel.id]
if(!fuel){
for(let i in smeltFuel){
if(checkCraftType(parseInt(i) || i,data.fuel.id)){
fuel = smeltFuel[i]
break
}
}
}
if(!smeltTo){
for(let i in smelts){
if(checkCraftType(parseInt(i) || i,data.input.id)){
smeltTo = smelts[i]
break
}
}
}
if(smeltTo && fuel) data.smelting = true
}
if(data.smelting){
if(!prevSmelting){
data.smeltStart = Date.now()
data.burnStart = Date.now()
}
var seconds = (Date.now() - data.smeltStart) / 1000
var progress = seconds * 20 //ticks
var burnProgress = (Date.now() - data.burnStart) / 1000
data.progress = progress / smeltTo.time
data.burnProgress = 1-(burnProgress / fuel.time)
if(progress >= smeltTo.time){
var a = floor(progress/smeltTo.time)
for(var i=0; i<a; i++){
data.input.amount --
data.xp += smeltTo.xp
if(data.output){
data.output.amount ++
}else{
data.output = {id:smeltTo.id, amount:1}
}
if(data.input.amount <= 0){
data.input = 0
break
}
}
data.smeltStart += (a/20)*smeltTo.time*1000
world.updateTags(x,y,z,dimension)
}
if(burnProgress >= fuel.time){
data.canBurn = false
}
if(!data.canBurn){
var a = floor(burnProgress/fuel.time)
for(var i=0; i<a; i++){
data.fuel.amount --
if(data.fuel.amount === 0){
data.fuel = 0
break
}
}
world.updateTags(x,y,z,dimension)
data.burnStart += a*fuel.time*1000
data.canBurn = true
}
}
if(!data.smelting){
if((!data.fuel || !data.fuel.id) && data.burnProgress) data.burnProgress = 0
if((!data.input || !data.input.id) && data.progress) data.progress = 0
}
var block = world.getBlock(x,y,z,dimension)
var needs = blockIds.furnace | (block & ROTATION)
if(data.smelting){
needs |= SLAB
}
if(block !== needs){
world.setBlock(x,y,z, needs, false, false, false, true,dimension)//last argument is keepTags
}
},
tick:function(block,x,y,z,dimension,world){
this.update(x,y,z,dimension,world)
},
stoneSound:true,
category:"items",
},
{
name:"blastFurnace",
Name:"Blast Furnace",
textures: ["blastFurnaceTop","blastFurnaceTop","blastFurnaceSide","blastFurnaceFront","blastFurnaceSide","blastFurnaceSide"],
rotate: true,
category:"items",
},
{
name:"smoker",
Name:"Smoker",
textures: ["smokerBottom","smokerTop","smokerSide","smokerFront","smokerSide","smokerSide"],
rotate: true,
category:"items",
},
{
name:"noteBlock",
Name:"Note Block",
tagBits:{
on:[0,1],
note:[1,5]
},
onclick:function(x,y,z,dimension,world){
var note = world.getTagByName(x,y,z,"note",dimension)
if(!note && note !== 0) note = -1
note ++
if(note >= 24) note = 0
world.setTagByName(x,y,z,"note",note,false,dimension)
blockData[blockIds.noteBlock].playNote(x,y,z,dimension,world)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension) ? true : false
var on = world.getTagByName(x,y,z,"on",dimension) || false
if(power !== on) {
world.setTagByName(x,y,z,"on",power,false,dimension)
if(power){
this.playNote(x,y,z,dimension,world)
}
}
},
playNote:function(x,y,z,dimension,world){
var note = world.getTagByName(x,y,z,"note",dimension) || 0
if(!note && note !== 0) return
var pitch = 2**((note-12)/12)
var instrument = "harp"
var block = world.getBlock(x,y-1,z,dimension)
if(block && this.noteTypes[blockData[block].name]) instrument = this.noteTypes[blockData[block].name]
if(block){
for(var i in this.noteTypes){
if(i.startsWith("type:") && i.replace("type:","") === blockData[block].type){
instrument = this.noteTypes[i]
}
}
}
world.playSound(x,y,z, "note."+instrument, 1, pitch)
world.sendAll({
type:"particles", particleType:"NoteParticle",
x,y:y+0.5,z, dimension, data:note
})
},
noteTypes:(function(obj){
var obj2 = {}
for(var i in obj){
if(typeof obj[i] === "string"){
obj2[obj[i]] = i
}else{
for(var i2 of obj[i]){
obj2[i2] = i
}
}
}
return obj2
})({
bass:"type:wood",
snare:["sand","gravel"],
hat:["glass","seaLantern","beacon"],
bd: ['type:rock1', 'type:rock2', 'type:rock3'],
bell: "goldBlock",
flute: ["clay", "honeycombBlock"],
icechime: ["packedIce"],
guitar: "type:wool",
xylobone: ["boneBlock","boneBlockSW"],
iron_xylophone: ["ironBlock"],
cow_bell: "soulSand",
didgeridoo: "pumpkin",
bit: "emeraldBlock",
banjo: ["hayBlock", "hayBlockSW"],
pling: "glowstone"
}),
category:"redstone",
},
{
name:"jukebox",
Name:"Jukebox",
textures: ["jukeboxTop","jukeboxSide"],
category:"items"
},
{
name:"loom",
Name:"Loom",
textures: ["loomBottom","loomTop","loomFront","loomSide","loomSide","loomSide"],
rotate: true,
category:"items"
},
{
name:"sandstone",
Name:"Sandstone",
textures: ["sandstoneBottom", "sandstoneTop", "sandstone"],
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true
},
{ name:"chiseledSandstone",
Name:"Chiseled Sandstone",
textures: ["sandstoneBottom", "sandstoneTop","chiseledSandstone"],
category:"build",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true
},
{ name:"cutSandstone",
Name:"Cut Sandstone",
textures: ["sandstoneBottom", "sandstoneTop","cutSandstone"],
category:"build",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true
},
{ name:"smoothSandstone", Name:"Smooth Sandstone", textures:"sandstoneTop", category:"nature",randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true },
{
name: "DoubleTallGrass",
Name:"Tall Grass",
solid: false,
transparent: true,
shadow: false,
textures: "tallGrassTop",
tallcrossShape: true,
drop:function(){
var r = rand()
if(r > 0.9){
return "tomatoSeeds"
}else if(r > 0.8){
return "corn"
}else if(r > 0.5){
return "wheatSeeds"
}
},
compostChance:0.3,
liquidBreakable:"drop",
category:"nature"
},
{
name:"apple",
Name:"Apple",
item:true,
edible: true,
eatWhenFull: false,
food: 4,
saturation: 2.4,
eatResult: "appleCore",
compostChance:0.65,
category:"food",
},
{
name:"woodenPickaxe",
Name:"Wooden Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 2,
durability: 59,
attackDamage: 2,
category:"tools",
},
{
name:"stonePickaxe",
Name:"Stone Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 4,
durability: 131,
attackDamage: 2,
material:"cobblestone",
category:"tools",
},
{
name:"ironPickaxe",
Name:"Iron Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 6,
durability: 250,
attackDamage: 3,
material:"ironIngot",
category:"tools",
},
{
name:"goldenPickaxe",
Name:"Golden Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 12,
durability: 32,
attackDamage: 4,
material:"goldIngot",
category:"tools",
},
{
name:"diamondPickaxe",
Name:"Diamond Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 8,
durability: 1561,
attackDamage: 5,
material:"diamond",
category:"tools",
},
{ name:"flint", Name:"Flint", item:true, category:"items" },
{
name:"mossBlock",
Name: "Moss Block",
hardness:0.1,
type: "plant2",
compostChance:0.65,
category:"nature"
},
{
name:"mossCarpet",
Name: "Moss Carpet",
textures: "mossBlock",
hardness:0.1,
carpet: true,
compostChance:0.3,
liquidBreakable:"drop",
category:"nature"
},
{
name: "caveVines",
Name:"Cave Vines",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
if(isIt){
world.setBlock(x,y,z,blockIds.caveVinesPlant | CROSS,false,false,false,false,dimension)
}
},
liquidBreakable:"drop",
category:"nature"
},
{
name: "caveVinesPlant",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
if(!isIt){
world.setBlock(x,y,z,blockIds.caveVines | CROSS,false,false,false,false,dimension)
}
},
hidden:true,
drop:"caveVines",
liquidBreakable:"drop"
},
{
name: "caveVinesLit",
Name: "Cave Vines With Glow Berries",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
lightLevel: 14,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
if(isIt){
world.setBlock(x,y,z,blockIds.caveVinesPlantLit | CROSS,false,false,false,false,dimension)
}
},
liquidBreakable:"drop",
category:"nature"
},
{
name: "caveVinesPlantLit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
lightLevel: 14,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
if(!isIt){
world.setBlock(x,y,z,blockIds.caveVinesLit | CROSS,false,false,false,false,dimension)
}
},
hidden:true,
liquidBreakable:"drop"
},
{
name:"sporeBlossom",
Name:"Spore Blossom",
sporeBlossom: true,
shadow:false,
transparent: true,
compostChance:0.65,
category:"nature"
},
{
name: "rootedDirt",
Name: "Rooted Dirt",
category:"nature",
type:"ground",
hardness:0.5, blastResistance:0.5,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
},
{
name: "hangingRoots",
Name: "Hanging Roots",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
compostChance:0.3,
liquidBreakable:"drop",
category:"nature"
},
{
name:"azalea",
Name:"Azalea",
textures: ["azaleaTop", "azaleaSide"],
potTex:["pottedAzaleaBushTop","pottedAzaleaBushSide"],
azalea: true,
transparent: true,
potCross:true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name:"floweringAzalea",
Name:"Flowering Azalea",
textures: ["floweringAzaleaTop","floweringAzaleaSide"],
potTex:["pottedFloweringAzaleaBushTop","pottedFloweringAzaleaBushSide"],
azalea: true,
transparent: true,
potCross:true,
compostChance:0.85,
liquidBreakable:"drop",
category:"nature",
lightLevel:10//make lush caves brighter
},
{
name:"sunflower",
Name:"Sunflower",
textures:["sunflowerBack","sunflowerFront","sunflowerConnected"],
sunflower: true,
transparent:true,
shadow:false,
iconTexture: "sunflowerFront",
solid:false,
category:"nature"
},
{
name: "bucket",
Name:"Bucket",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(block === blockIds.Water){
item.id = blockIds.waterBucket
world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
if(block === blockIds.Lava){
item.id = blockIds.lavaBucket
world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
if(block === blockIds.powderSnow){
item.id = blockIds.powderSnowBucket
world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
if(block === blockIds.oil){
item.id = blockIds.oilBucket
world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
},
stackSize: 1,
allHitbox: true,
category:"items"
},
{
name: "waterBucket",
Name:"Water Bucket",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(p.survival) item.id = blockIds.bucket
let pos = movePositionByFace(face,x,y,z)
world.setBlock(pos[0],pos[1],pos[2],blockIds.Water,false,false,false,false,dimension)
},
stackSize: 1,
category:"items"
},
{
name: "lavaBucket",
Name:"Lava Bucket",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(p.survival) item.id = blockIds.bucket
let pos = movePositionByFace(face,x,y,z)
world.setBlock(pos[0],pos[1],pos[2],blockIds.Lava,false,false,false,false,dimension)
},
stackSize: 1,
category:"items"
},
{
name: "spawnCow",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Cow](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Cow](x,y,z),false,dimension)
},
category:"items"
},
{
name:"sugarCane",
Name:"Sugar Cane",
iconTexture: "sugarCaneIcon",
flatIcon: true,
solid: false,
transparent: true,
shadow: false,
compostChance:0.5,
category:"nature",
smoothLight:false,
},
{
name:"woodenSword",
Name:"Wooden Swords aren't even sharp!",
item: true,
sword: true,
durability: 59,
attackDamage: 4,
category:"tools"
},
{
name:"stoneSword",
Name:"Stone Sword",
item: true,
sword: true,
durability: 131,
attackDamage: 5,
material:"cobblestone",
category:"tools"
},
{
name:"ironSword",
Name:"Iron Sword",
item: true,
sword: true,
durability: 250,
attackDamage: 6,
material:"ironIngot",
category:"tools"
},
{
name:"goldenSword",
Name:"Golden Sword",
item: true,
sword: true,
durability: 32,
attackDamage: 4,
material:"goldIngot",
category:"tools"
},
{
name:"diamondSword",
Name:"Diamond Sword",
item: true,
sword: true,
durability: 1561,
attackDamage: 7,
material:"diamond",
category:"tools"
},
{ name:"azaleaLeaves",
Name:"Azalea Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
drop: function(){
if(rand() > 0.05){
let r = floor(rand(2))
if(r === 0) return "azalea"
else return "floweringAzalea"
}
},
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
category:"nature",
grassSound: true,
leaves:true
},
{ name:"floweringAzaleaLeaves",
Name:"Flowering Azalea Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
drop: function(){
if(rand() > 0.05){
let r = floor(rand(2))
if(r === 0) return "azalea"
else return "floweringAzalea"
}
},
burnChance: 0.2,
burnTime: 30,
compostChance:0.5,
category:"nature",
grassSound: true,
leaves:true
},
{
name: "spawnPig",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Pig](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Pig](x,y,z),false,dimension)
},
category:"items"
},
{name:"tuff",Name:"Tuff",category:"nature",hardness:1.5},
{name:"deepslate", Name:"Deepslate", textures:["deepslateTop","deepslate"],category:"nature",hardness:3,deepslateSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true, craftSlabs:true, craftStairs:true},
{name:"cobbledDeepslate", Name:"Cobbled Deepslate",deepslateSound:true,category:"nature",hardness:3.5, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{name:"chiseledDeepslate", Name:"Chiseled Deepslate",category:"build",hardness:3.5,deepslateSound:true},
{name:"polishedDeepslate",Name:"Polished Deepslate",category:"build",hardness:3.5,deepslateSound:true, craftSlabs:true, craftStairs:true},
{name:"deepslateTiles",Name:"Deepslate Tiles",category:"build",hardness:3.5,deepslateSound:true, craftSlabs:true, craftStairs:true},
{name:"deepslateBricks",Name:"Deepslate Bricks",category:"build",hardness:3.5,deepslateBricksSound:true, craftSlabs:true, craftStairs:true},
{name:"crackedDeepslateTiles",Name:"Cracked Deepslate Tiles",category:"build",hardness:3.5,deepslateSound:true},
{name:"crackedDeepslateBricks",Name:"Cracked Deepslate Bricks",category:"build",hardness:3.5,deepslateBricksSound:true},
{name:"deepslateCoalOre",Name:"Deepslate Coal Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"coal", dropAmount:[1,3]},
{name:"deepslateIronOre",Name:"Deepslate Iron Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawIron", dropAmount:[1,3]},
{name:"deepslateCopperOre",Name:"Deepslate Copper Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawCopper", dropAmount:[2,5]},
{name:"deepslateGoldOre",Name:"Deepslate Gold Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawGold", dropAmount:[1,3]},
{name:"deepslateDiamondOre",Name:"Deepslate Diamond Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"diamond", dropAmount:[1,3]},
{name:"deepslateRedstoneOre",Name:"Deepslate Redstone Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"redstone", dropAmount:[6,9]},
{name:"deepslateEmeraldOre",Name:"Deepslate Emerald Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"emerald", dropAmount:[1,3]},
{name:"deepslateLapisOre",Name:"Deepslate Lapis Lazuli Ore",category:"nature",hardness:4.5,deepslateSound:true,drop:"lapisLazuli", dropAmount:[1,3]},
{name:"amethystBlock",Name:"Amethyst Block", category:"nature",hardness:1.5,amethystSound: true},
{name:"amethystShard",Name:"Amythest Shard",category:"items",item:true},
{name:"buddingAmethyst",Name:"Budding Amethyst", category:"nature",hardness:1.5,amethystSound: true},
{name:"smallAmethystBud",Name:"Small Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
lightLevel:1
},
{name:"mediumAmethystBud",Name:"Medium Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
lightLevel:2
},
{name:"largeAmethystBud",Name:"Large Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
lightLevel:4
},
{name:"amethystCluster",Name:"Amethyst Cluster",category:"nature",hardness:1.5,sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
drop: "amethystShard",
lightLevel:5
},
{
name:"snowBlock",
Name:"Block of Snow",
textures:"snow",
hardness: 0.2,
drop:"snowball",
dropAmount: 4,
temperature:5,
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"snow",
Name:"Snow Layer",
layers: true,
transparent:true,
shadow:true,
drop:"snowball",
hardness: 0.1,
fallingDust:[248/255, 253/255, 253/255],
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
temperature:5,
liquidBreakable:"drop",
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"powderSnow",
Name:"Powder Snow",
solid:false,
powder: true,
hardness: 0.25,
drop:"air",
transparent:true,
temperature:5,
category:"nature",
},
{
name:"snowball",
Name:"Snowball",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
item.amount--
var pd = p.direction
world.addEntity(new entities[entityIds.Snowball](p.x+pd.x,p.y+pd.y,p.z+pd.z, pd.x*0.8, pd.y*0.8, pd.z*0.8,p.id),false,dimension)
},
useAnywhere:true,
category:"items",
},
{
name:"powderSnowBucket",
Name:"Powder Snow Bucket",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(p.survival) item.id = blockIds.bucket
var pos = movePositionByFace(face,x,y,z)
world.setBlock(pos[0],pos[1],pos[2],blockIds.powderSnow,false,false,false,false,dimension)
},
stackSize: 1,
category:"items",
},
{
name:"bread",
Name:"Bread",
edible: true,
item:true,
eatWhenFull: false,
food: 6,
saturation: 11,
compostChance:0.85,
category:"food",
},
{
name:"boneBlock",
Name:"Bone Block",
textures:["boneBlockTop","boneBlockSide"],
category:"nature",
},
{
name:"farmland",
Name:"Farmland",
textures:["dirt","farmland","dirt"],
_1PixLower: true,
category:"nature",
hardness:0.6, blastResistance:0.5,
type:"ground",
tick:function(block,x,y,z,dimension,world){
var target = this.id
for(var X=x-4;X<=x+4;X++){
for(var Z=z-4;Z<=z+4;Z++){
var b = world.getBlock(X,y,Z,dimension), a = world.getBlock(X,y+1,Z,dimension)
if(b && blockData[b].name === "Water" || a && blockData[a].name === "Water") target = this.id|SLAB
}
}
if(block !== target) world.setBlock(x,y,z,target,false,false,false,false,dimension)
}
},
{
name:"glowBerries",
Name:"Glow Berries",
edible: true,
item:true,
eatWhenFull: false,
food: 2,
saturation: 0.4,
compostChance:0.3,
category:"food",
},
{
name:"hayBlock",
Name:"Hay Bale",
textures:["hayBlockTop","hayBlockSide"],
type:"plant2",
damageResistance:0.8,
burnChance: 0.2,
burnTime: 20,
category:"decoration",
},
{
name:"hayBlockSW",
textures: ["hayBlockSide","hayBlockSide","hayBlockTop","hayBlockSide"],
SW: true,
type:"plant2",
damageResistance:0.8,
compostChance:0.85,
hidden:true
},
{
name:"woodenShovel",
Name:"Wooden Shovel",
item: true,
shovel: true,
durability: 59,
mineSpeed:2,
attackDamage: 2,
category:"tools"
},
{
name:"stoneShovel",
Name:"Stone Shovel",
item: true,
shovel: true,
durability: 131,
mineSpeed:3.6,
attackDamage: 4,
material:"cobblestone",
category:"tools"
},
{
name:"ironShovel",
Name:"Iron Shovel",
item: true,
shovel: true,
durability: 250,
mineSpeed:6,
attackDamage: 4,
material:"ironIngot",
category:"tools"
},
{
name:"goldenShovel",
Name:"Golden Shovel",
item: true,
shovel: true,
durability: 32,
mineSpeed:12,
attackDamage: 2,
material:"goldIngot",
category:"tools"
},
{
name:"diamondShovel",
Name:"Diamond Shovel",
item: true,
shovel: true,
durability: 1561,
mineSpeed:8,
attackDamage: 5,
material:"diamond",
category:"tools"
},
{
name:"woodenAxe",
Name:"Wooden Axe",
item: true,
axe: true,
durability: 59,
mineSpeed:2,
attackDamage: 7,
attackSpeed:0.8,
category:"tools"
},
{
name:"stoneAxe",
Name:"Stone Axe",
item: true,
axe: true,
durability: 131,
mineSpeed:4,
attackDamage: 9,
attackSpeed:0.8,
material:"cobblestone",
category:"tools"
},
{
name:"ironAxe",
Name:"Iron Axe",
item: true,
axe: true,
durability: 250,
mineSpeed:6,
attackDamage: 9,
attackSpeed:0.9,
material:"ironIngot",
category:"tools"
},
{
name:"goldenAxe",
Name:"Golden Axe",
item: true,
axe: true,
durability: 32,
mineSpeed:12,
attackDamage: 7,
attackSpeed:1,
material:"goldIngot",
category:"tools"
},
{
name:"diamondAxe",
Name:"Diamond Axe",
item: true,
axe: true,
durability: 1561,
mineSpeed:8,
attackDamage: 9,
attackSpeed:1,
material:"diamond",
category:"tools"
},
{
name: "strippedOakLog",
Name: "Stripped Oak Log",
textures: ["strippedOakLogTop", "strippedOakLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedOakLogSW",
textures: ["strippedOakLog", "strippedOakLog", "strippedOakLogTop","strippedOakLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedBirchLog",
Name: "Stripped Birch Log",
textures: ["strippedBirchLogTop", "strippedBirchLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedBirchLogSW",
textures: ["strippedBirchLog", "strippedBirchLog", "strippedBirchLogTop","strippedBirchLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedAcaciaLog",
Name: "Stripped Acacia Log",
textures: ["strippedAcaciaLogTop", "strippedAcaciaLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedAcaciaLogSW",
textures: ["strippedAcaciaLog", "strippedAcaciaLog", "strippedAcaciaLogTop","strippedAcaciaLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedJungleLog",
Name: "Stripped Jungle Log",
textures: ["strippedJungleLogTop", "strippedJungleLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedJungleLogSW",
textures: ["strippedJungleLog", "strippedJungleLog", "strippedJungleLogTop","strippedJungleLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedSpruceLog",
Name: "Stripped Spruce Log",
textures: ["strippedSpruceLogTop", "strippedSpruceLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedSpruceLogSW",
textures: ["strippedSpruceLog", "strippedSpruceLog", "strippedSpruceLogTop","strippedSpruceLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedDarkOakLog",
Name: "Stripped Dark Oak Log",
textures: ["strippedDarkOakLogTop", "strippedDarkOakLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedDarkOakLogSW",
textures: ["strippedDarkOakLog", "strippedDarkOakLog", "strippedDarkOakLogTop","strippedDarkOakLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name:"boneBlockSW",
textures:["boneBlockSide","boneBlockSide","boneBlockTop","boneBlockSide"],
SW: true,
hidden:true
},
{
name:"redMushroom",
Name:"Red Mushroom",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
lightLevel:1,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
growBonemeal: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnHugeMushroom(x&15,y-1,z&15,x,z,false)
win.serverRestoreWorldGen()
}
},
{
name:"brownMushroom",
Name:"Brown Mushroom",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
lightLevel:1,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
growBonemeal: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnHugeMushroom(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
}
},
{
name:"mushroomStem",
Name: "Mushroom Stem",
mushroomBlock:true,
compostChance:0.65,
category:"nature"
},
{
name:"redMushroomBlock",
Name: "Red Mushroom Block",
mushroomBlock:true,
compostChance:0.85,
category:"nature"
},
{
name:"brownMushroomBlock",
Name: "Brown Mushroom Block",
mushroomBlock:true,
compostChance:0.85,
category:"nature"
},
{
name:"mycelium",
Name:"Mycelium",
textures:["dirt","myceliumTop","myceliumSide"],
type:"ground",
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
hardness: 0.6,
blastResistance:0.6,
drop:"dirt",
grassSound: true,
},
{
name:"terracotta",
Name:"Terracotta",
category:"build"
},
{
name:"redTerracotta",
Name:"Terracotta with watermelon juice",
category:"build"
},
{
name:"blueTerracotta",
Name:"Terracotta with blueberry juice",
category:"build"
},
{
name:"cyanTerracotta",
Name:"Terracotta with cyan colored fruit punch",
category:"build"
},
{
name:"grayTerracotta",
Name:"Dusty Terracotta",
category:"build"
},
{
name:"limeTerracotta",
Name:"Terracotta with leaf juice",
category:"build"
},
{
name:"pinkTerracotta",
Name:"Terracotta with fruit punch",
category:"build"
},
{
name:"blackTerracotta",
Name:"Terracotta painted black",
category:"build"
},
{
name:"brownTerracotta",
Name:"Dirty Terracotta",
category:"build"
},
{
name:"greenTerracotta",
Name:"Terracotta with some other leaf juice",
category:"build"
},
{
name:"whiteTerracotta",
Name:"Terracotta with flour",
category:"build"
},
{
name:"orangeTerracotta",
Name:"Orange Terracotta",
category:"build"
},
{
name:"purpleTerracotta",
Name:"Purple Terracotta",
category:"build"
},
{
name:"yellowTerracotta",
Name:"Terracotta with lemon juice",
category:"build"
},
{
name:"magentaTerracotta",
Name:"Magenta Terracotta",
category:"build"
},
{
name:"lightBlueTerracotta",
Name:"Light Blue Terracotta",
category:"build"
},
{
name:"lightGrayTerracotta",
Name:"Light Gray Terracotta",
category:"build"
},
{
name:"redGlazedTerracotta",
Name:"Watermelon Swirl",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"blueGlazedTerracotta",
Name:"Blue Fan",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"cyanGlazedTerracotta",
Name:"Creeper in the skies",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"grayGlazedTerracotta",
Name:"Bunch of Dust",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"limeGlazedTerracotta",
Name:"Overlapping lilies",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"pinkGlazedTerracotta",
Name:"Pink turtle shell",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"blackGlazedTerracotta",
Name:"Red monster",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"brownGlazedTerracotta",
Name:"Mudslide in the ocean",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"greenGlazedTerracotta",
Name:"Camouflaged monster",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"whiteGlazedTerracotta",
Name:"Sun & clouds",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"orangeGlazedTerracotta",
Name:"Flower Monster",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"purpleGlazedTerracotta",
Name:"Sword & pickaxe monster",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"yellowGlazedTerracotta",
Name:"Some kind of bug",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"magentaGlazedTerracotta",
Name:"Arrow",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"lightBlueGlazedTerracotta",
Name:"Monster sticking out tongue and eyes facing opposite direction",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"lightGrayGlazedTerracotta",
Name:"Monster with blue eyes and mouth",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"ancientDebris",
Name:"Ancient Debris",
textures:["ancientDebrisTop","ancientDebrisSide"],
hardness:30,
type:"rock4",
category:"nature",
},
{
name:"wheatSeeds",
Name:"Seeds",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "wheat"
},
compostChance:0.3,
category:"items"
},
{
name:"yellowStainedGlass",
Name: "Yellow Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"whiteStainedGlass",
Name: "White Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"redStainedGlass",
Name: "Red Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"purpleStainedGlass",
Name: "Purple Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"pinkStainedGlass",
Name: "Pink Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"orangeStainedGlass",
Name: "Orange Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"magentaStainedGlass",
Name: "Magenta Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"limeStainedGlass",
Name: "Lime Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"lightGrayStainedGlass",
Name: "Light Gray Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"lightBlueStainedGlass",
Name: "Light Blue Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"greenStainedGlass",
Name: "Green Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"grayStainedGlass",
Name: "Gray Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"cyanStainedGlass",
Name: "Cyan Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"brownStainedGlass",
Name: "Brown Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"blueStainedGlass",
Name: "Blue Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"blackStainedGlass",
Name: "Black Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name: "yellowStainedGlassPane",
Name: "Yellow Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["yellowStainedGlassPaneTop","yellowStainedGlassPaneTop","yellowStainedGlass","yellowStainedGlass","yellowStainedGlassPaneSide","yellowStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "whiteStainedGlassPane",
Name: "White Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["whiteStainedGlassPaneTop","whiteStainedGlassPaneTop","whiteStainedGlass","whiteStainedGlass","whiteStainedGlassPaneSide","whiteStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "redStainedGlassPane",
Name: "Red Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["redStainedGlassPaneTop","redStainedGlassPaneTop","redStainedGlass","redStainedGlass","redStainedGlassPaneSide","redStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "purpleStainedGlassPane",
Name: "Purple Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["purpleStainedGlassPaneTop","purpleStainedGlassPaneTop","purpleStainedGlass","purpleStainedGlass","purpleStainedGlassPaneSide","purpleStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "pinkStainedGlassPane",
Name: "Pink Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["pinkStainedGlassPaneTop","pinkStainedGlassPaneTop","pinkStainedGlass","pinkStainedGlass","pinkStainedGlassPaneSide","pinkStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "orangeStainedGlassPane",
Name: "Orange Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["orangeStainedGlassPaneTop","orangeStainedGlassPaneTop","orangeStainedGlass","orangeStainedGlass","orangeStainedGlassPaneSide","orangeStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "magentaStainedGlassPane",
Name: "Magenta Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["magentaStainedGlassPaneTop","magentaStainedGlassPaneTop","magentaStainedGlass","magentaStainedGlass","magentaStainedGlassPaneSide","magentaStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "limeStainedGlassPane",
Name: "Lime Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["limeStainedGlassPaneTop","limeStainedGlassPaneTop","limeStainedGlass","limeStainedGlass","limeStainedGlassPaneSide","limeStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "lightGrayStainedGlassPane",
Name: "Light Gray Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["lightGrayStainedGlassPaneTop","lightGrayStainedGlassPaneTop","lightGrayStainedGlass","lightGrayStainedGlass","lightGrayStainedGlassPaneSide","lightGrayStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "lightBlueStainedGlassPane",
Name: "Light Blue Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["lightBlueStainedGlassPaneTop","lightBlueStainedGlassPaneTop","lightBlueStainedGlass","lightBlueStainedGlass","lightBlueStainedGlassPaneSide","lightBlueStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "greenStainedGlassPane",
Name: "Green Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["greenStainedGlassPaneTop","greenStainedGlassPaneTop","greenStainedGlass","greenStainedGlass","greenStainedGlassPaneSide","greenStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "grayStainedGlassPane",
Name: "Gray Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["grayStainedGlassPaneTop","grayStainedGlassPaneTop","grayStainedGlass","grayStainedGlass","grayStainedGlassPaneSide","grayStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "cyanStainedGlassPane",
Name: "Cyan Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["cyanStainedGlassPaneTop","cyanStainedGlassPaneTop","cyanStainedGlass","cyanStainedGlass","cyanStainedGlassPaneSide","cyanStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "brownStainedGlassPane",
Name: "Brown Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["brownStainedGlassPaneTop","brownStainedGlassPaneTop","brownStainedGlass","brownStainedGlass","brownStainedGlassPaneSide","brownStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "blueStainedGlassPane",
Name: "Blue Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["blueStainedGlassPaneTop","blueStainedGlassPaneTop","blueStainedGlass","blueStainedGlass","blueStainedGlassPaneSide","blueStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "blackStainedGlassPane",
Name: "Black Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["blackStainedGlassPaneTop","blackStainedGlassPaneTop","blackStainedGlass","blackStainedGlass","blackStainedGlassPaneSide","blackStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "cobweb",
Name:"Cobweb",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
hardness:4,
drop:"air",
dropSelfWhenSheared:true,
shearBreakTime:0.4,
liquidBreakable:"drop",
category:"decoration"
},
{
name: "strippedCrimsonStem",
Name: "Stripped Crimson Stem",
textures: ["strippedCrimsonStemTop", "strippedCrimsonStem"],
hardness:2,
stemSound:true,
category:"build"
},
{
name: "strippedCrimsonStemSW",
textures: ["strippedCrimsonStem", "strippedCrimsonStem", "strippedCrimsonStemTop","strippedCrimsonStem"],
hardness:2,
stemSound:true,
SW: true,
hidden:true
},
{
name: "strippedWarpedStem",
Name: "Stripped Warped Stem",
textures: ["strippedWarpedStemTop", "strippedWarpedStem"],
hardness:2,
stemSound:true,
category:"build"
},
{
name: "strippedWarpedStemSW",
textures: ["strippedWarpedStem", "strippedWarpedStem", "strippedWarpedStemTop","strippedWarpedStem"],
hardness:2,
stemSound:true,
SW: true,
hidden:true
},
{
name: "oakPressurePlate",
Name: "Oak Pressure Plate",
textures: "oakPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "birchPressurePlate",
Name: "Birch Pressure Plate",
textures: "birchPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "sprucePressurePlate",
Name: "Spruce Pressure Plate",
textures: "sprucePlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "junglePressurePlate",
Name: "Jungle Pressure Plate",
textures: "junglePlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "acaciaPressurePlate",
Name: "Acacia Pressure Plate",
textures: "acaciaPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name:"darkOakPressurePlate",
Name: "Dark Oak Pressure Plate",
textures: "darkOakPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "warpedPressurePlate",
Name: "Warped Pressure Plate",
textures: "warpedPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "crimsonPressurePlate",
Name: "Crimson Pressure Plate",
textures: "crimsonPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "stonePressurePlate",
Name: "Stone Pressure Plate",
textures: "stone",
pressurePlate: true,
type:"stone",
hardness:0.5,
category:"redstone"
},
{
name: "polishedBlackstonePressurePlate",
textures: "polishedBlackstone",
pressurePlate: true,
type:"stone",
hardness:0.5,
category:"redstone"
},
{
name: "lightWeightedPressurePlate",
textures: "goldBlock",
pressurePlate: true,
type:"stone",
hardness:0.5,
lightWeighted:true,
category:"redstone"
},
{
name: "heavyWeightedPressurePlate",
textures: "ironBlock",
pressurePlate: true,
type:"stone",
hardness:0.5,
heavyWeighted:true,
category:"redstone"
},
{
name:"oakButton",
Name: "Oak Button",
textures:"oakPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"birchButton",
Name: "Birch Button",
textures:"birchPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"acaciaButton",
Name: "Acacia Button",
textures:"acaciaPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"darkOakButton",
Name: "Dark Oak Button",
textures:"darkOakPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"jungleButton",
Name: "Jungle Button",
textures:"junglePlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"spruceButton",
Name: "Spruce Button",
textures:"sprucePlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"warpedButton",
Name: "Warped Button",
textures:"warpedPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"crimsonButton",
Name: "Crimson Button",
textures:"crimsonPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"polishedBlackstoneButton",
Name: "Polished Blackstone Button",
textures:"polishedBlackstone",
button:true,
transparent:true,
shadow:false,
stone:true,
category:"redstone"
},
{
name:"copperBlock",
Name:"Block of Copper",
category:"build"
},
{
name:"crackedPolishedBlackstoneBricks",
Name:"Cracked Polished Blackstone Bricks",
category:"build"
},
{
name:"crackedStoneBricks",
Name:"Cracked Stone Bricks",
category:"build"
},
{
name:"woodenHoe",
Name:"Wooden Hoe",
item: true,
hoe: true,
durability: 59,
mineSpeed:2,
attackDamage: 1,
attackSpeed:1,
category:"tools"
},
{
name:"stoneHoe",
Name:"Stone Hoe",
item: true,
hoe: true,
durability: 131,
mineSpeed:4,
attackDamage: 1,
attackSpeed:2,
material:"cobblestone",
category:"tools"
},
{
name:"ironHoe",
Name:"Iron Hoe",
item: true,
hoe: true,
durability: 250,
mineSpeed:6,
attackDamage: 1,
attackSpeed:3,
material:"ironIngot",
category:"tools"
},
{
name:"goldenHoe",
Name:"Golden Hoe",
item: true,
hoe: true,
durability: 32,
mineSpeed:12,
attackDamage: 1,
attackSpeed:1,
material:"goldIngot",
category:"tools"
},
{
name:"diamondHoe",
Name:"Diamond Hoe",
item: true,
hoe: true,
durability: 1561,
mineSpeed:8,
attackDamage: 1,
attackSpeed:4,
material:"diamond",
category:"tools"
},
{
name:"podzol",
Name:"Podzol",
textures:["dirt","podzolTop","podzolSide"],
category:"nature",
hardness:0.5,
blastResistance:0.5,
type:"ground",
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
let top = world.getBlock(x,y+1,z,dimension)
let isSnow = blockData[top].name === "snow" || blockData[top].name === "snowBlock"
if(b === blockIds.podzol && isSnow){
world.setBlock(x,y,z,blockIds.podzol | CROSS,false,false,false,false,dimension)
}else if(b === (blockIds.podzol | CROSS) && !isSnow){
world.setBlock(x,y,z,blockIds.podzol,false,false,false,false,dimension)
}
},
compostChance:0.3,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
},
{
name:"rawIronBlock",
Name:"Block of Raw Iron",
type:"rock2",
hardness:5,
category:"build"
},
{
name:"rawGoldBlock",
Name:"Block of Raw Gold",
type:"rock3",
hardness:5,
category:"build"
},
{
name:"rawCopperBlock",
Name:"Block of Raw Copper",
type:"rock2",
hardness:5,
category:"build"
},
{
name:"netheriteScrap",
Name:"Netherite Scrap",
item:true,
category:"items"
},
{
name:"netheriteIngot",
Name:"Netherite Ingot",
item:true,
category:"items"
},
{
name:"netheritePickaxe",
Name:"Netherite Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 9,
durability: 2031,
attackDamage: 6,
material:"netheriteIngot",
category:"tools"
},
{
name:"netheriteSword",
Name:"Netherite Sword",
item: true,
sword: true,
durability: 2031,
attackDamage: 8,
material:"netheriteIngot",
category:"tools"
},
{
name:"netheriteAxe",
Name:"Netherite Axe",
item: true,
axe: true,
durability: 2031,
mineSpeed:9,
attackDamage: 10,
attackSpeed:1,
material:"netheriteIngot",
category:"tools"
},
{
name:"netheriteShovel",
Name:"Netherite Shovel",
item: true,
shovel: true,
durability: 2031,
mineSpeed:9,
attackDamage: 6,
material:"netheriteIngot",
category:"tools"
},
{
name:"netheriteHoe",
Name:"Nethrite Hoe",
item: true,
hoe: true,
durability: 2031,
mineSpeed:9,
attackDamage: 1,
attackSpeed:4,
material:"netheriteIngot",
category:"tools"
},
{
name:"cartographyTable",
Name:"Cartograpgy Table",
textures: ["cartographyTableSide3","cartographyTableTop","cartographyTableSide3","cartographyTableSide1","cartographyTableSide2","cartographyTableSide3"],
rotate:true,
category:"items"
},
{
name:"cake",
Name:"Cake",
textures:["cakeBottom","cakeTop","cakeSide"],
cake:true,
transparent:true,
flatIcon:true,
iconTexture:"cake",
compostChance:1,
category:"food"
},
{
name:"smithingTable",
Name:"Smithing Table",
textures:["smithingTableBottom","smithingTableTop","smithingTableFront","smithingTableSide"],
category:"items"
},
{
name:"stonecutter",
Name:"Stonecutter",
textures:["stonecutterBottom","stonecutterTop","stonecutterSide"],
transparent:true,
stonecutter:true,
category:"items"
},
{
name:"itemFrame",
Name:"Item Frame",
transparent:true,
itemFrame:true,
flatIcon:true,
iconTexture:"itemFrameIcon",
category:"items"
},
{
name:"enderPearl",
Name:"Ender Pearl",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
item.amount--
world.addEntity(new entities[entityIds.EnderPearl](p.x,p.y,p.z, p.direction.x, p.direction.y, p.direction.z, p.id),false,dimension)
},
useAnywhere:true,
category:"items"
},
{
name:"ironNugget",
Name:"Iron Nugget",
item:true,
category:"items"
},
{
name:"goldNugget",
Name:"Gold Nugget",
item:true,
category:"items"
},
{
name:"pumpkin",
Name:"Pumpkin",
textures:["pumpkinSide","pumpkinTop","pumpkinSide"],
compostChance:0.65,
category:"nature"
},
{
name:"carvedPumpkin",
Name:"Carved Pumpkin",
textures:["pumpkinSide","pumpkinTop","pumpkinSide","carvedPumpkin","pumpkinSide","pumpkinSide"],
rotate:true,
compostChance:0.65,
category:"nature"
},
{
name:"jackOLantern",
Name:"Jack o'Lantern",
textures:["pumpkinSide","pumpkinTop","pumpkinSide","jackOLantern","pumpkinSide","pumpkinSide"],
lightLevel:15,
rotate:true,
compostChance:0.65,
category:"nature"
},
{
name:"shears",
Name:"Shears",
item:true,
shears:true,
category:"items"
},
{
name:"pumpkinSeeds",
Name:"Pumpkin Seeds",
item:true,
compostChance:0.3,
category:"items"
},
{
name:"melonSeeds",
Name:"Watermelon Seeds",
item:true,
compostChance:0.3,
category:"items"
},
{
name:"melon",
Name:"Watermelon",
textures:["melonSide","melonTop","melonSide"],
hardness:1,
drop:"melonSlice",
dropAmount:[3,7],
compostChance:0.65,
category:"nature"
},
{
name:"melonSlice",
Name:"Slice of Watermelon",
item:true,
edible: true,
food: 2,
saturation: 1.2,
compostChance:0.5,
category:"nature"
},
{
name:"redstoneLamp",
Name:"Redstone Lamp",
//if you chang this, change colored lamps too
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
category:"redstone"
},
{
name:"glowstoneDust",
Name:"Glowstone Dust",
item:true,
category:"items"
},
{
name:"quartz",
Name:"Quartz",
item:true,
category:"items"
},
{
name: "endPortalFrame", 
Name:"End Portal Frame",
textures: ["endStone", "endPortalFrameTop", "endPortalFrameSide"],
category:"items",
blastResistance:3600000,
hardness:Infinity,
lightLevel:1,
glassSound: true,
eyeplace:function(x,y,z,dimension,world){
this.findFullFrame(x+1,y,z,dimension,world)
this.findFullFrame(x-1,y,z,dimension,world)
this.findFullFrame(x,y,z+1,dimension,world)
this.findFullFrame(x,y,z-1,dimension,world)
},
findFullFrame:function(x,y,z,dimension,world){
if(blockData[world.getBlock(x,y,z)].solid) return
let spread = [], spreadAt = [x,y,z,0]
let minX = x, minZ = z
let maxX = x, maxZ = z
while(spreadAt.length){
let [sx,sy,sz] = spreadAt
if(Math.max(Math.abs(x-sx),Math.abs(y-sy),Math.abs(z-sz)) > 2) return //portal area isn't that big
minX = Math.min(minX,sx), minZ = Math.min(minZ,sz)
maxX = Math.max(maxX,sx), maxZ = Math.max(maxZ,sz)
if(!xyArrayHas(spread,spreadAt,sx,sy,sz+1)){
let b = world.getBlock(sx,sy,sz+1,dimension)
if(!blockData[b].solid) spreadAt.push(sx,sy,sz+1,0)
else if(blockData[b].name !== this.name) return
}
if(!xyArrayHas(spread,spreadAt,sx,sy,sz-1)){
let b = world.getBlock(sx,sy,sz-1,dimension)
if(!blockData[b].solid) spreadAt.push(sx,sy,sz-1,0)
else if(blockData[b].name !== this.name) return
}
if(!xyArrayHas(spread,spreadAt,sx+1,sy,sz)){
let b = world.getBlock(sx+1,sy,sz,dimension)
if(!blockData[b].solid) spreadAt.push(sx+1,sy,sz,0)
else if(blockData[b].name !== this.name) return
}
if(!xyArrayHas(spread,spreadAt,sx-1,sy,sz)){
let b = world.getBlock(sx-1,sy,sz,dimension)
if(!blockData[b].solid) spreadAt.push(sx-1,sy,sz,0)
else if(blockData[b].name !== this.name) return
}
spread.push(...spreadAt.splice(0,4))
}
//check if frame is correct
x = minX-1, z = minZ-1
if(world.getBlock(x+1,y,z,dimension) !== (this.id | SLAB | SOUTH)) return
if(world.getBlock(x+2,y,z,dimension) !== (this.id | SLAB | SOUTH)) return
if(world.getBlock(x+3,y,z,dimension) !== (this.id | SLAB | SOUTH)) return
if(world.getBlock(x+4,y,z+1,dimension) !== (this.id | SLAB | EAST)) return
if(world.getBlock(x+4,y,z+2,dimension) !== (this.id | SLAB | EAST)) return
if(world.getBlock(x+4,y,z+3,dimension) !== (this.id | SLAB | EAST)) return
if(world.getBlock(x+1,y,z+4,dimension) !== (this.id | SLAB | NORTH)) return
if(world.getBlock(x+2,y,z+4,dimension) !== (this.id | SLAB | NORTH)) return
if(world.getBlock(x+3,y,z+4,dimension) !== (this.id | SLAB | NORTH)) return
if(world.getBlock(x,y,z+1,dimension) !== (this.id | SLAB | WEST)) return
if(world.getBlock(x,y,z+2,dimension) !== (this.id | SLAB | WEST)) return
if(world.getBlock(x,y,z+3,dimension) !== (this.id | SLAB | WEST)) return
//place the frame
world.setBlock(x+1,y,z+1,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+2,y,z+1,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+3,y,z+1,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+1,y,z+2,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+2,y,z+2,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+3,y,z+2,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+1,y,z+3,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+2,y,z+3,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+3,y,z+3,blockIds.endPortal,false,false,false,false,dimension)
world.playSound(x+2,y,z+2,"end_portal.endportal")
}
},
{
name: "eyeOfEnder",
Name:"Eye of Ender",
flatIcon:true,
item:true,
placeSound:["end_portal.eyeplace1","end_portal.eyeplace2","end_portal.eyeplace3"],
category:"items"
},
{
name:"endStone",
Name:"End Stone",
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"redSand",
Name:"Red Sand",
hardness:0.5,
fallingDust:[178/255, 94/255, 26/255],
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
category:"nature",
digSound: ["sand.dig1", "sand.dig2", "sand.dig3", "sand.dig4"],
stepSound: ["sand.step1", "sand.step2","sand.step3","sand.step4","sand.step5"]
},
{
name:"redSandstone",
Name:"Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop", "redSandstone"],
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true
},
{ name:"chiseledRedSandstone",
Name:"Chiseled Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop","chiseledRedSandstone"],
category:"build",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true
},
{ name:"cutRedSandstone",
Name:"Cut Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop","cutRedSandstone"],
category:"build",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true
},
{ name:"smoothRedSandstone", Name:"Smooth Red Sandstone", textures:"redSandstoneTop", category:"nature", randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true },
{
name:"purpurBlock",
Name:"Purpur Block",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"purpurPillar",
Name:"Purpur Pillar",
textures:["purpurPillarTop","purpurPillar"],
category:"build"
},
{
name:"purpurPillarSW",
textures:["purpurPillar","purpurPillar","purpurPillarTop","purpurPillar"],
SW: true,
hidden:true
},
{
name:"prismarine",
Name:"Prismarine",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"prismarineBricks",
Name:"Prismarine Bricks",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"darkPrismarine",
Name:"Dark Prismarine",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"prismarineCrystals",
Name:"Prismarine Crystals",
category:"items",
item:true
},
{
name:"prismarineShard",
Name:"Prismarine Shard",
item:true,
category:"items"
},
{
name:"seaLantern",
Name:"Sea Lantern",
lightLevel:15,
hardness:0.3,
category:"decoration"
},
{
name:"oakLeaves",
Name: "Oak Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "oakSapling"
else{
return rand() > 0.8 ? "orange" : "apple"
}
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "acaciaLeaves",
Name:"Acacia Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "acaciaSapling"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "birchLeaves",
Name:"Birch Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "birchSapling"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "darkOakLeaves",
Name:"Dark Oak Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "darkOakSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "jungleLeaves",
Name:"Jungle Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "jungleSapling"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "spruceLeaves",
Name:"Spruce Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "spruceSapling"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name:"spyglass",
Name:"Spyglass",
textures:"spyglassModel",
iconTexture:"spyglass",
item:true,
spyglass:true,
category:"items"
},
{
name:"egg",
Name:"Egg",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
item.amount--
world.addEntity(new entities[entityIds.Egg](p.x+pd.x,p.y+pd.y,p.z+pd.z, pd.x*0.8, pd.y*0.8, pd.z*0.8, p.id),false,dimension)
},
useAnywhere:true,
category:"items"
},
{
name:"noodles",
Name:"Noodles",
item:true,
category:"food",
hidden:true
},
{
name:"bowl",
Name:"Bowl",
item:true,
category:"items"
},
{
name:"mushroomStew",
Name:"Mushroom Stew",
edible: true,
item:true,
eatWhenFull: false,
food: 6,
saturation: 7.2,
eatResult:"bowl",
category:"food"
},
{
name:"ramen",
Name:"Ramen! Yum!",
edible: true,
item:true,
eatWhenFull: true,
food: 8,
saturation: 10,
eatResult:"bowl",
category:"food",
hidden:true
},
{
name:"orange",
Name:"Orange",
edible: true,
item:true,
eatWhenFull: false,
food: 4,
saturation: 2.4,
category:"food"
},
{
name:"fern",
Name:"Fern",
solid: false,
transparent: true,
shadow: false,
flatIcon: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
potCross:true
},
{
name: "largeFern",
Name:"Large Fern",
solid: false,
transparent: true,
shadow: false,
textures: "largeFernTop",
tallcrossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name:"fire",
fire:true,
damage:1,
burnEnt:true,
transparent:true,
shadow:false,
solid:false,
lightLevel:15,
ambientSound:"fire.fire",
temperature:20,
smoothLight:false,
hidden:true,
liquidBreakable:true,
noHitbox:true,
tagBits:{
age:[0,8]
},
getAttached:function(x,y,z,block,dimension,getBlockOnly,world){
var ax = x, ay = y, az = z
switch(block){
case this.id:
ay--
break
case this.id | STAIR:
ay++
break
case this.id | SLAB | NORTH:
az++
break
case this.id | SLAB | SOUTH:
az--
break
case this.id | SLAB | EAST:
ax++
break
case this.id | SLAB | WEST:
ax--
break
}
var attached = world.getBlock(ax,ay,az,dimension)
if(getBlockOnly) return attached
else return [attached,ax,ay,az]
},
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var block = this.getAttached(x,y,z,b,dimension,true,world)
if(!block || !blockData[block].solid && !blockData[block].liquid) world.setBlock(x,y,z,0,false,false,false,false,dimension)
},
tick:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var attached = this.getAttached(x,y,z,block,dimension,false,world)
var ax = attached[1], ay = attached[2], az = attached[3]
attached = attached[0]
var age = world.getTagByName(x,y,z,"age",dimension)
if(!age) age = 0
age += rand(10,11)
//finish burning
if(age >= 15 && (!attached || !blockData[attached].burnTime)){
return world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
if(attached && blockData[attached].burnTime && age > blockData[attached].burnTime){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
world.setBlock(ax,ay,az,0,false,false,false,false,dimension)
return
}
if(age > 255) age = 255
world.setTagByName(x,y,z,"age",age,false,dimension)
if(world.weather === "rain" && world.weatherAmount > 0.5){
let top = world.getSolidTop(x,z,dimension)
if(y > top) world.setBlock(x,y,z,0,false,false,false,false,dimension) //rain extinguish
}
this.spread(x,y,z,dimension,world)
},
spread:function(x,y,z,dimension,world){
for(var i=x-1; i<=x+1; i++){
for(var j=y-1; j<=y+4; j++){
for(var k=z-1; k<=z+1; k++){
var block = world.getBlock(i,j,k,dimension)
if(block && blockData[block].burnChance && rand() < blockData[block].burnChance){
if(blockData[block].onburn) blockData[block].onburn(i,j,k,dimension,world)
var block
let rx, ry, rz
//find a place where the fire can go
for(var t=0; t<6; t++){
rx = i, ry = j, rz = k
switch(floor(rand(6))){
case 0:
block = this.id
ry++
break
case 1:
block = this.id | STAIR
ry--
break
case 2:
block = this.id | SLAB | NORTH
rz--
break
case 3:
block = this.id | SLAB | SOUTH
rz++
break
case 4:
block = this.id | SLAB | EAST
rx--
break
case 5:
block = this.id | SLAB | WEST
rx++
break
}
if(!world.getBlock(rx,ry,rz,dimension)) break
}
if(!world.getBlock(rx,ry,rz,dimension)) world.setBlock(rx,ry,rz,block,false,false,false,false,dimension)
}
}
}
}
},
tryCreatePortalZ:function(x,y,z,dimension){ //weird portals are allowed
let spread = [], spreadAt = [x,y,z,0], maxSpread = 23, block
while(spreadAt.length){
let [sx,sy,sz,i] = spreadAt.splice(0,4)
spread.push(sx,sy,sz,i)
if(max(abs(sx-x),abs(sy-y),abs(sz-z)) > maxSpread) return
block = world.getBlock(sx,sy,sz+1,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy,sz+1)){
if(!blockData[block].solid) spreadAt.push(sx,sy,sz+1,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy,sz-1,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy,sz-1)){
if(!blockData[block].solid) spreadAt.push(sx,sy,sz-1,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy+1,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy+1,sz)){
if(!blockData[block].solid) spreadAt.push(sx,sy+1,sz,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy-1,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy-1,sz)){
if(!blockData[block].solid) spreadAt.push(sx,sy-1,sz,i+1)
else if(block !== blockIds.obsidian) return
}
}
for(let i=0; i<spread.length; i+=4){
world.setBlock(spread[i],spread[i+1],spread[i+2],blockIds.portal|PORTAL|EAST,false,false,false,false,dimension)
}
return true
},
tryCreatePortalX:function(x,y,z,dimension){ //weird portals are allowed
let spread = [], spreadAt = [x,y,z,0], maxSpread = 23, block
while(spreadAt.length){
let [sx,sy,sz,i] = spreadAt.splice(0,4)
spread.push(sx,sy,sz,i)
if(max(abs(sx-x),abs(sy-y),abs(sz-z)) > maxSpread) return
block = world.getBlock(sx+1,sy,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx+1,sy,sz)){
if(!blockData[block].solid) spreadAt.push(sx+1,sy,sz,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx-1,sy,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx-1,sy,sz)){
if(!blockData[block].solid) spreadAt.push(sx-1,sy,sz,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy+1,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy+1,sz)){
if(!blockData[block].solid) spreadAt.push(sx,sy+1,sz,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy-1,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy-1,sz)){
if(!blockData[block].solid) spreadAt.push(sx,sy-1,sz,i+1)
else if(block !== blockIds.obsidian) return
}
}
for(let i=0; i<spread.length; i+=4){
world.setBlock(spread[i],spread[i+1],spread[i+2],blockIds.portal|PORTAL|NORTH,false,false,false,false,dimension)
}
return true
},
tryCreatePortal:function(x,y,z,dimension){
return this.tryCreatePortalZ(x,y,z,dimension) || this.tryCreatePortalX(x,y,z,dimension)
}
},
{
name: "endRod",
Name:"End Rod",
transparent: true,
shadow: false,
lightLevel: 15,
category:"decoration"
},
{
name: "oakWood",
Name:"Oak Wood",
textures: "logSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "acaciaWood",
Name:"Acacia Wood",
textures: "acaciaLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "birchWood",
Name:"Birch Wood",
textures: "birchLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "darkOakWood",
Name:"Dark Oak Wood",
textures: "darkOakLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "jungleWood",
Name:"Jungle Wood",
textures: "jungleLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "spruceWood",
Name:"Spruce Wood",
textures: "spruceLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "crimsonHyphae",
textures: "crimsonStemSide",
stemSound: true,
hardness:2,
type:"wood",
category:"nature"
},
{
name: "warpedHyphae",
textures: "warpedStemSide",
stemSound: true,
hardness:2,
type:"wood",
category:"nature"
},
{
name: "strippedOakWood",
Name:"Stripped Oak Wood",
textures: "strippedOakLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedAcaciaWood",
Name:"Stripped Acacia Wood",
textures: "strippedAcaciaLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedBirchWood",
Name:"Stripped Birch Wood",
textures: "strippedBirchLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedDarkOakWood",
Name:"Stripped Dark Oak Wood",
textures: "strippedDarkOakLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedJungleWood",
Name:"Stripped Jungle Wood",
textures: "strippedJungleLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedSpruceWood",
Name:"Stripped Spruce Wood",
textures: "strippedSpruceLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedCrimsonHyphae",
textures: "strippedCrimsonStem",
stemSound: true,
hardness:2,
type:"wood",
category:"build"
},
{
name: "strippedWarpedHyphae",
textures: "strippedWarpedStem",
stemSound: true,
hardness:2,
type:"wood",
category:"build"
},
{
name:"oakFenceGate",
Name:"Oak Fence Gate",
textures:"oakPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"acaciaFenceGate",
Name:"Acacia Fence Gate",
textures:"acaciaPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"birchFenceGate",
Name:"Birch Fence Gate",
textures:"birchPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"darkOakFenceGate",
Name:"Dark Oak Fence Gate",
textures:"darkOakPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"jungleFenceGate",
Name:"Jungle Fence Gate",
textures:"junglePlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"spruceFenceGate",
Name:"Spruce Fence Gate",
textures:"sprucePlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"crimsonFenceGate",
Name:"Crimson Fence Gate",
textures:"crimsonPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"warpedFenceGate",
Name:"Warped Fence Gate",
textures:"warpedPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{ 
name: "kelp",
Name:"Kelp",
flatIcon:true,
iconTexture:"kelpIcon",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isIt = blockData[top].name === "kelp" || blockData[top].name === "kelpPlant"
if(isIt){
world.setBlock(x,y,z,blockIds.kelpPlant | CROSS,false,false,false,false,dimension)
}
},
category:"nature"
},
{ 
name: "kelpPlant",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isIt = blockData[top].name === "kelp" || blockData[top].name === "kelpPlant"
if(!isIt){
world.setBlock(x,y,z,blockIds.kelp | CROSS,false,false,false,false,dimension)
}
},
hidden:true
},
{
name:"seagrass",
Name:"Seagrass",
iconTexture:"seagrassIcon",
transparent: true,
solid: false,
shadow: false,
crop:true,
category:"nature"
},
{
name:"tallSeagrass",
Name:"Tall Seagrass",
textures:"tallSeagrassTop",
transparent: true,
solid: false,
shadow: false,
tallCrop:true,
category:"nature"
},
{
name:"barrel",
Name:"Barrel",
textures:["barrelBottom","barrelTop","barrelSide"],
texturesOpen:fillTextureArray(["barrelBottom","barrelTopOpen","barrelSide"]),
texturesSW:fillTextureArray(["barrelSide","barrelSide","barrelTop","barrelSide"]),
texturesSWOpen:fillTextureArray(["barrelSide","barrelSide","barrelTopOpen","barrelSide"]),
texturesDown:fillTextureArray(["barrelTop","barrelBottom","barrelSide"]),
texturesDownOpen:fillTextureArray(["barrelTopOpen","barrelBottom","barrelSide"]),
woodSound:true,
barrel:true,
category:"items",
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {chest:true, contents:new Array(27).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.chest && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
},
{
name:"endStoneBricks",
Name:"End Stone Bricks",
stoneSound:true,
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"beeNest",
Name:"Bee Nest",
textures:["beeNestBottom","beeNestTop","beeNestSide","beeNestFront","beeNestSide","beeNestSide"],
texturesHoney:["beeNestBottom","beeNestTop","beeNestSide","beeNestFrontHoney","beeNestSide","beeNestSide"],
rotate:true,
category:"nature"
},
{
name:"beehive",
Name:"Beehive",
textures:["beehiveEnd","beehiveEnd","beehiveSide","beehiveFront","beehiveSide","beehiveSide"],
texturesHoney:["beehiveEnd","beehiveEnd","beehiveSide","beehiveFrontHoney","beehiveSide","beehiveSide"],
rotate:true,
category:"items"
},
{
name:"honeyBlock",
Name:"Block of Honey",
textures:"honeyBlockBottom",
transparent:true,
shapeName:"honeyBlock",
damageResistance:0.8,
category:"build",
sticky:true
},
{
name:"honeycomb",
Name:"Honeycomb",
item:true,
category:"items"
},
{
name:"honeycombBlock",
Name:"Honeycomb Block",
category:"build"
},
{
name:"coarseDirt",
Name:"Coarse Dirt",
hardness:1,
type:"ground",
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
},
{
name:"inkSac",
Name:"Ink Sac",
item:true,
category:"items"
},
{
name:"glowInkSac",
Name:"Glow Ink Sac",
item:true,
category:"items"
},
{
name:"glowItemFrame",
Name:"Glow Item Frame",
transparent:true,
itemFrame:true,
flatIcon:true,
iconTexture:"glowItemFrameIcon",
category:"items"
},
{
name:"glowLichen",
Name:"Glow Lichen",
transparent: true,
shadow: false,
wallFlat: true,
flatIcon:true,
solid:false,
lightLevel:7,
compostChance:0.5,
category:"nature"
},
{
name:"sponge",
Name:"Sponge",
wetTexture:new Array(6).fill("wetSponge"),
category:"items",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"cutCopper",
Name:"Cut Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"exposedCopper",
Name:"Exposed Block of Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"exposedCutCopper",
Name:"Exposed Cut Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"weatheredCopper",
Name:"Weathered Block of Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"weatheredCutCopper",
Name:"Weathered Cut Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"oxidizedCopper",
Name:"Oxidized Block of Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"oxidizedCutCopper",
Name:"Oxidized Cut Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"quartzBricks",
Name:"Quartz Bricks",
stoneSound:true,
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"campfire",
Name:"Campfire",
flatIcon:true,
iconTexture:"campfire",
textures: "campfireLogLit",
campfire:true,
shadow:false,
lightLevel:15,
transparent:true,
woodSound:true,
drop:"campfire",
category:"items",
damageUp:2,
burnEnt:true,
smoothLight:false,
blastResistance:2,
hardness:2,
activate:function(x,y,z,dimension,block,ent){
if(ent.burning && block === (this.id | SLAB) && onBoxEnt(x,y,z,1,1,1,ent)){
world.setBlock(x,y,z,this.id,false,false,false,false,dimension)
}
}
},
{
name:"soulCampfire",
Name:"Soul Campfire",
flatIcon:true,
iconTexture:"soulCampfire",
textures: "soulCampfireLogLit",
campfire:true,
shadow:false,
lightLevel:10,
transparent:true,
woodSound:true,
drop:"soulCampfire",
category:"items",
damageUp:4,
burnEnt:true,
smoothLight:false,
blastResistance:2,
hardness:2,
activate:function(x,y,z,dimension,block,ent){
if(ent.burning && block === (this.id | SLAB) && onBoxEnt(x,y,z,1,1,1,ent)){
world.setBlock(x,y,z,this.id,false,false,false,false,dimension)
}
}
},
{
name:"bambooShoot",
Name:"Bamboo Shoot",
textures:"bambooStage0",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
liquidBreakable:"drop",
category:"nature",
potCross:true
},
{
name:"bambooStalk",
Name:"Bamboo",
iconTexture:"bamboo",
flatIcon:true,
bamboo:true,
shadow: false,
potCross:true,
transparent:true,
drop:"bambooStalk",
hardness:1,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
liquidBreakable:"drop",
category:"nature"
},
{
name:"chest",
Name:"Chest",
textures:/*"christmasChestSide",//*/"chestFront",//christmas
transparent:true,
chest:true,
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {chest:true, contents:new Array(27).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.chest && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
category:"items"
},
{
name:"boneMeal",
Name:"Bone \"Meal\"",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
item.amount--
if(blockData[block].grow){
blockData[block].grow(x,y,z,dimension,world)
}else if(blockData[block].growBonemeal){
blockData[block].growBonemeal(x,y,z,dimension,world)
}else return true
world.glint(x,y,z,dimension)
},
category:"items"
},
{
name:"clay",
Name:"Clay",
hardness:0.6,
type:"ground",
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"],
drop:"clayBall",
dropAmount:4,
category:"nature"
},
{
name:"clayBall",
Name:"Clay Ball",
item:true,
category:"items"
},
{
name:"brick",
Name:"Brick",
item:true,
category:"items"
},
{
name:"charcoal",
Name:"Charcoal",
item:true,
category:"items"
},
{
name:"appleCore",
Name:"Apple Core",
item:true,
category:"items"
},
{
name:"tintedGlass",
Name:"Tinted Glass",
transparent: true,
shadow: true,
hardness: 0.3,
type: "glass",
glassSound: true,
category:"build"
},
{
name:"tomato",
Name:"Tomato",
item:true,
edible:true,
eatWhenFull: false,
food: 3,
saturation: 2,
eatResult:"tomatoSeeds",
category:"nature"
},
{
name:"tomatoPlant",
Name:"Tomato Plant",
textures:new Array(6).fill("tomatoPlantStage0"),
textures1:new Array(6).fill("tomatoPlantStage1"),
textures2:new Array(6).fill("tomatoPlantStage2"),
textures3:new Array(6).fill("tomatoPlantStage3"),
textures4:new Array(6).fill("tomatoPlantStage4"),
iconTexture:"tomatoPlantStage3",
flatIcon:true,
shadow:false,
transparent:true,
solid:false,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
category:"nature",
liquidBreakable:"drop",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|TALLCROSS,false,false,false,false,dimension)
}
},
{
name:"tomatoSeeds",
Name:"Tomato Seeds",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland"){
return "tomatoPlant"
}else{
Messages.write("tomato seeds need to be planted on farmland")
p.lastPlace = Date.now()
}
},
category:"nature"
},
{
name:"newCactusFruit",
Name:"New Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
cactusFruit:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.3,
liquidBreakable:true,
category:"nature"
},
{
name:"greenCactusFruit",
Name:"Green Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
cactusFruit:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.4,
liquidBreakable:true,
category:"nature"
},
{
name:"redCactusFruit",
Name:"Red Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
edible: true,
eatWhenFull: false,
food: 2,
saturation: 1,
cactusFruit:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.5,
liquidBreakable:true,
category:"food"
},
{
name:"purpleCactusFruit",
Name:"Purple Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
edible: true,
eatWhenFull: false,
food: 3,
saturation: 2,
cactusFruit:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.6,
liquidBreakable:true,
category:"food"
},
{
name:"cherry",
Name:"Cherry",
item:true,
edible:true,
eatWhenFull: false,
food: 1,
saturation: 1,
compostChance:0.5,
category:"food"
},
{
name:"cherryLog",
Name:"Cherry Log",
textures:["cherryLogTop","cherryLog"],
woodSound:true,
hardness:2,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name:"cherryLogSW",
textures: ["cherryLog","cherryLog","cherryLogTop","cherryLog"],
rotate: true,
woodSound:true,
hidden:true
},
{
name:"greenCherryLeaves", //Before minecraft 1.20 update
Name:"Green Cherry Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "cherrySapling"
else return "cherry"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
grassSound: true,
category:"nature",
hidden:true
},
{
name:"cherryLeaves",
Name:"Cherry Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "cherrySapling"
else if(rand() > 0.5) return "cherry"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
grassSound: true,
category:"nature"
},
{
name:"cherrySapling",
Name:"Cherry Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
category:"nature",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnCherryTree(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
}
},
{
name:"cherryWood",
Name:"Cherry Wood",
textures: "cherryLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name:"slingshot",
Name:"Slingshot",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
var pd = p.direction
world.addEntity(new entities[entityIds.SlingshotShot](p.x,p.y,p.z,pd.x,pd.y,pd.z),false,dimension)
},
useAnywhere:true,
stackSize:1,
category:"tools"
},
{
name:"redstoneTorch",
Name:"Redstone Torch",
transparent: true,
shadow: false,
redstoneTorch: true,
lightLevel: 7,
woodSound:true,
solid:false,
flatIcon:true,
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
if(world.getPower(x,y,z,dimension) === 16){ //is torch on?
var b = world.getBlock(x,y+1,z,dimension)
if(b && !blockData[b].transparent){
world.setBlockPower(x,y+1,z, "strong", "bottom",dimension) //torch is under this block
}
b = world.getBlock(x,y-1,z,dimension)
if(b && blockData[b].carryRedstone){
world.setPower(x,y-1,z,15,false,dimension)
world.spreadPower(x,y-1,z,15,dimension)
}
}
},
onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var that = this
world.setTimeout(function(){
//find block it's attached to
var me = world.getBlock(x,y,z,dimension)
var ax=x,ay=y,az=z
var wall = that.id | SLAB
var wallOff = that.id | STAIR
switch(me){
case wall | NORTH:
case wallOff | NORTH:
az++
break
case wall | SOUTH:
case wallOff | SOUTH:
az--
break
case wall | EAST:
case wallOff | EAST:
ax++
break
case wall | WEST:
case wallOff | WEST:
ax--
break
default:
ay--
}
var block = world.getBlock(ax,ay,az,dimension)
//see if the torch should be on of off
var on = world.getPower(ax,ay,az,dimension) || world.getBlockPower(ax,ay,az,null,dimension) ? false : true
var target = me
if(on){
switch(me){
case wallOff | NORTH:
target = wall | NORTH
break
case wallOff | SOUTH:
target = wall | SOUTH
break
case wallOff | EAST:
target = wall | EAST
break
case wallOff | WEST:
target = wall | WEST
break
case that.id | CROSS:
target = that.id
}
}else{
switch(me){
case wall | NORTH:
target = wallOff | NORTH
break
case wall | SOUTH:
target = wallOff | SOUTH
break
case wall | EAST:
target = wallOff | EAST
break
case wall | WEST:
target = wallOff | WEST
break
case that.id:
target = that.id | CROSS
}
}
//set it
if(me !== target) {
world.setBlock(x,y,z,target,false,false,false,false,dimension)
if(on){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,16,dimension)
}else{
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
}
var b = world.getBlock(x,y+1,z,dimension)
if(b && !blockData[b].transparent){
world.setBlockPower(x,y+1,z, on ? "strong" : null, "bottom",dimension) //torch is under this block
}
b = world.getBlock(x,y-1,z,dimension)
if(b && blockData[b].carryRedstone){
if(on){
world.setPower(x,y-1,z,15,false,dimension)
world.spreadPower(x,y-1,z,15,dimension)
}else{
world.unspreadPower(x,y-1,z,15,true,dimension)
}
}
}
},tickTime*2, x,y,z,dimension)
},
onset:function(x,y,z,dimension,world){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,16,dimension)
},
ondelete:function(x,y,z,prevTags,prev,dimension,world){
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
var b = world.getBlock(x,y+1,z,dimension)
if(b && !blockData[b].transparent){
world.setBlockPower(x,y+1,z, null, "bottom",dimension) //torch is under this block
}
b = world.getBlock(x,y-1,z,dimension)
if(b && blockData[b].carryRedstone){
world.unspreadPower(x,y-1,z,15,true,dimension)
}
},
category:"redstone"
},
{
name:"redstoneConnector",
Name:"Block That Redstone Dust Connects To",
stoneSound:true,
category:"redstone"
},
{
name:"lever",
Name:"Lever",
transparent:true,
shadow:false,
solid:false,
lever:true,
flatIcon:true,
onclick:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var me = blockData[blockIds.lever]
var wall = me.id
var wallOn = me.id | SLAB
var ax = x, ay = y, az = z
var dir
switch(block){
case wall | NORTH:
case wallOn | NORTH:
az++
dir = "south"
break
case wall | SOUTH:
case wallOn | SOUTH:
az--
dir = "north"
break
case wall | EAST:
case wallOn | EAST:
ax++
dir = "east"
break
case wall | WEST:
case wallOn | WEST:
ax--
dir = "west"
break
case me.id | STAIR:
case me.id | CROSS:
ay --
dir = "top"
break
case me.id | TALLCROSS:
case me.id | DOOR:
ay ++
dir = "bottom"
break
}
var target, on
switch(block){
case wall | NORTH:
on = true
target = wallOn | NORTH
break
case wall | SOUTH:
on = true
target = wallOn | SOUTH
break
case wall | EAST:
on = true
target = wallOn | EAST
break
case wall | WEST:
on = true
target = wallOn | WEST
break
case wallOn | NORTH:
on = false
target = wall | NORTH
break
case wallOn | SOUTH:
on = false
target = wall | SOUTH
break
case wallOn | EAST:
on = false
target = wall | EAST
break
case wallOn | WEST:
on = false
target = wall | WEST
break
case me.id | STAIR:
on = true
target = me.id | CROSS
break
case me.id | CROSS:
on = false
target = me.id | STAIR
break
case me.id | TALLCROSS:
on = true
target = me.id | DOOR
break
case me.id | DOOR:
on = false
target = me.id | TALLCROSS
break
}
world.setBlock(x,y,z,target,false,false,false,false,dimension)
if(on){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,15,dimension)
}else{
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
}
var a = world.getBlock(ax,ay,az,dimension)
if(a && !blockData[a].transparent){
world.setBlockPower(ax,ay,az,on ? "strong" : null,dir,dimension)
}
},
ondelete:function(x,y,z,prevTags,prevBlock,dimension,world){
if(getTagBits(prevTags,"power",this.id)){
world.unspreadPower(x,y,z,16,false,dimension)
var block = prevBlock
var me = blockData[blockIds.lever]
var wall = me.id
var wallOn = me.id | SLAB
var ax = x, ay = y, az = z
var dir
switch(block){
case wall | NORTH:
case wallOn | NORTH:
az++
dir = "south"
break
case wall | SOUTH:
case wallOn | SOUTH:
az--
dir = "north"
break
case wall | EAST:
case wallOn | EAST:
ax++
dir = "east"
break
case wall | WEST:
case wallOn | WEST:
ax--
dir = "west"
break
case me.id | STAIR:
case me.id | CROSS:
ay --
dir = "top"
break
case me.id | TALLCROSS:
case me.id | DOOR:
ay ++
dir = "bottom"
break
}
var a = world.getBlock(ax,ay,az,dimension)
if(a && !blockData[a].transparent){
world.setBlockPower(ax,ay,az,null,dir,dimension)
}
}
},
category:"redstone"
},
{
name:"repeater",
Name:"Redstone Repeater",
flatIcon:true,
iconTexture:"repeaterIcon",
repeater:true,
transparent:true,
onupdate:function(x,y,z,b,w,sx,sy,sz,dimension){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
},
ondelete:function(x,y,z,prevTags,prevBlock,dimension,world){
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(x,y,z+1,null,"south",dimension)
world.setBlockPower(x,y,z-1,null,"north",dimension)
world.setBlockPower(x+1,y,z,null,"east",dimension)
world.setBlockPower(x-1,y,z,null,"west",dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var fx = x, fy = y, fz = z //from
var tx = x, ty = y, tz = z //pointing to
var side //side of block it's pointing to
var block = world.getBlock(x,y,z,dimension)
var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
switch(block){
case d1 | NORTH:
case d2 | NORTH:
case d3 | NORTH:
case d4 | NORTH:
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
fz--
tz++
side = "south"
break
case d1 | SOUTH:
case d2 | SOUTH:
case d3 | SOUTH:
case d4 | SOUTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
fz++
tz--
side = "north"
break
case d1 | EAST:
case d2 | EAST:
case d3 | EAST:
case d4 | EAST:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
fx--
tx++
side = "east"
break
case d1 | WEST:
case d2 | WEST:
case d3 | WEST:
case d4 | WEST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
fx++
tx--
side = "west"
break
}
if(fx === x && fy === y && fz === z) return console.log("doesn't match up") //doesn't match up
var delay
switch(block){
case d1 | NORTH:
case d1 | SOUTH:
case d1 | EAST:
case d1 | WEST:
case D1 | NORTH:
case D1 | SOUTH:
case D1 | EAST:
case D1 | WEST:
delay = 1
break
case d2 | NORTH:
case d2 | SOUTH:
case d2 | EAST:
case d2 | WEST:
case D2 | NORTH:
case D2 | SOUTH:
case D2 | EAST:
case D2 | WEST:
delay = 2
break
case d3 | NORTH:
case d3 | SOUTH:
case d3 | EAST:
case d3 | WEST:
case D3 | NORTH:
case D3 | SOUTH:
case D3 | EAST:
case D3 | WEST:
delay = 3
break
case d4 | NORTH:
case d4 | SOUTH:
case d4 | EAST:
case d4 | WEST:
case D4 | NORTH:
case D4 | SOUTH:
case D4 | EAST:
case D4 | WEST:
delay = 4
break
}
if(!delay) return console.log("delay hasn't been set")
var on = false
switch(block){ //todo: make it an if loop
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
on = true
}
var tblock = world.getBlock(tx,ty,tz,dimension)
if(tblock && blockData[tblock].carryRedstone){
if(on){
if(world.getPower(tx,ty,tz,dimension) !== 15){
world.setPower(tx,ty,tz,15,false,dimension)
world.spreadPower(tx,ty,tz,15,dimension)
}
}
}else if(tblock && !blockData[tblock].transparent){
if(on){
world.setBlockPower(tx,ty,tz,"strong",side,dimension)
}else{
world.setBlockPower(tx,ty,tz,null,side,dimension)
}
}
var shouldBeOn = world.getRepeaterPower(x,y,z,fx,fy,fz,dimension) || world.getBlockPower(fx,fy,fz,null,dimension) ? true : false
if(on === shouldBeOn) return
var t = function(){
block = world.getBlock(x,y,z,dimension)
var on = world.getRepeaterPower(x,y,z,fx,fy,fz,dimension) || world.getBlockPower(fx,fy,fz,null,dimension) ? true : false //should it be on?
var isOn = false
switch(block){ //todo: make it an if loop
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
isOn = true
}
if(on !== isOn) {
var target
var f = "north"
switch(block){
case d1 | NORTH:
target = D1
break
case d2 | NORTH:
target = D2
break
case d3 | NORTH:
target = D3
break
case d4 | NORTH:
target = D4
break
case D1 | NORTH:
target = d1
break
case D2 | NORTH:
target = d2
break
case D3 | NORTH:
target = d3
break
case D4 | NORTH:
target = d4
break
case d1 | SOUTH:
target = D1, f = "south"
break
case d2 | SOUTH:
target = D2, f = "south"
break
case d3 | SOUTH:
target = D3, f = "south"
break
case d4 | SOUTH:
target = D4, f = "south"
break
case D1 | SOUTH:
target = d1, f = "south"
break
case D2 | SOUTH:
target = d2, f = "south"
break
case D3 | SOUTH:
target = d3, f = "south"
break
case D4 | SOUTH:
target = d4, f = "south"
break
case d1 | EAST:
target = D1, f = "east"
break
case d2 | EAST:
target = D2, f = "east"
break
case d3 | EAST:
target = D3, f = "east"
break
case d4 | EAST:
target = D4, f = "east"
break
case D1 | EAST:
target = d1, f = "east"
break
case D2 | EAST:
target = d2, f = "east"
break
case D3 | EAST:
target = d3, f = "east"
break
case D4 | EAST:
target = d4, f = "east"
break
case d1 | WEST:
target = D1, f = "west"
break
case d2 | WEST:
target = D2, f = "west"
break
case d3 | WEST:
target = D3, f = "west"
break
case d4 | WEST:
target = D4, f = "west"
break
case D1 | WEST:
target = d1, f = "west"
break
case D2 | WEST:
target = d2, f = "west"
break
case D3 | WEST:
target = d3, f = "west"
break
case D4 | WEST:
target = d4, f = "west"
break
}
switch(f){
case "north":
break
case "south":
target |= SOUTH
break
case "east":
target |= EAST
break
case "west":
target |= WEST
}
if(block !== target) world.setBlock(x,y,z,target,false,false,false,false,dimension)
var tblock = world.getBlock(tx,ty,tz,dimension)
if(on){
if(tblock && blockData[tblock].carryRedstone){
if(world.getPower(tx,ty,tz,dimension) !== 15){
world.setPower(tx,ty,tz,15,false,dimension)
world.spreadPower(tx,ty,tz,15,dimension)
}
}else if(tblock && !blockData[tblock].transparent){
world.setBlockPower(tx,ty,tz,"strong",side,dimension)
}
}else{
if(tblock && blockData[tblock].carryRedstone){
world.unspreadPower(tx,ty,tz,15,true,dimension)
}else if(tblock && !blockData[tblock].transparent){
world.setBlockPower(tx,ty,tz,null,side,dimension)
}
}
}//end if repeater power changed
}
world.setTimeout(t,tickTime*delay*2, x,y,z,dimension)
},
onclick:function(x,y,z,dimension){
var me = blockData[blockIds.repeater]
var block = world.getBlock(x,y,z,dimension)
var d1 = me.id, d2 = me.id | SLAB, d3 = me.id | STAIR, d4 = me.id | DOOR //delay
var D1 = me.id | PANE, D2 = me.id | PORTAL, D3 = me.id | WALLFLAT, D4 = me.id | TRAPDOOROPEN //delay for on repeaters
var target
switch(block){
case d1 | NORTH:
target = d2 | NORTH
break
case d2 | NORTH:
target = d3 | NORTH
break
case d3 | NORTH:
target = d4 | NORTH
break
case d4 | NORTH:
target = d1 | NORTH
break
case D1 | NORTH:
target = D2 | NORTH
break
case D2 | NORTH:
target = D3 | NORTH
break
case D3 | NORTH:
target = D4 | NORTH
break
case D4 | NORTH:
target = D1 | NORTH
break
case d1 | SOUTH:
target = d2 | SOUTH
break
case d2 | SOUTH:
target = d3 | SOUTH
break
case d3 | SOUTH:
target = d4 | SOUTH
break
case d4 | SOUTH:
target = d1 | SOUTH
break
case D1 | SOUTH:
target = D2 | SOUTH
break
case D2 | SOUTH:
target = D3 | SOUTH
break
case D3 | SOUTH:
target = D4 | SOUTH
break
case D4 | SOUTH:
target = D1 | SOUTH
break
case d1 | EAST:
target = d2 | EAST
break
case d2 | EAST:
target = d3 | EAST
break
case d3 | EAST:
target = d4 | EAST
break
case d4 | EAST:
target = d1 | EAST
break
case D1 | EAST:
target = D2 | EAST
break
case D2 | EAST:
target = D3 | EAST
break
case D3 | EAST:
target = D4 | EAST
break
case D4 | EAST:
target = D1 | EAST
break
case d1 | WEST:
target = d2 | WEST
break
case d2 | WEST:
target = d3 | WEST
break
case d3 | WEST:
target = d4 | WEST
break
case d4 | WEST:
target = d1 | WEST
break
case D1 | WEST:
target = D2 | WEST
break
case D2 | WEST:
target = D3 | WEST
break
case D3 | WEST:
target = D4 | WEST
break
case D4 | WEST:
target = D1 | WEST
break
}
world.setBlock(x,y,z,target,false,false,false,false,dimension)
},
getFacing:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
var f
switch(block){
case d1 | NORTH:
case d2 | NORTH:
case d3 | NORTH:
case d4 | NORTH:
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
f = "north"
break
case d1 | SOUTH:
case d2 | SOUTH:
case d3 | SOUTH:
case d4 | SOUTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
f = "south"
break
case d1 | EAST:
case d2 | EAST:
case d3 | EAST:
case d4 | EAST:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
f = "east"
break
case d1 | WEST:
case d2 | WEST:
case d3 | WEST:
case d4 | WEST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
f = "west"
break
}
return f
},
canHavePower:function(/*repeater*/rx,ry,rz,/*other thing*/x,y,z,dimension,world){
var tx = rx, ty = ry, tz = rz
var block = world.getBlock(rx,ry,rz,dimension)
var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
switch(block){
case d1 | NORTH:
case d2 | NORTH:
case d3 | NORTH:
case d4 | NORTH:
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
tz++
break
case d1 | SOUTH:
case d2 | SOUTH:
case d3 | SOUTH:
case d4 | SOUTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
tz--
break
case d1 | EAST:
case d2 | EAST:
case d3 | EAST:
case d4 | EAST:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
tx++
break
case d1 | WEST:
case d2 | WEST:
case d3 | WEST:
case d4 | WEST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
tx--
break
}
var on = false
switch(block){ //todo: make it an if loop
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
on = true
}
if(on && tx === x && ty === y && tz === z){
return 15
}
return 0
},
category:"redstone"
},
{
name:"piston",
Name:"Piston",
textures:["pistonBack","pistonFront","pistonSide"],
piston:true,
headSideTexture:"pistonHeadSide",
frontOpenTexture:"pistonFrontOpen",
headBackTexture:"pistonFront",
onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var extended = false, facing, attachedHead = false
switch(block){
case this.id:
facing = "top"
break
case this.id | FLIP:
facing = "bottom"
break
case this.id | SLAB | NORTH:
facing = "north"
break
case this.id | SLAB | SOUTH:
facing = "south"
break
case this.id | SLAB | EAST:
facing = "east"
break
case this.id | SLAB | WEST:
facing = "west"
break
case this.id | TALLCROSS:
facing = "top"
extended = true
break
case this.id | TALLCROSS | FLIP:
facing = "bottom"
extended = true
break
case this.id | PORTAL | NORTH:
facing = "north"
extended = true
break
case this.id | PORTAL | SOUTH:
facing = "south"
extended = true
break
case this.id | PORTAL | EAST:
facing = "east"
extended = true
break
case this.id | PORTAL | WEST:
facing = "west"
extended = true
break
default:
return //parts like piston heads shouldn't do the calculations when power changes
}
if(extended){
switch(facing){
case "top":
if(world.getBlock(x,y+1,z,dimension) === (this.id | STAIR)) attachedHead = true
break
case "bottom":
if(world.getBlock(x,y-1,z,dimension) === (this.id | STAIR | FLIP)) attachedHead = true
break
case "north":
if(world.getBlock(x,y,z-1,dimension) === (this.id | DOOR | NORTH)) attachedHead = true
break
case "south":
if(world.getBlock(x,y,z+1,dimension) === (this.id | DOOR | SOUTH)) attachedHead = true
break
case "east":
if(world.getBlock(x-1,y,z,dimension) === (this.id | DOOR | EAST)) attachedHead = true
break
case "west":
if(world.getBlock(x+1,y,z,dimension) === (this.id | DOOR | WEST)) attachedHead = true
break
}
}
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
if(power && !extended){
this.extend(x,y,z,facing,dimension,world)
}else if(!power && extended && attachedHead){
this.retract(x,y,z,facing,dimension,world)
}
},
onupdate:function(x,y,z,b,w,sx,sy,sz,dimension){ //onupdate is run when placed
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
},
onbreak:function(x,y,z, prevBlock, prevTags,dimension,world){
//dissapear if it isn't connected (it = piston heads and piston open)
let tx = x, ty = y, tz = z
switch(prevBlock){
case this.id | TALLCROSS:
case this.id | STAIR | FLIP:
ty++
break
case this.id | TALLCROSS | FLIP:
case this.id | STAIR:
ty--
break
case this.id | PORTAL | NORTH:
case this.id | DOOR | SOUTH:
tz--
break
case this.id | PORTAL | SOUTH:
case this.id | DOOR | NORTH:
tz++
break
case this.id | PORTAL | EAST:
case this.id | DOOR | WEST:
tx--
break
case this.id | PORTAL | WEST:
case this.id | DOOR | EAST:
tx++
break
default:
return //unextended pistons
}
world.setBlock(tx,ty,tz,0,false,false,false,false,dimension)
},
extend:function(x,y,z, facing,dimension,world){
var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
var head, headCut, open
switch(facing){
case "top":
open = this.id | TALLCROSS
head = this.id | STAIR
headCut = this.id | CROSS
ty ++
my = 1
break
case "bottom":
open = this.id | TALLCROSS | FLIP
head = this.id | STAIR | FLIP
headCut = this.id | CROSS | FLIP
ty --
my = -1
break
case "north":
open = this.id | PORTAL | NORTH
head = this.id | DOOR | NORTH
headCut = this.id | PANE | NORTH
tz --
mz = -1
break
case "south":
open = this.id | PORTAL | SOUTH
head = this.id | DOOR | SOUTH
headCut = this.id | PANE | SOUTH
tz ++
mz = 1
break
case "east":
open = this.id | PORTAL | EAST
head = this.id | DOOR | EAST
headCut = this.id | PANE | EAST
tx --
mx = -1
break
case "west":
open = this.id | PORTAL | WEST
head = this.id | DOOR | WEST
headCut = this.id | PANE | WEST
tx ++
mx = 1
break
default:
return console.log("oh no! piston isn't facing anywhere")
}
var push = getPistonPushedBlocks(x,y,z,mx,my,mz,dimension,world)
if(push === false) return
world.setBlock(x,y,z,open,false,false,false,false,dimension)
var e = new entities[entityIds.MovingBlock](headCut,x,y,z,tx,ty,tz, tickTime*2, true)
e.endAs = head
world.addEntity(e,false,dimension)
//world.setTimeout(function(){
//	e.changeBlock(head)
//}, tickTime*1.5)
for(var i=0; i<push.length; i+=4){
var bx = push[i], by = push[i+1], bz = push[i+2]
var tags = world.getTags(bx,by,bz,dimension)
world.setBlock(bx,by,bz,0,false,false,false,false,dimension)
world.addEntity(new entities[entityIds.MovingBlock](push[i+3],bx,by,bz,bx+mx,by+my,bz+mz, tickTime*2, true, tags),false,dimension)
}
},
retract:function(x,y,z, facing,dimension,world){
var tx = x, ty = y, tz = z
var head, headCut, body
switch(facing){
case "top":
body = this.id
head = this.id | STAIR
headCut = this.id | CROSS
ty ++
break
case "bottom":
body = this.id | FLIP
head = this.id | STAIR | FLIP
headCut = this.id | CROSS | FLIP
ty --
break
case "north":
body = this.id | SLAB | NORTH
head = this.id | DOOR | NORTH
headCut = this.id | PANE | NORTH
tz --
break
case "south":
body = this.id | SLAB | SOUTH
head = this.id | DOOR | SOUTH
headCut = this.id | PANE | SOUTH
tz ++
break
case "east":
body = this.id | SLAB | EAST
head = this.id | DOOR | EAST
headCut = this.id | PANE | EAST
tx --
break
case "west":
body = this.id | SLAB | WEST
head = this.id | DOOR | WEST
headCut = this.id | PANE | WEST
tx ++
break
default:
return console.log("oh no! piston isn't facing anywhere")
}
world.setBlock(tx,ty,tz,0,false,false,false,false,dimension)
var e = new entities[entityIds.MovingBlock](head,tx,ty,tz,x,y,z, tickTime*2)
world.addEntity(e,false,dimension)
//world.setTimeout(function(){
//	e.changeBlock(headCut)
//}, tickTime*0.5)
world.setTimeout(function(){
world.setBlock(x,y,z,body,false,false,false,false,dimension)
}, tickTime*2)
},
category:"redstone"
},
{
name:"smoothQuartz",
Name:"Smooth Quartz Block",
textures:"quartzBlockBottom",
stoneSound:true,
category:"build"
},
{
name:"pistonSticky",
Name:"Sticky Piston",
textures:["pistonBack","pistonFrontSticky","pistonSide"],
piston:true,
headSideTexture:"pistonHeadSide",
frontOpenTexture:"pistonFrontOpen",
headBackTexture:"pistonFront",
category:"redstone",
onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var extended = false, facing, attachedHead = false
switch(block){
case this.id:
facing = "top"
break
case this.id | FLIP:
facing = "bottom"
break
case this.id | SLAB | NORTH:
facing = "north"
break
case this.id | SLAB | SOUTH:
facing = "south"
break
case this.id | SLAB | EAST:
facing = "east"
break
case this.id | SLAB | WEST:
facing = "west"
break
case this.id | TALLCROSS:
facing = "top"
extended = true
break
case this.id | TALLCROSS | FLIP:
facing = "bottom"
extended = true
break
case this.id | PORTAL | NORTH:
facing = "north"
extended = true
break
case this.id | PORTAL | SOUTH:
facing = "south"
extended = true
break
case this.id | PORTAL | EAST:
facing = "east"
extended = true
break
case this.id | PORTAL | WEST:
facing = "west"
extended = true
break
default:
return //parts like piston heads shouldn't do the calculations when power changes
}
if(extended){
switch(facing){
case "top":
if(world.getBlock(x,y+1,z,dimension) === (this.id | STAIR)) attachedHead = true
break
case "bottom":
if(world.getBlock(x,y-1,z,dimension) === (this.id | STAIR | FLIP)) attachedHead = true
break
case "north":
if(world.getBlock(x,y,z-1,dimension) === (this.id | DOOR | NORTH)) attachedHead = true
break
case "south":
if(world.getBlock(x,y,z+1,dimension) === (this.id | DOOR | SOUTH)) attachedHead = true
break
case "east":
if(world.getBlock(x-1,y,z,dimension) === (this.id | DOOR | EAST)) attachedHead = true
break
case "west":
if(world.getBlock(x+1,y,z,dimension) === (this.id | DOOR | WEST)) attachedHead = true
break
}
}
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
if(power && !extended){
this.extend(x,y,z,facing,dimension,world)
}else if(!power && extended && attachedHead){
this.retract(x,y,z,facing,dimension,world)
}
},
onupdate:function(x,y,z,b,w,sx,sy,sz,dimension){ //onupdate is run when placed
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
},
onbreak:function(x,y,z, prevBlock, prevTags,dimension,world){
//dissapear if it isn't connected (it = piston heads and piston open)
let tx = x, ty = y, tz = z
switch(prevBlock){
case this.id | TALLCROSS:
case this.id | STAIR | FLIP:
ty++
break
case this.id | TALLCROSS | FLIP:
case this.id | STAIR:
ty--
break
case this.id | PORTAL | NORTH:
case this.id | DOOR | SOUTH:
tz--
break
case this.id | PORTAL | SOUTH:
case this.id | DOOR | NORTH:
tz++
break
case this.id | PORTAL | EAST:
case this.id | DOOR | WEST:
tx--
break
case this.id | PORTAL | WEST:
case this.id | DOOR | EAST:
tx++
break
default:
return //unextended pistons
}
world.setBlock(tx,ty,tz,0,false,false,false,false,dimension)
},
extend:function(x,y,z, facing,dimension,world){
var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
var head, headCut, open
switch(facing){
case "top":
open = this.id | TALLCROSS
head = this.id | STAIR
headCut = this.id | CROSS
ty ++
my = 1
break
case "bottom":
open = this.id | TALLCROSS | FLIP
head = this.id | STAIR | FLIP
headCut = this.id | CROSS | FLIP
ty --
my = -1
break
case "north":
open = this.id | PORTAL | NORTH
head = this.id | DOOR | NORTH
headCut = this.id | PANE | NORTH
tz --
mz = -1
break
case "south":
open = this.id | PORTAL | SOUTH
head = this.id | DOOR | SOUTH
headCut = this.id | PANE | SOUTH
tz ++
mz = 1
break
case "east":
open = this.id | PORTAL | EAST
head = this.id | DOOR | EAST
headCut = this.id | PANE | EAST
tx --
mx = -1
break
case "west":
open = this.id | PORTAL | WEST
head = this.id | DOOR | WEST
headCut = this.id | PANE | WEST
tx ++
mx = 1
break
default:
return console.log("oh no! piston isn't facing anywhere")
}
var push = getPistonPushedBlocks(x,y,z,mx,my,mz,dimension,world)
if(push === false) return
world.setBlock(x,y,z,open,false,false,false,false,dimension)
var e = new entities[entityIds.MovingBlock](headCut,x,y,z,tx,ty,tz, tickTime*2, true)
for(var i=0; i<push.length; i+=4){
var bx = push[i], by = push[i+1], bz = push[i+2]
var tags = world.getTags(bx,by,bz,dimension)
world.setBlock(bx,by,bz,0,false,false,false,false,dimension)
world.addEntity(new entities[entityIds.MovingBlock](push[i+3],bx,by,bz,bx+mx,by+my,bz+mz, tickTime*2, true, tags),false,dimension)
}
e.endAs = head
world.addEntity(e,false,dimension)
//world.setTimeout(function(){
//	e.changeBlock(head)
//}, tickTime*1.5)
},
retract:function(x,y,z, facing,dimension,world){
var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
var head, headCut, body
switch(facing){
case "top":
body = this.id
head = this.id | STAIR
headCut = this.id | CROSS
ty ++
my = 1
break
case "bottom":
body = this.id | FLIP
head = this.id | STAIR | FLIP
headCut = this.id | CROSS | FLIP
ty --
my = -1
break
case "north":
body = this.id | SLAB | NORTH
head = this.id | DOOR | NORTH
headCut = this.id | PANE | NORTH
tz --
mz = -1
break
case "south":
body = this.id | SLAB | SOUTH
head = this.id | DOOR | SOUTH
headCut = this.id | PANE | SOUTH
tz ++
mz = 1
break
case "east":
body = this.id | SLAB | EAST
head = this.id | DOOR | EAST
headCut = this.id | PANE | EAST
tx --
mx = -1
break
case "west":
body = this.id | SLAB | WEST
head = this.id | DOOR | WEST
headCut = this.id | PANE | WEST
tx ++
mx = 1
break
default:
return console.log("oh no! piston isn't facing anywhere")
}
world.setBlock(tx,ty,tz,0,false,false,false,false,dimension)
var e = new entities[entityIds.MovingBlock](head,tx,ty,tz,x,y,z, tickTime*2)
world.addEntity(e,false,dimension)
//world.setTimeout(function(){
//	e.changeBlock(headCut)
//}, tickTime*0.5)
world.setTimeout(function(){
world.setBlock(x,y,z,body,false,false,false,false,dimension)
}, tickTime*2)
var pull = getPistonPulledBlocks(x,y,z,mx,my,mz,dimension,world)
if(pull){
for(var i=0; i<pull.length; i+=4){
var bx = pull[i], by = pull[i+1], bz = pull[i+2]
var tags = world.getTags(bx,by,bz,dimension)
world.setBlock(bx,by,bz,0,false,false,false,false,dimension)
world.addEntity(new entities[entityIds.MovingBlock](pull[i+3],bx,by,bz,bx-mx,by-my,bz-mz, tickTime*2, true, tags),false,dimension)
}
}
}
},
{
name:"observer",
Name:"Observer",
textures:["observerTop","observerTop","observerBack","observerFront","observerSide","observerSide"],
blastResistance:3.5,
hardness:3,
getFacing:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var facing
switch(block){
case this.id | NORTH:
case this.id | STAIR | NORTH:
facing = "north"
break
case this.id | SOUTH:
case this.id | STAIR | SOUTH:
facing = "south"
break
case this.id | EAST:
case this.id | STAIR | EAST:
facing = "east"
break
case this.id | WEST:
case this.id | STAIR | WEST:
facing = "west"
break
case this.id | SLAB:
case this.id | CROSS:
facing = "bottom"
break
case this.id | SLAB | FLIP:
case this.id | CROSS | FLIP:
facing = "top"
break
default:
return
}
return facing
},
detected:function(x,y,z,sx,sy,sz,world, detected = false,dimension){ //if detected is true, it will send a signal no matter what
var block = world.getBlock(x,y,z,dimension)
var facing, tx = 0, ty = 0, tz = 0, onBlock
switch(block){
case this.id | NORTH:
facing = "north"
tz = -1
onBlock = this.id | STAIR | NORTH
break
case this.id | SOUTH:
facing = "south"
tz = 1
onBlock = this.id | STAIR | SOUTH
break
case this.id | EAST:
facing = "east"
tx = -1
onBlock = this.id | STAIR | EAST
break
case this.id | WEST:
facing = "west"
tx = 1
onBlock = this.id | STAIR | WEST
break
case this.id | SLAB:
facing = "bottom"
ty = -1
onBlock = this.id | CROSS
break
case this.id | SLAB | FLIP:
facing = "top"
ty = 1
onBlock = this.id | CROSS | FLIP
break
default:
return
}
if(!(x+tx === sx && y+ty === sy && z+tz === sz) && !detected) return
world.setTimeout(function(){
var curBlock = world.getBlock(x,y,z,dimension)
if(!(curBlock && blockData[curBlock].name === "observer")) return
world.setBlock(x,y,z,onBlock, false,true,false,false,dimension)
let blockBehind = world.getBlock(x-tx,y-ty,z-tz,dimension)
if(blockBehind && blockData[blockBehind].carryRedstone){
world.setPower(x-tx,y-ty,z-tz, 15,false,dimension)
world.spreadPower(x-tx,y-ty,z-tz, 15,dimension)
}
world.setTimeout(function(){
let curBlock = world.getBlock(x,y,z,dimension)
if(!(curBlock && blockData[curBlock].name === "observer")) return
blockBehind = world.getBlock(x-tx,y-ty,z-tz,dimension)
world.setBlock(x,y,z,block, false,true,false,false,dimension)
if(blockBehind && blockData[blockBehind].carryRedstone) world.unspreadPower(x-tx,y-ty,z-tz, 15, true,dimension)
}, tickTime*2)
}, tickTime, x,y,z,dimension)
},
onupdate:function(x,y,z,block,world,sx,sy,sz,dimension){
this.detected(x,y,z,sx,sy,sz,world,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.detected(x,y,z,x,y,z,world,true,dimension)
},
canHavePower:function(rx,ry,rz, x,y,z, dimension,world){
var block = world.getBlock(rx,ry,rz,dimension)
var tx = 0, ty = 0, tz = 0
switch(block){
case this.id | STAIR | NORTH:
tz = -1
break
case this.id | STAIR | SOUTH:
tz = 1
break
case this.id | STAIR | EAST:
tx = -1
break
case this.id | STAIR | WEST:
tx = 1
break
case this.id | CROSS:
ty = -1
break
case this.id | CROSS | FLIP:
ty = 1
break
default:
return
}
if(rx-tx === x && ry-ty === y && rz-tz === z) return 15
return 0
},
category:"redstone"
},
{
name:"string",
Name:"String",
item:true,
category:"items"
},
{
name:"redDye",
Name:"Red Dye",
item:true,
dye:"red",
category:"items"
},
{
name:"lightGrayDye",
Name:"Light Gray Dye",
item:true,
dye:"lightGray",
category:"items"
},
{
name:"lightBlueDye",
Name:"Light Blue Dye",
item:true,
dye:"lightBlue",
category:"items"
},
{
name:"magentaDye",
Name:"Magenta Dye",
item:true,
dye:"magenta",
category:"items"
},
{
name:"yellowDye",
Name:"Yellow Dye",
item:true,
dye:"yellow",
category:"items"
},
{
name:"purpleDye",
Name:"Purple Dye",
item:true,
dye:"purple",
category:"items"
},
{
name:"orangeDye",
Name:"Orange Dye",
item:true,
dye:"orange",
category:"items"
},
{
name:"whiteDye",
Name:"White Dye",
item:true,
dye:"white",
category:"items"
},
{
name:"greenDye",
Name:"Green Dye",
item:true,
dye:"green",
category:"items"
},
{
name:"brownDye",
Name:"Brown Dye",
item:true,
dye:"brown",
category:"items"
},
{
name:"blackDye",
Name:"Black Dye",
item:true,
dye:"black",
category:"items"
},
{
name:"pinkDye",
Name:"Pink Dye",
item:true,
dye:"pink",
category:"items"
},
{
name:"limeDye",
Name:"Lime Dye",
item:true,
dye:"lime",
category:"items"
},
{
name:"grayDye",
Name:"Gray Dye",
item:true,
dye:"gray",
category:"items"
},
{
name:"cyanDye",
Name:"Cyan Dye",
item:true,
dye:"cyan",
category:"items"
},
{
name:"blueDye",
Name:"Blue Dye",
item:true,
dye:"blue",
category:"items"
},
{
name:"endPortal",
flatIcon:true,
solid:false,
transparent:true,
blastResistance: 3600000,
lightLevel:15,
pistonPush:false,
pistonPull:false,
hidden:true,
drop:"air",
ontouch: function(x,y,z,dimension,ent){
let nx, ny, nz
if(ent.dimension === ""){
nx = round(rand(-64,64))
nz = round(rand(-64,64))
ny = ent.y
}else{
let spawn = ent.spawnPoint || ent.world.spawnPoint
nx = spawn.x
ny = spawn.y
nz = spawn.z
}
ent.tp(nx,ny,nz,ent.dimension === "end" ? "" : "end")
ent.doingPortal = blockIds.endPortal
ent.world.playSound(x,y,z,"portal.travel")
if(ent.type === "Player"){
ent.addAchievment("Into the End")
if(ent.dimension === "" && !ent.didEndPoem && !ent.cheats){
ent.didEndPoem = true
ent.connection.send({type:"doEndPoem"})
}
}
},
doneLoading:function(p,world){
if(p.dimension === "end"){
let ny
ny = world.getSolidTop(round(p.x),round(p.z),p.dimension)+0.5+p.height*0.5
if(ny < 25) ny = 25
p.tp(p.x,ny,p.z)
if(!world.getBlock(p.x,floor(ny-p.height*0.5),p.z,p.dimension)){
world.setBlock(p.x,floor(ny-p.height*0.5),p.z,blockIds.obsidian,false,false,false,false,p.dimension)
}
}
}
},
{
name:"thatch",
Name:"Thatch",
type:"plant2",
burnChance: 0.2,
burnTime: 20,
compostChance:0.85,
category:"build"
},
{
name:"pearlescentFroglight",
Name:"Pearlescent Froglight",
textures:["pearlescentFroglightTop","pearlescentFroglightSide"],
lightLevel:15,
shadow:false,
category:"nature"
},
{
name:"verdantFroglight",
Name:"Verdant Froglight",
textures:["verdantFroglightTop","verdantFroglightSide"],
lightLevel:15,
shadow:false,
category:"nature"
},
{
name:"ochreFroglight",
Name:"Ochre Froglight",
textures:["ochreFroglightTop","ochreFroglightSide"],
lightLevel:15,
shadow:false,
category:"nature"
},
{
name:"mangroveLeaves",
Name:"Mangrove Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return ""//mangrove propagule here
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
grassSound: true,
category:"nature"
},
{
name:"mangroveLog",
Name:"Mangrove Log",
textures:["mangroveLogTop","mangroveLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name:"strippedMangroveLog",
Name:"Stripped Mangrove Log",
textures:["strippedMangroveLogTop","strippedMangroveLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name:"mangroveLogSW",
textures: ["mangroveLog","mangroveLog","mangroveLogTop","mangroveLog"],
SW: true, woodSound:true, hidden:true
},
{
name:"strippedMangroveLogSW",
textures: ["strippedMangroveLog","strippedMangroveLog","strippedMangroveLogTop","strippedMangroveLog"],
SW: true, woodSound:true, hidden:true
},
{name:"mangrovePlanks", Name:"Mangrove Planks", type:"wood", category:"build",hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
{ 
name: "mangroveDoor",
Name:"Mangrove Door",
transparent: true,
shadow: false,
textures: "mangroveDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{ 
name: "mangroveTrapdoor",
Name:"Mangrove Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{
name:"mangroveButton",
Name: "Mangrove Button",
textures:"mangrovePlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name: "mangrovePressurePlate",
Name: "Mangrove Pressure Plate",
textures: "mangrovePlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name:"mangroveFenceGate",
Name:"Mangrove Fence Gate",
textures:"mangrovePlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"mangroveRoots",
textures:["mangroveRootsTop","mangroveRootsSide"],
transparent:true,
type:"wood",
hardness:0.7,
blastResistance:0.7,
cullFace:"never",
compostChance:0.3,
category:"nature"
},
{
name:"muddyMangroveRoots",
textures:["muddyMangroveRootsTop","muddyMangroveRootsSide"],
type:"wood",
hardness:0.7,
blastResistance:0.7,
category:"nature"
},
{
name: "mangroveWood",
Name:"Mangrove Wood",
textures: "mangroveLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "strippedMangroveWood",
Name:"Stripped Mangrove Wood",
textures: "strippedMangroveLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name:"mud",
Name:"Mud",
hardness:0.5,
blastResistance:0.5,
type:"ground",
digSound: ["mud.break1", "mud.break2", "mud.break3", "mud.break4", "mud.break5", "mud.break6"],
stepSound: ["mud.step1", "mud.step2","mud.step3","mud.step4","mud.step5","mud.step6"],
category:"nature"
},
{
name:"mudBricks",
Name:"Mud Bricks",
category:"build",
hardness:1.5,
},
{
name:"packedMud",
Name:"Packed Mud",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
category:"build",
hardness:1
},
{
name:"reinforcedDeepslate",
textures:["reinforcedDeepslateBottom","reinforcedDeepslateTop","reinforcedDeepslateSide"],
blastResistance:1200,
hardness:55,
pistonPush:false,
pistonPull:false,
category:"build"
},
{
name:"redRedstoneLamp",
Name:"Red Redstone Lamp",
textures:"redstoneLamp",
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
coloredRedstoneLamp:true,
category:"redstone"
},
{
name:"yellowRedstoneLamp",
Name:"Yellow Redstone Lamp",
textures:"redstoneLamp",
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
coloredRedstoneLamp:true,
category:"redstone"
},
{
name:"greenRedstoneLamp",
Name:"Green Redstone Lamp",
textures:"redstoneLamp",
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
coloredRedstoneLamp:true,
category:"redstone"
},
{
name:"blueRedstoneLamp",
Name:"Blue Redstone Lamp",
textures:"redstoneLamp",
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
coloredRedstoneLamp:true,
category:"redstone"
},
{
name:"soulFire",
fire:true,
damage:2,
burnEnt:true,
transparent:true,
shadow:false,
solid:false,
lightLevel:15,
ambientSound:"fire.fire",
temperature:20,
smoothLight:false,
hidden:true,
noHitbox:true,
getAttached:function(x,y,z,block,dimension,getBlockOnly,world){
var ax = x, ay = y, az = z
switch(block){
case this.id:
ay--
break
case this.id | STAIR:
ay++
break
case this.id | SLAB | NORTH:
az++
break
case this.id | SLAB | SOUTH:
az--
break
case this.id | SLAB | EAST:
ax++
break
case this.id | SLAB | WEST:
ax--
break
}
var attached = world.getBlock(ax,ay,az,dimension)
if(getBlockOnly) return attached
else return [attached,ax,ay,az]
},
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var block = this.getAttached(x,y,z,b,dimension,true,world)
if(!block || !blockData[block].canHaveSoulFire) world.setBlock(x,y,z,0,false,false,false,false,dimension)
},
},
{
name:"sweetBerries",
Name:"Sweet Berries (they're spiky)",
item:true,
edible:true,
food:4,
saturation: 1.2,
eatResult: "stick",
useAs: "sweetBerryBush",
compostChance:0.3,
category:"food"
},
{
name:"sweetBerryBush",
textures:"sweetBerryBushStage0",
textures1:new Array(6).fill("sweetBerryBushStage1"),
textures2:new Array(6).fill("sweetBerryBushStage2"),
textures3:new Array(6).fill("sweetBerryBushStage3"),
flatIcon:true,
solid: false,
transparent: true,
shadow: false,
smoothLight:false,
hidden:true,
drop:"sweetBerries",
liquidBreakable:"drop",
category:"nature"
},
{
name:"smallDripleaf",
Name:"Small Dripleaf",
textures:"smallDripleafStemBottom",
shapeName:"smallDripleaf",
solid: false,
transparent: true,
shadow: false,
smoothLight:false,
liquidBreakable:"drop",
category:"nature"
},
{
name:"bigDripleaf",
Name:"Big Dripleaf",
textures:"bigDripleafStem",
shapeName:"bigDripleaf",
crossShape:true,
transparent: true,
shadow: false,
smoothLight:false,
liquidBreakable:"drop",
onupdate:function(x,y,z,block,world,sx,sy,sz,dimension){
var me = blockIds.bigDripleaf
var top = world.getBlock(x,y+1,z,dimension)
var isIt = top === me || top === (me | CROSS)
if(block === me && isIt){
world.setBlock(x,y,z,me | CROSS,false,false,false,false,dimension)
}else if(block === (me | CROSS) && !isIt){
world.setBlock(x,y,z,me,false,false,false,false,dimension)
}
},
category:"nature"
},
{
name:"orGate",
Name:"OR Gate",
textures:["smoothStone","orGate","repeaterSide"],
shapeName:"logicGate",
transparent: true,
shadow: false,
logicGate:true,
shouldBeOn:function(x,y,z,dimension,px,pz,world){
return (world.getRepeaterPower(x,y,z,x-pz,y,z-px,dimension) || world.getBlockPower(x-pz,y,z-px,null,dimension)
|| world.getRepeaterPower(x,y,z,x+pz,y,z+px,dimension) || world.getBlockPower(x+pz,y,z+px,null,dimension)) ? true : false
},
category:"redstone"
},
{
name:"andGate",
Name:"AND Gate",
textures:["smoothStone","andGate","repeaterSide"],
shapeName:"logicGate",
transparent: true,
shadow: false,
logicGate:true,
shouldBeOn:function(x,y,z,dimension,px,pz,world){
return ((world.getRepeaterPower(x,y,z,x-pz,y,z-px,dimension) || world.getBlockPower(x-pz,y,z-px,null,dimension))
&& (world.getRepeaterPower(x,y,z,x+pz,y,z+px,dimension) || world.getBlockPower(x+pz,y,z+px,null,dimension))) ? true : false
},
category:"redstone"
},
{
name:"notGate",
Name:"NOT Gate",
textures:["smoothStone","notGate","repeaterSide"],
shapeName:"logicGate",
transparent: true,
shadow: false,
logicGate:true,
shouldBeOn:function(x,y,z,dimension,px,pz,world){
return !(world.getRepeaterPower(x,y,z,x-px,y,z-pz,dimension) || world.getBlockPower(x-px,y,z-pz,null,dimension)) ? true : false
},
category:"redstone"
},
{
name:"xorGate",
Name:"XOR Gate",
textures:["smoothStone","xorGate","repeaterSide"],
shapeName:"logicGate",
transparent: true,
shadow: false,
logicGate:true,
shouldBeOn:function(x,y,z,dimension,px,pz,world){
var a = world.getRepeaterPower(x,y,z,x-pz,y,z-px,dimension) || world.getBlockPower(x-pz,y,z-px,null,dimension)
var b = world.getRepeaterPower(x,y,z,x+pz,y,z+px,dimension) || world.getBlockPower(x+pz,y,z+px,null,dimension)
return ((a||b)&&!(a&&b)) ? true : false
},
category:"redstone"
},
{
name:"dripstoneBlock",
Name:"Dripstone Block",
type:"rock1",
hardness:1.5,
blastResistance:1,
randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
category:"nature"
},
{
name:"pointedDripstone",
Name:"Sharp Dripstone",
flatIcon:true,
iconTexture:"pointedDripstone",
transparent: true,
shadow: false,
hardness:1.5,
blastResistance:3,
type:"rock1",
drop:"pointedDripstone",
pointing:function(x,y,z,d,world){
var b = world.getBlock(x,y,z,d)
if(blockData[b].name === this.name) return (b & FLIP) === FLIP ? -1 : 1
},
onupdate:function(x,y,z,block,world,sx,sy,sz,dimension){
var down = (block & FLIP) === FLIP
var pointing = down ? -1 : 1
if(down){
var attached = world.getBlock(x,y+1,z,dimension)
if(world.settings.blocksFall && (!attached || !blockData[attached].solid)){
world.setBlock(x,y,z, 0, false,false,false,false,dimension)
world.addEntity(new entities[entityIds.BlockEntity](block, x,y,z),false,dimension)
return
}
}else{
if(needsSupportingBlocks(x,y,z, this.id,world,dimension)) return
}
var target = down ? this.id | FLIP : this.id
if(this.pointing(x,y+pointing,z,dimension,world) === pointing && this.pointing(x,y+pointing*2,z,dimension,world) !== pointing) target |= CROSS //frustum
else if(this.pointing(x,y+pointing,z,dimension,world) === pointing && !this.pointing(x,y-pointing,z,dimension,world)) target |= SLAB //base
else if(this.pointing(x,y+pointing,z,dimension,world) === pointing) target |= STAIR //middle
else if(this.pointing(x,y+pointing,z,dimension,world) === -pointing) target |= TALLCROSS //tip merge
if(block !== target) world.setBlock(x,y,z,target,false,false,false,false,dimension)
},
spawnUpdate:function(x,y,z,block,world,dimension){
let down = (block & FLIP) === FLIP
let pointing = down ? -1 : 1
let target = down ? this.id | FLIP : this.id
if(this.pointing(x,y+pointing,z,dimension,world) === pointing && this.pointing(x,y+pointing*2,z,dimension,world) !== pointing) target |= CROSS //frustum
else if(this.pointing(x,y+pointing,z,dimension,world) === pointing && !this.pointing(x,y-pointing,z,dimension,world)) target |= SLAB //base
else if(this.pointing(x,y+pointing,z,dimension,world) === pointing) target |= STAIR //middle
else if(this.pointing(x,y+pointing,z,dimension,world) === -pointing) target |= TALLCROSS //tip merge
if(block !== target) world.spawnBlock(x,y,z,target,dimension, true)
},
category:"nature"
},
{
name:"oakSign",
Name:"Oak sign",
textures:"oakPlanks",
poleTop:"logTop",
poleSide:"logSide",
iconTexture:"oakSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"birchSign",
Name:"Birch Sign",
textures:"birchPlanks",
poleTop:"birchLogTop",
poleSide:"birchLogSide",
iconTexture:"birchSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"acaciaSign",
Name:"Acacia Sign",
textures:"acaciaPlanks",
poleTop:"acaciaLogTop",
poleSide:"acaciaLogSide",
iconTexture:"acaciaSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"jungleSign",
Name:"Jungle Sign",
textures:"junglePlanks",
poleTop:"jungleLogTop",
poleSide:"jungleLogSide",
iconTexture:"jungleSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"spruceSign",
Name:"Spruce Sign",
textures:"sprucePlanks",
poleTop:"spruceLogTop",
poleSide:"spruceLogSide",
iconTexture:"spruceSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"darkOakSign",
Name:"Dark Oak Sign",
textures:"darkOakPlanks",
poleTop:"darkOakLogTop",
poleSide:"darkOakLogSide",
iconTexture:"darkOakSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
color:[0.85,0.7,0.2],
category:"decoration"
},
{
name:"mangroveSign",
Name:"Mangrove Sign",
textures:"mangrovePlanks",
poleTop:"mangroveLogTop",
poleSide:"mangroveLog",
iconTexture:"mangroveSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"composter",
Name:"Make bonemeal",
textures:"composter",
transparent:true,
blastResistance:0.6,
hardness:0.6,
woodSound:true,
type:"wood",
getLevel:function(block){
var id = this.id
switch(block){
case id:
return 0
case id | SLAB:
return 1
case id | STAIR:
return 2
case id | CROSS:
return 3
case id | TALLCROSS:
return 4
case id | DOOR:
return 5
case id | TORCH:
return 6
case id | LANTERN:
return 7
}
},
onclick:function(x,y,z,dimension,world,p,holdObj){
if(!holdObj || !blockData[holdObj.id].compostChance) return true
let id = blockIds.composter
let target = id
let block = world.getBlock(x,y,z,dimension)
let add = rand() <= blockData[holdObj.id].compostChance
switch(block){
case id:
target |= SLAB
break
case id | SLAB:
target |= STAIR
break
case id | STAIR:
target |= CROSS
break
case id | CROSS:
target |= TALLCROSS
break
case id | TALLCROSS:
target |= DOOR
break
case id | DOOR:
target |= TORCH
break
case id | TORCH:
target |= LANTERN
break
case id | LANTERN:
if(add) world.addItems(x,y,z+0.5,dimension,0,0,0,blockIds.boneMeal,true, 1)
}
holdObj.amount--
if(add) world.setBlock(x,y,z,target,false,false,false,false,dimension)
world.glint(x,y,z,dimension)
},
category:"items"
},
{
name:"cocoaBeans",
Name:"Cocoa Beans",
item:true,
useAs:"cocoa",
category:"items"
},
{
name:"cocoa",
textures:"cocoaStage0",
hardness:0.2,
blastResistance:3,
transparent:true,
shadow:false,
drop:"cocoaBeans",
woodSound:true,
hidden:true,
liquidBreakable:"drop"
},
{
name:"cookie",
Name:"Cookie",
item:true,
edible: true,
food: 2,
saturation: 0.4,
compostChance:0.85,
category:"food"
},
{
name:"pumpkinPie",
Name:"Pumpkin Pie",
item:true,
edible: true,
food: 8,
saturation: 4.8,
compostChance:1,
category:"food"
},
{
name:"rawChicken",
Name:"Raw Chicken",
item:true,
edible: true,
food: 2,
saturation: 1.2,
category:"food"
},
{
name:"cookedChicken",
Name:"Cooked Chicken",
item:true,
edible: true,
food: 6,
saturation: 7.2,
category:"food"
},
{
name:"rawCod",
Name:"Raw Cod",
item:true,
edible: true,
food: 2,
saturation: 0.4,
category:"food"
},
{
name:"cookedCod",
Name:"Cooked Cod",
item:true,
edible: true,
food: 5,
saturation: 6,
category:"food"
},
{
name:"rawMutton",
Name:"Raw Mutton",
item:true,
edible: true,
food: 2,
saturation: 1.2,
category:"food"
},
{
name:"cookedMutton",
Name:"Cooked Mutton",
item:true,
edible: true,
food: 6,
saturation: 9.6,
category:"food"
},
{
name:"rawPorkchop",
Name:"Raw Porkchop",
item:true,
edible: true,
food: 3,
saturation: 1.8,
category:"food"
},
{
name:"cookedPorkchop",
Name:"Cooked Porkchop",
item:true,
edible: true,
food: 8,
saturation: 12.8,
category:"food"
},
{
name:"rawRabbit",
Name:"Raw Rabbit",
item:true,
edible: true,
food: 3,
saturation: 1.8,
category:"food"
},
{
name:"cookedRabbit",
Name:"Cooked Rabbit",
item:true,
edible: true,
food: 5,
saturation: 6,
category:"food"
},
{
name:"rawSalmon",
Name:"Raw Salmon",
item:true,
edible: true,
food: 2,
saturation: 0.4,
category:"food"
},
{
name:"cookedSalmon",
Name:"Cooked Salmon",
item:true,
edible: true,
food: 6,
saturation: 9.6,
category:"food"
},
{
name:"tropicalFish",
Name:"Tropical Fish",
item:true,
edible: true,
food: 1,
saturation: 0.2,
category:"food"
},
{
name:"beetroot",
Name:"Beetroot",
item:true,
edible: true,
food: 1,
saturation: 1.2,
compostChance:0.65,
category:"food"
},
{
name:"beetrootSoup",
Name:"Beetroot Soup",
item:true,
edible: true,
food: 7.2,
saturation: 13.2,
eatResult:"bowl",
category:"food",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|CROSS,false,false,false,false,dimension)
}
},
{
name:"carrot",
Name:"Carrot",
item:true,
edible: true,
food: 3,
saturation: 3.6,
compostChance:0.65,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "carrots"
},
category:"food"
},
{
name:"goldenCarrot",
Name:"Golden Carrot",
item:true,
edible: true,
food: 6,
saturation: 14.4,
category:"food"
},
{
name:"rabbitStew",
Name:"Rabbit Stew",
item:true,
edible: true,
food: 10,
saturation: 12,
category:"food"
},
{
name:"goldenApple",
Name:"Golden Apple",
item:true,
edible: true,
food: 4,
saturation: 9.6,
category:"food",
rarity:"rare"
},
{
name:"rawBeef",
Name:"Raw Beef",
item:true,
edible: true,
food: 3,
saturation: 1.8,
category:"food"
},
{
name:"cookedBeef",
Name:"stake cooked befe",
item:true,
edible: true,
food: 8,
saturation: 12.8,
category:"food"
},
{
name:"potato",
Name:"Potato",
item:true,
edible: true,
food: 1,
saturation: 0.6,
compostChance:0.85,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "potatoes"
},
category:"food",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|CROSS,false,false,false,false,dimension)
}
},
{
name:"bakedPotato",
Name:"Baked Potato",
item:true,
edible: true,
food: 5,
saturation: 6,
compostChance:0.85,
category:"food"
},
{
name:"sugar",
Name:"Sugar",
item:true,
category:"items"
},
{
name:"milkBucket",
Name:"Milk Bucket",
item:true,
category:"items"
},
{
name:"beetrootSeeds",
Name:"Beetroot Seeds",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "beetroots"
},
category:"items"
},
{
name:"beetroots",
textures:"beetrootsStage0",
textures1:new Array(6).fill("beetrootsStage1"),
textures2:new Array(6).fill("beetrootsStage2"),
textures3:new Array(6).fill("beetrootsStage3"),
transparent: true,
shadow: false,
solid: false,
crop: true,
drop:"beetrootSeeds",
hidden:true,
liquidBreakable:"drop"
},
{
name:"potatoes",
textures:"potatoesStage0",
textures1:new Array(6).fill("potatoesStage1"),
textures2:new Array(6).fill("potatoesStage2"),
textures3:new Array(6).fill("potatoesStage3"),
transparent: true,
shadow: false,
solid: false,
crop: true,
drop:"potato",
hidden:true,
liquidBreakable:"drop"
},
{
name:"carrots",
textures:"carrotsStage0",
textures1:new Array(6).fill("carrotsStage1"),
textures2:new Array(6).fill("carrotsStage2"),
textures3:new Array(6).fill("carrotsStage3"),
transparent: true,
shadow: false,
solid: false,
crop: true,
drop:"carrot",
hidden:true,
liquidBreakable:"drop",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|CROSS,false,false,false,false,dimension)
}
},
{
name:"mudPie",
Name:"Mud Pie",
item:true,
edible: true,
food: 1,
saturation: 1,
category:"food"
},
{
name:"purpleGrapes",
Name:"Purple Grapes",
item:true,
edible: true,
food: 3,
saturation: 3,
category:"food"
},
{
name:"greenGrapes",
Name:"Green Grapes",
item:true,
edible: true,
food: 3,
saturation: 3,
category:"food"
},
{
name:"oakChair",
Name:"Oak Chair",
textures:"oakPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"lightGrayBed",
Name:"Light Gray Bed",
textures: "lightGrayBedbottom",
iconTexture: "lightGrayBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"lightBlueBed",
Name:"Light Blue Bed",
textures: "lightBlueBedbottom",
iconTexture: "lightBlueBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"magentaBed",
Name:"Magenta Bed",
textures: "magentaBedbottom",
iconTexture: "magentaBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"yellowBed",
Name:"Yellow Bed",
textures: "yellowBedbottom",
iconTexture: "yellowBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"purpleBed",
Name:"Purple Bed",
textures: "purpleBedbottom",
iconTexture: "purpleBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"orangeBed",
Name:"Orange Bed",
textures: "orangeBedbottom",
iconTexture: "orangeBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"whiteBed",
Name:"White Bed",
textures: "whiteBedbottom",
iconTexture: "whiteBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"greenBed",
Name:"Green Bed",
textures: "greenBedbottom",
iconTexture: "greenBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"brownBed",
Name:"Brown Bed",
textures: "brownBedbottom",
iconTexture: "brownBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"blackBed",
Name:"Black Bed",
textures: "blackBedbottom",
iconTexture: "blackBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"pinkBed",
Name:"Pink Bed",
textures: "pinkBedbottom",
iconTexture: "pinkBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"limeBed",
Name:"Lime Bed",
textures: "limeBedbottom",
iconTexture: "limeBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"grayBed",
Name:"Gray Bed",
textures: "grayBedbottom",
iconTexture: "grayBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"cyanBed",
Name:"Cyan Bed",
textures: "cyanBedbottom",
iconTexture: "cyanBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"blueBed",
Name:"Blue Bed",
textures: "blueBedbottom",
iconTexture: "blueBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"quicksand",
Name:"Quicksand",
quicksand:true,
solid:false,
category:"nature"
},
{
name:"bow",
Name:"Bow",
pullTextures:["bow","bowPulling0","bowPulling1","bowPulling2"],
useAnywhere:true,
item:true,
stackSize:1,
category:"tools"
},
{
name:"arrow",
Name:"Arrow",
textures:"arrowIcon",
item:true,
category:"items"
},
{
name:"glisteringMelonSlice",
Name:"Slice of Watermelon With Unedible Gold",
item:true,
category:"items"
},
{
name:"untnt",
Name:"UnTNT",
textures:["untntBottom","untntTop","untnt"],
explode:function(x,y,z,how,dimension,world){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
var e = new entities[entityIds.PrimedUnTNT](x,y,z)
world.addEntity(e,false,dimension)
world.playSound(x,y,z, "random.fuse")
switch(how){
case "explosion":
e.timeLimit = rand(10,30)
}
},
burnChance:0.6,
onburn:function(x,y,z,dimension,world){
this.explode(x,y,z,null,dimension,world)
},
category:"redstone"
},
{
name:"crimsonSign",
Name:"Crimson Sign",
textures:"crimsonPlanks",
poleTop:"crimsonStemTop",
poleSide:"crimsonStemSide",
iconTexture:"crimsonSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"warpedSign",
Name:"Warped Sign",
textures:"warpedPlanks",
poleTop:"warpedStemTop",
poleSide:"warpedStemSide",
iconTexture:"warpedSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"dropper",
Name:"Dropper",
textures:["furnaceTop","furnaceTop","furnaceSide","dropperFront","furnaceSide","furnaceSide"],
upTextures:fillTextureArray(["furnaceTop","dropperFrontVertical","furnaceTop"]),
downTextures:fillTextureArray(["dropperFrontVertical","furnaceTop","furnaceTop"]),
stoneSound:true,
category:"redstone",
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {dispenser:true, contents:new Array(9).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.dispenser && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var tags = world.getTags(x,y,z,dimension)
var on = tags && tags.on || false
if(power !== on) {
world.setTagByName(x,y,z,"on",power,false,dimension)
if(power){
var me = this
world.setTimeout(function(){
world.playSound(x,y,z, "click")
if(!tags || !tags.contents) return
var items = tags.contents.filter(r => r)
var idx = floor(rand(items.length))
if(!items[idx]) return
idx = tags.contents.indexOf(items[idx]), items = tags.contents
var vx = 0, vy = 0, vz = 0, ix = x, iy = y, iz = z, tx = x, ty = y, tz = z
switch(block){
case me.id | NORTH:
vz = -0.25
iz -= 0.75
tz--
break
case me.id | SOUTH:
vz = 0.25
iz += 0.75
tz++
break
case me.id | EAST:
vx = -0.25
ix -= 0.75
tx--
break
case me.id | WEST:
vx = 0.25
ix += 0.75
tx++
break
case me.id | SLAB:
vy = 0.25
iy += 0.75
ty++
break
case me.id | STAIR:
vy = -0.25
iy -= 0.75
ty--
break
}
if(!putItemInContainer(tx,ty,tz,dimension,items[idx].id,items[idx].durability,items[idx].customName,false,world)){
world.addItems(ix,iy,iz,dimension,vx,vy,vz,items[idx].id, false, 1, items[idx].durability, items[idx].customName)
}
items[idx].amount--
if(items[idx].amount <= 0) items[idx] = 0
world.setTags(x,y,z,tags,false,dimension)
},tickTime*4, x,y,z,dimension)
}
}
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
},
{
name:"dispenser",
Name:"Dispenser",
textures:["furnaceTop","furnaceTop","furnaceSide","dispenserFront","furnaceSide","furnaceSide"],
upTextures:fillTextureArray(["furnaceTop","dispenserFrontVertical","furnaceTop"]),
downTextures:fillTextureArray(["dispenserFrontVertical","furnaceTop","furnaceTop"]),
stoneSound:true,
category:"redstone",
hardness:3.5,
type:"rock2",
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {dispenser:true, contents:new Array(9).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.dispenser && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var tags = world.getTags(x,y,z,dimension)
var on = tags && tags.on || false
if(power !== on) {
world.setTagByName(x,y,z,"on",power,false,dimension)
if(power){
var me = this
world.setTimeout(function(){
world.playSound(x,y,z, "click")
if(!tags || !tags.contents) return
var items = tags.contents.filter(r => r)
var idx = floor(rand(items.length))
if(!items[idx]) return
idx = tags.contents.indexOf(items[idx]), items = tags.contents
var vx = 0, vy = 0, vz = 0, ix = x, iy = y, iz = z
switch(block){
case me.id | NORTH:
vz = -0.25
iz--
break
case me.id | SOUTH:
vz = 0.25
iz++
break
case me.id | EAST:
vx = -0.25
ix--
break
case me.id | WEST:
vx = 0.25
ix++
break
case me.id | SLAB:
vy = 0.25
iy++
break
case me.id | STAIR:
vy = -0.25
iy--
break
}
var front = world.getBlock(ix,iy,iz,dimension)
if(front && blockData[front].solid) return
var data = blockData[items[idx].id]
var minus = true
if(data.name === "arrow") world.addEntity(new entities[entityIds.Arrow](ix,iy,iz,vx*4,vy*4,vz*4),false,dimension)
else if(data.name === "boneMeal") data.serveronuse(ix,iy,iz, front,dimension, world,"",items[idx],{}), minus = false
else if(data.name === "snowball") world.addEntity(new entities[entityIds.Snowball](ix,iy,iz,vx*4,vy*4,vz*4),false,dimension)
else if(data.name === "egg") world.addEntity(new entities[entityIds.Egg](ix,iy,iz,vx*4,vy*4,vz*4),false,dimension)
else if(data.name === "bucket"){
var set = false
if(front === blockIds.Water) set = true, items[idx].id = blockIds.waterBucket
if(front === blockIds.Lava) set = true, items[idx].id = blockIds.lavaBucket
if(front === blockIds.powderSnow) set = true, items[idx].id = blockIds.powderSnowBucket
if(front === blockIds.oil) set = true, items[idx].id = blockIds.oilBucket
world.setBlock(ix,iy,iz,0,false,false,false,false,dimension)
minus = false
}else if(data.name === "waterBucket") world.setBlock(ix,iy,iz,blockIds.Water,false,false,false,false,dimension), items[idx].id = blockIds.bucket, minus = false
else if(data.name === "lavaBucket") world.setBlock(ix,iy,iz,blockIds.Lava,false,false,false,false,dimension), items[idx].id = blockIds.bucket, minus = false
else if(data.name === "powderSnowBucket") world.setBlock(ix,iy,iz,blockIds.powderSnow,false,false,false,false,dimension), items[idx].id = blockIds.bucket, minus = false
else if(data.name === "oilBucket") world.setBlock(ix,iy,iz,blockIds.oil,false,false,false,false,dimension), items[idx].id = blockIds.bucket, minus = false
else if(data.name === "tnt") data.explode(ix,iy,iz,null,dimension,world)
else if(data.item) world.addItems(ix,iy,iz,dimension,vx,vy,vz,items[idx].id, false, 1, items[idx].durability, items[idx].customName)
else world.setBlock(ix,iy,iz,items[idx].id,false,false,false,false,dimension)
if(minus) items[idx].amount--
if(items[idx].amount <= 0) items[idx] = 0
world.setTags(x,y,z,tags,false,dimension)
},tickTime*4, x,y,z,dimension)
}
}
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
},
{
name:"hopper",
Name:"Hopper",
textures:"hopper",
flatIcon:true,
iconTexture:"hopperIcon",
blastResistance:4.8,
transparent:true,
hardness:3,
type:"metal2",
stoneSound:true,
category:"redstone",
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {hopper:true, contents:new Array(5).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.hopper && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
pushItem:function(x,y,z,dimension,tags,world){
var tx = x, ty = y, tz = z, top, dx = 0, dy = 0, dz = 0
switch(world.getBlock(x,y,z,dimension)){
case this.id:
ty--
dy = -1
top = true
break
case this.id | SLAB | NORTH:
tz++
dz = 1
break
case this.id | SLAB | SOUTH:
tz--
dz = -1
break
case this.id | SLAB | EAST:
tx++
dx = 1
break
case this.id | SLAB | WEST:
tx--
dx = -1
break
}
var to = world.getBlock(tx,ty,tz,dimension)
for(var i=0; i<tags.contents.length; i++){
var item = tags.contents[i]
if(!item || !item.id) continue
var put
if(!to || !blockData[to].solid){
world.addItems(x+dx*0.625,y+dy*0.625,z+dz*0.625,dimension,dx/8,dy/8,dz/8,item.id, false, 1, item.durability, item.customName)
put = true
}else if(blockData[to].name === "furnace"){
var toTags = world.getTags(tx,ty,tz,dimension), toTagName
if(!toTags) toTags = blockData[to].setContents(tx,ty,tz,dimension,this.world)
if(top) toTagName = "input"
else toTagName = "fuel"
var toTag = toTags[toTagName]
if(!toTag){
toTag = {id:item.id,amount:1,durability:item.durability,customName:item.customName}
put = true
}else if(toTag.id === item.id && (!toTag.customName && !item.customName || toTag.customName === item.customName) && toTag.amount < blockData[toTag.id].stackSize){
toTag.amount++
put = true
}
if(put){
toTags[toTagName] = toTag
world.setTags(tx,ty,tz,toTags,false,dimension)
}
}else if(putItemInContainer(tx,ty,tz,dimension,item.id,item.durability,item.customName,false,world)){
put = true
}
if(put){
item.amount--
if(!item.amount) tags.contents[i] = 0
return true
}
}
},
pullItem:function(x,y,z,dimension,myTags,world){
var block = world.getBlock(x,y+1,z,dimension)
var tags = world.getTags(x,y+1,z,dimension)
if(!tags) return
if(blockData[block].name === "furnace"){
var item = tags.output
if(item && item.id){
if(!putItemInContainer(x,y,z,dimension,item.id,item.durability,item.customName,true,world)) return
item.amount--
if(!item.amount) tags.output = 0
world.tagsChanged(x,y,z,tags,false,dimension)
return true
}
}else if(tags.contents) for(var i=0; i<tags.contents.length; i++){
var item = tags.contents[i]
if(item && item.id){
if(!putItemInContainer(x,y,z,dimension,item.id,item.durability,item.customName,true,world)) return
item.amount--
if(!item.amount) tags.contents[i] = 0
world.tagsChanged(x,y,z,tags,false,dimension)
return true
}
}
},
update:function(x,y,z,dimension,world){
if(this.isLocked(x,y,z,dimension,world)) return
var tags = world.getTags(x,y,z,dimension)
if(!tags) tags = this.setContents(x,y,z,dimension,world)
var u = false
if(this.pushItem(x,y,z,dimension,tags,world)) u = true
if(this.pullItem(x,y,z,dimension,tags,world)) u = true
if(u) world.setTags(x,y,z,tags,false,dimension)
},
onupdate:function(x,y,z,block,world,sx,sy,sz,dimension){
var me = this
var t = () => me.update(x,y,z,dimension,world)
world.setTimeout(t, tickTime*8, x,y,z,dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
this.onupdate(x,y,z,null,world,sx,sy,sz,dimension,world)
},
ontagsupdate:function(x,y,z,dimension,tags,world){
this.onupdate(x,y,z,null,world,null,null,null,dimension,world)
},
isLocked:function(x,y,z,dimension,world){
return world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
},
itemOnTop(x,y,z,dimension,ent){
let world = ent.world
if(this.isLocked(x,y,z,dimension,world)) return
var amount = ent.amount
while(amount){
if(!putItemInContainer(x,y,z,dimension,ent.block,ent.durability,ent.name,false,world)) break
amount--
}
return amount
}
},
{
name:"target",
Name:"Target",
textures:["targetTop","targetSide"],
hardness:0.5,
blastResistance:0.5,
burnChance: 0.2,
burnTime: 20,
category:"redstone",
grassSound: true,
type:"plant2",
cornerDist:sqrt(0.75),
sideDist:0.5,
projectileHit:function(x,y,z,dimension,ent){
let world = ent.world
var dist = dist3(ent.x+ent.direction.x/2,ent.y+ent.direction.y/2,ent.z+ent.direction.z/2,x,y,z)
var power = round(map(dist,this.sideDist,this.cornerDist,15,0))
world.setPower(x,y,z,power,false,dimension)
world.spreadPower(x,y,z,power,dimension)
world.setTimeout(function(){
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,power,false,dimension)
},tickTime*8, x,y,z,dimension)
}
},
{
name:"comparator",
Name:"Redstone Comparator",
transparent:true,
flatIcon:true,
iconTexture:"comparatorIcon",
category:"redstone",
tagBits:{
output:[0,4]
},
on:function(x,y,z,dimension,dx,dy,dz,subtract,world){
var fx = x-dx, fy = y-dy, fz = z-dz
var backPower = min(max(world.getRepeaterPower(x,y,z,fx,fy,fz,dimension),ceil((getContainerFullness(fx,fy,fz,dimension,world) || 0)*15)),15)
if(world.getBlockPower(fx,fy,fz,null,dimension)) backPower = 15
var sidePower = min(max(world.getRepeaterPower(x,y,z,x-dz,y-dy,z-dx,dimension),world.getRepeaterPower(x,y,z,x+dz,y-dy,z+dx,dimension)),15)
if(subtract) return max(backPower - sidePower, 0)
else return backPower * (sidePower <= backPower)
},
onupdate:function(x,y,z,b,w,sx,sy,sz,dimension){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
},
ontagsupdate:function(x,y,z,dimension,tags,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
ondelete:function(x,y,z,prevTags,prevBlock,dimension,world){
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(x,y,z+1,null,"south",dimension)
world.setBlockPower(x,y,z-1,null,"north",dimension)
world.setBlockPower(x+1,y,z,null,"east",dimension)
world.setBlockPower(x-1,y,z,null,"west",dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var dx = 0, dy = 0, dz = 0 //direction
var side //side of block it's pointing to
var block = world.getBlock(x,y,z,dimension)
var offCompare = this.id, onCompare = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
var subtractMode
switch(block){
case offSubtract | NORTH:
case onSubtract | NORTH:
subtractMode = true
case offCompare | NORTH:
case onCompare | NORTH:
dz = 1
side = "south"
break
case offSubtract | SOUTH:
case onSubtract | SOUTH:
subtractMode = true
case offCompare | SOUTH:
case onCompare | SOUTH:
dz = -1
side = "north"
break
case offSubtract | EAST:
case onSubtract | EAST:
subtractMode = true
case offCompare | EAST:
case onCompare | EAST:
dx = 1
side = "east"
break
case offSubtract | WEST:
case onSubtract | WEST:
subtractMode = true
case offCompare | WEST:
case onCompare | WEST:
dx = -1
side = "west"
break
}
if(!dx && !dy && !dz) return console.log("doesn't match up") //doesn't match up
var tx = x+dx, ty = y+dy, tz = z+dz
var output = world.getTagByName(x,y,z,"output",dimension) || 0
var power = this.on(x,y,z,dimension,dx,dy,dz,subtractMode,world)
var tblock = world.getBlock(tx,ty,tz,dimension)
if(tblock && blockData[tblock].carryRedstone){
if(output){
var frontPower = world.getPower(tx,ty,tz,dimension)
if(output < frontPower){
world.unspreadPower(tx,ty,tz,frontPower,true,dimension)
}else if(output > frontPower){
world.setPower(tx,ty,tz,output,false,dimension)
world.spreadPower(tx,ty,tz,output,dimension)
}
}
}
if(power === output) return
var me = this
var t = function(){
block = world.getBlock(x,y,z,dimension)
power = me.on(x,y,z,dimension,dx,dy,dz,subtractMode,world)
output = world.getTagByName(x,y,z,"output",dimension) || 0
if(power !== output) {
world.setTagByName(x,y,z,"output",power,false,dimension)
var on = false
switch(block){
case onSubtract | NORTH:
case onCompare | NORTH:
case onSubtract | SOUTH:
case onCompare | SOUTH:
case onSubtract | EAST:
case onCompare | EAST:
case onSubtract | WEST:
case onCompare | WEST:
on = true
}
if((power ? true : false) !== on){
var target
switch(block){
case offCompare | NORTH:
target = onCompare | NORTH
break
case onCompare | NORTH:
target = offCompare | NORTH
break
case offSubtract | NORTH:
target = onSubtract | NORTH
break
case onSubtract | NORTH:
target = offSubtract | NORTH
break
case offCompare | SOUTH:
target = onCompare | SOUTH
break
case onCompare | SOUTH:
target = offCompare | SOUTH
break
case offSubtract | SOUTH:
target = onSubtract | SOUTH
break
case onSubtract | SOUTH:
target = offSubtract | SOUTH
break
case offCompare | EAST:
target = onCompare | EAST
break
case onCompare | EAST:
target = offCompare | EAST
break
case offSubtract | EAST:
target = onSubtract | EAST
break
case onSubtract | EAST:
target = offSubtract | EAST
break
case offCompare | WEST:
target = onCompare | WEST
break
case onCompare | WEST:
target = offCompare | WEST
break
case offSubtract | WEST:
target = onSubtract | WEST
break
case onSubtract | WEST:
target = offSubtract | WEST
break
}
if(block !== target) world.setBlock(x,y,z,target,false,false,false,true,dimension)
}
var tblock = world.getBlock(tx,ty,tz,dimension)
if(power){
if(tblock && blockData[tblock].carryRedstone){
var frontPower = world.getPower(tx,ty,tz,dimension)
if(power < frontPower){
world.unspreadPower(tx,ty,tz,frontPower,true,dimension)
}else if(power > frontPower){
world.setPower(tx,ty,tz,power,false,dimension)
world.spreadPower(tx,ty,tz,power,dimension)
}
}
}else{
if(tblock && blockData[tblock].carryRedstone){
world.unspreadPower(tx,ty,tz,output,true,dimension)
}
}
}//end if power changed
}
world.setTimeout(t,tickTime*2, x,y,z,dimension)
},
onclick:function(x,y,z,dimension,world){
var me = blockData[blockIds.comparator]
var block = world.getBlock(x,y,z,dimension)
var off = me.id, on = me.id | SLAB, offSubtract = me.id | STAIR, onSubtract = me.id | DOOR
var target
switch(block){
case off | NORTH:
target = offSubtract | NORTH
break
case on | NORTH:
target = onSubtract | NORTH
break
case offSubtract | NORTH:
target = off | NORTH
break
case onSubtract | NORTH:
target = on | NORTH
break
case off | SOUTH:
target = offSubtract | SOUTH
break
case on | SOUTH:
target = onSubtract | SOUTH
break
case offSubtract | SOUTH:
target = off | SOUTH
break
case onSubtract | SOUTH:
target = on | SOUTH
break
case off | EAST:
target = offSubtract | EAST
break
case on | EAST:
target = onSubtract | EAST
break
case offSubtract | EAST:
target = off | EAST
break
case onSubtract | EAST:
target = on | EAST
break
case off | WEST:
target = offSubtract | WEST
break
case on | WEST:
target = onSubtract | WEST
break
case offSubtract | WEST:
target = off | WEST
break
case onSubtract | WEST:
target = on | WEST
break
}
world.setBlock(x,y,z,target,false,false,false,true,dimension)
},
getFacing:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var off = this.id, on = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
var f
switch(block){
case off | NORTH:
case on | NORTH:
case offSubtract | NORTH:
case onSubtract | NORTH:
f = "north"
break
case off | SOUTH:
case on | SOUTH:
case offSubtract | SOUTH:
case onSubtract | SOUTH:
f = "south"
break
case off | EAST:
case on | EAST:
case offSubtract | EAST:
case onSubtract | EAST:
f = "east"
break
case off | WEST:
case on | WEST:
case offSubtract | WEST:
case onSubtract | WEST:
f = "west"
break
}
return f
},
canHavePower:function(/*this*/rx,ry,rz,/*other thing*/x,y,z,dimension,world){
var tx = rx, ty = ry, tz = rz
var block = world.getBlock(rx,ry,rz,dimension)
var off = this.id, on = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
switch(block){
case offSubtract | NORTH:
case onSubtract | NORTH:
case off | NORTH:
case on | NORTH:
tz++
break
case offSubtract | SOUTH:
case onSubtract | SOUTH:
case off | SOUTH:
case on | SOUTH:
tz--
break
case offSubtract | EAST:
case onSubtract | EAST:
case off | EAST:
case on | EAST:
tx++
break
case offSubtract | WEST:
case onSubtract | WEST:
case off | WEST:
case on | WEST:
tx--
break
}
if(tx === x && ty === y && tz === z){
return world.getTagByName(rx,ry,rz,"output",dimension) || 0
}
return 0
}
},
{
name:"acaciaChair",
Name:"Acacia Chair",
textures:"acaciaPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"birchChair",
Name:"Birch Chair",
textures:"birchPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"jungleChair",
Name:"Jungle Chair",
textures:"junglePlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"darkOakChair",
Name:"Dark Oak Chair",
textures:"darkOakPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"spruceChair",
Name:"Spruce Chair",
textures:"sprucePlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"mangroveChair",
Name:"Mangrove Chair",
textures:"mangrovePlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"crimsonChair",
Name:"Crimson Chair",
textures:"crimsonPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"warpedChair",
Name:"Warped Chair",
textures:"warpedPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"blackChair",
Name:"Black Chair",
textures:"blackWool",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name: "spawnCreeper",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Creeper](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Creeper](x,y,z),false,dimension)
},
category:"items"
},
{
name:"gunpowder",
Name:"Gray exploding stuff",
item:true
},
{
name:"rottenFlesh",
Name:"Rotten Flesh",
item:true
},
{
name: "spawnSheep",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Sheep](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Sheep](x,y,z),false,dimension)
},
category:"items"
},
{
name: "spawnChicken",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Chicken](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Chicken](x,y,z),false,dimension)
},
category:"items"
},
{
name:"feather",
Name:"Feather",
item:true
},
{
name: "spawnZombie",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Zombie](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Zombie](x,y,z),false,dimension)
},
category:"items"
},
{
name: "spawnSkeleton",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Skeleton](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Skeleton](x,y,z),false,dimension)
},
category:"items"
},
{
name: "bone",
Name: "Bone",
item: true,
category:"items"
},
{
name:"spawner",
Name:"Mob Spawner",
transparent:true,
blastResistance:5,
hardness:5,
drop:"air",
experience:15,
tagBits:null,
tick:function(block,x,y,z,dimension,world){
let spawn = world.getTagByName(x,y,z,"spawn",dimension)
if(spawn){
world.sendAll({
type:"particles", particleType:"flameCube",
x,y,z,dimension, amount: 20
})
for(let i=0; i<10; i++){
let sx = x+round(rand(-4.5,4))
let sy = y+round(rand(-1.5,1.5))
let sz = z+round(rand(-4.5,4))
let block = world.getBlock(sx,sy,sz,dimension)
if(blockData[block].transparent){
blockData[spawn].spawnMob(sx,sy,sz,dimension,world)
break
}
}
}
},
onclick:function(x,y,z,dimension,world,p){
if(p.holding && blockData[p.holding].spawnMob){
world.setTagByName(x,y,z,"spawn",p.holding,false,dimension)
world.sendAll({
type:"particles", particleType:"flameCube",
x,y,z,dimension, amount: 30
})
}else return true
}
},
{
name:"daylightDetector",
Name:"Daylight detector",
textures:["daylightDetectorSide","daylightDetectorTop","daylightDetectorSide"],
invertedTextures:fillTextureArray(["daylightDetectorSide","daylightDetectorInvertedTop","daylightDetectorSide"]),
transparent:true,
blastResistance:0.2,
hardness:0.2,
woodSound:true,
onclick:function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension)
let me = blockData[blockIds.daylightDetector]
if(block === (me.id | SLAB)) block = me.id
else block = me.id | SLAB
world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
tick:function(block,x,y,z,dimension,world){
let power = round(world.getLight(x, y, z, 0, dimension)*world.skyLight)
if(block === (this.id | SLAB)) power = 15 - power
let prev = world.getPower(x,y,z,dimension)
if(prev !== power){
world.setPower(x,y,z,power,false,dimension)
if(power){
if(power < prev){
world.unspreadPower(x,y,z,prev,false,dimension)
}else if(power > prev){
world.spreadPower(x,y,z,power,dimension)
}
}else{
world.unspreadPower(x,y,z,prev,false,dimension)
}
}
},
onset:function(x,y,z,dimension,world){
this.tick(world.getBlock(x,y,z,dimension),x,y,z,dimension,world)
},
ondelete: function(x,y,z,prevTags,prev,dimension,world){
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z, 16,false,dimension)
},
category:"redstone"
},
{
name:"commandBlock",
Name:"Command Block",
textures:["commandBlockBack",'commandBlockFront','commandBlockSide'],
errorTextures:fillTextureArray(["commandBlockBackError",'commandBlockFrontError','commandBlockSideError']),
sideTextures:["commandBlockSide","commandBlockSide","commandBlockBack","commandBlockFront","commandBlockSide","commandBlockSide"],
sideErrorTextures:["commandBlockSideError","commandBlockSideError","commandBlockBackError","commandBlockFrontError","commandBlockSideError","commandBlockSideError"],
flipTextures:fillTextureArray(["commandBlockFront",'commandBlockBack','commandBlockSide']),
flipErrorTextures:fillTextureArray(["commandBlockFrontError",'commandBlockBackError','commandBlockSideError']),
hardness:Infinity,
commandBlock:true,
tagBits: null,
trigger:function(x,y,z,dimension,world){
let data = world.getTagByName(x,y,z,"data",dimension)
let running = world.getTagByName(x,y,z,"running",dimension)
if(data && !running){
world.setTagByName(x,y,z,"running",true,false,dimension)
runCmd(data,{x,y,z,dimension},world,true, output => {
let outputHTML = "none"
outputHTML = ""
for(let i=0; i<output.length; i+=2){
if(i) outputHTML += "<br>"
outputHTML += Messages.format(output[i])
}
world.setTagByName(x,y,z,"output",outputHTML,false,dimension)
let target
let block = world.getBlock(x,y,z,dimension)
switch(block){
case this.id:
case this.id | FLIP:
target = this.id
break
case this.id | SLAB | NORTH:
case this.id | SLAB | FLIP | NORTH:
target = this.id | SLAB | NORTH
break
case this.id | SLAB | SOUTH:
case this.id | SLAB | FLIP | SOUTH:
target = this.id | SLAB | SOUTH
break
case this.id | SLAB | EAST:
case this.id | SLAB | FLIP | EAST:
target = this.id | SLAB | EAST
break
case this.id | SLAB | WEST:
case this.id | SLAB | FLIP | WEST:
target = this.id | SLAB | WEST
break
case this.id | STAIR:
case this.id | STAIR | FLIP:
target = this.id | STAIR
break
}
if(output && output[output.length-1] === "error") target |= FLIP
if(block !== target) world.setBlock(x,y,z,target,false,false,false,true,dimension)
}).then(() => world.setTagByName(x,y,z,"running",false,false,dimension))
}
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension) ? true : false
var on = world.getTagByName(x,y,z,"on",dimension) || false
if(power !== on) {
world.setTagByName(x,y,z,"on",power,false,dimension)
if(power){
this.trigger(x,y,z,dimension,world)
}
}
},
rarity:"epic",
category:"redstone"
},
{
name:"spiderEye",
item:true,
category:"items"
},
{
name: "spawnSpider",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Spider](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Spider](x,y,z),false,dimension)
},
category:"items"
},
{
name: "spawnCaveSpider",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Spider](pos[0],pos[1],pos[2],true)
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Spider](x,y,z,true),false,dimension)
},
category:"items"
},
{
name: "spawnWolf",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Wolf](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Wolf](x,y,z),false,dimension)
},
category:"items"
},
{
name:"nameTag",
Name:"Name Tag",
item:true,
onserverentityuse:function(ent,holding){
if(ent.mob && holding.customName){
ent.name = holding.customName
ent.world.sendEntityPos(ent)
holding.amount--
}
}
},
{
name:"blazeRod",
Name:"Blaze Rod",
item:true
},
{
name:"blazePowder",
Name:"Blaze Powder",
item:true
},
{
name: "spawnBlaze",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Blaze](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Blaze](x,y,z),false,dimension)
},
category:"items"
},
{
name:"fireCharge",
item:true
},
{
name: "spawnEnderDragon",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.EnderDragon](pos[0],pos[1],pos[2])
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.EnderDragon](x,y,z),false,dimension)
},
category:"items",
hidden:true
},
{
name:"debugStick",
item:true,
hidden:true
},
{
name: "oil",
textures:"oil",
transparent: true,
liquid: true,
solid:false,
shadow: false,
blastResistance:100,
hidden:true,
drop:"air",
burnChance: 1,
burnTime: 15,
density:0.1,
inLiquid:3,
getLevelDifference:function(level){return level-2},
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
if(!world.settings.blocksFall) return
var me = this
world.setTimeout(() => me.flow(x,y,z,dimension,world), tickTime*5, x,y,z,dimension)
},
getY:function(x,y,z,dimension){
var block = world.getBlock(x,y,z,dimension)
return (min((this.getLevel(block) || (block ? 8 : 0))*2,14.5)/16)-0.5
},
},
{
name: "oilBucket",
Name:"Oil Bucket",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(p.survival) item.id = blockIds.bucket
var pos = movePositionByFace(face,x,y,z)
world.setBlock(pos[0],pos[1],pos[2],blockIds.oil,false,false,false,false,dimension)
},
stackSize: 1,
category:"items"
},
{ name: "silverBlock", Name:"Block of Silver", hardness:5, type:"metal2",category:"build", stoneSound:true},
{ name: "limestone", Name:"Limestone", type:"rock1",category:"nature", hardness:1.25, blastResistance:0.8, stoneSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
{
name: "spawnEnderman",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Enderman](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Enderman](x,y,z),false,dimension)
},
category:"items"
},
{
name:"bambooBlock",
Name:"Block of Bamboo",
textures:["bambooBlockTop","bambooBlock"],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{
name:"bambooBlockSW",
textures: ["bambooBlock","bambooBlock","bambooBlockTop","bambooBlock"],
SW: true, hidden:true
},
{
name:"strippedBambooBlock",
Name:"Stripped Block of Bamboo",
textures:["strippedBambooBlockTop","strippedBambooBlock"],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{
name:"strippedBambooBlockSW",
textures: ["strippedBambooBlock","strippedBambooBlock","strippedBambooBlockTop","strippedBambooBlock"],
SW: true, hidden:true
},
{ name: "bambooPlanks", Name:"Bamboo Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
{ name: "bambooMosaic", Name:"Bamboo Mosaic", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
{
name:"bambooButton",
Name: "Bamboo Button",
textures:"bambooPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{ 
name: "bambooDoor",
Name:"Bamboo Door",
transparent: true,
shadow: false,
textures: "bambooDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name:"bambooFenceGate",
Name:"Bamboo Fence Gate",
textures:"bambooPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name: "bambooPressurePlate",
Name: "Bamboo Pressure Plate",
textures: "bambooPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name:"bambooSign",
Name:"Bamboo sign",
textures:"bambooPlanks",
poleTop:"bambooBlockTop",
poleSide:"bambooBlock",
iconTexture:"bambooSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{ 
name: "bambooTrapdoor",
Name:"Bamboo Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{
name:"strippedCherryLog",
Name:"Stripped Cherry Log",
textures:["strippedCherryLogTop","strippedCherryLog"],
woodSound:true,
hardness:2,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature"
},
{
name:"strippedCherryLogSW",
textures: ["strippedCherryLog","strippedCherryLog","strippedCherryLogTop","strippedCherryLog"],
SW: true, hidden:true
},
{ name: "cherryPlanks", Name:"Cherry Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
{
name:"cherryButton",
Name: "Cherry Button",
textures:"cherryPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{ 
name: "cherryDoor",
Name:"Cherry Door",
transparent: true,
shadow: false,
textures: "cherryDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name:"cherryFenceGate",
Name:"Cherry Fence Gate",
textures:"cherryPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name: "cherryPressurePlate",
Name: "Cherry Pressure Plate",
textures: "cherryPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name:"cherrySign",
Name:"Cherry sign",
textures:"cherryPlanks",
poleTop:"cherryLogTop",
poleSide:"cherryLog",
iconTexture:"cherrySign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{ 
name: "cherryTrapdoor",
Name:"Cherry Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{
name:"cherryChair",
Name:"Cherry Chair",
textures:"cherryPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"bambooChair",
Name:"Bamboo Chair",
textures:"bambooPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name: "suspicousSand",
Name:"Suspicois Sand",
textures:"suspiciousSand0",
hardness:0.25, blastResistance:0.5,
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
drop:"air"
},
{
name: "suspicousGravel",
Name:"Suspicous Gravel",
textures:"suspiciousGravel0",
hardness:0.25, blastResistance:0.5,
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
drop:"air"
},
{
name:"pitcherPlant",
Name:"Pitcher Plant",
shapeName:"pitcherPlant",
flatIcon:true,
solid: false,
transparent: true,
shadow: false,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name:"pitcherPod",
Name:"Pitcher Pod",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "pitcherCrop"
},
category:"items"
},
{
name:"pitcherCrop",
textures:"pitcherCropSide",
textures1:new Array(6).fill("pitcherCropBottomStage1"),
textures2:new Array(6).fill("pitcherCropBottomStage2"),
textures3:new Array(6).fill("pitcherCropBottomStage3"),
textures4:new Array(6).fill("pitcherCropBottomStage4"),
transparent: true,
shadow: false,
solid: false,
drop:"pitcherPod",
hidden:true,
liquidBreakable:"drop"
},
{
name: "torchflower",
Name:"\"Torch\" flower",
textures1:new Array(6).fill("torchflowerCropStage0"),
textures2:new Array(6).fill("torchflowerCropStage1"),
drop:"torchflowerSeeds",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name:"torchflowerSeeds",
Name:"Torchflower seeds",
item:true,
useAs:function(x,y,z,block,face){
return blockIds.torchflower|SLAB
},
category:"items"
},
{
name:"driedOakLeaves",
Name:"Dried Oak Leaves",
thickTexture:"driedOakLeavesThick",
hardness:0.1,
drop:"air",
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
groundLeaves:true
},
{
name:"driedBirchLeaves",
Name:"Dried Birch Leaves",
hardness:0.1,
drop:"air",
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
groundLeaves:true
},
{
name:"driedSpruceLeaves",
Name:"Dried Spruce Leaves",
hardness:0.1,
drop:"air",
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
groundLeaves:true
},
{
name:"strippedCherryWood",
Name:"Stripped Cherry Wood",
textures: "strippedCherryLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name:"pinkPetals",
Name:"Pink flowers",
textures:["pinkPetalsFlower","pinkPetalsStem"],
iconTexture:"pinkPetals",
flowerbed:true,
solid: false,
transparent: true,
shadow: false,
liquidBreakable:"drop",
category:"nature",
randomRotateOnSpawn:true,
addPetal:function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension), target, rot = block&ROTATION
switch(block & (~ROTATION)){
case this.id:
target = this.id | SLAB
break
case this.id|SLAB:
target = this.id | STAIR
break
case this.id|STAIR:
target = this.id | DOOR
break
}
if(target) world.setBlock(x,y,z,target|rot,false,false,false,false,dimension)
}
},
{
name:"lilyPad",
Name:"Lily Pad",
transparent:true,
shadow:false,
shapeName:"flat",
flatIcon:true,
liquidBreakable:"drop",
category:"nature",
type:"plant2",
allHitbox: true
},
{
name:"lightPanel",
Name:"Light Panel",
transparent:true,
shadow:false,
shapeName:"ceilingPanel",
lightLevel:15,
category:"build",
glassSound:true,
flatIcon:true
},
{
name:"bambooLeaves",
Name: "Bamboo Leaves",
transparent: true,
cullFace:0,
hardness: 0.2,
type:"plant2",
leaves:true,
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(2))
if(r === 0) return "stick"
else if(r === 1) return "bambooShoot"
}
},
},
{
name:"driedBambooLeaves",
Name:"Dried Bamboo Leaves",
hardness:0.1,
drop:"air",
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
groundLeaves:true
},
{
name:"groundBerries",
Name:"Ground Berries",
textures:["groundBerries","groundBerriesStem"],
hardness:0.1,
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
shapeName:"groundBush",
randomRotateOnSpawn:true
},
{
name:"brainCoralBlock",
Name:"Sponge-like Coral Block",
category:"nature",
coralBlock:true
},
{
name:"bubbleCoralBlock",
Name:"Bubble Coral Block",
category:"nature",
coralBlock:true
},
{
name:"fireCoralBlock",
Name:"Fire Coral Block",
category:"nature",
coralBlock:true
},
{
name:"hornCoralBlock",
Name:"Horn Coral Block",
category:"nature",
coralBlock:true
},
{
name:"tubeCoralBlock",
Name:"Tube Coral Block",
category:"nature",
coralBlock:true
},
{
name:"brainCoral",
Name:"Sponge-like Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"bubbleCoral",
Name:"Bubble Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"fireCoral",
Name:"Fire Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"hornCoral",
Name:"Horn Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"tubeCoral",
Name:"Tube Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"brainCoralFan",
Name:"Sponge-like Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"bubbleCoralFan",
Name:"Bubble Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"fireCoralFan",
Name:"Fire Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"hornCoralFan",
Name:"Horn Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"tubeCoralFan",
Name:"Tube Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"minecart",
Name:"Minecart",
textures:"minecartIcon",
item:true,
category:"redstone",
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Minecart](pos[0],pos[1],pos[2])
world.addEntity(ent,false,dimension)
},
},
{
name:"rail",
Name:"Rail",
transparent:true,
shadow:false,
solid:false,
blastResistance:0.7,
hardness:0.7,
rail:true,
category:"redstone",
flatIcon:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
this.railonupdate(x,y,z,b,world,dimension)
},
},
{
name:"poweredRail",
Name:"Powered Rail",
transparent:true,
shadow:false,
solid:false,
blastResistance:0.7,
hardness:0.7,
rail:true,
category:"redstone",
flatIcon:true,
carryRedstone:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
let on = world.getTagByName(x,y,z,"power",dimension)
if(on && !(b&FLIP)){
b |= FLIP
world.setBlock(x,y,z,b,false,false,false,true,dimension)
}else if(!on && (b&FLIP)){
b &= ~FLIP
world.setBlock(x,y,z,b,false,false,false,true,dimension)
}
this.railonupdate(x,y,z,b,world,dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
this.onupdate(x,y,z,world.getBlock(x,y,z,dimension),world,sx,sy,sz,dimension)
}
},
{
name:"cornPlant",
textures:"cornStage0",
textures1:new Array(6).fill("cornStage1"),
textures2:new Array(6).fill("cornStage2"),
textures3:new Array(6).fill("cornStage3"),
textures4:new Array(6).fill("cornStage4"),
textures5:new Array(6).fill("cornStage5"),
transparent: true,
shadow: false,
solid: false,
drop:"corn",
hidden:true,
liquidBreakable:"drop",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|DOOR,false,false,false,false,dimension)
}
},
{
name:"corn",
Name:"Corn",
item:true,
edible: true,
food: 3,
saturation: 2,
compostChance:0.85,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "cornPlant"
},
category:"food"
},
{
name:"popcornBowl",
Name:"Bowl of Popcorn",
item:true,
edible: true,
food: 4,
saturation: 2,
eatResult:"bowl",
category:"food"
},
];
const BLOCK_COUNT = blockData.length
console.log(BLOCK_COUNT," blocks on server side")
win.SERVER_BLOCK_COUNT = BLOCK_COUNT, win.serverBlockData = blockData
win.emptyFunc = function(){}
let blockIds = {}
win.serverBlockIds = blockIds
let generateBlockIds = {
grass:true, dirt:true, stone: true, gravel: true,
snowBlock: true, snow: true, packedIce:true, ice:true,
Water: true, powderSnow: true, mud:true,
coarseDirt:true, podzol: true,
sand: true, bedrock: true, deepslate: true,
sandstone: true, limestone: true,
mycelium: true, redSand: true, rootedDirt:true,
redSandstone: true, calcite: true,
terracotta: true, lightGrayTerracotta: true, whiteTerracotta: true, yellowTerracotta: true, orangeTerracotta: true,
glass: true,//for testing without shadows
orangeConcrete:true,glowstone:true//also for testing
} //blocks that can be naturally generated
function initBlockData(){
const stoneDigSound = ["stone.dig1", "stone.dig2", "stone.dig3", "stone.dig4"],
stoneStepSound = ["stone.step1", "stone.step2","stone.step3","stone.step4","stone.step5","stone.step6"],
woodDigSound = ["wood.dig1", "wood.dig2", "wood.dig3", "wood.dig4"],
woodStepSound = ["wood.step1", "wood.step2","wood.step3","wood.step4","wood.step5","wood.step6"],
clothDigSound = ["cloth.dig1", "cloth.dig2", "cloth.dig3", "cloth.dig4"],
clothStepSound = ["cloth.step1", "cloth.step2","cloth.step3","cloth.step4"],
glassDigSound = ["glass.dig1", "glass.dig2", "glass.dig3"],
nyliumDigSound = ["nylium.dig1", "nylium.dig2", "nylium.dig3", "nylium.dig4", "nylium.dig5", "nylium.dig6"],
nyliumStepSound = ["nylium.step1", "nylium.step2","nylium.step3","nylium.step4","nylium.step5","nylium.step6"],
stemDigSound = ["stem.dig1", "stem.dig2", "stem.dig3", "stem.dig4", "stem.dig5", "stem.dig6"],
stemStepSound = ["stem.step1", "stem.step2","stem.step3","stem.step4","stem.step5","stem.step6"],
basaltDigSound = ["basalt.dig1", "basalt.dig2", "basalt.dig3", "basalt.dig4", "basalt.dig5"],
basaltStepSound = ["basalt.step1", "basalt.step2","basalt.step3","basalt.step4","basalt.step5","basalt.step6"],
rootDigSound = ["roots.dig1", "roots.dig2", "roots.dig3", "roots.dig4", "roots.dig5", "roots.dig6"],
rootStepSound = ["roots.step1", "roots.step2","roots.step3","roots.step4","roots.step5","roots.step6"],
amethystPlaceSound = ["amethyst.place1","amethyst.place2","amethyst.place3","amethyst.place4"],
amethystDigSound = ["amethyst.dig1","amethyst.dig2","amethyst.dig3","amethyst.dig4"],
amethystStepSound = (function(){var arr=[]; for(var i=0; i<14; i++){arr.push("amethyst.step"+(i+1))};return arr})(),
amethystClusterPlaceSound = ["amethyst_cluster.place1", "amethyst_cluster.place2", "amethyst_cluster.place3", "amethyst_cluster.place4"],
amethystClusterDigSound = ["amethyst_cluster.dig1", "amethyst_cluster.dig2", "amethyst_cluster.dig3", "amethyst_cluster.dig4"],
deepslatePlaceSound = ["deepslate.place1","deepslate.place2","deepslate.place3","deepslate.place4","deepslate.place5","deepslate.place6"],
deepslateStepSound = ["deepslate.step1","deepslate.step2","deepslate.step3","deepslate.step4","deepslate.step5","deepslate.step6"],
deepslateDigSound = ["deepslate.dig1","deepslate.dig2","deepslate.dig3","deepslate.dig4"],
deepslateBricksPlaceSound = [1,2,3,4,5,6].map(v => "deepslate_bricks.place"+v),
deepslateBricksStepSound = [1,2,3,4,5].map(v => "deepslate_bricks.step"+v),
grassDigSound = ["grass.dig1", "grass.dig2", "grass.dig3", "grass.dig4"],
grassStepSound = ["grass.step1", "grass.step2","grass.step3","grass.step4","grass.step5","grass.step6"],
coralDigSound = ["coral.dig1","coral.dig2","coral.dig3","coral.dig4"],
coralStepSound = ["coral.step1","coral.step2","coral.step3","coral.step4","coral.step5","coral.step6"],
wetgrassDigSound = ["wetgrass.dig1","wetgrass.dig2","wetgrass.dig3","wetgrass.dig4"],
wetgrassStepSound = ["wetgrass.step1","wetgrass.step2","wetgrass.step3","wetgrass.step4","wetgrass.step5","wetgrass.step6"]
const defaultTagBits = {
power:[15,5], //extra for power level 16 (power sources)
blockPowerNorth:[20,2],
blockPowerSouth:[22,2],
blockPowerEast:[24,2],
blockPowerWest:[26,2],
blockPowerTop:[28,2],
blockPowerBottom:[30,2],
} /*
tag bits have a index and a count
if tagBits is set to null
- it stores it as a properties of an object,
otherwise
- it stores it in specific bits in a number
*/
// Set defaults on blockData
for (let i = 1; i < BLOCK_COUNT; ++i) {
const data = blockData[i];
data.id = i;
if ( !("textures" in data) ) {
data.textures = new Array(6).fill(data.name);
} else if (typeof data.textures === "string") {
data.textures = new Array(6).fill(data.textures);
} else {
const { textures } = data;
if (textures.length === 3) {
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
} else if (textures.length === 2) {
// Top and bottom are the first texture, sides are the second.
textures[2] = textures[1];
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
textures[1] = textures[0];
}else if(textures.length === 4){
textures[4] = textures[5] = textures[3]
textures[3] = textures[2]
}
}
data.transparent = data.transparent || false
data.shadow = data.shadow !== undefined ? data.shadow : true
data.shade = data.shade !== undefined ? data.shade : true
data.smoothLight = data.smoothLight !== undefined ? data.smoothLight : true //if smoothLight is false, it also needs to be transparent
data.lightLevel = data.lightLevel || 0
if(data.solid === undefined)data.solid = true
//data.breakTime = data.breakTime ? data.breakTime*1000 : 0 //time for breaking, changed to hardness
data.hardness = data.hardness || 0
if(data.dropAmount === undefined) data.dropAmount = 1
if(data.leaves && data.decreaseLight === undefined) data.decreaseLight = 1
if(data.crossShape || data.tallcrossShape || data.sideCross || data.ladder || data.torch || data.lantern || data.chain || data.sunflower || data.crop || data.tallCrop) data.smoothLight = false
if(data.item){
data.transparent = true
data.shadow = false
}
if(data.liquid) data.noHitbox = true
if(!data.stackSize)data.stackSize = 64
if(data.pickaxe){
data.stackSize = 1
data.attackTime = 20/1.2
}
if(data.sword){
data.stackSize = 1
data.attackTime = 20/1.6
}
if(data.shovel){
data.stackSize = 1
data.attackTime = 20/1
}
if(data.axe || data.hoe){
data.stackSize = 1
}
data.tool = data.tool || data.pickaxe || data.sword || data.shovel || data.axe || data.hoe
if(data.attackSpeed) data.attackTime = 20/data.attackSpeed
if(data.tagBits !== null){
if(data.tagBits) Object.assign(data.tagBits,defaultTagBits)
else data.tagBits = defaultTagBits
}
if(data.stoneSound){
data.digSound = stoneDigSound
data.stepSound = stoneStepSound
}
if(data.woodSound){
data.digSound = woodDigSound
data.stepSound = woodStepSound
}
if(data.clothSound){
data.digSound = clothDigSound
data.stepSound = clothStepSound
}
if(data.glassSound){
data.digSound = glassDigSound
data.placeSound = stoneDigSound
}
if(data.nyliumSound){
data.digSound = nyliumDigSound
data.stepSound = nyliumStepSound
}
if(data.stemSound){
data.digSound = stemDigSound
data.stepSound = stemStepSound
}
if(data.basaltSound){
data.digSound = basaltDigSound
data.stepSound = basaltStepSound
}
if(data.rootSound){
data.digSound = rootDigSound
data.stepSound = rootStepSound
}
if(data.amethystSound){
data.placeSound = amethystPlaceSound
data.digSound = amethystDigSound
data.stepSound = amethystStepSound
}
if(data.amethystClusterSound){
data.placeSound = amethystClusterPlaceSound
data.digSound = amethystClusterDigSound
}
if(data.deepslateSound){
data.placeSound = deepslatePlaceSound
data.digSound = deepslateDigSound
data.stepSound = deepslateStepSound
}
if(data.deepslateBricksSound){
data.placeSound = deepslateBricksPlaceSound
data.stepSound = deepslateBricksStepSound
}
if(data.grassSound){
data.digSound = grassDigSound
data.stepSound = grassStepSound
}
if(data.coralBlock){
data.digSound = coralDigSound
data.stepSound = coralStepSound
}
if(data.wetgrassSound){
data.digSound = wetgrassDigSound
data.stepSound = wetgrassStepSound
}
data.Name = data.Name || data.name
data.pistonPush = data.pistonPush !== undefined ? data.pistonPush : true
data.pistonPull = data.pistonPull !== undefined ? data.pistonPull : true
}
blockData.forEach(block => {
blockIds[block.name] = block.id
if(block.SW && block.name.includes("SW")){
let unSw = block.name.replace("SW",'')
if(blockIds[unSw]){
block.drop = unSw
let obj = blockData[blockIds[unSw]]
block.hardness = obj.hardness
block.type = obj.type
block.burnChance = obj.burnChance
block.burnTime = obj.burnTime
block.log = obj.log
obj.swId = block.id
}
}
if(generateBlockIds[block.name]) generateBlockIds[block.name] = block.id
})
//fill the crafts that have less than 9 items. Ex: "thing" => "thing,air,air..."
let arr, arr2 = new Array(9)
for(let i in crafts){
arr = i.split(",")
for(let j = 0; j<9; j++){
if(arr[j]){
arr[j] = getBlockId(arr[j])
}else{
arr.push(0)
}
}
crafts[i].id = getBlockId(crafts[i].name)
if(crafts[i].amount === undefined) crafts[i].amount = 1
craftArrays[arr.join(",")] = arr.slice()
crafts[arr.join(",")] = crafts[i]
//shaped recipes
if(crafts[i].shaped){
var craft2 = Object.assign({},crafts[i])
craft2.hidden = true
var xSpace = 3, ySpace = 3
//find how much empty space there is
for(var x=2; x>=0; x--){
var a = arr[x]
var b = arr[x+3]
var c = arr[x+6]
if(a||b||c){
xSpace = x
break
}
}
for(var y=2; y>=0; y--){
var a = arr[y*3]
var b = arr[(y*3)+1]
var c = arr[(y*3)+2]
if(a||b||c){
ySpace = y
break
}
}
var offsetX = -1, offsetY = -1
for(var x = xSpace; x<3; x++){
offsetX ++
for(var y = ySpace; y<3; y++){
offsetY ++
if(x === xSpace && y === ySpace) continue
arr2.fill(0)
for(var x2 = 0; x2<3; x2++){
for(var y2 = 0; y2<3; y2++){
var b = arr[x2+(y2*3)]
if(b){
var bx = x2 + offsetX
var by = y2 + offsetY
arr2[bx+(by*3)] = b
}
}
}
crafts[arr2.join(",")] = craft2
craftArrays[arr2.join(",")] = arr2.slice()
}
offsetY = -1
}
}
delete crafts[i]
}
win.crafts = crafts
for(let i in craftTypes){
for(let j=0; j<craftTypes[i].length; j++){
craftTypes[i][j] = getBlockId(craftTypes[i][j])
}
}
for(let i in smelts){
smelts[i].id = blockIds[smelts[i].name]
if(blockIds[i]){
smelts[blockIds[i]] = smelts[i]
delete smelts[i]
}
}
for(let i in smeltFuel){
smeltFuel[i].operations = smeltFuel[i].time / 10
smeltFuel[i].ops = smeltFuel[i].operations / smeltFuel[i].time //operations per seconds
if(blockIds[i]){
smeltFuel[blockIds[i]] = smeltFuel[i]
delete smeltFuel[i]
}
}
win.smelts = smelts; win.smeltFuel = smeltFuel
}
const breakTypes = {
plant: "axe",
wood: "axe",
metal1: "pickaxe",
metal2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
metal3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
metal4: ["diamondPickaxe","netheritePickaxe"],
rock1: "pickaxe",
rock2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
rock3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
rock4: ["diamondPickaxe","netheritePickaxe"],
ground: "shovel",
plant2: "hoe",
wool:"air"
}
win.breakTypes = breakTypes
const handBreakable = [
"plant","wood","plant2","ground","wool"
]
win.handBreakable = handBreakable
var allPickaxes = ["woodenPickaxe","stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe","goldenPickaxe"]
var allShovels = ["woodenShovel","stoneShovel","ironShovel","diamondShovel","netheriteShovel","goldenShovel"]
for(var b in breakTypes){
var t = breakTypes[b]
if(t === "pickaxe"){
breakTypes[b] = allPickaxes
}
if(t === "shovel"){
breakTypes[b] = allShovels
}
}
const crafts = {
"oakLog": {name:"oakPlanks", amount:4, shapeless: true},
"acaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
"birchLog": {name:"birchPlanks", amount:4, shapeless: true},
"darkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
"jungleLog": {name:"junglePlanks", amount:4, shapeless: true},
"spruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
"mangroveLog": {name:"mangrovePlanks", amount:4, shapeless:true},
"cherryLog": {name:"cherryPlanks", amount:4, shapeless:true},
"_planks,air,air,_planks": {name:"stick", amount:4, shaped:true},
"oakPlanks,oakPlanks,air,oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"oakDoor", amount:3},
"acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"acaciaDoor", amount:3},
"birchPlanks,birchPlanks,air,birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"birchDoor", amount:3},
"darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks":{name:"darkOakDoor", amount:3},
"junglePlanks,junglePlanks,air,junglePlanks,junglePlanks,air,junglePlanks,junglePlanks":{name:"jungleDoor", amount:3},
"sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks":{name:"spruceDoor", amount:3},
"mangrovePlanks,mangrovePlanks,air,mangrovePlanks,mangrovePlanks,air,mangrovePlanks,mangrovePlanks":{name:"mangroveDoor", amount:3},
"warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks":{name:"warpedDoor", amount:3},
"crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air":{name:"crimsonDoor",amount:3},
"bambooPlanks,bambooPlanks,air,bambooPlanks,bambooPlanks,air,bambooPlanks,bambooPlanks":{name:"bambooDoor", amount:3},
"cherryPlanks,cherryPlanks,air,cherryPlanks,cherryPlanks,air,cherryPlanks,cherryPlanks":{name:"cherryDoor", amount:3},
"ironIngot,ironIngot,air,ironIngot,ironIngot,air,ironIngot,ironIngot,air":{name:"ironDoor",amount:3},
"oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"oakTrapdoor", amount:2},
"birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks":{name:"birchTrapdoor", amount:2},
"darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks":{name:"darkOakTrapdoor", amount:2},
"junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks":{name:"jungleTrapdoor", amount:2},
"sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks":{name:"spruceTrapdoor", amount:2},
"acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks":{name:"acaciaTrapdoor", amount:2},
"mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks":{name:"mangroveTrapdoor", amount:2},
"warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks":{name:"warpedTrapdoor", amount:2},
"crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks":{name:"crimsonTrapdoor", amount:2},
"ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironTrapdoor", amount:2},
"bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks":{name:"bambooTrapdoor", amount:2},
"cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks":{name:"cherryTrapdoor", amount:2},
"redWool,redWool,redWool,_planks,_planks,_planks":{name:"redBed"},
"_planks,_planks,air,_planks,_planks":{name:"craftingTable",shaped:true},
"coal,air,air,stick":{name:"torch",amount:4,shaped:true},
"coal,air,air,stick,air,air,soulSand":{name:"soulTorch",amount:4,shaped:true},
"charcoal,air,air,stick":{name:"torch",amount:4,shaped:true},
"charcoal,air,air,stick,air,air,soulSand":{name:"soulTorch",amount:4,shaped:true},
"coal,coal,coal,coal,coal,coal,coal,coal,coal":{name:"coalBlock"},
"ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironBlock"},
"goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldBlock"},
"diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond":{name:"diamondBlock"},
"lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli":{name:"lapisBlock"},
"emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald":{name:"emeraldBlock"},
"_planks,_planks,_planks,air,stick,air,air,stick":{name:"woodenPickaxe"},
"_stone,_stone,_stone,air,stick,air,air,stick":{name:"stonePickaxe"},
"ironIngot,ironIngot,ironIngot,air,stick,air,air,stick":{name:"ironPickaxe"},
"goldIngot,goldIngot,goldIngot,air,stick,air,air,stick":{name:"goldenPickaxe"},
"diamond,diamond,diamond,air,stick,air,air,stick":{name:"diamondPickaxe"},
"ironIngot,air,air,air,flint": {name:"flintAndSteel"},
"air,_planks,air,air,_planks,air,air,stick": {name:"woodenSword"},
"air,_stone,air,air,_stone,air,air,stick": {name:"stoneSword"},
"air,ironIngot,air,air,ironIngot,air,air,stick": {name:"ironSword"},
"air,goldIngot,air,air,goldIngot,air,air,stick": {name:"goldenSword"},
"air,diamond,air,air,diamond,air,air,stick": {name:"diamondSword"},
"air,air,air,snowBlock,snowBlock,snowBlock": {name:"snow", amount:6},
"snowball,snowball,air,snowball,snowball": {name:"snowBlock"},
"ironIngot,air,ironIngot,air,ironIngot":{name:"bucket"},
"_stone,_stone,_stone,_stone,air,_stone,_stone,_stone,_stone":{name:"furnace"},
"wheat,wheat,wheat":{name:"bread"},
"_planks,air,air,stick,air,air,stick":{name:"woodenShovel"},
"_stone,air,air,stick,air,air,stick":{name:"stoneShovel"},
"ironIngot,air,air,stick,air,air,stick":{name:"ironShovel"},
"goldIngot,air,air,stick,air,air,stick":{name:"goldenShovel"},
"diamond,air,air,stick,air,air,stick":{name:"diamondShovel"},
"_planks,_planks,air,_planks,stick,air,air,stick":{name:"woodenAxe"},
"_stone,_stone,air,_stone,stick,air,air,stick":{name:"stoneAxe"},
"ironIngot,ironIngot,air,ironIngot,stick,air,air,stick":{name:"ironAxe"},
"goldIngot,goldIngot,air,goldIngot,stick,air,air,stick":{name:"goldenAxe"},
"diamond,diamond,air,diamond,stick,air,air,stick":{name:"diamondAxe"},
"birchPlanks,birchPlanks":{name:"birchPressurePlate",shapeless:true},
"oakPlanks,oakPlanks":{name:"oakPressurePlate",shapeless:true},
"junglePlanks,junglePlanks":{name:"junglePressurePlate",shapeless:true},
"sprucePlanks,sprucePlanks":{name:"sprucePressurePlate",shapeless:true},
"darkOakPlanks,darkOakPlanks":{name:"darkOakPressurePlate",shapeless:true},
"acaciaPlanks,acaciaPlanks":{name:"acaciaPressurePlate",shapeless:true},
"mangrovePlanks,mangrovePlanks":{name:"mangrovePressurePlate",shapeless:true},
"warpedPlanks,warpedPlanks":{name:"warpedPressurePlate",shapeless:true},
"crimsonPlanks,crimsonPlanks":{name:"crimsonPressurePlate",shapeless:true},
"stone,stone":{name:"stonePressurePlate",shapeless:true},
"polishedBlackstone,polishedBlackstone":{name:"polishedBlackstone",shapeless:true},
"goldIngot,goldIngot":{name:"lightWeightedPressurePlate",shapeless:true},
"ironIngot,ironIngot":{name:"heavyWeightedPressurePlate",shapeless:true},
"bambooPlanks,bambooPlanks":{name:"bambooPressurePlate",shapeless:true},
"cherryPlanks,cherryPlanks":{name:"cherryPressurePlate",shapeless:true},
"strippedOakLog": {name:"oakPlanks", amount:4, shapeless: true},
"strippedAcaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
"strippedBirchLog": {name:"birchPlanks", amount:4, shapeless: true},
"strippedDarkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
"strippedJungleLog": {name:"junglePlanks", amount:4, shapeless: true},
"strippedSpruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
"strippedMangroveLog": {name:"mangrovePlanks", amount:4, shapeless: true},
"strippedCherryLog": {name:"cherryPlanks", amount:4, shapeless: true},
"warpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
"crimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
"strippedWarpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
"strippedCrimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
"warpedPlanks,air,air,warpedPlanks": {name:"stick", amount:4},
"crimsonPlanks,air,air,crimsonPlanks": {name:"stick", amount:4},
"stone":{name:"stoneButton", shapeless: true},
"oakPlanks":{name:"oakButton", shapeless: true},
"birchPlanks":{name:"birchButton", shapeless: true},
"darkOakPlanks":{name:"darkOakButton", shapeless: true},
"acaciaPlanks":{name:"acaciaButton", shapeless: true},
"sprucePlanks":{name:"spruceButton", shapeless: true},
"junglePlanks":{name:"jungleButton", shapeless: true},
"mangrovePlanks":{name:"mangroveButton", shapeless: true},
"warpedPlanks":{name:"warpedButton", shapeless: true},
"crimsonPlanks":{name:"crimsonButton", shapeless: true},
"polishedBlackstone":{name:"polishedBlackstoneButton", shapeless:true},
"bambooPlanks":{name:"bambooButton", shapeless: true},
"cherryPlanks":{name:"cherryButton", shapeless: true},
"ironBlock": {name:"ironIngot",amount:9,shapeless:true},
"goldBlock": {name:"goldIngot",amount:9,shapeless:true},
"coalBlock": {name:"coal",amount:9,shapeless:true},
"emeraldBlock": {name:"emerald",amount:9,shapeless:true},
"diamondBlock": {name:"diamond",amount:9,shapeless:true},
"copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot":{name:"copperBlock"},
"copperBlock": {name:"copperIngot",amount:9,shapeless:true},
"_planks,_planks,air,air,stick,air,air,stick":{name:"woodenHoe"},
"_stone,_stone,air,air,stick,air,air,stick":{name:"stoneHoe"},
"ironIngot,ironIngot,air,air,stick,air,air,stick":{name:"ironHoe"},
"goldIngot,goldIngot,air,air,stick,air,air,stick":{name:"goldenHoe"},
"diamond,diamond,air,air,stick,air,air,stick":{name:"diamondHoe"},
"rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron":{name:"rawIronBlock"},
"rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold":{name:"rawGoldBlock"},
"rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper":{name:"rawCopperBlock"},
"rawIronBlock":{name:"rawIron",amount:9,shapeless:true},
"rawGoldBlock":{name:"rawGold",amount:9,shapeless:true},
"rawCopperBlock":{name:"rawCopper",amount:9,shapeless:true},
"netheriteScrap,netheriteScrap,netheriteScrap,netheriteScrap,goldIngot,goldIngot,goldIngot,goldIngot":{name:"netheriteIngot"},
"netheriteIngot,netheriteIngot,netheriteIngot,air,stick,air,air,stick":{name:"netheritePickaxe"},
"netheriteIngot,air,air,netheriteIngot,air,air,stick":{name:"netheriteSword"},
"netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteShovel"},
"netheriteIngot,netheriteIngot,air,netheriteIngot,stick,air,air,stick":{name:"netheriteAxe"},
"netheriteIngot,netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteHoe"},
"netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot":{name:"netheriteBlock"},
"netheriteBlock":{name:"netheriteIngot",amount:9,shapeless:true},
"wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat":{name:"hayBlock"},
"hayBlock":{name:"wheat",amount:9,shapeless:true},
"ironIngot":{name:"ironNugget",amount:9,shapeless:true},
"goldIngot":{name:"goldNugget",amount:9,shapeless:true},
"ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget":{name:"ironIngot"},
"goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget":{name:"goldIngot"},
"ironNugget,ironNugget,ironNugget,ironNugget,torch,ironNugget,ironNugget,ironNugget,ironNugget":{name:"lantern"},
"stick,air,stick,stick,stick,stick,stick,air,stick":{name:"ladder",amount:3},
"ironNugget,air,air,ironIngot,air,air,ironNugget":{name:"chain"},
"stone,stone,air,stone,stone":{name:"stoneBricks",amount:4},
"stoneBricks,vine":{name:"mossyStoneBricks",shapeless:true},
"cobblestone,vine":{name:"mossyCobble",shapeless:true},
"chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,netheriteIngot,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks":{name:"lodestone"},
"_planks,_planks,_planks,_planks,redstone,_planks,_planks,_planks,_planks":{name:"noteBlock"},
"_planks,_planks,_planks,_planks,diamond,_planks,_planks,_planks,_planks":{name:"jukebox"},
"ironIngot,ironIngot,ironIngot,ironIngot,furnace,ironIngot,smoothStone,smoothStone,smoothStone":{name:"blastFurnace"},
"air,_log,air,_log,furnace,_log,air,_log":{name:"smoker"},
"carvedPumpkin,torch":{name:"jackOLantern",shapeless:true},
"air,ironIngot,air,ironIngot":{name:"shears"},
"melonSlice":{name:"melonSeeds",shapeless:true},
"melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice":{name:"melon"},
"redstone,redstone,redstone,redstone,redstone,redstone,redstone,redstone,redstone":{name:"redstoneBlock"},
"redstoneBlock":{name:"redstone",amount:9,shapeless:true},
"air,redstone,air,redstone,glowstone,redstone,air,redstone":{name:"redstoneLamp"},
"glowstoneDust,glowstoneDust,air,glowstoneDust,glowstoneDust":{name:"glowstone"},
"cobblestone,quartz,air,quartz,cobblestone":{name:"diorite",amount:2,shaped:true},
"diorite,diorite,air,diorite,diorite":{name:"polishedDiorite",amount:4,shaped:true},
"cobblestone,diorite":{name:"andesite",amount:2,shapeless:true},
"andesite,andesite,air,andesite,andesite":{name:"polishedAndesite",amount:4,shaped:true},
"diorite,quartz":{name:"granite",shapeless:true},
"granite,granite,air,granite,granite":{name:"polishedGranite",amount:4,shaped:true},
"amethystShard,air,air,copperIngot,air,air,copperIngot":{name:"spyglass",shaped:true},
"_planks,air,_planks,air,_planks":{name:"bowl",amount:4,shaped:true},
"redMushroom,brownMushroom,bowl":{name:"mushroomStew",shapeless:true},
"egg,noodles,wheatSeeds,bowl":{name:"ramen",shapeless:true},
"wheat,egg,wheat":{name:"noodles",shaped:true},
"endStone,endStone,air,endStone,endStone":{name:"endStoneBricks",amount:4,shaped:true},
"dirt,gravel,air,gravel,dirt":{name:"coarseDirt",amount:4,shaped:true},
"itemFrame,glowInkSac":{name:"glowItemFrame",shapeless:true},
"copperBlock,copperBlock,air,copperBlock,copperBlock":{name:"cutCopper",amount:4,shaped:true},
"air,stick,air,stick,coal,stick,_log,_log,_log":{name:"campfire"},
"air,stick,air,stick,soulSand,stick,_log,_log,_log":{name:"soulCampfire"},
"_planks,_planks,_planks,_planks,air,_planks,_planks,_planks,_planks":{name:"chest"},
"clayBall,clayBall,air,clayBall,clayBall":{name:"clay",shaped:true},
"brick,brick,air,brick,brick":{name:"bricks",shaped:true},
"brick,air,brick,air,brick":{name:"flowerPot",shaped:true},
"air,amethystShard,air,amethystShard,glass,amethystShard,air,amethystShard":{name:"tintedGlass",amount:2},
"redstone,air,air,stick":{name:"redstoneTorch",shaped:true},
"stick,air,air,_stone":{name:"lever",shaped:true},
"_planks,_planks,_planks,_stone,ironIngot,_stone,_stone,redstone,_stone":{name:"piston"},
"_stone,_stone,_stone,redstone,redstone,quartz,_stone,_stone,_stone":{name:"observer"},
"string,string,air,string,string": {name:"whiteWool"},
"poppy": {name:"redDye", shapeless: true},
"redTulip": {name:"redDye", shapeless: true},
"roseBush": {name:"redDye", shapeless: true,amount:2},
"sunflower": {name:"yellowDye", shapeless: true,amount:2},
"dandelion": {name:"yellowDye", shapeless: true},
"boneMeal":{name:"whiteDye",shapeless:true},
"lilyOftheValley":{name:"whiteDye",shapeless:true},
"azureBluet":{name:"lightGrayDye",shapeless:true},
"oxeyeDaisy":{name:"lightGrayDye",shapeless:true},
"whiteTulip":{name:"lightGrayDye",shapeless:true},
"whiteDye,whiteDye,blackDye":{name:"lightGrayDye",amount:3,shapeless:true},
"grayDye,whiteDye":{name:"lightGrayDye",amount:2,shapeless:true},
"blackDye,whiteDye":{name:"grayDye",amount:2,shapeless:true},
"witherRose":{name:"blackDye",shapeless:true},
"inkSac":{name:"blackDye",shapeless:true},
"redDye,yellowDye":{name:"orangeDye",amount:2,shapeless:true},
"orangeTulip":{name:"orangeDye",shapeless:true},
"greenDye,whiteDye":{name:"limeDye",amount:2,shapeless:true},
"blueOrchid":{name:"lightBlueDye",shapeless:true},
"whiteDye,blueDye":{name:"lightBlueDye",amount:2,shapeless:true},
"blueDye,greenDye":{name:"cyanDye",amount:2,shapeless:true},
"lapisLazuli":{name:"blueDye",shapeless:true},
"cornFlower":{name:"blueDye",shapeless:true},
"redDye,blueDye":{name:"purpleDye",amount:2,shapeless:true},
"purpleDye,pinkDye":{name:"magentaDye",amount:2,shapeless:true},
"redDye,blueDye,whiteDye":{name:"magentaDye",amount:3,shapeless:true},
"redDye,blueDye,pinkDye":{name:"magentaDye",amount:3,shapeless:true},
"allium":{name:"magentaDye",shapeless:true},
"lilac":{name:"magentaDye",amount:2,shapeless:true},
"redDye,whiteDye":{name:"pinkDye",amount:2,shapeless:true},
"pinkTulip":{name:"pinkDye",shapeless:true},
"peony":{name:"pinkDye",amount:2,shapeless:true},
"pinkPetals":{name:"pinkDye",shapeless:true},
"wheat,wheat,air,wheat,wheat":{name:"thatch",shaped:true},
"mud,mangroveRoots":{name:"muddyMangroveRoots",shapeless:true},
"mud,wheat":{name:"packedMud",shapeless:true},
"packedMud,packedMud,air,packedMud,packedMud":{name:"mudBricks",shaped:true},
"pointedDripstone,pointedDripstone,air,pointedDripstone,pointedDripstone":{name:"dripstoneBlock",shaped:true},
"oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,air,stick":{name:"oakSign",amount:3},
"birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,air,stick":{name:"birchSign",amount:3},
"acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,air,stick":{name:"acaciaSign",amount:3},
"junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,air,stick":{name:"jungleSign",amount:3},
"sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,air,stick":{name:"spruceSign",amount:3},
"darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,air,stick":{name:"darkOakSign",amount:3},
"mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,air,stick":{name:"mangroveSign",amount:3},
"warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,air,stick":{name:"warpedSign",amount:3},
"crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,air,stick":{name:"crimsonSign",amount:3},
"bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,air,stick":{name:"bambooSign",amount:3},
"cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,air,stick":{name:"cherrySign",amount:3},
"_planksSlabs,air,_planksSlabs,_planksSlabs,air,_planksSlabs,_planksSlabs,_planksSlabs,_planksSlabs":{name:"composter"},
"cocoaBeans":{name:"brownDye",shapeless:true},
"wheat,cocoaBeans,wheat":{name:"cookie",shapeless:true,amount:8},
"pumpkin,sugar,egg":{name:"pumpkinPie",shapeless:true},
"beetroot":{name:"redDye",shapeless:true},
"beetroot,beetroot,beetroot,beetroot,beetroot,beetroot,air,bowl":{name:"beetrootSoup"},
"goldNugget,goldNugget,goldNugget,goldNugget,carrot,goldNugget,goldNugget,goldNugget,goldNugget":{name:"goldenCarrot"},
"cookedRabbit,carrot,bakedPotato,redMushroom,bowl":{name:"rabbitStew",shapeless:true},
"cookedRabbit,carrot,bakedPotato,brownMushroom,bowl":{name:"rabbitStew",shapeless:true},
"goldIngot,goldIngot,goldIngot,goldIngot,apple,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldenApple"},
"dirt,waterBucket":{name:"mud",shapeless:true,replace:{waterBucket:"bucket"}},
"waterBucket,air,air,lavaBucket":{name:"obsidian",shaped:true,replace:{waterBucket:"bucket",lavaBucket:"bucket"}},
"waterBucket,lavaBucket":{name:"cobblestone",shapeless:true,replace:{waterBucket:"bucket",lavaBucket:"bucket"}},
"carrot,dirt,mud":{name:"mudPie",shapeless:true},
"ironBlock,ironBlock,ironBlock,air,ironIngot,air,ironIngot,ironIngot,ironIngot":{name:"anvil"},
"air,stick,string,stick,air,string,air,stick,string":{name:"bow"},
"redstoneLamp,redDye":{name:"redRedstoneLamp",shapeless:true},
"redstoneLamp,yellowDye":{name:"yellowRedstoneLamp",shapeless:true},
"redstoneLamp,greenDye":{name:"greenRedstoneLamp",shapeless:true},
"redstoneLamp,blueDye":{name:"blueRedstoneLamp",shapeless:true},
"goldNugget,goldNugget,goldNugget,goldNugget,melonSlice,goldNugget,goldNugget,goldNugget,goldNugget":{name:"glisteringMelonSlice"},
"lightGrayWool,lightGrayWool,lightGrayWool,_planks,_planks,_planks":{name:"lightGrayBed"},
"lightBlueWool,lightBlueWool,lightBlueWool,_planks,_planks,_planks":{name:"lightBlueBed"},
"magentaWool,magentaWool,magentaWool,_planks,_planks,_planks":{name:"magentaBed"},
"yellowWool,yellowWool,yellowWool,_planks,_planks,_planks":{name:"yellowBed"},
"purpleWool,purpleWool,purpleWool,_planks,_planks,_planks":{name:"purpleBed"},
"orangeWool,orangeWool,orangeWool,_planks,_planks,_planks":{name:"orangeBed"},
"whiteWool,whiteWool,whiteWool,_planks,_planks,_planks":{name:"whiteBed"},
"greenWool,greenWool,greenWool,_planks,_planks,_planks":{name:"greenBed"},
"brownWool,brownWool,brownWool,_planks,_planks,_planks":{name:"brownBed"},
"blackWool,blackWool,blackWool,_planks,_planks,_planks":{name:"blackBed"},
"pinkWool,pinkWool,pinkWool,_planks,_planks,_planks":{name:"pinkBed"},
"limeWool,limeWool,limeWool,_planks,_planks,_planks":{name:"limeBed"},
"grayWool,grayWool,grayWool,_planks,_planks,_planks":{name:"grayBed"},
"cyanWool,cyanWool,cyanWool,_planks,_planks,_planks":{name:"cyanBed"},
"blueWool,blueWool,blueWool,_planks,_planks,_planks":{name:"blueBed"},
"oakPlanks,air,air,oakPlanks,oakPlanks,air,stick,stick":{name:"oakChair",shaped:true},
"acaciaPlanks,air,air,acaciaPlanks,acaciaPlanks,air,stick,stick":{name:"acaciaChair",shaped:true},
"birchPlanks,air,air,birchPlanks,birchPlanks,air,stick,stick":{name:"birchChair",shaped:true},
"junglePlanks,air,air,junglePlanks,junglePlanks,air,stick,stick":{name:"jungleChair",shaped:true},
"sprucePlanks,air,air,sprucePlanks,sprucePlanks,air,stick,stick":{name:"spruceChair",shaped:true},
"darkOakPlanks,air,air,darkOakPlanks,darkOakPlanks,air,stick,stick":{name:"darkOakChair",shaped:true},
"mangrovePlanks,air,air,mangrovePlanks,mangrovePlanks,air,stick,stick":{name:"mangroveChair",shaped:true},
"warpedPlanks,air,air,warpedPlanks,warpedPlanks,air,stick,stick":{name:"warpedChair",shaped:true},
"crimsonPlanks,air,air,crimsonPlanks,crimsonPlanks,air,stick,stick":{name:"crimsonChair",shaped:true},
"blackWool,air,air,blackWool,blackWool,air,stick,stick":{name:"blackChair",shaped:true},
"cherryPlanks,air,air,cherryPlanks,cherryPlanks,air,stick,stick":{name:"cherryChair",shaped:true},
"bambooPlanks,air,air,bambooPlanks,bambooPlanks,air,stick,stick":{name:"bambooChair",shaped:true},
"_stone,_stone,_stone,_stone,air,_stone,_stone,redstone,_stone":{name:"dropper"},
"_stone,_stone,_stone,_stone,bow,_stone,_stone,redstone,_stone":{name:"dispenser"},
"ironIngot,air,ironIngot,ironIngot,chest,ironIngot,air,ironIngot":{name:"hopper"},
"air,redstone,air,redstone,hayBlock,redstone,air,redstone":{name:"target"},
"air,redstoneTorch,air,redstoneTorch,quartz,redstoneTorch,stone,stone,stone":{name:"comparator"},
"redstone,lapisLazuli,redstone":{name:"blueRedstone",amount:2,shaped:true},
"gunpowder,sand,gunpowder,sand,gunpowder,sand,gunpowder,sand,gunpowder":{name:"tnt"},
"gunpowder,redSand,gunpowder,redSand,gunpowder,redSand,gunpowder,redSand,gunpowder":{name:"tnt"},
"flint,air,air,stick,air,air,feather":{name:"arrow",shaped:true,amount:4},
"redstoneTorch,redstone,redstoneTorch,stone,stone,stone":{name:"repeater"},
"bone":{name:"boneMeal",amount:3,shapeless:true},
"glass,glass,glass,quartz,quartz,quartz,_planks,_planks,_planks":{name:"daylightDetector",amount:3},
"blazeRod":{name:"blazePowder",amount:2,shapeless:true},
"ice,ice,ice,ice,ice,ice,ice,ice,ice":{name:"packedIce"},
"packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce":{name:"blueIce"},
"blazePowder,enderPearl":{name:"eyeOfEnder"},
"bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk":{name:"bambooBlock"},
"bambooBlock":{name:"bambooPlanks",amount:2,shapeless:true},
"strippedBambooBlock":{name:"bambooPlanks",amount:2,shapeless:true},
"waterBucket,sand":{name:"quicksand",shapeless:true,replace:{waterBucket:"bucket"}},
"glass,glass,glass,glass,glass,glass":{name:"glassPane",shaped:true,amount:48},
"ironIngot,air,ironIngot,ironIngot,ironIngot,ironIngot":{name:"minecart",shaped:true},
"ironIngot,air,ironIngot,ironIngot,stick,ironIngot,ironIngot,air,ironIngot":{name:"rail",amount:16},
"goldIngot,air,goldIngot,goldIngot,stick,goldIngot,goldIngot,redstone,goldIngot":{name:"poweredRail",amount:16},
"corn,bowl":{name:"popcornBowl",shapeless:true}
}
for (let i = 1; i < BLOCK_COUNT; ++i){
const block = blockData[i]
if(block.craftSlabs){
crafts[block.name+","+block.name+","+block.name] = {name:block.name+"|SLAB",amount:6,shaped:true}
}
if(block.craftStairs){
crafts[block.name+",air,air,"+block.name+","+block.name+",air,"+block.name+","+block.name+","+block.name] = {name:block.name+"|STAIR",amount:4}
}
if(block.name.endsWith("Wool")){
let c = block.name.replace("Wool","")
crafts[block.name+","+block.name] = {name:c+"Carpet",shaped:true,amount:32}
}else if(block.name.endsWith("Dye")){
let c = block.name.replace("Dye","")
crafts["whiteWool,"+block.name] = {name:c+"Wool",shapeless:true}
crafts["terracotta,terracotta,terracotta,terracotta,"+block.name+",terracotta,terracotta,terracotta,terracotta"] = {name:c+"Terracotta", amount:8, shapeless:true}
crafts["glass,glass,glass,glass,"+block.name+",glass,glass,glass,glass"] = {name:c+"StainedGlass", amount:8, shapeless:true}
crafts["glassPane,glassPane,glassPane,glassPane,"+block.name+",glassPane,glassPane,glassPane,glassPane"] = {name:c+"StainedGlassPane", amount:8, shapeless:true}
}else if(block.name.endsWith("StainedGlass")){
crafts[block.name+","+block.name+","+block.name+","+block.name+","+block.name+","+block.name] = {name:block.name+"Pane",shaped:true,amount:48}
}
}
//replace anything in crafts starting with _
const craftTypes = {
_planks: ["oakPlanks","birchPlanks","sprucePlanks","junglePlanks","darkOakPlanks","acaciaPlanks","mangrovePlanks","crimsonPlanks","warpedPlanks","cherryPlanks","bambooPlanks","bambooMosaic"],
_planksSlabs: ["oakPlanks|SLAB","birchPlanks|SLAB","sprucePlanks|SLAB","junglePlanks|SLAB","darkOakPlanks|SLAB","acaciaPlanks|SLAB","mangrovePlanks|SLAB","crimsonPlanks|SLAB","warpedPlanks|SLAB","cherryPlanks|SLAB","bambooPlanks|SLAB","bambooMosaic|SLAB"],
_stone: ["stone","cobblestone","deepslate","cobbledDeepslate","blackstone","limestone"],
_log: ["oakLog","birchLog","spruceLog","jungleLog","darkOakLog","acaciaLog","mangroveLog","crimsonStem","warpedStem","cherryLog","bambooBlock"],
_strippedLog: ["strippedOakLog","strippedBirchLog","strippedSpruceLog","strippedJungleLog","strippedDarkOakLog","strippedAcaciaLog","strippedMangroveLog","strippedCrimsonStem","strippedWarpedStem","strippedCherryLog","strippedBambooBlock"],
}
let smelts = {
rawIron: {name:"ironIngot", time:200, xp:0.7},
rawCopper: {name:"copperIngot", time:200, xp:0.7},
rawGold: {name:"goldIngot", time:200, xp:1},
sand: {name:"glass",time:200,xp:0.1, furnace:true},//furnace propertie means it can only be smelted in furnace
cobblestone: {name:"stone",time:200,xp:0.1, furnace:true},
stone: {name:"smoothStone", time:200, xp:0.1, furnace:true},
stoneBricks: {name:"crackedStoneBricks",time:200,xp:0.1, furnace:true},
clay: {name:"terracotta",time:200,xp:0.35},
clayBall: {name:"brick",time:200,xp:0.3},
ancientDebris: {name:"netheriteScrap", time:200, xp:1},
cactus: {name:"greenDye", time:200, xp:0.1},
rawChicken: {name:"cookedChicken",time:200,xp:0.35},
rawBeef: {name:"cookedBeef",time:200,xp:0.35},
rawCod: {name:"cookedCod",time:200,xp:0.35},
rawMutton: {name:"cookedMutton",time:200,xp:0.35},
rawPorkchop: {name:"cookedPorkchop",time:200,xp:0.35},
rawRabbit: {name:"cookedRabbit",time:200,xp:0.35},
rawSalmon: {name:"cookedSalmon",time:200,xp:0.35},
potato: {name:"cookedPotato",time:200,xp:0.35},
_log: {name:"charcoal",time:200,xp:0.15},
_strippedLog: {name:"charcoal",time:200,xp:0.15}
}
let smeltFuel = { //time is in seconds
_log: {time:15},
_planks: {time:15},
coal: {time:80},
stick: {time:5},
coalBlock: {time:690},
lavaBucket: {time:1000},
blazeRod: {time:120},
charcoal: {time:80},
bambooStalk: {time:2.5}
}
let craftArrays = {}
function checkCraftType(a,b){
return craftTypes[a] && craftTypes[a].includes(b) || a === b
}
function getCraft(craft){
main:for(var i in crafts){
if(crafts[i].shapeless) continue
var arr = craftArrays[i]
for(var j=0; j<arr.length; j++){
if(!checkCraftType(arr[j], craft[j])) continue main
}
return i
}
}
function shapelessCraft(craft) {
/*let arr2 = craft;
arr2.sort(function(a, b) {
return a - b;
});
let arr = [];
for(let i in crafts) {
if(!crafts[i].shapeless) continue;
arr = i.split(",");
arr.sort(function(a, b) {
return a - b;
});
let comp = arr.map(num => Number(num));
if(arrayValues(comp,arr2)) {
return i;
}
}*/
main:for(var i in crafts){
if(!crafts[i].shapeless) continue
var arr = craft.slice()
var arr2 = craftArrays[i]
remover:for(var j of arr2){ //remove the ones that exist for this recipe
for(var k=0; k<arr.length; k++){
if(checkCraftType(j,arr[k])){
arr.splice(k,1)
continue remover
}
}
continue main //recipe doesn't have this item
}
if(!arr.length) return i
}
}
function getBlockId(name){
if(typeof name === "number" || name.startsWith("_")) return name
let first = name.indexOf("|")
let id = blockIds[first === -1 ? name : name.substring(0, first)]
if(id===undefined)debugger
if(name.endsWith("|SLAB")) id |= SLAB
if(name.endsWith("|STAIR")) id |= STAIR
return id
}
const achievementTypes = [
//dont change order, because it may cause problems with loading
{
name:"Taking Inventory",
score: 10,
description:"Open your inventory"
},
{
name:"Getting Wood",
score:10,
description:"Punch a tree until a block of wood pops out."
},
{
name:"Benchmaking",
score:10,
description:"Craft a Crafting Table with four blocks of wooden planks."
},
{
name:"Time to Mine!",
score:10,
description:"Use planks and sticks to make a pickaxe."
},
{
name:"Getting an Upgrade",
score:15,
description:"Construct a better pickaxe."
},
{
name:"Bake Bread",
score:15,
description:"Turn wheat into bread."
},
{
name:"Time to Strike!",
score:10,
description:"Use planks and sticks to make a sword."
},
{
name:"DIAMONDS!",
score:20,
description:"Acquire diamonds with your iron tools."
},
{
name:"Diamonds to you!", //how is this possible to code???
score:15,
description:"Throw diamonds at another player."
},
{
name:"Time to Farm!",
score:10,
description:"Make a Hoe."
},
{
name:"Time to plant tomatoes!",
score:10,
description:"Get tomato seeds from Tall Grass."
},
{
name:"Into the Nether",
score:20,
description:"Go into the Nether."
},
{
name:"Hidden In The Depths",
score:20,
description:"Get Ancient Debris"
},
{
name:"Into the End",
score:20,
description:"Go into the End."
},
{
name:"get a hot stick",
score:20,
description:"get a blaze rod"
},
{
name:"Make a bed",
score:10,
description:"Make a bed"
}
]
const achievmentIds = {}
for(let i=0; i<achievementTypes.length; i++){
achievmentIds[achievementTypes[i].name] = i
achievementTypes[i].id = i
}
win.achievmentIds = achievmentIds, win.achievementTypes = achievementTypes
//add something to inventory
function newInvItem(p, id, durability, name){
//look for empty slot
let {inventory} = p
for(let i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i] && inventory.hotbar[i].id === id && (!inventory.hotbar[i].customName && !name || inventory.hotbar[i].customName === name) && inventory.hotbar[i].amount < blockData[inventory.hotbar[i].id].stackSize){
inventory.hotbar[i].amount ++
return true
}
}
for(let i=0; i<inventory.main.length; i++){
if(inventory.main[i] && inventory.main[i].id === id && (!inventory.main[i].customName && !name || inventory.main[i].customName === name) && inventory.main[i].amount < blockData[inventory.main[i].id].stackSize){
inventory.main[i].amount ++;
return true
}
}
for(let i=0; i<inventory.hotbar.length; i++){
if(!inventory.hotbar[i]){
inventory.hotbar[i] = {id:id, amount:1, durability:durability, customName:name}
if(i === inventory.hotbarSlot){
inventory.showName = 1.5
}
return true
}
}
for(let i=0; i<inventory.main.length; i++){
if(!inventory.main[i]){
inventory.main[i] = {id:id, durability:durability, customName:name, amount:1}
return true
}
}
return false
}
function minusOneItem(p,id){
let {inventory} = p
for(let i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i] && inventory.hotbar[i].id === id){
if(p.survival){
inventory.hotbar[i].amount--
if(!inventory.hotbar[i].amount) inventory.hotbar[i] = null
}
return true
}
}
for(let i=0; i<inventory.main.length; i++){
if(inventory.main[i] && inventory.main[i].id === id){
if(p.survival){
inventory.main[i].amount--
if(!inventory.main[i].amount) inventory.main[i] = null
}
return true
}
}
return false
}
function hasItem(p,id){
let {inventory} = p
for(let i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i] && inventory.hotbar[i].id === id){
return true
}
}
for(let i=0; i<inventory.main.length; i++){
if(inventory.main[i] && inventory.main[i].id === id){
return true
}
}
return false
}
/*Format for jigsaw
{
data:array, Contains the blocks in the pallete of the jigsaw
pallete:object, Each letter represents a block name
center:string, The place to connect to the previous jigsaw, must be a letter from data
newJigsaws:object, Jigsaws to generate connected to current jigsaw, the key is a letter from data, the value is the name of a jigsaw pool
newJigsawTries:number, optional, Amount of tries to generate a new jigsaw connected to current jigsaw
onGround:boolean, optional,
flatOnGround:boolean, optional
}
*/
let jigsaws = {
endPortal:{
data:[
`sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss`,
`sssssssss
s       s
s sssss s
s sllls s
s sllls s
s sllls s
s sssss s
s  sss  s
s  sss  s
s  ttt  s
s       s
sss   sss
sls   sls
ssss!ssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s  sss  s
s  ttt  s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s  ---  s
s (   ) s
s (   ) s
s (   ) s
s  ___  s
s  ttt  s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss`,
],
pallete:{
s:"stoneBricks",
"!":"stoneBricks",
"_":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|e:blockIds.endPortalFrame|e,
"-":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|w:blockIds.endPortalFrame|w,
"(":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|s:blockIds.endPortalFrame|s,
")":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|n:blockIds.endPortalFrame|n,
l:"Lava"," ":"air",
t:(n,e,s,w)=>blockIds.stoneBricks|STAIR|w,
},
center:"!",
}
}
let jigsawPools = {
endPortal:["endPortal"]
}
/*Format for structures
{
type:string, can be simple or compound
start:array, Jigsaw pool to choose starting jigsaw, randomly chosen
chance:number, How common is it every structureSpacing blocks
getY:function, Return y level of starting jigsaw, not needed if all jigsaws are on ground
maxSize:number, Maximum distance for jigsaws to be from starting jigsaw, Also for determining how far to look for structures
If type is compound:
jigsawCount:number, Target amount of jigsaws to generate in structure, actual amount of jigsaws may be lower
maxTries:number, Maximum tries to generate a jigsaw, will stop generating if amount of jigsaw reaches jigsawCount
}
*/
let structures = [
{
type:"simple",
start:"endPortal",
chance:0.5,
maxSize:16,
getY:(x,z,rnd)=>{
return 10+Math.round(rnd%16)
}
}
]
/*Structure notes
Jigsaws can only have a new jigsaw on the sides, not on top, bottom, or inside.
If a block is undefined in pallete, that block will be ignored.
If a jigsaw is onGround, it can not be more than 16 blocks from center to prevent chunk errors
*/
let structureCheckDist = 0
const structureSpacing = 64
for(let s of structures){
structureCheckDist = Math.max(structureCheckDist,s.maxSize)
s.start = jigsawPools[s.start]
}
structureCheckDist = Math.ceil(structureCheckDist/16)*16
for(let jn in jigsaws){
let s = jigsaws[jn]
let ss = Object.create(s)
let se = Object.create(s)
let sw = Object.create(s)
ss.data = [], se.data = [], sw.data = []
if(s.type === "compound"){
s.nextJigsawPos = [], ss.nextJigsawPos = [], se.nextJigsawPos = [], sw.nextJigsawPos = []
s.newJigsaws = s.newJigsaws || {}
}
let data = []
let w=0, h=s.data.length, d=0
for(let i=0;i<s.data.length;i++){
let rows = s.data[i].split("\n")
w = Math.max(w,rows.length)
for(let j=0;j<rows.length;j++){
let row = rows[j]
d = Math.max(d,row.length)
}
}
for(let i=0;i<s.data.length;i++){
let rows = s.data[i].split("\n")
for(let j=0;j<rows.length;j++){
let row = rows[j]
for(let k=0;k<row.length;k++){
if(s.pallete[row[k]]){
data.push(j,i,k,s.pallete[row[k]])
ss.data.push(w-1-j,i,d-1-k,s.pallete[row[k]])
se.data.push(k,i,j,s.pallete[row[k]])
sw.data.push(d-1-k,i,w-1-j,s.pallete[row[k]])
}
if(row[k] === s.center){
s.centerPos = [j,i,k]
ss.centerPos = [w-1-j,i,d-1-k]
se.centerPos = [k,i,j]
sw.centerPos = [d-1-k,i,w-1-j]
}
if(s.type === "compound" && s.newJigsaws[row[k]]){
let newJigsaws = s.newJigsaws[row[k]]
/*if(!Array.isArray(newJigsaws)){
tempJigsawArr[0] = newJigsaws
newJigsaws = tempJigsawArr
}*/
for(let nj of jigsawPools[newJigsaws]){
s.nextJigsawPos.push([j,i,k,nj])
ss.nextJigsawPos.push([w-1-j,i,d-1-k,nj])
se.nextJigsawPos.push([k,i,j,nj])
sw.nextJigsawPos.push([d-1-k,i,w-1-j,nj])
}
}
}
}
}
s.data = data
s.w = w, s.h = h, s.d = d
ss.w = w, ss.h = h, ss.d = d
se.w = d, se.h = h, se.d = w
sw.w = d, sw.h = h, sw.d = w
s.variants = [s,sw,ss,se]
if(s.type === "compound") s.newJigsawTries = s.nextJigsawPos.length ? (s.newJigsawTries === undefined ? 1 : s.newJigsawTries) : 0
}
function objectify(x, y, z, width, height, textureX, textureY, texXFlip,texYFlip,rotateTex,texW,texH,textureName) {
return {
x: x,
y: y,
z: z,
w: width,
h: height,
tx: textureX,
ty: textureY,
txf: texXFlip,
tyf: texYFlip,
rt:rotateTex,
tw:texW || width,
th:texH || height,
t:textureName
}
}
function customFace(x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th, t){
tw = tw || 16
th = th || 16
return {
x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th,
t,
custom:true
}
}
function generateItemShape(){
var arr = []
var bottom = [],
top = [],
east = [],
west = []
var i
for(i=0; i<16; i++){
bottom.push(objectify(0,i,7.5,16,1,0,(16-i)-1))
top.push(objectify(0,i+1,8.5,16,1,0,16-i-1))
east.push(objectify(i+1,16,7.5,1,16,(16-i)-1,0))
west.push(objectify(i,16,8.5,1,16,(16-i)-1,0))
}
return [bottom,top,
[objectify(16, 16, 8.5, 16, 16, 0, 0, true)],[objectify( 0, 16,  7.5, 16, 16, 0, 0)],
east,west]
}
function layerShape(h){
return [
[objectify(0,0,0,16,16,0,0)],
[objectify(0,h,16,16,16,0,0)],
[objectify(16, h, 16, 16, h, 0, 16-h)],
[objectify( 0, h,  0, 16, h, 0, 16-h)],
[objectify(16, h,  0, 16, h, 0, 16-h)],
[objectify( 0, h, 16, 16, h, 0, 16-h)]
]
}
function liquidLayerShape(h){
return [
[objectify(0,0,0,16,16,0,0),objectify(16,0,0,-16,16,16,0, false,false,false,null,null, "in")],
[objectify(0,h,16,16,16,0,0),objectify(16,h,16,-16,16,16,0, false,false,false,null,null, "in")],
[objectify(16, h, 16, 16, h, 0, 16-h),objectify( 0, h, 16, -16, h, 16, 16-h, false,false,false,null,null, "in")],
[objectify( 0, h,  0, 16, h, 0, 16-h),objectify(16, h,  0, -16, h, 16, 16-h, false,false,false,null,null, "in")],
[objectify(16, h,  0, 16, h, 0, 16-h),objectify(16, h, 16, -16, h, 16, 16-h, false,false,false,null,null, "in")],
[objectify( 0, h, 16, 16, h, 0, 16-h),objectify( 0, h,  0, -16, h, 16, 16-h, false,false,false,null,null, "in")]
]
}
function generateRepeater(delay = 1, on = false){
on = on ? 16 : 0
let torch = on ? "redstoneTorch" : "redstoneTorchOff"
let arr = [
[objectify(0,0,0,16,16,0,0,false,false,null,null,null,"smoothStone")],
[objectify(0,2,16,16,16,on,0),objectify(7,7,14,2,2,7,6,false,false,null,null,null,torch),objectify(7,7,12 - delay*2,2,2,7,6,false,false,null,null,null,torch)], //top
[objectify(16,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,7,14,2,5,7,6,false,false,null,null,null,torch),objectify(9,7,12 - delay*2,2,5,7,6,false,false,null,null,null,torch)], //north
[objectify(0,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,7,12,2,5,7,6,false,false,null,null,null,torch),objectify(7,7,10 - delay*2,2,5,7,6,false,false,null,null,null,torch)],  //south
[objectify(16,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,7,12,2,5,7,6,false,false,null,null,null,torch),objectify(9,7,10 - delay*2,2,5,7,6,false,false,null,null,null,torch)], //east
[objectify(0,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,7,14,2,5,7,6,false,false,null,null,null,torch),objectify(7,7,12 - delay*2,2,5,7,6,false,false,null,null,null,torch)] //west
]
if(on){
arr[0].push(objectify(6,7,9 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(6,5,13 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(10,8,10 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(6,8,12 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(7,8,9 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(9,8,13 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[0].push(objectify(6,7,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(6,5,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(10,8,12,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(6,8,14,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(7,8,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(9,8,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
}
return arr
}
function generateComparator(subtractMode,on){
on = on ? 16 : 0
let subtractModeUp = subtractMode ? 1 : 0
let torchSubtract = subtractMode ? "redstoneTorch" : "redstoneTorchOff"
let torch = on ? "redstoneTorch" : "redstoneTorchOff"
let arr = [
[objectify(0,0,0,16,16,0,0,false,false,null,null,null,"smoothStone")],
[objectify(0,2,16,16,16,on,0),objectify(7,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,5,2,2,7,6,false,false,null,null,null,torch),objectify(10,7,5,2,2,7,6,false,false,null,null,null,torch)],
[objectify(16,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(6,7,5,2,5,7,6,false,false,null,null,null,torch),objectify(12,7,5,2,5,7,6,false,false,null,null,null,torch)],
[objectify(0,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,4+subtractModeUp,12,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,3,2,5,7,6,false,false,null,null,null,torch),objectify(10,7,3,2,5,7,6,false,false,null,null,null,torch)],
[objectify(16,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,4+subtractModeUp,12,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(6,7,3,2,5,7,6,false,false,null,null,null,torch),objectify(12,7,3,2,5,7,6,false,false,null,null,null,torch)],
[objectify(0,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,5,2,5,7,6,false,false,null,null,null,torch),objectify(10,7,5,2,5,7,6,false,false,null,null,null,torch)]
]
if(subtractMode){
arr[0].push(objectify(6,5,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(6,3,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(10,6,12,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(6,6,14,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(7,6,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(9,6,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
}
if(on){
arr[0].push(objectify(3,7,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(3,5,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(7,8,3,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(3,8,5,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(4,8,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(6,8,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[0].push(objectify(9,7,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(9,5,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(13,8,3,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(9,8,5,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(10,8,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(12,8,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
}
return arr
}
function generateRectangleShape(w,h,name){
const offsetX = -w*8
let arr = []
for(let x=0; x<w; x++) for(let y=0; y<h; y++){
if(!textures[name]) continue
let t = name+(x+y*w)
let tex = textureCoords[textureMap[t]]
arr.push(objectify(x*16+offsetX,y*16,8,16,16,0,0,false,false,false,null,null,t))
}
return[[],[],arr,[],[],[]]
}
function generateSpike(verts,x,y,z,tilt,h,t){
verts[2].push(customFace(2+x,y+h,2+tilt+z, 10+x,y+h,2+tilt+z, 10+x,y,4+z, 2+x,y,4+z, 8,0,8,16,t))
verts[3].push(customFace(14+x,y+h,2+tilt+z, 6+x,y+h,2+tilt+z, 6+x,y,0+z, 14+x,y,0+z, 8,0,8,16,t))
verts[4].push(customFace(8+x,y+h,-4+tilt+z, 8+x,y+h,4+tilt+z, 6+x,y,4+z, 6+x,y,-4+z, 8,0,8,16,t))
verts[5].push(customFace(8+x,y+h,6+tilt+z, 8+x,y+h,tilt+z, 10+x,y,0+z, 10+x,y,8+z, 8,0,8,16,t))
}
function addStem1x1(verts,x,z,h){
verts[2].push(customFace(x,h,z, x+1,h,z+1, x+1,0,z+1, x,0,z, 0,4,1,h))
verts[3].push(customFace(x+1,h,z, x,h,z+1, x,0,z+1, x+1,0,z, 0,4,1,h))
verts[4].push(customFace(x+1,h,z+1, x,h,z, x,0,z, x+1,0,z+1, 0,4,1,h))
verts[5].push(customFace(x,h,z+1, x+1,h,z, x+1,0,z, x,0,z+1, 0,4,1,h))
return verts
}
let shapes = {
/*
[
[(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
[(-x, +z), (+x, +z), (+x, -z), (-x, -z)], // minX = 9,  minZ = 10, maxX = 3, maxZ = 4
[(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
[(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
[(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
[(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
]
*/
cube: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
],
},
rotate: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
],
rotate: true
},
flipped:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0, false,true)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0, false,true)], //south
[objectify(16, 16,  0, 16, 16, 0, 0, false,true)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0, false,true)]  //west
]
},
SW:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0, false,false, 2)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0, false,false, 1)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0, false,false, -1)]  //west
],
rotate:true
},
_1PixLower:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 15, 16, 16, 16, 0, 0)], //top
[objectify(16, 15, 16, 16, 15, 0, 1)], //north
[objectify( 0, 15,  0, 16, 15, 0, 1)], //south
[objectify(16, 15,  0, 16, 15, 0, 1)], //east
[objectify( 0, 15, 16, 16, 15, 0, 1)]  //west
],
},
none: {
verts: [[],[],[],[],[],[]],
hitbox:"cube"
},
slab: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
[objectify(16, 8, 16, 16, 8, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0)], //south
[objectify(16, 8,  0, 16, 8, 0, 0)], //east
[objectify( 0, 8, 16, 16, 8, 0, 0)]  //west
],
flip: true
},
verticalSlab:{
verts:[
[objectify(0,0,8,16,8,0,0)],
[objectify(0,16,16,16,8,0,0)],
[objectify(16,16,16,16,16,0,0)],
[objectify(0,16,8,16,16,0,0)],
[objectify(16,16,8,8,16,0,0)],
[objectify(0,16,16,8,16,0,0)]
],
rotate: true
},
stair: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8,  8, 16, 8, 0, 8), objectify( 0, 16,  16, 16, 8, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 16, 8, 0, 0)], //south
[objectify(16, 8, 0, 8, 8, 8, 0), objectify(16, 16, 8, 8, 16, 0, 0)], //east
[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
],
flip: true,
rotate: true
},
stairCornerOut: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8,  16, 16, 16, 0, 0), objectify( 0, 16,  16, 8, 8, 0, 0)], //top
[objectify(8, 16, 16, 8, 8, 0, 0), objectify(16, 8, 16, 16, 8, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 8, 8, 0, 0)], //south
[objectify(16, 8, 0, 16, 8, 0, 0), objectify(8, 8, 8, 8, 16, 0, 0)], //east
[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
],
flip: true,
rotate: true
},
stairCornerIn: {
verts: [
[objectify(0,0,0,16,16,0,0)],
[objectify(8,8,8,8,8,0,0),objectify(0,16,16,16,8,0,0),objectify(0,16,8,8,8,0,0)],
[objectify(16,16,16,16,16,0,0)],
[objectify(8,16,8,8,8,0,0),objectify(0,16,0,8,8,0,0),objectify(0,8,0,16,8,0,0)],
[objectify(8,16,0,8,8,0,0),objectify(16,16,8,8,8,0,0),objectify(16,8,0,16,8,0,0)],
[objectify(0,16,16,16,16,0,0)]
],
flip: true,
rotate: true
},
cross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,0)]  //west
],
hitbox: "cube"
},
sideCross: {
verts: [
[], //bottom
[], //top
[customFace(2,2,16, 14,14,16, 14,14,0, 2,2,0, 0,16,16,-16)], //north
[customFace(14,2,16, 2,14,16, 2,14,0, 14,2,0, 0,16,16,-16)], //south
[customFace(14,14,16, 2,2,16, 2,2,0, 14,14,0, 0,16,16,-16)], //east
[customFace(2,14,16, 14,2,16, 14,2,0, 2,14,0, 0,16,16,-16)]  //west
],
rotate: true,
hitbox: "cube"
},
bottomCross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,16,16,-16)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,16,16,-16)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,16,16,-16)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,16,16,-16)]  //west
],
size: 6,
hitbox: "cube"
},
tallCross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
],
hitbox:"tallCube"
},
door: {
verts: [
[objectify( 0,  0,  0, 16, 3, 16, 0, false,false,false,null,2)], //bottom
[objectify( 0, 16, 3, 16, 3, 16, 0),objectify( 0, 32, 3, 16, 3, 0, 0, false,false,false,null,2)], //top
[objectify(16, 16, 3, 16, 16, 16, 0),objectify(16, 32, 3, 16, 16, 0, 0)], //north
[objectify(0, 32, 0, 16, 16, 0, 0, true),objectify(0, 16, 0, 16, 16, 16, 0, true)], //south
[objectify(16, 16,  0, 3, 16, 16, 0, false,false,false,2),objectify(16, 32,  0, 3, 16, 0, 0, false,false,false,2)], //east
[objectify( 0, 16, 3, 3, 16, 16, 0, false,false,false,2),objectify( 0, 32, 3, 3, 16, 0, 0, false,false,false,2)]  //west
],
rotate: true
},
torchHitbox:{
verts:[
[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
[objectify(9, 10, 9, 2, 10, 7, 6)], //north
[objectify( 7, 10,  7, 2, 10, 7, 6)], //south
[objectify(9, 10,  7, 2, 10, 7, 6)], //east
[objectify( 7, 10, 9, 2, 10, 7, 6)]  //west
],
},
torch: {
verts: [
[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
[objectify(16, 16, 9, 16, 16, 0, 0)], //north
[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
[objectify(9, 16,  0, 16, 16, 0, 0)], //east
[objectify( 7, 16, 16, 16, 16, 0, 0)]  //west
],
hitbox:"torchHitbox"
},
wallTorch: {
verts: [
[customFace(9,4,17, 7,4,17, 7,3,15, 9,3,15, 7,14,2,2)],
[customFace(9,13,11, 7,13,11, 7,14,13, 9,14,13, 7,6,2,2)],
[customFace(16,20,10.6, 0,20,10.6, 0,4,17, 16,4,17, 0,0,16,16)], //north
[customFace(0,19,8.6, 16,19,8.6, 16,3,15, 0,3,15, 0,0,16,16)], //south
[customFace(9,15.5,1.6, 9,23.5,17.6, 9,7.5,24, 9,-0.5,8, 0,0,16,16)], //east
[customFace(7,23.5,17.6, 7,15.5,1.6, 7,-0.5,8, 7,7.5,24, 0,0,16,16)]  //west
],
rotate: true
},
lantern: {
verts: [
[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10)], //north
[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10)], //south
[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2)], //east
[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2)]  //west
],
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
lanternHang: {
verts: [
[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10),objectify(9.5, 16, 8, 3, 3, 11, 2)], //north
[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10),objectify(6.5, 16, 8, 3, 3, 11, 2)], //south
[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2),objectify(8, 14, 6.5, 3, 4, 11, 1)], //east
[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2),objectify(8, 14, 9.5, 3, 4, 11, 1)]  //west
],
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
beacon: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify( 2, 0.001, 2, 12, 12, 0, 0,null,null,null,null,null,"obsidian")], //bottom
[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify( 2, 3, 14, 12, 12, 0, 3,null,null,null,null,null,"obsidian")], //top
[objectify(13, 13, 13, 10, 10, 3, 3),objectify( 16, 16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(14, 3, 14, 12, 3,  0, 3,null,null,null,null,null,"obsidian")], //north
[objectify( 3, 13,  3, 10, 10, 3, 3),objectify( 0,  16,  0,  16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(2,  3, 2,  12, 3,  0, 3,null,null,null,null,null,"obsidian")], //south
[objectify(13, 13,  3, 10, 10, 3, 3),objectify( 16, 16,  0,  16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(14, 3, 2,  12, 3,  0, 3,null,null,null,null,null,"obsidian")], //east
[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(2,  3, 14, 12, 3,  0, 3,null,null,null,null,null,"obsidian")]  //west
],
size: 6,
},
cactus: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 15, 16, 16, 0, 0)], //north
[objectify( 0, 16,  1, 16, 16, 0, 0)], //south
[objectify(15, 16,  0, 16, 16, 0, 0)], //east
[objectify( 1, 16, 16, 16, 16, 0, 0)]  //west
],
hitbox: "cube"
},
pane: {
verts: [
[objectify( 0,  0,  7, 16, 2, 0, 7)], //bottom
[objectify( 0, 16, 9, 16, 2, 0, 7)], //top
[objectify(16, 16, 9, 16, 16, 0, 0)], //north
[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
[objectify(16, 16, 7, 2, 16, 7, 0)], //east
[objectify(0, 16, 9, 2, 16, 7, 0)]  //west
],
rotate: true
},
horizontalPane: {
verts:[
[objectify(0,7,0,16,16,0,0)],
[objectify(0,9,16,16,16,0,0)],
[objectify(16,9,16,16,2,0,7)],
[objectify(0,9,0,16,2,0,7)],
[objectify(16,9,0,16,2,0,7)],
[objectify(0,9,16,16,2,0,7)]
],
},
portal: {
verts: [
[objectify(0, 0, 7, 16, 2, 0, 0)],
[objectify(0, 16, 9, 16, 2, 0, 0)],
[objectify(16, 16, 9, 16, 16, 0, 0)],
[objectify(0, 16, 7, 16, 16, 0, 0)],
[objectify(16, 16, 7, 2, 16, 0, 0)],
[objectify(0, 16, 9, 2, 16, 0, 0)]
],
rotate: true
},
trapdoor: {
verts: [
[objectify(0, 0, 0, 16, 16, 0, 0)], //bottom
[objectify(0, 3, 16, 16, 16, 0, 0)], //top
[objectify(16, 3, 16, 16, 3, 0, 0)], //north
[objectify(0, 3, 0, 16, 3, 0, 0)], //south
[objectify(16, 3, 0, 16, 3, 0, 0)], //east
[objectify(0, 3, 16, 16, 3, 0, 0)]  //west
],
rotate: true,
flip: true
},
trapdoorOpen: {
verts: [
[objectify(0, 0, 13, 16, 3, 0, 0)], //bottom
[objectify(0, 16, 16, 16, 3, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify(0, 16, 13, 16, 16, 0, 0)], //south
[objectify(16, 16, 13, 3, 16, 0, 0)], //east
[objectify(0, 16, 16, 3, 16, 0, 0)]  //west
],
size: 6,
rotate: true
},
wallFlat: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
[objectify(0, 16, 16, 0, 0, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify(0, 16,  15, 16, 16, 0, 0)], //south
[objectify(0, 0,  0, 0, 0, 0, 0)], //east
[objectify(0, 0, 16, 0, 0, 0, 0)]  //west
],
rotate: true
},
fence: {
verts: [
[objectify(6, 0, 6, 4, 4, 0, 1)], //bottom
[objectify(6, 16, 10, 4, 4, 0, 1)], //top
[objectify(10, 16, 10, 4, 16, 6, 0)], //north
[objectify(6, 16, 6, 4, 16, 6, 0)], //south
[objectify(10, 16, 6, 4, 16, 6, 0)], //east
[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
],
size: 6,
},
wallpost: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4)], //top
[objectify(12, 16, 12, 8, 16, 4, 0)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0)], //east
[objectify(4, 16, 12, 8, 16, 4, 0)]  //west
],
size: 6
},
wall: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 16, 16, 6, 4, 5, 10)], //top
[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 16, 16, 6, 16, 5, 0)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 16, 12, 4, 16, 12, 0)], //east
[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 16, 16, 4, 16, 12, 0)]  //west
],
rotate: true
},
wallu: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 13, 16, 6, 4, 5, 10)], //top
[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 13, 16, 6, 13, 5, 3)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 13, 12, 4, 13, 12, 3)], //east
[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 13, 16, 4, 13, 12, 3)]  //west
],
rotate: true
},
fencq: {
verts: [
[objectify(6, 0, 6, 4, 4, 0, 1),objectify(10, 12, 7, 6, 2, 0, 2),objectify(10, 6, 7, 6, 2, 0, 2)], //bottom
[objectify(6, 16, 10, 4, 4, 0, 1),objectify(10, 15, 9, 6, 2, 0, 2),objectify(10, 9, 9, 6, 2, 0, 2)], //top
[objectify(10, 16, 10, 4, 16, 6, 0),objectify(16, 15, 9, 6, 3, 6, 0),objectify(16, 9, 9, 6, 3, 6, 0)], //north
[objectify(6, 16, 6, 4, 16, 6, 0),objectify(10, 15, 7, 6, 3, 6, 0),objectify(10, 9, 7, 6, 3, 6, 0)], //south
[objectify(10, 16, 6, 4, 16, 6, 0)], //east
[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
],
rotate: true
},
fench: {
verts:[
[objectify(6,0,6,4,4,0,1),objectify(10,12,7,6,2,0,2),objectify(10,6,7,6,2,0,2),objectify(0,12,7,6,2,0,0),objectify(0,6,7,6,2,0,0)],
[objectify(6,16,10,4,4,0,1),objectify(10,15,9,6,2,0,2),objectify(10,9,9,6,2,0,2),objectify(0,15,9,6,2,0,0),objectify(0,9,9,6,2,0,0)],
[objectify(10,16,10,4,16,6,0),objectify(16,15,9,6,3,6,0),objectify(16,9,9,6,3,6,0),objectify(6,15,9,6,3,0,0),objectify(6,9,9,6,3,0,0)],
[objectify(6,16,6,4,16,6,0),objectify(10,15,7,6,3,6,0),objectify(10,9,7,6,3,6,0),objectify(0,15,7,6,3,0,0),objectify(0,9,7,6,3,0,0)],
[objectify(10,16,6,4,16,6,0)],
[objectify(6,16,10,4,16,6,0)]
],
rotate: true
},
button: {
verts: [
[objectify(5, 6, 14, 6, 2, 5, 6)], //bottom
[objectify(5, 10, 16, 6, 2, 5, 6)], //top
[objectify(11, 10, 16, 6, 4, 5, 6)], //north
[objectify(5, 10, 14, 6, 4, 5, 6)], //south
[objectify(11, 10, 14, 2, 4, 5, 6)], //east
[objectify(5, 10, 16, 2, 4, 5, 6)]  //west
],
rotate: true
},
chain: {
verts: [
[objectify(8, 0, 8, 0.5, 0.5, 0, 0)], //bottom
[objectify(8, 16, 8, 0.5, 0.5, 0, 0)], //top
[objectify(9.5, 16, 8, 3, 16, 3, 0)], //north
[objectify(6.5, 16, 8, 3, 16, 3, 0)], //south
[objectify(8, 16, 6.5, 3, 16, 0, 0)], //east
[objectify(8, 16, 9.5, 3, 16, 0, 0)] //west
],
size: 6,
},
pot: {
verts: [
[objectify(5, 0, 5, 6, 6, 5, 10)], //bottom
[objectify(5, 6, 11, 6, 6, 5, 5), objectify(6, 4, 10, 4, 4, -16, 0)], //top
[objectify(11, 6, 11, 6, 6, 5, 10), objectify(11, 6, 6, 6, 6, 5, 10)], //north
[objectify(5, 6, 5, 6, 6, 5, 10), objectify(5, 6, 10, 6, 6, 5, 10)], //south
[objectify(11, 6, 5, 6, 6, 5, 10), objectify(6, 6, 5, 6, 6, 5, 10)], //east
[objectify(5, 6, 11, 6, 6, 5, 10), objectify(10, 6, 11, 6, 6, 5, 10)]  //west
],
size: 6,
},
potCross: {
verts: [
[], //bottom
[], //top
[customFace(2,4,2, 14,4,14, 14,-12,14, 2,-12,2, 0,0)], //north
[customFace(14,4,2, 2,4,14, 2,-12,14, 14,-12,2, 0,0)], //south
[customFace(14,4,14, 2,4,2, 2,-12,2, 14,-12,14, 0,0)], //east
[customFace(2,4,14, 14,4,2, 14,-12,2, 2,-12,14, 0,0)]  //west
],
size: 6
},
carpet: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 1, 16, 16, 16, 0, 0)], //top
[objectify(16, 1, 16, 16, 1, 0, 0)], //north
[objectify( 0, 1,  0, 16, 1, 0, 0)], //south
[objectify(16, 1,  0, 16, 1, 0, 0)], //east
[objectify( 0, 1, 16, 16, 1, 0, 0)]  //west
]
},
wallCarpet:{
verts:[
[objectify(0,0,15,16,1,0,0)],
[objectify(0,16,16,16,1,0,0)],
[objectify(16,16,16,16,16,0,0)],
[objectify(0,16,15,16,16,0,0)],
[objectify(16,16,15,1,16,0,0)],
[objectify(0,16,16,1,16,0,0)]
],
rotate:true
},
bed: {
verts: [
[objectify( 0, 3,  0, 16, 16, 96, 0),objectify( 0, 3,  16, 16, 16, 96, 0),
objectify(0, 0, 0, 3,3,  38,0),
objectify(13, 0, 29, 3,3,38,0),
objectify(0, 0, 29, 3,3, 38,0),
objectify(13, 0, 0, 3,3, 38,0)], //bottom
[objectify( 0, 9, 32, 16, 16, 16, 0),objectify( 0, 9, 16, 16, 16, 0, 0)], //top
[objectify(16, 9, 32, 16, 6, 80, 6),
objectify(3, 3, 3, 3,3,  38,3),
objectify(16, 3, 32, 3,3,32,3),
objectify(3, 3, 32, 3,3, 35,3),
objectify(16, 3, 3, 3,3, 41,3)], //north
[objectify( 0, 9,  0, 16, 6, 80, 0),
objectify(0, 3, 0, 3,3,  32,3),
objectify(13, 3, 29, 3,3,38,3),
objectify(0, 3, 29, 3,3, 41,3),
objectify(13, 3, 0, 3,3, 35,3)], //south
[objectify( 16, 9,  0, 16, 6, 48, 0),objectify( 16, 9,  16, 16, 6, 64, 0),
objectify(3, 3, 0, 3,3,  41,3),
objectify(16, 3, 29, 3,3,35,3),
objectify(3, 3, 29, 3,3, 38,3),
objectify(16, 3, 0, 3,3, 32,3)], //east
[objectify( 0, 9, 32, 16, 6, 64, 6),objectify( 0, 9, 16, 16, 6, 48, 6),
objectify(0, 3, 3, 3,3,  35,3),
objectify(13, 3, 32, 3,3,41,3),
objectify(0, 3, 32, 3,3, 32,3),
objectify(13, 3, 3, 3,3, 38,3)]  //west
],
rotate: true
},
cactusPot: {
verts: [
[], //bottom
[objectify( 6, 1, 10, 4,  4, 6, 6)], //top
[objectify(10, 1, 10, 4, 11, 6, 0)], //north
[objectify( 6, 1,  6, 4, 11, 6, 0)], //south
[objectify(10, 1,  6, 4, 11, 6, 0)], //east
[objectify( 6, 1, 10, 4, 11, 6, 0)]  //west
],
size: 6
},
crop: {
verts: [
[objectify(0,0,0,0,0,0,0)],
[objectify(0,0,0,0,0,0,0)],
[objectify(16,16,4,16,16,0,0),objectify(16,16,12,16,16,0,0)],
[objectify(0,16,12,16,16,0,0),objectify(0,16,4,16,16,0,0)],
[objectify(4,16,0,16,16,0,0),objectify(12,16,0,16,16,0,0)],
[objectify(12,16,16,16,16,0,0),objectify(4,16,16,16,16,0,0)]
],
varients: []
},
anvil: {
verts: [
[objectify(2,0,2,12,12,0,0),objectify(0,10,3,16,10,0,0)],
[objectify(2,4,14,12,12,0,0),objectify(3,5,12,10,8,0,0),objectify(0,16,13,16,10,16,3)],
[objectify(14,4,14,12,4,0,0),objectify(16,16,13,16,6,0,0),objectify(13,5,12,10,1,0,0),objectify(12,10,11,8,5,0,0)],
[objectify(2,4,2,12,4,0,0),objectify(0,16,3,16,6,0,0),objectify(3,5,4,10,1,0,0),objectify(4,10,5,8,5,0,0)],
[objectify(14,4,2,12,4,0,0),objectify(16,16,3,10,6,0,0),objectify(13,5,4,8,1,0,0),objectify(12,10,5,6,5,0,0)],
[objectify(2,4,14,12,4,0,0),objectify(0,16,13,10,6,0,0),objectify(3,5,12,8,1,0,0),objectify(4,10,11,6,5,0,0)]
],
rotate: true
},
/*liquid: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0), objectify(16, 0, 0, -16, 16, 16, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify(16, 16, 16, -16, 16, 16, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0), objectify(0, 16, 16, -16, 16, 16, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0), objectify(16, 16, 0, -16, 16, 16, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0), objectify(16, 16, 16, -16, 16, 16, 0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify(0, 16, 0, -16, 16, 16, 0)]  //west
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},
liquidSurface: {
verts: [
[objectify( 0,    0,  0, 16,   16, 0, 0), objectify(16, 0, 0, -16, 16, 16, 0)], //bottom
[objectify( 0, 14.5, 16, 16,   16, 0, 0), objectify(16, 14.5, 16, -16, 16, 16, 0)], //top
[objectify(16, 14.5, 16, 16, 14.5, 0, 0), objectify(0, 14.5, 16, -16, 14.5, 16, 0)], //north
[objectify( 0, 14.5,  0, 16, 14.5, 0, 0), objectify(16, 14.5, 0, -16, 14.5, 16, 0)], //south
[objectify(16, 14.5,  0, 16, 14.5, 0, 0), objectify(16, 14.5, 16, -16, 14.5, 16, 0)], //east
[objectify( 0, 14.5, 16, 16, 14.5, 0, 0), objectify(0, 14.5, 0, -16, 14.5, 16, 0)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},*/
sporeBlossom: {
verts: [
[objectify( 1, 15.9, 1, 14, 14, -15, 1)], //bottom
[objectify( 1, 15.9, 15, 14, 14, -15, 1)], //top
[customFace(0,15.9,8, 16,15.9,8, 16,11.1,-8, 0,11.1,-8, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,-8, 16,11.1,-8, 16,16,-16,-16)],
[customFace(0,15.9,8, 16,15.9,8, 16,11.1,24, 0,11.1,24, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,24, 16,11.1,24, 16,16,-16,-16)], //southobjectify( 0, 16,  0, 16, 16, 0, 0)
[customFace(8,15.9,0, 8,15.9,16, -8,11.1,16, -8,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, -8,11.1,0, -8,11.1,16, 16,16,-16,-16)],
[customFace(8,15.9,0, 8,15.9,16, 24,11.1,16, 24,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, 24,11.1,0, 24,11.1,16, 16,16,-16,-16)]
],
},
azalea: {
verts: [
[objectify( 0,  8,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0),customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 16,0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0),customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 16,0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0),customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 16,0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0),customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 16,0)]  //west
]
},
azaleaPot: {
verts: [
[objectify( 4,  -7,  4, 8, 8, 4, 4)], //bottom
[objectify( 4, -1, 12, 8, 8, 4, 4)], //top
[objectify(12, -1, 12, 8, 11, 4, 5),customFace(4,-1,4, 12,-1,12, 12,-12,12, 4,-12,4, 20,5,8,11)], //north
[objectify( 4, -1,  4, 8, 11, 4, 5),customFace(12,-1,4, 4,-1,12, 4,-12,12, 12,-12,4, 20,5,8,11)], //south
[objectify(12, -1,  4, 8, 11, 4, 5),customFace(12,-1,12, 4,-1,4, 4,-12,4, 12,-12,12, 20,5,8,11)], //east
[objectify( 4, -1, 12, 8, 11, 4, 5),customFace(4,-1,12, 12,-1,4, 12,-12,4, 4,-12,12, 20,5,8,11)]  //west
]
},
sunflower: {
verts: [
[customFace(0,34,7, 16,34,7, 16,18,11, 0,18,11, 0,0)], //bottom
[customFace(16,34,7, 0,34,7, 0,18,11, 16,18,11, 0,0)], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
],
hitbox:"tallCube"
},
cake:{
verts: [
[objectify(1,0,1,14,14,1,1)],
[objectify(1,8,15,14,14,1,1)],
[objectify(15,8,15,14,8,1,8)],
[objectify(1,8,1,14,8,1,8)],
[objectify(15,8,1,14,8,1,8)],
[objectify(1,8,15,14,8,1,8)]
]
},
stonecutter:{
verts:[
[objectify(0,0,0,16,16,0,0)],
[objectify(0,9,16,16,16,0,0)],
[objectify(16,9,16,16,9,0,7),objectify(16,16,8,16,7,16,9)],
[objectify(0,9,0,16,9,0,7),objectify(0,16,8,16,7,16,9)],
[objectify(16,9,0,16,9,0,7)],
[objectify(0,9,16,16,9,0,7)]
]
},
itemFrame:{
verts: [
[objectify(2,2,15,12,1,-16,0),objectify(3,13,15,10,1,-16,0)],
[objectify(2,14,16,12,1,-16,0),objectify(3,3,16,10,1,-16,0)],
[objectify(14,14,16,12,12,-16,0)],
[objectify(3,13,15.5,10,10,3,3),objectify(2,14,15,11,1,-14,2),objectify(13,14,15,1,11,-3,2),objectify(3,3,15,11,1,-13,13),objectify(2,13,15,1,11,-14,3)],
[objectify(14,14,15,1,12,-16,0),objectify(3,13,15,1,10,-16,0)],
[objectify(2,14,16,1,12,-16,0),objectify(13,13,16,1,10,-16,0)]
],
rotate:true
},
endPortalFrame:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 13, 16, 16, 16, 0, 0)], //top
[objectify(16, 13, 16, 16, 13, 0, 3)], //north
[objectify( 0, 13,  0, 16, 13, 0, 3)], //south
[objectify(16, 13,  0, 16, 13, 0, 3)], //east
[objectify( 0, 13, 16, 16, 13, 0, 3)]  //west
],
rotate:true
},
endPortalFrameWithEyeOfEnder: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 13, 16, 16, 16, 0, 0), objectify( 4, 16, 12, 8, 8, 36, 4)], //top
[objectify(16, 13, 16, 16, 13, 0, 3), objectify( 12, 16, 12, 8, 3, 20, 0)], //north
[objectify( 0, 13,  0, 16, 13, 0, 3), objectify( 4, 16, 4, 8, 3, 20, 0)], //south
[objectify(16, 13,  0, 16, 13, 0, 3), objectify( 12, 16, 4, 8, 3, 20, 0)], //east
[objectify( 0, 13, 16, 16, 13, 0, 3), objectify( 4, 16, 12, 8, 3, 20, 0)]  //west
],
rotate: true
},
fire: {
verts: [
[], //bottom
[], //top
[customFace(16,22.4,15.5, 0,22.4,15.5, 0,0,16, 16,0,16, 0,0), customFace(0,22.4,15.5, 16,22.4,15.5, 16,0,16, 0,0,16, 0,0), customFace(0,20,12, 16,20,12, 16,0,0, 0,0,0, 0,0), customFace(16,20,12, 0,20,12, 0,0,0, 16,0,0, 0,0)], //north
[customFace(16,22.4,0.5, 0,22.4,0.5, 0,0,0, 16,0,0, 0,0), customFace(0,22.4,0.5, 16,22.4,0.5, 16,0,0, 0,0,0, 0,0), customFace(16,20,4, 0,20,4, 0,0,16, 16,0,16, 0,0), customFace(0,20,4, 16,20,4, 16,0,16, 0,0,16, 0,0)], //south
[customFace(15.5,22.4,16, 15.5,22.4,0, 16,0,0, 16,0,16, 0,0), customFace(15.5,22.4,0, 15.5,22.4,16, 16,0,16, 16,0,0, 0,0), customFace(12,20,0, 12,20,16, 0,0,16, 0,0,0, 0,0), customFace(12,20,16, 12,20,0, 0,0,0, 0,0,16, 0,0)], //east
[customFace(0.5,22.4,16, 0.5,22.4,0, 0,0,0, 0,0,16, 0,0), customFace(0.5,22.4,0, 0.5,22.4,16, 0,0,16, 0,0,0, 0,0), customFace(4,20,0, 4,20,16, 16,0,16, 16,0,0, 0,0), customFace(4,20,16, 4,20,0, 16,0,0, 16,0,16, 0,0)]  //west
],
hitbox:"cube"
},
sideFire:{
verts:[
[],
[],
[customFace(16,22.4,14, 0,22.4,14, 0,0,16, 16,0,16, 0,0)],
[customFace(0,22.4,14, 16,22.4,14, 16,0,16, 0,0,16, 0,0)],
[],
[]
],
rotate:true,
hitbox:"cube"
},
bottomFire:{
verts:[
[customFace(0,12,0, 16,12,0, 16,16,16, 0,16,16, 0,0),customFace(16,12,16, 0,12,16, 0,16,0, 16,16,0, 0,0), customFace(16,12,0, 16,12,16, 0,16,16, 0,16,0, 0,0),customFace(0,12,16, 0,12,0, 16,16,0, 16,16,16, 0,0)],
[customFace(16,12,0, 0,12,0, 0,16,16, 16,16,16, 0,0),customFace(0,12,16, 16,12,16, 16,16,0, 0,16,0, 0,0), customFace(0,12,0, 0,12,16, 16,16,16, 16,16,0, 0,0),customFace(16,12,16, 16,12,0, 0,16,0, 0,16,16, 0,0)],
[],
[],
[],
[]
],
hitbox:"cube"
},
endRod: {
verts: [
[objectify( 6, 0,  6, 4, 4, 2, 4)], //bottom
[objectify( 7, 16, 9, 2, 2, 2, 0),objectify(6, 1,  10, 4, 4, 2, 4)], //top
[objectify(9, 16, 9, 2, 15, 0, 0),objectify(10, 1, 10, 4, 1, 2, 2)], //north
[objectify(7, 16, 7, 2, 15, 0, 0),objectify(6, 1,  6, 4, 1, 2, 2)], //south
[objectify(9, 16, 7, 2, 15, 0, 0),objectify(10, 1, 6, 4, 1, 2, 2)], //east
[objectify(7, 16, 9, 2, 15, 0, 0),objectify(6, 1, 10, 4, 1, 2, 2)]  //west
],
flip: true,
},
endRodSW: {
verts: [
[objectify(7, 7, 0, 2, 15, 0, 0),objectify(6, 6,  15, 4, 1, 2, 4)], //bottom
[objectify(7, 9, 15, 2, 15, 0, 0),objectify(6, 10, 16, 4, 1, 2, 4)], //top
[objectify(10, 10, 16, 4, 4, 2, 4)], //north
[objectify( 7, 9, 0, 2, 2, 2, 0),objectify(6, 10,  15, 4, 4, 2, 2)], //south
[objectify(9, 9, 0, 15, 2, 16, 14),objectify(10, 10, 15, 1, 4, 2, 2)], //east
[objectify(7, 9, 15, 15, 2, 16, 14),objectify(6, 10, 16, 1, 4, 2, 2)]  //west
],
rotate: true,
},
door2: {
verts: [
[objectify(0,0,13,16,3,16,0, false,false,false,null,2)],
[objectify(0,32,16,16,3,16,0, false,false,false,null,2)],
[objectify(16,32,16,16,16,0,0),objectify(16,16,16,16,16,16,0)],
[objectify(0,32,13,16,16,0,0, true),objectify(0,16,13,16,16,16,0, true)],
[objectify(16,32,13,3,16,13,0, false,false,false,2),objectify(16,16,13,3,16,29,0, false,false,false,2)],
[objectify(0,32,16,3,16,0,0, false,false,false,2),objectify(0,16,16,3,16,16,0, false,false,false,2)]
],
rotate: true
},
fenceGate: {
verts: [
[objectify(0,5,7,2,2,0,1),objectify(2,12,7,12,2,0,2),objectify(2,6,7,12,2,0,2),objectify(14,5,7,2,2,0,0)],
[objectify(0,16,9,2,2,0,1),objectify(2,15,9,12,2,0,2),objectify(2,9,9,12,2,0,2),objectify(14,16,9,2,2,0,0)],
[objectify(2,16,9,2,11,0,0),objectify(14,15,9,12,3,2,1),objectify(14,9,9,12,3,2,7),objectify(16,16,9,2,11,14,0),objectify(10,12,9,4,3,6,4)],
[objectify(0,16,7,2,11,14,0),objectify(2,15,7,12,3,2,1),objectify(2,9,7,12,3,2,7),objectify(14,16,7,2,11,2,0),objectify(6,12,7,4,3,6,4)],
[objectify(2,16,7,2,11,6,0),objectify(10,12,7,2,3,0,0),objectify(16,16,7,2,11,0,0)],
[objectify(0,16,9,2,11,6,0),objectify(14,16,9,2,11,0,0),objectify(6,12,9,2,3,0,0)]
],
flip: false,
rotate: true
},
fenceGateWall: {
verts: [
[objectify(0,2,7,2,2,0,1),objectify(2,9,7,12,2,0,2),objectify(2,3,7,12,2,0,2),objectify(14,2,7,2,2,0,0)],
[objectify(0,13,9,2,2,0,1),objectify(2,12,9,12,2,0,2),objectify(2,6,9,12,2,0,2),objectify(14,13,9,2,2,0,0)],
[objectify(2,13,9,2,11,0,0),objectify(14,12,9,12,3,2,1),objectify(14,6,9,12,3,2,7),objectify(16,13,9,2,11,14,0),objectify(10,9,9,4,3,6,4)],
[objectify(0,13,7,2,11,14,0),objectify(2,12,7,12,3,2,1),objectify(2,6,7,12,3,2,7),objectify(14,13,7,2,11,2,0),objectify(6,9,7,4,3,6,4)],
[objectify(2,13,7,2,11,6,0),objectify(10,9,7,2,3,0,0),objectify(16,13,7,2,11,0,0)],
[objectify(0,13,9,2,11,6,0),objectify(14,13,9,2,11,0,0),objectify(6,9,9,2,3,0,0)]
],
flip: false,
rotate: true
},
fenceGateOpen: {
verts: [
[objectify(0,5,7,2,2,0,1),objectify(14,12,9,2,6,0,2),objectify(14,6,9,2,6,0,2),objectify(14,5,7,2,2,0,0),objectify(0,12,9,2,6,0,0),objectify(0,6,9,2,6,0,0)],
[objectify(0,16,9,2,2,0,1),objectify(14,15,15,2,6,0,2),objectify(14,9,15,2,6,0,2),objectify(14,16,9,2,2,0,0),objectify(0,15,15,2,6,0,0),objectify(0,9,15,2,6,0,0)],
[objectify(2,16,9,2,11,0,0),objectify(16,15,15,2,9,2,1),objectify(2,15,15,2,9,2,7),objectify(16,16,9,2,11,14,0)],
[objectify(0,16,7,2,11,14,0),objectify(14,12,13,2,3,2,1),objectify(0,12,13,2,3,2,7),objectify(14,16,7,2,11,2,0)],
[objectify(2,16,7,2,11,6,0),objectify(2,12,13,2,3,6,4),objectify(16,16,7,2,11,6,4),objectify(16,12,13,2,3,0,0),objectify(16,15,9,6,3,2,1),objectify(2,15,9,6,3,2,1),objectify(16,9,9,6,3,2,7),objectify(2,9,9,6,3,2,7)],
[objectify(0,16,9,2,11,6,0),objectify(14,16,9,2,11,0,0),objectify(14,12,15,2,3,6,4),objectify(0,12,15,2,3,6,4),objectify(0,15,15,6,3,0,1),objectify(0,9,15,6,3,2,7),objectify(14,15,15,6,3,2,1),objectify(14,9,15,6,3,2,7)]
],
flip: false,
rotate: true
},
fenceGateWallOpen: {
verts: [
[objectify(0,2,7,2,2,0,1),objectify(14,9,9,2,6,0,2),objectify(14,3,9,2,6,0,2),objectify(14,2,7,2,2,0,0),objectify(0,9,9,2,6,0,0),objectify(0,3,9,2,6,0,0)],
[objectify(0,13,9,2,2,0,1),objectify(14,12,15,2,6,0,2),objectify(14,6,15,2,6,0,2),objectify(14,13,9,2,2,0,0),objectify(0,12,15,2,6,0,0),objectify(0,6,15,2,6,0,0)],
[objectify(2,13,9,2,11,0,0),objectify(16,12,15,2,9,2,1),objectify(2,12,15,2,9,2,7),objectify(16,13,9,2,11,14,0)],
[objectify(0,13,7,2,11,14,0),objectify(14,9,13,2,3,2,1),objectify(0,9,13,2,3,2,7),objectify(14,13,7,2,11,2,0)],
[objectify(2,13,7,2,11,6,0),objectify(2,9,13,2,3,6,4),objectify(16,13,7,2,11,6,4),objectify(16,9,13,2,3,0,0),objectify(16,12,9,6,3,2,1),objectify(2,12,9,6,3,2,1),objectify(16,6,9,6,3,2,7),objectify(2,6,9,6,3,2,7)],
[objectify(0,13,9,2,11,6,0),objectify(14,13,9,2,11,0,0),objectify(14,9,15,2,3,6,4),objectify(0,9,15,2,3,6,4),objectify(0,12,15,6,3,0,1),objectify(0,6,15,6,3,2,7),objectify(14,12,15,6,3,2,1),objectify(14,6,15,6,3,2,7)]
],
flip: false,
rotate: true
},
tallCrop: {
verts: [
[],
[],
[objectify(16,32,4,16,16,0,0),objectify(16,32,12,16,16,0,0),objectify(16,16,4,16,16,16,0),objectify(16,16,12,16,16,16,0)],
[objectify(0,32,12,16,16,0,0),objectify(0,32,4,16,16,0,0),objectify(0,16,12,16,16,16,0),objectify(0,16,4,16,16,16,0)],
[objectify(4,32,0,16,16,0,0),objectify(12,32,0,16,16,0,0),objectify(4,16,0,16,16,16,0),objectify(12,16,0,16,16,16,0)],
[objectify(12,32,16,16,16,0,0),objectify(4,32,16,16,16,0,0),objectify(12,16,16,16,16,16,0),objectify(4,16,16,16,16,16,0)]
],
varients: []
},
chainSW: {
verts: [
[objectify(6.5,8,0,3,16,0,0)],
[objectify(6.5,8,16,3,16,0,0)],
[],
[],
[objectify(8,9.5,0,16,3,0,3)],
[objectify(8,9.5,16,16,3,0,3)]
],
rotate:true
},
campfire:{
verts: [
[objectify(1,0,0,4,16,16,0,false,false,1),objectify(11,0,0,4,16,16,0,false,false,1),objectify(0,3,1,16,4,0,4),objectify(0,3,11,16,4,0,4),objectify(5,0,0,6,16,16,10,false,false,1)],
[objectify(1,4,16,4,16,16,0,false,false,1),objectify(11,4,16,4,16,16,0,false,false,1),objectify(0,7,5,16,4,16,0),objectify(0,7,15,16,4,16,0),objectify(5,1,16,6,16,0,10,false,false,1)],
[objectify(5,4,16,4,4,16,4),objectify(15,4,16,4,4,16,4),objectify(16,7,5,16,4,0,0),objectify(16,7,15,16,4,0,0),objectify(11,1,16,6,1,0,15), customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 32,0)],
[objectify(1,4,0,4,4,16,4),objectify(11,4,0,4,4,16,4),objectify(0,7,1,16,4,0,0),objectify(0,7,11,16,4,0,0),objectify(5,1,0,6,1,0,15), customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 32,0)],
[objectify(15,4,0,16,4,16,0),objectify(5,4,0,16,4,0,0),objectify(16,7,1,4,4,16,4),objectify(16,7,11,4,4,16,4), customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 32,0)],
[objectify(11,4,16,16,4,0,0),objectify(1,4,16,16,4,16,0),objectify(0,7,5,4,4,16,4),objectify(0,7,15,4,4,16,4), customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 32,0)]
],
hitbox:"slab"
},
campfireUnlit:{
verts:[
[objectify(1,0,0,4,16,16,0,false,false,1),objectify(11,0,0,4,16,16,0,false,false,1),objectify(0,3,1,16,4,16,0),objectify(0,3,11,16,4,16,0),objectify(5,0,0,6,16,16,10,false,false,1)],
[objectify(1,4,16,4,16,16,0,false,false,1),objectify(11,4,16,4,16,16,0,false,false,1),objectify(0,7,5,16,4,16,0),objectify(0,7,15,16,4,16,0),objectify(5,1,16,6,16,16,10,false,false,1)],
[objectify(5,4,16,4,4,16,4),objectify(15,4,16,4,4,16,4),objectify(16,7,5,16,4,16,0),objectify(16,7,15,16,4,16,0),objectify(11,1,16,6,1,0,15)],
[objectify(1,4,0,4,4,16,4),objectify(11,4,0,4,4,16,4),objectify(0,7,1,16,4,16,0),objectify(0,7,11,16,4,16,0),objectify(5,1,0,6,1,0,15)],
[objectify(15,4,0,16,4,16,0),objectify(5,4,0,16,4,16,0),objectify(16,7,1,4,4,16,4),objectify(16,7,11,4,4,16,4)],
[objectify(11,4,16,16,4,16,0),objectify(1,4,16,16,4,16,0),objectify(0,7,5,4,4,16,4),objectify(0,7,15,4,4,16,4)]
],
hitbox:"slab"
},
bamboo:{
verts:[
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0)],
[objectify(6.5,16,6.5,3,16,0,0)],
[objectify(9.5,16,6.5,3,16,0,0)],
[objectify(6.5,16,9.5,3,16,0,0)]
],
hitbox:"cube"
},
bambooSmallLeaf:{
verts: [
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0),objectify(16,16,8,16,16,48,0)],
[objectify(6.5,16,6.5,3,16,0,0),objectify(0,16,8,16,16,48,0)],
[objectify(9.5,16,6.5,3,16,0,0),objectify(8,16,0,16,16,48,0)],
[objectify(6.5,16,9.5,3,16,0,0),objectify(8,16,16,16,16,48,0)]
],
hitbox:"cube"
},
bambooBigLeaf:{
verts:[
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0),objectify(16,16,8,16,16,32,0)],
[objectify(6.5,16,6.5,3,16,0,0),objectify(0,16,8,16,16,32,0)],
[objectify(9.5,16,6.5,3,16,0,0),objectify(8,16,0,16,16,32,0)],
[objectify(6.5,16,9.5,3,16,0,0),objectify(8,16,16,16,16,32,0)]
],
hitbox:"cube"
},
bambooYoung:{
verts:[
[objectify(7,0,7,2,2,13,4)],
[objectify(7,16,9,2,2,13,0)],
[objectify(9,16,9,2,16,0,0)],
[objectify(7,16,7,2,16,0,0)],
[objectify(9,16,7,2,16,0,0)],
[objectify(7,16,9,2,16,0,0)]
],
hitbox:"cube"
},
bambooYoungLeaf:{
verts:[
[objectify(7,0,7,2,2,13,4)],
[objectify(7,16,9,2,2,13,0)],
[objectify(9,16,9,2,16,0,0),objectify(16,16,8,16,16,48,0)],
[objectify(7,16,7,2,16,0,0),objectify(0,16,8,16,16,48,0)],
[objectify(9,16,7,2,16,0,0),objectify(8,16,0,16,16,48,0)],
[objectify(7,16,9,2,16,0,0),objectify(8,16,16,16,16,47,0)]
],
hitbox:"cube"
},
bambooPot:{
verts:[
[],
[objectify(7,0,9,2,2,13,0)],
[objectify(9,0,9,2,16,0,0),objectify(16,0,8,16,16,16,0)],
[objectify(7,0,7,2,16,0,0),objectify(0,0,8,16,16,16,0, true)],
[objectify(9,0,7,2,16,0,0)],
[objectify(7,0,9,2,16,0,0)]
],
},
chest:{
verts:[
[objectify(1,0,1,14,14,32,0),objectify(7,7,0,2,1,67,0)],
[objectify(1,14,15,14,14,48,0),objectify(7,11,1,2,1,79,0)],
[objectify(15,14,15,14,4,16,0),objectify(15,10,15,14,10,16,5),objectify(9,11,1,2,4,64,1)],
[objectify(1,14,1,14,4,0,0),objectify(1,10,1,14,10,0,5),objectify(7,11,0,2,4,62,1)],
[objectify(15,14,1,14,4,16,0),objectify(15,10,1,14,10,16,5),objectify(9,11,0,1,4,64,1)],
[objectify(1,14,15,14,4,16,0),objectify(1,10,15,14,10,16,5),objectify(7,11,1,1,4,62,1)]
],
rotate:true
},
pressurePlate:{
verts:[
[objectify(1,0,1,14,14,1,1)],
[objectify(1,1,15,14,14,1,1)],
[objectify(15,1,15,14,1,0,0)],
[objectify(1,1,1,14,1,0,0)],
[objectify(15,1,1,14,1,0,0)],
[objectify(1,1,15,14,1,0,0)]
],
},
pressurePlateActive:{
verts:[
[objectify(1,0,1,14,14,1,1)],
[objectify(1,0.5,15,14,14,1,1)],
[objectify(15,0.5,15,14,0.5,0,0)],
[objectify(1,0.5,1,14,0.5,0,0)],
[objectify(15,0.5,1,14,0.5,0,0)],
[objectify(1,0.5,15,14,0.5,0,0)]
]
},
redstoneDust:{
verts:[
[objectify(0,0.25,0,16,16,0,0,false,true)],
[objectify(0,0.25,16,16,16,0,0)],
[objectify(16, 16,  0.25, 16, 16, 0, 0, false,false,false,null,null, "north"), objectify(16, 16,  15.75, 16, 16, 0, 0, false,false,false,null,null, "south")],
[objectify( 0, 16, 15.75, 16, 16, 0, 0, false,false,false,null,null, "south"), objectify( 0, 16, 0.25, 16, 16, 0, 0, false,false,false,null,null, "north")],
[objectify( 0.25, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "east"), objectify( 15.75, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "west")],
[objectify(15.75, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "west"), objectify(0.25, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "east")]
],
hitbox:"carpet"
},
redstoneDustRotate:{
verts:[
[objectify(0,0.25,0,16,16,0,0,false,true)],
[objectify(0,0.25,16,16,16,0,0)],
[objectify(16, 16,  0.25, 16, 16, 0, 0, false,false,false,null,null, "north"), objectify(16, 16,  15.75, 16, 16, 0, 0, false,false,false,null,null, "south")],
[objectify( 0, 16, 15.75, 16, 16, 0, 0, false,false,false,null,null, "south"), objectify( 0, 16, 0.25, 16, 16, 0, 0, false,false,false,null,null, "north")],
[objectify( 0.25, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "east"), objectify( 15.75, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "west")],
[objectify(15.75, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "west"), objectify(0.25, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "east")]
],
rotate:true,
hitbox:"carpet"
},
redstoneTorch:{
verts:[
[objectify(7,0,7,2,2,7,14),objectify(6,10,6,4,4,6,5)],
[objectify(7,10,9,2,2,7,6),objectify(6,8,10,4,4,6,5)],
[objectify(9,10,9,2,10,7,6),objectify(10,11,7,4,4,6,5)],
[objectify(7,10,7,2,10,7,6),objectify(6,11,9,4,4,6,5)],
[objectify(9,10,7,2,10,7,6),objectify(7,11,6,4,4,6,5)],
[objectify(7,10,9,2,10,7,6),objectify(9,11,10,4,4,6,5)]
]
},
redstoneWallTorch:{
verts: [
[customFace(9,4,17, 7,4,17, 7,3,15, 9,3,15, 7,14,2,2),customFace(6,12.5,10, 10,12.5,10, 10,14.5,14, 6,14.5,14, 6,5,4,4)],
[customFace(9,13,11, 7,13,11, 7,14,13, 9,14,13, 7,6,2,2),customFace(10,10.5,10.8, 6,10.5,10.8, 6,12.5,14.8, 10,12.5,14.8, 6,5,4,4)],
[customFace(9,14,13, 7,14,13, 7,4,17, 9,4,17, 7,6,2,10),customFace(10,14,10.6, 6,14,10.6, 6,10,12.2, 10,10,12.2, 6,5,4,4)], //north
[customFace(7,13,11, 9,13,11, 9,3,15, 7,3,15, 7,6,2,10),customFace(6,15,12.6, 10,15,12.6, 10,11,14.2, 6,11,14.2, 6,5,4,4)], //south
[customFace(9,13,11, 9,14,13, 9,4,17, 9,3,15, 7,6,2,10),customFace(7,13.5,9.6, 7,15.5,13.6, 7,11.5,15.2, 7,9.5,11.2, 6,5,4,4)], //east
[customFace(7,14,13, 7,13,11, 7,3,15, 7,4,17, 7,6,2,10),customFace(9,15.5,13.6, 9,13.5,9.6, 9,9.5,11.2, 9,11.5,15.2, 6,5,4,4)]  //west
],
rotate:true
},
leverWall:{
verts:[
[objectify(5,4,13,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,12,7, 9,12,7, 9,8.45,15, 7,8.45,15, 7,6,2,10)],
[objectify(5,12,16,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,13.5,8, 7,13.5,8, 7,10,16, 9,10,16, 7,6,2,10)],
[objectify(11,12,16,6,8,0,0,null,null,null,null,null,"cobblestone")],
[objectify(5,12,13,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,13.5,8, 9,13.5,8, 9,12,7, 7,12,7, 7,6,2,2)],
[objectify(11,12,13,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,12,7, 9,13.5,8, 9,10,16, 9,8.45,15, 7,6,2,10)],
[objectify(5,12,16,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,13.5,8, 7,12,7, 7,8.45,15, 7,10,16, 7,6,2,10)]
],
rotate:true
},
leverWallOn:{
verts:[
[objectify(5,4,13,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,2.5,8, 9,2.5,8, 9,6,16, 7,6,16, 7,6,2,10)],
[objectify(5,12,16,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,4,7, 7,4,7, 7,7.55,15, 9,7.55,15, 7,6,2,10)],
[objectify(11,12,16,6,8,0,0,null,null,null,null,null,"cobblestone")],
[objectify(5,12,13,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,2.5,8, 7,2.5,8, 7,4,7, 9,4,7, 7,6,2,2)],
[objectify(11,12,13,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,2.5,8, 9,4,7, 9,7.55,15, 9,6,16, 7,6,2,10)],
[objectify(5,12,16,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,4,7, 7,2.5,8, 7,6,16, 7,7.55,15, 7,6,2,10)]
],
rotate:true
},
leverFloor:{
verts:[
[objectify(5,0,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 7,8,13.5, 7,0,10, 9,0,10, 7,6,2,10)],
[objectify(5,3,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,9,12, 9,9,12, 9,1,8.45, 7,1,8.45, 7,6,2,10)],
[objectify(11,3,12,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 9,8,13.5, 9,9,12, 7,9,12, 7,6,2,2)],
[objectify(5,3,4,6,3,0,0,null,null,null,null,null,"cobblestone")],
[objectify(11,3,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,9,12, 9,8,13.5, 9,0,10, 9,1,8.45, 7,6,2,10)],
[objectify(5,3,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 7,9,12, 7,1,8.45, 7,0,10, 7,6,2,10)]
],
},
leverFloorOn:{
verts:[
[objectify(5,0,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 9,8,2.5, 9,0,6, 7,0,6, 7,6,2,10)],
[objectify(5,3,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,9,4, 7,9,4, 7,1,7.55, 9,1,7.55, 7,6,2,10)],
[objectify(11,3,12,6,3,0,0,null,null,null,null,null,"cobblestone")],
[objectify(5,3,4,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 7,8,2.5, 7,9,4, 9,9,4, 7,6,2,2)],
[objectify(11,3,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 9,9,4, 9,1,7.55, 9,0,6, 7,6,2,10)],
[objectify(5,3,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,9,4, 7,8,2.5, 7,0,6, 7,1,7.55, 7,6,2,10)]
],
},
leverCeil:{
verts:[
[objectify(5,13,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,7,12, 7,7,12, 7,15,8.45, 9,15,8.45, 7,6,2,10)],
[objectify(5,16,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 9,8,13.5, 9,16,10, 7,16,10, 7,6,2,10)],
[objectify(11,16,12,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 7,8,13.5, 7,7,12, 9,7,12, 7,6,2,2)],
[objectify(5,16,4,6,3,0,0,null,null,null,null,null,"cobblestone")],
[objectify(11,16,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 9,7,12, 9,15,8.45, 9,16,10, 7,6,2,10)],
[objectify(5,16,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,7,12, 7,8,13.5, 7,16,10, 7,15,8.45, 7,6,2,10)]
],
},
leverCeilOn:{
verts:[
[objectify(5,13,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,7,4, 9,7,4, 9,15,7.55, 7,15,7.55, 7,6,2,10)],
[objectify(5,16,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 7,8,2.5, 7,16,6, 9,16,6, 7,6,2,10)],
[objectify(11,16,12,6,3,0,0,null,null,null,null,null,"cobblestone")],
[objectify(5,16,4,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 9,8,2.5, 9,7,4, 7,7,4, 7,6,2,2)],
[objectify(11,16,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,7,4, 9,8,2.5, 9,16,6, 9,15,7.55, 7,6,2,10)],
[objectify(5,16,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 7,7,4, 7,15,7.55, 7,16,6, 7,6,2,10)]
],
},
buttonPushed:{
verts:[
[objectify(5,6,15,6,1,5,6)],
[objectify(5,10,16,6,1,5,6)],
[objectify(11,10,16,6,4,5,6)],
[objectify(5,10,15,6,4,5,6)],
[objectify(11,10,15,1,4,5,6)],
[objectify(5,10,16,1,4,5,6)]
],
rotate: true
},
repeater1:{
verts:generateRepeater(),
rotate: true
},
repeater2:{
verts:generateRepeater(2),
rotate: true
},
repeater3:{
verts:generateRepeater(3),
rotate: true
},
repeater4:{
verts:generateRepeater(4),
rotate: true
},
repeaterOn1:{
verts:generateRepeater(1,true),
rotate: true
},
repeaterOn2:{
verts:generateRepeater(2,true),
rotate: true
},
repeaterOn3:{
verts:generateRepeater(3,true),
rotate: true
},
repeaterOn4:{
verts:generateRepeater(4,true),
rotate: true
},
//the piston shapes come from https://minekhan-testing.lukep0wers.repl.co
pistonOpen: {
verts: [
[objectify(0,0,0,16,16,0,0)], //bottom
[objectify(0,12,16,16,16,0,0)], //top
[objectify(16,12,16,16,12,0,4)], //north
[objectify(0,12,0,16,12,0,4)], //south
[objectify(16,12,0,16,12,0,4)], //east
[objectify(0,12,16,16,12,0,4)]  //west
]
},
pistonOpenFlipped: {
verts: [
[objectify(0,4,0,16,16,0,0, false,true)],
[objectify(0,16,16,16,16,0,0, false,true)],
[objectify(16,16,16,16,12,0,4, false,true)],
[objectify(0,16,0,16,12,0,4, false,true)],
[objectify(16,16,0,16,12,0,4, false,true)],
[objectify(0,16,16,16,12,0,4, false,true)]
]
},
pistonOpenSW: {
verts: [
[objectify(0,0,4,16,12,0,4)],
[objectify(0,16,16,16,12,0,4, false,false,2)],
[objectify(16,16,16,16,16,0,0)],
[objectify(0,16,4,16,16,0,0)],
[objectify(16,16,4,12,16,0,4, false,false,1)],
[objectify(0,16,16,12,16,0,4, false,false,-1)]
],
rotate:true
},
pistonHead: {
verts: [
[objectify(0,12,0,16,16,0,0)], //b
[objectify(0,16,16,16,16,0,0)], //t
[objectify(16,16,16,16,4,0,0), objectify(10,12,10,4,12,6,4), objectify(10,0,10,4,4,6,9)], //n
[objectify(0,16,0,16,4,0,0), objectify(6,12,6,4,12,6,4), objectify(6,0,6,4,4,6,9)], //s
[objectify(16,16,0,16,4,0,0), objectify(10,12,6,4,12,6,4), objectify(10,0,6,4,4,6,9)], //e
[objectify(0,16,16,16,4,0,0), objectify(6,12,10,4,12,6,4), objectify(6,0,10,4,4,6,9)] //w
]
},
pistonHeadFlipped: {
verts: [
[objectify(0,0,0,16,16,0,0)], //b
[objectify(0,4,16,16,16,0,0)], //t
[objectify(16,4,16,16,4,0,0), objectify(10,20,10,4,12,6,4), objectify(10,8,10,4,4,6,9)], //n
[objectify(0,4,0,16,4,0,0), objectify(6,20,6,4,12,6,4), objectify(6,8,6,4,4,6,9)], //s
[objectify(16,4,0,16,4,0,0), objectify(10,20,6,4,12,6,4), objectify(10,8,6,4,4,6,9)], //e
[objectify(0,4,16,16,4,0,0), objectify(6,20,10,4,12,6,4), objectify(6,8,10,4,4,6,9)] //w
]
},
pistonHeadSW: {
verts: [
[objectify(0,0,0,16,4,0,0),objectify(6,6,4,4,12,6,4),objectify(6,6,16,4,4,6,9)],
[objectify(0,16,4,16,4,0,0),objectify(6,10,16,4,12,6,4, false,true),objectify(6,10,20,4,4,6,9, false,true)],
[objectify(16,16,4,16,16,0,0)],
[objectify(0,16,0,16,16,0,0)],
[objectify(16,16,0,4,16,0,0, false,false,true),objectify(10,10,4,12,4,6,4, false,false,1),objectify(10,10,16,4,4,6,9, false,false,1)],
[objectify(0,16,4,4,16,0,0, false,false,true),objectify(6,10,16,12,4,6,4, false,false,-1),objectify(6,10,20,4,4,6,9, false,false,-1)]
],
rotate:true
},
pistonHeadCut: {
verts: [
[objectify(0,12,0,16,16,0,0)], //b
[objectify(0,16,16,16,16,0,0)], //t
[objectify(16,16,16,16,4,0,0), objectify(10,12,10,4,12,6,4)], //n
[objectify(0,16,0,16,4,0,0), objectify(6,12,6,4,12,6,4)], //s
[objectify(16,16,0,16,4,0,0), objectify(10,12,6,4,12,6,4)], //e
[objectify(0,16,16,16,4,0,0), objectify(6,12,10,4,12,6,4)] //w
]
},
pistonHeadCutFlipped: {
verts: [
[objectify(0,0,0,16,16,0,0)], //b
[objectify(0,4,16,16,16,0,0)], //t
[objectify(16,4,16,16,4,0,0), objectify(10,16,10,4,12,6,4)], //n
[objectify(0,4,0,16,4,0,0), objectify(6,16,6,4,12,6,4)], //s
[objectify(16,4,0,16,4,0,0), objectify(10,16,6,4,12,6,4)], //e
[objectify(0,4,16,16,4,0,0), objectify(6,16,10,4,12,6,4)] //w
]
},
pistonHeadCutSW: {
verts: [
[objectify(0,0,0,16,4,0,0),objectify(6,6,4,4,12,6,4)],
[objectify(0,16,4,16,4,0,0),objectify(6,10,16,4,12,6,4, false,true)],
[objectify(16,16,4,16,16,0,0)],
[objectify(0,16,0,16,16,0,0)],
[objectify(16,16,0,4,16,0,0, false,false,true),objectify(10,10,4,12,4,6,4, false,false,1)],
[objectify(0,16,4,4,16,0,0, false,false,true),objectify(6,10,16,12,4,6,4, false,false,-1)]
],
rotate:true
},
slimeBlock:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0), objectify( 3,  3,  3, 10, 10, 3, 3)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 3, 13, 13, 10, 10, 3, 3)], //top
[objectify(16, 16, 16, 16, 16, 0, 0), objectify(13, 13, 13, 10, 10, 3, 3)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0), objectify( 3, 13,  3, 10, 10, 3, 3)], //south
[objectify(16, 16,  0, 16, 16, 0, 0), objectify(13, 13,  3, 10, 10, 3, 3)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 3, 13, 13, 10, 10, 3, 3)]  //west
],
},
honeyBlock:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0), objectify( 1,  1,  1, 14, 14, 1, 1)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 1, 15, 15, 14, 14, -31, 1)], //top
[objectify(16, 16, 16, 16, 16, 0, 0), objectify(15, 15, 15, 14, 14, -15, 1)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0), objectify( 1, 15,  1, 14, 14, -15, 1)], //south
[objectify(16, 16,  0, 16, 16, 0, 0), objectify(15, 15,  1, 14, 14, -15, 1)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 1, 15, 15, 14, 14, -15, 1)]  //west
],
},
stairCornerOut: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8,  16, 16, 16, 0, 0), objectify( 0, 16,  16, 8, 8, 0, 0)], //top
[objectify(8, 16, 16, 8, 8, 0, 0), objectify(16, 8, 16, 16, 8, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 8, 8, 0, 0)], //south
[objectify(16, 8, 0, 16, 8, 0, 0), objectify(8, 16, 8, 8, 16, 0, 0)], //east
[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
],
flip: true,
rotate: true
},
stairCornerIn: {
verts: [
[objectify(0,0,0,16,16,0,0)],
[objectify(8,8,8,8,8,0,0),objectify(0,16,16,16,8,0,0),objectify(0,16,8,8,8,0,0)],
[objectify(16,16,16,16,16,0,0)],
[objectify(8,16,8,8,8,0,0),objectify(0,16,0,8,8,0,0),objectify(0,8,0,16,8,0,0)],
[objectify(8,16,0,8,8,0,0),objectify(16,16,8,8,8,0,0),objectify(16,8,0,16,8,0,0)],
[objectify(0,16,16,16,16,0,0)]
],
flip: true,
rotate: true
},
endPortal: {
verts: [
[objectify( 0, 8,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
[], //north
[], //south
[], //east
[]  //west
],
},
smallDripleaf:{
verts:[
[objectify(8,21,8,7,7,48,0,false,false,-1),objectify(1,26,1,7,7,48,0,false,false,1),objectify(1,30,8,7,7,48,0,false,false,2)],
[objectify(8,21,15,7,7,48,0,true,false,-1),objectify(1,26,8,7,7,48,0,true,false,1),objectify(1,30,15,7,7,48,0,true)],
[objectify(15,21,15,7,1,32,0),objectify(8,26,8,7,1,32,0),objectify(8,30,15,7,1,32,0),customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 16,0)],
[objectify(8,21,8,7,1,32,0),objectify(1,26,1,7,1,32,0),objectify(1,30,8,7,1,32,0),customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 16,0)],
[objectify(15,21,8,7,1,32,0),objectify(8,26,1,7,1,32,0),objectify(8,30,8,7,1,32,0),customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 16,0)],
[objectify(8,21,15,7,1,32,0),objectify(1,26,8,7,1,32,0),objectify(1,30,15,7,1,32,0),customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 16,0)]
],
rotate:true,
hitbox:"tallCube"
},
bigDripleaf:{
verts:[
[objectify(0,15,0,16,16,32,0)],
[objectify(0,15,16,16,16,32,0,false,true)],
[objectify(16,15,0,16,4,48,0),customFace(2,15,2, 14,15,14, 14,0,14, 2,0,2, 0,0)],
[objectify(0,15,0,16,4,48,0),customFace(14,15,2, 2,15,14, 2,0,14, 14,0,2, 0,0)],
[objectify(0,15,0,16,4,16,0,true),objectify(16,15,0,16,4,16,0),customFace(14,15,14, 2,15,2, 2,0,2, 14,0,14, 0,0)],
[objectify(0,15,16,16,4,16,0),objectify(16,15,16,16,4,16,0),customFace(2,15,14, 14,15,2, 14,0,2, 2,0,14, 0,0)]
],
rotate:true,
hitbox:"cube"
},
logicGate:{
verts:[
[objectify(0,0,0,16,16,0,0)],
[objectify(0,2,16,16,16,0,0)],
[objectify(16,2,16,16,2,0,2)],
[objectify(0,2,0,16,2,0,2)],
[objectify(16,2,0,16,2,0,14)],
[objectify(0,2,16,16,2,0,14)]
],
rotate:true
},
sign:{
verts:[
[objectify(-4,14,7,16,2,0,0),objectify(7,0,7,2,2,7,7, false,false,null,null,null,"poleTop"),objectify(12,14,7,8,2,0,0)],
[objectify(-4,26,9,16,2,0,0),objectify(12,26,9,8,2,0,0)],
[objectify(20,26,9,16,12,0,0),objectify(9,14,9,2,14,0,0, false,false,null,null,null,"poleSide"),objectify(4,26,9,8,12,0,0)],
[objectify(-4,26,7,16,12,0,0),objectify(7,14,7,2,14,0,0, false,false,null,null,null,"poleSide"),objectify(12,26,7,8,12,0,0)],
[objectify(20,26,7,2,12,0,0),objectify(9,14,7,2,14,0,0, false,false,null,null,null,"poleSide")],
[objectify(-4,26,9,2,12,0,0),objectify(7,14,9,2,14,0,0, false,false,null,null,null,"poleSide")]
],
},
wallSign:{
verts:[
[objectify(-4,6,16.7,16,2,0,0),objectify(12,6,16.7,8,2,0,0)],
[objectify(-4,18,18.7,16,2,0,0),objectify(12,18,18.7,8,2,0,0)],
[objectify(20,18,18.7,16,12,0,0),objectify(4,18,18.7,8,12,0,0)],
[objectify(-4,18,16.7,16,12,0,0),objectify(12,18,16.7,8,12,0,0)],
[objectify(20,18,16.7,2,12,0,0)],
[objectify(-4,18,18.7,2,12,0,0)]
],
},
composter:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,2,16,16,16,16,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter2:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,4,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter3:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,6,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter4:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,8,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter5:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,10,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter6:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,12,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter7:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,14,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter8:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,15,16,16,16,32,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
cocoaStage0:{
verts:[
[objectify(6,7,11,4,4,0,0)],
[objectify(6,12,15,4,4,0,0)],
[objectify(10,12,15,4,5,11,4)],
[objectify(6,12,11,4,5,11,4)],
[objectify(10,12,11,4,5,11,4),objectify(8,16,12,4,4,12,0,true)],
[objectify(6,12,15,4,5,11,4),objectify(8,16,16,4,4,12,0)]
],
rotate:true
},
cocoaStage1:{
verts:[
[objectify(5,5,9,6,6,0,0)],
[objectify(5,12,15,6,6,0,0)],
[objectify(11,12,15,6,7,9,4)],
[objectify(5,12,9,6,7,9,4)],
[objectify(11,12,9,6,7,9,4),objectify(8,16,12,4,4,12,0,true)],
[objectify(5,12,15,6,7,9,4),objectify(8,16,16,4,4,12,0)]
],
rotate:true
},
cocoaStage2:{
verts:[
[objectify(4,3,7,8,8,0,0)],
[objectify(4,12,15,8,8,0,0)],
[objectify(12,12,15,8,9,8,4)],
[objectify(4,12,7,8,9,8,4)],
[objectify(12,12,7,8,9,8,4),objectify(8,16,12,4,4,12,0,true)],
[objectify(4,12,15,8,9,8,4),objectify(8,16,16,4,4,12,0)]
],
rotate:true
},
chair:{
verts:[
[objectify(3,6,0,10,16,0,0),objectify(3,0,14,2,2,0,0),objectify(11,0,14,2,2,0,0),objectify(3,0,0,2,2,0,0),objectify(11,0,0,2,2,0,0)],
[objectify(3,8,16,10,16,0,0),objectify(3,24,16,10,2,0,0)],
[objectify(13,8,16,10,2,0,0),objectify(5,6,16,2,6,0,0),objectify(13,6,16,2,6,0,0),objectify(5,6,2,2,6,0,0),objectify(13,6,2,2,6,0,0),objectify(13,24,16,10,16,0,0)],
[objectify(3,8,0,10,2,0,0),objectify(3,6,14,2,6,0,0),objectify(11,6,14,2,6,0,0),objectify(3,6,0,2,6,0,0),objectify(11,6,0,2,6,0,0),objectify(3,24,14,10,16,0,0)],
[objectify(13,8,0,16,2,0,0),objectify(5,6,0,2,6,0,0),objectify(13,6,0,2,6,0,0),objectify(5,6,14,2,6,0,0),objectify(13,6,14,2,6,0,0),objectify(13,24,14,2,16,0,0)],
[objectify(3,8,16,16,2,0,0),objectify(3,6,2,2,6,0,0),objectify(3,6,16,2,6,0,0),objectify(11,6,2,2,6,0,0),objectify(11,6,16,2,6,0,0),objectify(3,24,16,2,16,0,0)]
],
rotate:true
},
arrow:{
verts:[
[objectify(5.5,8,0,5,16,0,0, false,false,true)],
[objectify(5.5,8,16,5,16,0,0, false,true,true)],
[],
[objectify(5.5,10.5,1,5,5,0,5)],
[objectify(8,10.5,0,16,5,0,0, true)],
[objectify(8,10.5,16,16,5,0,0)]
]
},
spyglass:{
verts:[
[objectify(6.9,2.4,6.9,2.2,2.2,0,0, false,false,false,2,2)],
[objectify(6.9,8.6,9.1,2.2,2.2,0,5, false,false,false,2,2),objectify(7,13.5,9,2,2,0,13)],
[objectify(9.1,8.6,9.1,2.2,6.2,0,7, false,false,false,2,6),objectify(9,13.5,9,2,5,0,2)],
[objectify(6.9,8.6,6.9,2.2,6.2,0,7, false,false,false,2,6),objectify(7,13.5,7,2,5,0,2)],
[objectify(9.1,8.6,6.9,2.2,6.2,0,7, false,false,false,2,6),objectify(9,13.5,7,2,5,0,2)],
[objectify(6.9,8.6,9.1,2.2,6.2,0,7, false,false,false,2,6),objectify(7,13.5,9,2,5,0,2)]
]
},
hopper:{
verts:[
[objectify(0,10,0,16,16,0,0),objectify(4,4,4,8,8,4,4),objectify(6,0,6,4,4,6,6)],
[objectify(0,16,16,13,3,35,0),objectify(0,10,16,16,16,0,0),objectify(3,16,3,13,3,32,13),objectify(0,16,13,3,13,45,3),objectify(13,16,16,3,13,32,0)],
[objectify(16,16,16,16,6,16,0),objectify(12,10,12,8,6,20,6),objectify(10,4,10,4,4,22,12),objectify(13,16,3,10,6,19,0)],
[objectify(0,16,0,16,6,16,0),objectify(4,10,4,8,6,20,6),objectify(6,4,6,4,4,22,12),objectify(3,16,13,10,6,19,0)],
[objectify(16,16,0,16,6,16,0),objectify(12,10,4,8,6,20,6),objectify(10,4,6,4,4,22,12),objectify(3,16,3,10,6,19,0)],
[objectify(0,16,16,16,6,16,0),objectify(4,10,12,8,6,20,6),objectify(6,4,10,4,4,22,12),objectify(13,16,13,10,6,19,0)]
]
},
hopperWall:{
verts:[
[objectify(0,10,0,16,16,-16,0),objectify(4,4,4,8,8,-12,4),objectify(6,4,12,4,4,-10,6)],
[objectify(0,16,16,13,3,19,0),objectify(0,10,16,16,16,-16,0),objectify(3,16,3,13,3,16,13),objectify(0,16,13,3,13,29,3),objectify(13,16,16,3,13,16,0),objectify(6,8,16,4,4,6,12)],
[objectify(16,16,16,16,6,0,0),objectify(12,10,12,8,6,4,6),objectify(13,16,3,10,6,3,0),objectify(10,8,16,4,4,6,12)],
[objectify(0,16,0,16,6,0,0),objectify(4,10,4,8,6,4,6),objectify(3,16,13,10,6,3,0)],
[objectify(16,16,0,16,6,0,0),objectify(12,10,4,8,6,4,6),objectify(10,8,12,4,4,6,12),objectify(3,16,3,10,6,3,0)],
[objectify(0,16,16,16,6,0,0),objectify(4,10,12,8,6,4,6),objectify(6,8,16,4,4,6,12),objectify(13,16,13,10,6,3,0)]
],
rotate:true
},
comparator:{
verts:generateComparator(),
rotate:true
},
comparatorOn:{
verts:generateComparator(false,true),
rotate:true
},
comparatorSubtract:{
verts:generateComparator(true),
rotate:true
},
comparatorSubtractOn:{
verts:generateComparator(true,true),
rotate:true
},
daylightDetector:{
verts:[
[objectify(0,0,0,16,16,0,0)],
[objectify(0,6,16,16,16,0,0)],
[objectify(16,6,16,16,6,0,0)],
[objectify(0,6,0,16,6,0,0)],
[objectify(16,6,0,16,6,0,0)],
[objectify(0,6,16,16,6,0,0)]
],
},
pitcherPlant:{
verts:[
[], //bottom
[], //top
[customFace(2,11,2, 14,11,14, 14,-5,14, 2,-5,2, 0,0,16,16,"pitcherCropBottomStage4"),customFace(2,29,2, 14,29,14, 14,11,14, 2,11,2, 0,0,16,16,"pitcherCropTopStage4")], //north
[customFace(14,11,2, 2,11,14, 2,-5,14, 14,-5,2, 0,0,16,16,"pitcherCropBottomStage4"),customFace(14,29,2, 2,29,14, 2,11,14, 14,11,2, 0,0,16,16,"pitcherCropTopStage4")], //south
[customFace(14,11,14, 2,11,2, 2,-5,2, 14,-5,14, 0,0,16,16,"pitcherCropBottomStage4"),customFace(14,29,14, 2,29,2, 2,11,2, 14,11,14, 0,0,16,16,"pitcherCropTopStage4")], //east
[customFace(2,11,14, 14,11,2, 14,-5,2, 2,-5,14, 0,0,16,16,"pitcherCropBottomStage4"),customFace(2,29,14, 14,29,2, 14,11,2, 2,11,14, 0,0,16,16,"pitcherCropTopStage4")]  //west
],
},
pitcherCropStage0:{
verts:[
[objectify(5,0,5,6,6,5,5,null,null,null,null,null,"pitcherCropBottom")],
[objectify(5,4,11,6,6,5,5,null,null,null,null,null,"pitcherCropTop")],
[objectify(11,4,11,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
[objectify(5,4,5,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
[objectify(11,4,5,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
[objectify(5,4,11,6,4,3,10,null,null,null,null,null,"pitcherCropSide")]
],
hitbox:"slab"
},
pitcherCropStage1:{
verts:[
[objectify(3,0,3,10,10,3,3,null,null,null,null,null,"pitcherCropBottom")],
[objectify(3,6,13,10,10,3,3,null,null,null,null,null,"pitcherCropTop")],
[objectify(13,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,22,2, 14,22,14, 14,6,14, 2,6,2, 0,0)],
[objectify(3,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,22,2, 2,22,14, 2,6,14, 14,6,2, 0,0)],
[objectify(13,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,22,14, 2,22,2, 2,6,2, 14,6,14, 0,0)],
[objectify(3,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,22,14, 14,22,2, 14,6,2, 2,6,14, 0,0)]
],
hitbox:"cube"
},
pitcherCropStage3:{
verts:[
[objectify(3,0,3,10,10,3,3,null,null,null,null,null,"pitcherCropBottom")],
[objectify(3,6,13,10,10,3,3,null,null,null,null,null,"pitcherCropTop")],
[objectify(13,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,17,2, 14,17,14, 14,1,14, 2,1,2, 0,0),customFace(2,33,2, 14,33,14, 14,17,14, 2,17,2, 16,0)],
[objectify(3,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,17,2, 2,17,14, 2,1,14, 14,1,2, 0,0),customFace(14,33,2, 2,33,14, 2,17,14, 14,17,2, 16,0)],
[objectify(13,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,17,14, 2,17,2, 2,1,2, 14,1,14, 0,0),customFace(14,33,14, 2,33,2, 2,17,2, 14,17,14, 16,0)],
[objectify(3,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,17,14, 14,17,2, 14,1,2, 2,1,14, 0,0),customFace(2,33,14, 14,33,2, 14,17,2, 2,17,14, 16,0)]
],
hitbox:"tallCube"
},
flat:{
verts:[
[objectify(0,0.25,0,16,16,0,0,false,true)],
[objectify(0,0.25,16,16,16,0,0)],
[],[],[],[]
],
hitbox:"carpet"
},
flowerbed1:{
verts:addStem1x1(addStem1x1(addStem1x1([
[objectify(8,3,8,8,8,0,0,false,true)],
[objectify(8,3,16,8,8,0,0)],
[],[],[],[]
],
11,14,3),
14,10,3),
9,9,3),
hitbox:"layer2",
rotate:true
},
flowerbed2:{
verts:addStem1x1(addStem1x1(addStem1x1([
[objectify(8,3,0,8,16,0,0,false,true)],
[objectify(8,3,8,16,16,0,0)],
[],[],[],[]
],
11,14,3),
14,10,3),
9,9,3),
hitbox:"layer2",
rotate:true
},
flowerbed3:{
verts:addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1([
[objectify(8,3,0,8,16,0,0,false,true),objectify(0,2,0,8,8,8,8,false,true)],
[objectify(8,3,16,8,16,0,0),objectify(0,2,8,8,8,8,8)],
[],[],[],[]
],
11,14,3),
14,10,3),
9,9,3),
6,6,2),
3.5,1.5,2),
1,5,2),
hitbox:"layer2",
rotate:true
},
flowerbed4:{
verts:addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1([
[objectify(8,3,0,8,16,0,0,false,true),objectify(0,2,0,8,16,8,0,false,true)],
[objectify(8,3,16,8,16,0,0),objectify(0,2,16,8,16,8,0)],
[],[],[],[]
],
11,14,3),
14,10,3),
9,9,3),
6,6,2),
3.5,1.5,2),
1,5,2),
hitbox:"layer2",
rotate:true
},
fern:{
verts:[
[],[],
[customFace(16,10,0, 0,10,0, 0,0,8, 16,0,8, 0,0),customFace(0,10,0, 16,10,0, 16,0,8, 0,0,8, 16,0, -16)],
[customFace(0,10,14, 16,10,14, 16,0,8, 0,0,8, 0,0),customFace(16,10,14, 0,10,14, 0,0,8, 16,0,8, 16,0, -16)],
[customFace(2,10,0, 2,10,16, 8,0,16, 8,0,0, 0,0),customFace(2,10,16, 2,10,0, 8,0,0, 8,0,16, 16,0, -16)],
[customFace(12,10,16, 12,10,0, 8,0,0, 8,0,16, 0,0),customFace(12,10,0, 12,10,16, 8,0,16, 8,0,0, 16,0, -16)]
],
hitbox:"cube",
rotate:true
},
ceilingPanel: {
verts: [
[objectify(0, 13, 0, 16, 16, 0, 0)], //bottom
[objectify(0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 3, 0, 0)], //north
[objectify(0, 16, 0, 16, 3, 0, 0)], //south
[objectify(16, 16, 0, 16, 3, 0, 0)], //east
[objectify(0, 16, 16, 16, 3, 0, 0)]  //west
],
rotate: true
},
groundBush:{
verts:addStem1x1(addStem1x1(addStem1x1([
[objectify(0,2,0,16,16,0,0,false,true,-1), objectify(0,5,0,16,16,0,0,false,true,2), objectify(0,8,0,16,16,0,0,false,true,1)],
[objectify(0,2,16,16,16,0,0,false,false,1),objectify(0,5,16,16,16,0,0,false,false,2),objectify(0,8,16,16,16,0,0,false,false,-1)],
[],[],[],[]
],
5,2,8),
12,5,5),
9,14,8),
hitbox:"slab",
rotate:true
},
coralFan:{
verts:[
[],[],
[customFace(16,9,-6, 0,9,-6, 0,0,8, 16,0,8, 0,0),customFace(0,9,-6, 16,9,-6, 16,0,8, 0,0,8, 16,0, -16)],
[customFace(0,9,22, 16,9,22, 16,0,8, 0,0,8, 0,0),customFace(16,9,22, 0,9,22, 0,0,8, 16,0,8, 16,0, -16)],
[customFace(-6,9,0, -6,9,16, 8,0,16, 8,0,0, 0,0),customFace(-6,9,16, -6,9,0, 8,0,0, 8,0,16, 16,0, -16)],
[customFace(22,9,16, 22,9,0, 8,0,0, 8,0,16, 0,0),customFace(22,9,0, 22,9,16, 8,0,16, 8,0,0, 16,0, -16)]
],
hitbox:"cube"
},
coralWallFan:{
verts:[
[],
[
customFace(16,16,-3.8, 0,16,-3.8, 0,7,16, 16,7,16, 0,0),customFace(0,16,-3.8, 16,16,-3.8, 16,7,16, 0,7,16, 16,0, -16),
customFace(16,0,-3.8, 0,0,-3.8, 0,9,16, 16,9,16, 0,0),customFace(0,0,-3.8, 16,0,-3.8, 16,9,16, 0,9,16, 16,0, -16)],
[],[],[],[]
],
hitbox:"cube",
rotate:true
},
rail:{
verts:[
[objectify(0,1,0,16,16,0,0,false,true)],
[objectify(0,1,16,16,16,0,0)],
[],
[],
[],
[]
],
hitbox:"carpet",
rotate:true
},
railDiagonal:{
verts:[
[customFace(16,17,16, 0,17,16, 0,1,0, 16,1,0, 0,0)],
[customFace(0,17,16, 16,17,16, 16,1,0, 0,1,0, 0,0)],
[],
[],
[],
[]
],
hitbox:"cube",
rotate:true
},
item: {
verts: generateItemShape(),
},
/*cube2: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
cube3: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
cube4: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0),objectify(8,-4,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0),objectify(24,12,8,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0),objectify(8,12,-8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0),objectify(24,12,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},
cube5:{
verts:[
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0),objectify(8,-4,-8,16,16,0,0),objectify(16,8,0,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0),objectify(16,24,16,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0),objectify(24,12,8,16,16,0,0),objectify(32,24,16,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0),objectify(8,12,-8,16,16,0,0),objectify(16,24,0,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0),objectify(24,12,-8,16,16,0,0),objectify(32,24,0,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0),objectify(16,24,16,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},*/
tallCube:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 32, 16, 16, 16, 0, 0)], //top
[objectify(16, 32, 16, 16, 32, 0, 0)], //north
[objectify( 0, 32,  0, 16, 32, 0, 0)], //south
[objectify(16, 32,  0, 16, 32, 0, 0)], //east
[objectify( 0, 32, 16, 16, 32, 0, 0)]  //west
],
}
}
win.serverShapes = shapes
for(var shape = 0; shape < 8; shape ++){
shapes["layer"+(shape+1)] = {
verts: layerShape((shape+1)*2)
}
shapes["liquidLayer"+(shape+1)] = {
verts: liquidLayerShape((shape+1)*2)
}
}
function compareArr(arr, out) {
let minX = 1000
let maxX = -1000
let minY = 1000
let maxY = -1000
let minZ = 1000
let maxZ = -1000
let num = 0
for (let i = 0; i < arr.length; i += 3) {
num = arr[i]
minX = minX > num ? num : minX
maxX = maxX < num ? num : maxX
num = arr[i + 1]
minY = minY > num ? num : minY
maxY = maxY < num ? num : maxY
num = arr[i + 2]
minZ = minZ > num ? num : minZ
maxZ = maxZ < num ? num : maxZ
}
out[0] = minX
out[1] = minY
out[2] = minZ
out[3] = maxX
out[4] = maxY
out[5] = maxZ
return out
}
function copyArr(a, b) {
for (let i = 0; i < a.length; i++) {
b[i] = a[i]
}
}
function arrayValuesEqual(a1,a2){
if(a1.length !== a2.length) return false
let minLen = a1.length
for(var i=0; i<minLen; i++){
if(a1[i] !== a2[i]){
return false
}
}
return true
}
function compareMaps(map1, map2) {//from https://stackoverflow.com/questions/35948335/how-can-i-check-if-two-map-objects-are-equal
let testVal;
if (map1.size !== map2.size) {
return false;
}
for (let [key, val] of map1) {
testVal = map2.get(key);
// in cases of an undefined value, make sure the key
// actually exists on the object so there are no false positives
if (testVal !== val || (testVal === undefined && !map2.has(key))) {
return false;
}
}
return true;
}
let defaultWorldSettings = {
tntExplode:true,
killCmdOff:false,
dayNightCycle: true,
blocksFall: true,
attack: true,
fireSpreads: true,
weatherCycle: true,
mobSpawning: true,
autosave: true
}
let worldSettingKeys = Object.keys(defaultWorldSettings)
win.defaultWorldSettings = defaultWorldSettings
const {DoubleToIEEE, IEEEToDouble} = (function(){
let tempArrayBuffer = new ArrayBuffer(8)
let tempUint32 = new Uint32Array(tempArrayBuffer), tempFloat64 = new Float64Array(tempArrayBuffer)
return {
DoubleToIEEE(f) {
tempFloat64[0] = f
return tempUint32
},
IEEEToDouble(a,b) {
tempUint32[0] = a
tempUint32[1] = b
return tempFloat64[0]
}
}
})()
const textEncoder = new TextEncoder(), textDecoder = new TextDecoder()
class BitArrayBuilder {
//chaning this requires changing server side
constructor() {
this.bitLength = 0
this.data = [] // Byte array
}
add(num, bits) {
if (+num !== +num || +bits !== +bits || +bits < 0) throw new Error("Broken")
num &= -1 >>> 32 - bits
if(Math.log2(num) >= bits) throw new Error("too big")
let index = this.bitLength >>> 3
let openBits = 8 - (this.bitLength & 7)
this.bitLength += bits
while (bits > 0) {
this.data[index] |= openBits >= bits ? num << openBits - bits : num >>> bits - openBits
bits -= openBits
index++
openBits = 8
}
return this // allow chaining like arr.add(x, 16).add(y, 8).add(z, 16)
}
addDouble(num){
let [a,b] = DoubleToIEEE(num)
this.add(a,32), this.add(b,32)
}
addBasicString(str, lenBits = 8){
this.add(min(str.length,255),lenBits)
for(let c of str.substring(0,255)) this.add(c.charCodeAt(0),8)
}
addString(str,lenBits = 8){
if(!str.length) return this.add(0,lenBits)
let arr = textEncoder.encode(str), len = arr.length
this.add(len,lenBits)
this.appendArray(arr.subarray(0,len))
}
/**
* Takes all the bits from another BAB and adds them to this one.
* @param {BitArrayBuilder} bab The BAB to append
*/
append(bab) {
// If our bits are already aligned, just add them directly
if ((this.bitLength & 7) === 0) {
this.data.push(...bab.data)
this.bitLength += bab.bitLength
return
}
// Add them 1 at a time, except for the last one
let bits = bab.bitLength
let i = 0
while (bits > 7) {
this.add(bab.data[i++], 8)
bits -= 8
}
if (bits) {
this.add(bab.data[i] >>> 8 - bits, bits)
}
}
appendArray(arr){//same as above, but for Uint8Array
if ((this.bitLength & 7) === 0) {
this.data.push(...arr)
this.bitLength += arr.length*8
return
}
for(let i of arr) this.add(i, 8)
}
appendInt16Array(arr){//same as above, but for Int16Array
for(let i of arr) this.add(i, 16)
}
get array() {
return new Uint8Array(this.data)
}
/**
* @param {Number} num
* @returns The number of bits required to hold num
*/
static bits(num) {
return Math.ceil(Math.log2(num))
}
}
win.BitArrayBuilder = BitArrayBuilder
class BitArrayOverwriter extends BitArrayBuilder{
constructor(data){
super()
this.data = data
}
skip(bits){
this.bitLength += bits
return this
}
overwrite(num, bits){
if (+num !== +num || +bits !== +bits || +bits < 0) throw new Error("Broken")
num &= -1 >>> 32 - bits
if(Math.log2(num) >= bits) throw new Error("too big")
let index = this.bitLength >>> 3
let openBits = 8 - (this.bitLength & 7)
this.bitLength += bits
while (bits > 0) {
if(openBits >= bits){
this.data[index] = (this.data[index] & (~(((1 << bits)-1)<<(openBits - bits)))) | (num << openBits - bits)
}else{
this.data[index] = (this.data[index] & (~((1 << openBits)-1))) | (num >>> bits - openBits)
}
bits -= openBits
index++
openBits = 8
}
return this // allow chaining like arr.add(x, 16).add(y, 8).add(z, 16)
}
}
win.BitArrayOverwriter = BitArrayOverwriter
class BitArrayReader {
//chaning this requires changing server side
/**
* @param {Uint8Array} array An array of values from 0 to 255
*/
constructor(array, allowPassLength) {
this.data = array // Byte array; values are assumed to be under 256
this.bit = 0
this.allowPassLength = allowPassLength
}
get canRead(){
return this.bit < this.data.length*8
}
read(bits, negative = false) {
let openBits = 32 - bits
let { data, bit } = this
this.bit += bits // Move pointer
if (bit > data.length * 8 && !this.allowPassLength) {
throw new Error("Cannot read more bits")
}
let unread = 8 - (bit & 7)
let index = bit >>> 3
let ret = 0
while (bits > 0) {
let n = data[index] & -1 >>> 32 - unread
ret |= bits >= unread ? n << bits - unread : n >> unread - bits
bits -= unread
unread = 8
index++
}
if (negative) {
// console.log("Negative", ret, ret << openBits >> openBits)
return ret << openBits >> openBits
}
return ret
}
readDouble(){
return IEEEToDouble(this.read(32),this.read(32))
}
readBasicString(lenBits = 8){
let len = this.read(lenBits)
let str = ""
for (let i = 0; i < len; i++) str += String.fromCharCode(this.read(8))
return str
}
readString(lenBits = 8){
let len = this.read(lenBits)
if(!len) return ""
let arr = new Uint8Array(len)
for(let i=0; i<len; i++){
arr[i] = this.read(8)
}
return textDecoder.decode(arr)
}
readToNew(bits, allowPassLength){
let ret = new Uint8Array(ceil(bits/8))
let idx = 0
while(bits){
let next = min(bits,8)
bits -= next
ret[idx] = this.read(next) << (8-next)
idx++
}
return new BitArrayReader(ret, allowPassLength)
}
readToArrayBits(bits){
let ret = new Uint8Array(ceil(bits/8))
let idx = 0
while(bits){
let next = min(bits,8)
bits -= next
ret[idx] = this.read(next) << (8-next)
idx++
}
return ret
}
readToArray(length){
let ret = new Uint8Array(length)
for(let i = 0; i < length; i++){
ret[i] = this.read(8)
}
return ret
}
readToInt16Array(length){
let ret = new Uint8Array(length)
for(let i = 0; i < length; i++){
ret[i] = this.read(16, true)
}
return ret
}
skip(bits){
if (this.bit > this.data.length * 8 && !this.allowPassLength) {
throw new Error("Cannot read more bits")
}
this.bit += bits
}
}
win.BitArrayReader = BitArrayReader
/*
Each item in packetTypes is an array.
The array starts with the name of the packet,
then contains more arrays with property, type, and other things.
These are the types:
string, number, bitArray, array, object, boolean,
replacerNumber, mapObject, json, double, int16Array,
includeIf, constant, basicString, int, uint, byte,
sparseArray
For numbers, there are 3 more items that are
the amount of bits needed and how much to
multiply the number by (for precision) and a
boolean that shows if the number can be negative.
For arrays and mapObjects and sparseArrays, there is another item that is the type
of things that it will contain.
For objects, there is another item that contains
arrays, each with a property and a type.
For replacerNumbers, there are two more items
which contains the bits, then an object that
contain things to replace.
For includeIf, there the property name is replaced
with a function that checks returns a boolean.
If the function returns true, the things in the
3rd item are included.
*/
const packetDimension = ['dimension',"replacerNumber",3,["","nether","end"]]
//const packetInv = ["inv","object",[["inv","bitArray"],["survivStr","bitArray"],[o=>o.x!==undefined,"includeIf",[["x","int"],["y","int"],["z","int"]]]]]
const packetGameMode = ['gameMode',"replacerNumber",2,["creative","survival","hardcore","spectator"]]
const packetSlot = [null,"object",[["id","uint"],["amount","byte"],[o=>o.durability!==undefined,"includeIf",["durability","uint"]],[o=>o.customName,"includeIf",["customName","string"]]]]
const packetP = [
['x',"double"], ['y',"double"], ['z',"double"],packetDimension, ['ry',"double"], ['rx',"double"], ['bodyRot',"double"],
['sneaking',"boolean"], ['username',"string"], ['harmEffect',"number",6,1],
[o=>o.crackPos,'includeIf',[['crackPos',"array",[null,"int"]]]], ['crack',"number",5,1,true], ['burning',"boolean"], ['holding',"uint"], ['walking',"boolean"], ['eating',"boolean"], ['sprinting',"boolean"], ['punchEffect',"number",8,8],
['sleeping',"boolean"], ['sitting',"boolean"], ['swimming',"boolean"], ['usingItem',"boolean"], ['hidden',"boolean"], ['spectating',"basicString"], ['scale',"double"],
["velx","double"],["vely","double"],["velz","double"], ["die","boolean"], ["riding","basicString"], ["onGround","boolean"], ["flying",'boolean']
]
const packetFace = ["face","replacerNumber",3,[undefined/*for no face*/,"bottom","top","north","south","east","west"]]
let packetTypes = [
["connect",["id","basicString"]],
["pos",["data","object",packetP],["afk","boolean"]],
["mySkin", ["data","string"], ["cape","string"]],
["settings", ["data","object",worldSettingKeys.map(r => [r,"boolean"])],["time","double"],["weather","replacerNumber",2,["","rain","snow"]]],
["setBlock", ["data","object",[["x","int"],["y","int"],["z","int"],packetDimension,["block","uint"],["keepTags","boolean"]]]],
["loadSave", /*["data","bitArray"], ["stringChunks","number",8,1]*/ ["mod","string"],["id","basicString"],["name","string"],["activeResourcePacks","array",[null,"string"]],["x","double"],["y","double"],["z","double"],["version","basicString"],["time","double"],["weather","replacerNumber",2,["","rain","snow"]],packetGameMode,["cheats","boolean"],["hotbarSlot","byte"],["flying",'boolean'],["achievments","array",[null,"uint"]]],
//["loadSaveChunk", ["data","bitArray"],["idx","number",8,1]],
["resourcePacks",["activeResourcePacks","array",[null,"string"]]],
["serverCmds",["data","array",[null,"object",["type","basicString"],["name","basicString"],["id","uint"],["next","array",[null,"uint"]],[o=>o.redirect!==undefined,"includeIf",["redirect","uint"]],["info","string"],["argType","basicString"],["func","boolean"],["noCheats","boolean"]]]],
["saveProg",["data","basicString"]],
["canSendPos"],
["setTags",["x","int"],["y","int"],["z","int"],packetDimension,["data","json"],["lazy","boolean"]],
["serverChangeBlock",["x","int"],["y","int"],["z","int"],packetDimension,["place","boolean"],packetFace,["shift","boolean"],["blockMode","uint"]],
["entityPos",["data","bitArray"]],
["entityDelete",["id","basicString"]],
["entityPosAll", ["data","array",[null,"bitArray"]]],
//["entEvent",["id","basicString"],["event","basicString"],["data","json"]],
["particles",["particleType","basicString"],["x","double"],["y","double"],["z","double"],packetDimension,["amount","byte"],["data","json"]],
["achievment",["data","uint"]],
//["hit",["damageType","basicString"],["damage","byte"],["velx","double"],["vely","double"],["velz","double"],["username","string"],["id","basicString"],["message","string"],["x","double"],["y","double"],["z","double"],["holding","json"],["burn","number",8,4],["isEntity","boolean"]],
["harmEffect",["id","basicString"]],
["die",["id","basicString"],["message","string"]],
["message",["username","string"],["data","string"],["fromServer","boolean"]],
["playSound",["x","double"],["y","double"],["z","double"],["data","string"],["volume","double"],["pitch","double"],["hasPos","boolean"]],
["title",["data","string"],["sub","string"],["color","string"],["fadeIn","number",32,1],["fadeOut","number",32,1],["stay","number",32,1]],
["remoteControl",["event","basicString"],["key","basicString"],["x","double"],["y","double"]],
["eval",["data","string"]], ["safeEval",["data","json"]],
["error",["data","string"]],
["joined"],
//["serverCmd",["data","string"],["args","json"],["id","string"],["scope","json"]],
["runCmd",["data","string"]],
["loadChunks",["data","array",[null,"int"]],["loadDistance","number",6,1],packetDimension],
["chunkData",["x","int"],["z","int"],["data","bitArray"],["tops","int16Array"],["solidTops","int16Array"],["biomes","bitArray"],["caveY","int16Array"],["caveBiomes","bitArray"]],
["tp",['x',"double"],['y',"double"],['z',"double"],packetDimension],
//["commandDone",["id","string"],["data","json"],["scope","json"]],
["clientCmd",["data","basicString"],["args","json"]],
["dc",["data","basicString"]],
["fetchUsers"],
//["entClick",["id","string"],["holding","uint"],["fromItem","json"]],
["effects",["data","mapObject",[null,"object",[["name","string"],["level","byte"],["time","int"],["showParticles","boolean"]]]]],
["gameMode",packetGameMode,["spectating","basicString"],["spectateRemoteControl","boolean"]],
["openContainer",["data","string"],["x","int"],["y","int"],["z","int"],packetDimension,["side","boolean"]],
//["containerData",["data","sparseArray",packetSlot]],
["containerChange",["data","sparseArray",packetSlot],["idxs","array",[null,"int"]]],
["hotbar",["slot","byte"]],
["entInteract",["data","basicString"],["hit","boolean"],["cooldown","double"]],
["respawn"],
["health",["health","double"],["food","double"],["foodSaturation","double"],["oxygen","double"],["burning","boolean"],["freezeEffect","uint"],["XP","double"],["level","uint"],["nextLevel","uint"]],
["damage",["x","double"],["y","double"],["z","double"],["lastHealth","double"],["velx","double"],["vely","double"],["velz","double"]],
["jump"], ["sleep"], ["sit",["riding","basicString"]],
["rot",["rx","double"],["ry","double"],["bodyRot","double"]],
["closeContainer"],
["containerChangeFurnace",["burnProgress","double"],["progress","double"]],
["containerChangeAnvil",["rename","string"],["cost","uint"]],
["containerChangeCommandBlock",["data","string"]],
["startBreak",["x","int"],["y","int"],["z","int"]],
["containerChangeSign",["data","string"],["side","boolean"]],
["portalOut"], ["doEndPoem"]
/*["test",
["a",'string'],['n','number',8,4],
["data","array",[null,"string"]],
['n2','number',32,1]
]*/
]
win.unorderedPackets = new Set(["chunkData"])
let packetNames = []
let packetIds = {}, defaultPacketData = [["FROM","string"],["USER","string"],["TO","string"]]
for(let i=0; i<packetTypes.length; i++){
let t = packetTypes[i]
if(!t) throw new Error("after "+packetNames[i-1])
packetIds[t[0]] = i
packetNames[i] = t[0]
t.shift()
t.unshift(...defaultPacketData)
}
win.packetTypes = packetTypes
function packetPartToBitArray(i,bab,v){
switch(i[1]){
case "number":
bab.add((v||0)*i[3],i[2])
break
case "json":
v = v ? JSON.stringify(v) : ""
case "string":
if(v){
v = v+""
bab.addString(v,32)
}else bab.add(0,32)
break
case "bitArray":
if(v){
bab.add(v.length,32)
bab.appendArray(v)
}else bab.add(0,32)
break
case "int16Array":
if(v){
bab.add(v.length,32)
bab.appendInt16Array(v)
}else bab.add(0,32)
break
case "array":
bab.add(v.length,32)
for(let j of v){
packetPartToBitArray(i[2],bab,j)
}
break
case "object":
bab.add(v?1:0,1)
if(v) packetToBitArrayLoop(i[2],v,bab)
break
case "boolean":
bab.add(v?1:0,1)
break
case "replacerNumber":
let idx = i[3].indexOf(v)
if(idx === -1) throw new Error("Unknown replacer number for "+v)
bab.add(idx,i[2])
break
case "mapObject":
bab.add(Object.keys(v).length,32)
for(let j in v){
bab.addString(j,8)
packetPartToBitArray(i[2],bab,v[j])
}
break
case "constant":
bab.add(i[2],8)
break
case "basicString":
bab.addBasicString((v||"")+"")
break
case "int":
case "uint":
bab.add(v,32)
break
case "byte":
bab.add(v,8)
break
case "double":
bab.addDouble(v)
break
case "sparseArray":
bab.add(v.length,32)
for(let j of v){
bab.add(j?1:0,1)
if(j) packetPartToBitArray(i[2],bab,j)
}
break
}
}
function packetToBitArrayLoop(type,obj,bab){
for(let i of type){
if(i[1] === "includeIf"){
if(i[0](obj)){
bab.add(1,1)
packetToBitArrayLoop(i[2],obj,bab)
}else bab.add(0,1)
continue
}
const v = obj[i[0]]
packetPartToBitArray(i,bab,v)
}
}
function packetToBitArray(obj, type, returnBAB){
let bab
if(type){
bab = new BitArrayBuilder()
}else{
let id = packetIds[obj.type]
type = packetTypes[id]
if(!type) throw new Error("Unknown packet type: "+obj.type)
bab = new BitArrayBuilder()
bab.add(id,8)
}
packetToBitArrayLoop(type,obj,bab)
return returnBAB ? bab : bab.array
}
win.packetToBitArray = packetToBitArray
function bitArrayToPacketPart(i,reader){
switch(i[1]){
case "number":
return reader.read(i[2],i[4])/i[3]
case "string":
return reader.readString(32)
case "bitArray":
let len = reader.read(32)
return reader.readToArray(len)
case "array":
let len2 = reader.read(32), arr = []
for(let j=0; j<len2; j++){
arr.push(bitArrayToPacketPart(i[2],reader))
}
return arr
case "object":
if(reader.read(1)){
let obj = {}
bitArrayToPacketLoop(i[2],obj,reader)
return obj
}else return
case "boolean":
return reader.read(1)
case "replacerNumber":
return i[3][reader.read(i[2])]
case "mapObject":
let len3 = reader.read(32)
let obj = {}
for(let j=0; j<len3; j++){
obj[reader.readString()] = bitArrayToPacketPart(i[2],reader)
}
return obj
case "json":
let str2 = reader.readString(32)
return str2 ? JSON.parse(str2) : undefined
case "int16Array":
let len4 = reader.read(32)
return reader.readToInt16Array(len4)
case "constant":
return reader.read(8)
case "basicString":
return reader.readBasicString()
case "int":
return reader.read(32,true)
case "uint":
return reader.read(32)
case "byte":
return reader.read(8)
case "double":
return reader.readDouble()
case "sparseArray":
let len5 = reader.read(32), arr2 = []
for(let j=0; j<len5; j++){
arr2.push(reader.read(1) ? bitArrayToPacketPart(i[2],reader) : undefined)
}
return arr2
}
}
function bitArrayToPacketLoop(type,obj,reader){
for(let i of type){
if(i[1] === "includeIf"){
if(reader.read(1)){
bitArrayToPacketLoop(i[2],obj,reader)
}
continue
}
obj[i[0]] = bitArrayToPacketPart(i,reader)
}
}
function bitArrayToPacket(arr,type){
let reader = arr instanceof BitArrayReader ? arr : new BitArrayReader(arr)
let obj
if(type){
obj = {}
}else{
let id = reader.read(8)
type = packetTypes[id], obj = {type:packetNames[id]}
}
bitArrayToPacketLoop(type,obj,reader)
return obj
}
win.bitArrayToPacket = bitArrayToPacket
function initShapes() {
function mapCoords(rect, face) {
if(rect.custom) return mapCustomCoords(rect)
let x = rect.x
let y = rect.y
let z = rect.z
let w = rect.w
let h = rect.h
let tx = rect.tx
let ty = rect.ty
let tw = rect.tw
let th = rect.th
let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
if(rect.rt){
if(rect.rt === -1){
tex[0] = tx+th
tex[5] = ty+tw
tex[6] = tx+th
tex[7] = ty+tw
tex.unshift(...tex.splice(tex.length-2,2))
}else if(rect.rt === 2){
tex.push(...tex.splice(0,4))
}else{
tex[0] = tx+th
tex[5] = ty+tw
tex[6] = tx+th
tex[7] = ty+tw
tex.push(...tex.splice(0,2))
}
}
if(rect.txf){
tex[0] = tw-(tex[0]-tx)+tx
tex[2] = tw-(tex[2]-tx)+tx
tex[4] = tw-(tex[4]-tx)+tx
tex[6] = tw-(tex[6]-tx)+tx
}
if(rect.tyf){
tex[1] = th-(tex[1]-ty)+ty
tex[3] = th-(tex[3]-ty)+ty
tex[5] = th-(tex[5]-ty)+ty
tex[7] = th-(tex[7]-ty)+ty
}
let pos = null, normal = null
switch(face) {
case 0: // Bottom
pos = [x,y,z, x+w,y,z, x+w,y,z+h, x,y,z+h]
normal = [0,1,0]
break
case 1: // Top
pos = [x,y,z, x+w,y,z, x+w,y,z-h, x,y,z-h]
normal = [0,-1,0]
break
case 2: // North
pos = [x,y,z, x-w,y,z, x-w,y-h,z, x,y-h,z]
normal = [0,0,-1]
break
case 3: // South
pos = [x,y,z, x+w,y,z, x+w,y-h,z, x,y-h,z]
normal = [0,0,1]
break
case 4: // East
pos = [x,y,z, x,y,z+w, x,y-h,z+w, x,y-h,z]
normal = [-1,0,0]
break
case 5: // West
pos = [x,y,z, x,y,z-w, x,y-h,z-w, x,y-h,z]
normal = [1,0,0]
break
}
pos = pos.map(c => c / 16 - 0.5)
let minmax = compareArr(pos, [])
pos.max = minmax.splice(3, 3)
pos.min = minmax
tex = tex.map(c => c / 16 / 16)
return {
pos,
tex,
normal
}
}
function mapCustomCoords(coords){
let {x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th} = coords
let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
let pos = [x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4]
pos = pos.map(c => c / 16 - 0.5)
let minmax = compareArr(pos, [])
pos.max = minmax.splice(3, 3)
pos.min = minmax
tex = tex.map(c => c / 16 / 16)
vec1.set(x2-x,y2-y,z2-z)
vec1.crossProduct(x3-x,y3-y,z3-z,vec3)
vec2.set(x3-x,y3-y,z3-z)
vec2.crossProduct(x4-x,y4-y,z4-z,vec4)
vec3.normalize(), vec4.normalize()
let normal = [(vec3.x+vec4.x)/2, (vec3.y+vec4.y)/2, (vec3.z+vec4.z)/2]
return {pos,tex,normal}
}
// 90 degree clockwise rotation; returns a new shape object
function rotate(shape, bit) {
let verts = shape.verts
let texVerts = shape.texVerts
let pos = []
let normal = []
let tex = []
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
pos[i] = []
tex[i] = []
normal[i] = []
for (let j = 0; j < side.length; j++) {
let face = side[j]
let c = []
pos[i][j] = c
for (let k = 0; k < face.length; k += 3) {
c[k] = face[k + 2]
c[k + 1] = face[k + 1]
c[k + 2] = -face[k]
}
tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
if (i === 0) {
// Bottom
c.push(...c.splice(0, 3))
tex[i][j].push(...tex[i][j].splice(0, 2))
}
if (i === 1) {
// Top
c.unshift(...c.splice(-3, 3))
tex[i][j].unshift(...tex[i][j].splice(-2, 2))
}
let minmax = compareArr(c, [])
c.max = minmax.splice(3, 3)
c.min = minmax
normal[i][j] = shape.normal[i][j].slice()
let temp = normal[i][j][0]
normal[i][j][0] = normal[i][j][2]
normal[i][j][2] = -temp
}
}
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
temp = pos[2] // North
pos[2] = pos[5] // North = West
pos[5] = pos[3] // West = South
pos[3] = pos[4] // South = East
pos[4] = temp // East = North
temp = normal[2] // North
normal[2] = normal[5] // North = West
normal[5] = normal[3] // West = South
normal[3] = normal[4] // South = East
normal[4] = temp // East = North
return {
verts: pos,
texVerts: tex,
normal,
rotate: true,
flip: shape.flip,
size: shape.size,
varients: shape.varients,
bit: bit,
rotated: true,
rotateTimes: (shape.rotateTimes || 0) + 1,
originalVerts: shape.originalVerts,
hitbox: shape.hitbox
}
}
// Reflect over the y plane; returns a new shape object
function flip(shape, bit) {
let verts = shape.verts
let texVerts = shape.texVerts
let pos = []
let normal = []
let tex = []
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
pos[i] = []
tex[i] = []
normal[i] = []
for (let j = 0; j < side.length; j++) {
let face = side[j].slice().reverse()
let c = []
pos[i][j] = c
for (let k = 0; k < face.length; k += 3) {
c[k] = face[k + 2]
c[k + 1] = -face[k + 1]
c[k + 2] = face[k]
}
let minmax = compareArr(c, [])
c.max = minmax.splice(3, 3)
c.min = minmax
tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
normal[i][j] = shape.normal[i][j].slice()
normal[i][j][1] = -normal[i][j][1]
}
}
let temp = pos[0] // Bottom
pos[0] = pos[1] // Bottom = Top
pos[1] = temp // Top = Bottom
temp = tex[0] // Bottom
tex[0] = tex[1] // Bottom = Top
tex[1] = temp // Top = Bottom
temp = normal[0] // Bottom
normal[0] = normal[1] // Bottom = Top
normal[1] = temp // Top = Bottom
return {
verts: pos,
texVerts: tex,
normal,
rotate: shape.rotate,
flip: shape.flip,
size: shape.size,
varients: shape.varients,
bit: bit,
originalVerts: shape.originalVerts
}
}
for (let shape in shapes) {
win.sh = shape
let obj = shapes[shape]
let verts = obj.verts
obj.size = verts[0].length + verts[1].length + verts[2].length + verts[3].length + verts[4].length + verts[5].length
obj.texVerts = []
obj.varients = []
obj.normal = []
if(typeof obj.hitbox === "string"){
obj.hitbox = shapes[obj.hitbox]
}
obj.originalVerts = []
for(let i=0; i<verts.length; i++){
obj.originalVerts[i] = verts[i].slice()
}
// Populate the vertex coordinates
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
let texArr = []
obj.texVerts.push(texArr)
let normal = obj.normal[i] = []
for (let j = 0; j < side.length; j++) {
let face = side[j]
let mapped = mapCoords(face, i)
side[j] = mapped.pos
texArr.push(mapped.tex)
normal[j] = mapped.normal
}
}
if (obj.rotate) {
let v = obj.varients
let east = rotate(obj, 4<<10)
let south = rotate(east, 2<<10)
let west = rotate(south, 6<<10)
v[0] = obj
v[2] = south
v[4] = east
v[6] = west
}
if (obj.flip) {
let v = obj.varients
v[1] = flip(obj,1<<10)
if (obj.rotate) {
v[3] = flip(v[2], 3<<10)
v[5] = flip(v[4], 5<<10)
v[7] = flip(v[6], 7<<10)
}
}
}
function makeBlock(tex,shape,Block, base, Name){
Block.textures = tex
Block.shape = shape
Block.shadow = base ? base.shadow : true
Block.transparent = base ? base.transparent : false
Block.solid = base ? base.solid : true
if(Name) Block.Name = Name
}
function rotTex(tex,n){
tex = tex.slice()
if(n){
for(var i=0; i<n; i++){
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
}
}else{
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
}
return tex
}
var buttonOnclick = function(x,y,z,dimension,world){
var off = this.id | BUTTON
var on = this.id | SLAB
var target = null
switch(world.getBlock(x,y,z,dimension)){
case off | NORTH:
target = on | NORTH
break
case off | SOUTH:
target = on | SOUTH
break
case off | EAST:
target = on | EAST
break
case off | WEST:
target = on | WEST
}
if(target){
world.setBlock(x,y,z,target, false,false,false,false,dimension)
}
}
var buttonProjectileHit = function(x,y,z,dimension,ent){
let world = ent.world
this.onclick(x,y,z,dimension,world)
}
var buttonOnupdate = function(x,y,z,b,world,sx,sy,sz,dimension){
var off = this.id | BUTTON
var on = this.id | SLAB
var target = null
var ax=x,ay=y,az=z, dir
var block = world.getBlock(x,y,z,dimension)
switch(block){
case on | NORTH:
case off | NORTH:
az++
dir = "south"
break
case on | SOUTH:
case off | SOUTH:
az--
dir = "north"
break
case on | EAST:
case off | EAST:
ax++
dir = "east"
break
case on | WEST:
case off | WEST:
ax--
dir = "west"
break
}
var hasPower
switch(block){
case on | NORTH:
target = off | NORTH
hasPower = true
break
case on | SOUTH:
target = off | SOUTH
hasPower = true
break
case on | EAST:
target = off | EAST
hasPower = true
break
case on | WEST:
target = off | WEST
hasPower = true
break
}
if(hasPower && !world.getPower(x,y,z,dimension)){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,16,dimension)
world.setBlockPower(ax,ay,az,"strong",dir,dimension)
world.playSound(x,y,z, "click",1,0.6)
world.setTimeout(function(){
world.setBlock(x,y,z,target, false,false,false,false,dimension)
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(ax,ay,az,null,dir,dimension)
world.playSound(x,y,z, "click",1,0.5)
},this.stone ? tickTime*20 : tickTime*30, x,y,z,dimension)
}
}
var pressurePlateActivate = function(x,y,z,dimension,block,ent,world){
if(this.heavyWeighted || this.lightWeighted) return //not going to do those yet
if(world.getBlock(x,y,z,dimension) === this.id && pressurePlateHasPressure(x,y,z,dimension,world)){
world.setBlock(x,y,z, this.id | SLAB, false,false,false,false,dimension)
}
}
var pressurePlateOnupdate = function(x,y,z,b,world,sx,sy,sz,dimension){
var block = world.getBlock(x,y,z,dimension)
if(block === (this.id | SLAB) && !world.getPower(x,y,z,dimension)){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,16,dimension)
world.setBlockPower(x,y-1,z,"strong","top",dimension)
world.playSound(x,y,z, "click",1,0.6)
var me = this
var i = setInterval(function(){
if(pressurePlateHasPressure(x,y,z,dimension,world)) return
clearInterval(i)
world.setTimeout(function(){
world.setBlock(x,y,z,me.id, false,false,false,false,dimension)
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(x,y-1,z,null,"top",dimension)
world.playSound(x,y,z, "click",1,0.5)
}, tickTime*20, x,y,z,dimension)
}, tickTime*2)
}
}
var logicGateOnupdate = function(x,y,z,b,w,sx,sy,sz,dimension){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
}
var logicGateOndelete = function(x,y,z,prevTags,prevBlock,dimension,world){
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(x,y,z+1,null,"south",dimension)
world.setBlockPower(x,y,z-1,null,"north",dimension)
world.setBlockPower(x+1,y,z,null,"east",dimension)
world.setBlockPower(x-1,y,z,null,"west",dimension)
}
var logicGateOnpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var px = 0, pz = 0
switch(block){
case this.id | NORTH:
case this.id | SLAB | NORTH:
pz++
break
case this.id | SOUTH:
case this.id | SLAB | SOUTH:
pz--
break
case this.id | EAST:
case this.id | SLAB | EAST:
px++
break
case this.id | WEST:
case this.id | SLAB | WEST:
px--
break
}
var shouldBeOn = this.shouldBeOn(x,y,z,dimension,px,pz,world)
var isOn = false
var target, tx = x, ty = y, tz = z, side
switch(block){
case this.id | NORTH:
target = this.id | SLAB | NORTH
tz++
side = "south"
break
case this.id | SOUTH:
target = this.id | SLAB | SOUTH
tz--
side = "north"
break
case this.id | EAST:
target = this.id | SLAB | EAST
tx++
side = "east"
break
case this.id | WEST:
target = this.id | SLAB | WEST
tx--
side = "west"
break
case this.id | SLAB | NORTH:
isOn = true
target = this.id | NORTH
tz++
side = "south"
break
case this.id | SLAB | SOUTH:
isOn = true
target = this.id | SOUTH
tz--
side = "north"
break
case this.id | SLAB | EAST:
isOn = true
target = this.id | EAST
tx++
side = "east"
break
case this.id | SLAB | WEST:
isOn = true
target = this.id | WEST
tx--
side = "west"
break
}
var tblock = world.getBlock(tx,ty,tz,dimension)
if(tblock && blockData[tblock].carryRedstone){
if(isOn){
if(world.getPower(tx,ty,tz,dimension) !== 15){
world.setPower(tx,ty,tz,15,false,dimension)
world.spreadPower(tx,ty,tz,15,dimension)
}
}
}else if(tblock && !blockData[tblock].transparent){
if(isOn){
world.setBlockPower(tx,ty,tz,"strong",side,dimension)
}else{
world.setBlockPower(tx,ty,tz,null,side,dimension)
}
}
if(isOn !== shouldBeOn){
var t = function(){
world.setBlock(x,y,z,target,false,false,false,false,dimension)
var tblock = world.getBlock(tx,ty,tz,dimension)
if(shouldBeOn){
if(tblock && blockData[tblock].carryRedstone){
world.setPower(tx,ty,tz,15,false,dimension)
world.spreadPower(tx,ty,tz,15,dimension)
}else if(tblock && !blockData[tblock].transparent){
world.setBlockPower(tx,ty,tz,"strong",side,dimension)
}
}else{
if(tblock && blockData[tblock].carryRedstone){
world.unspreadPower(tx,ty,tz,15,true,dimension)
}else if(tblock && !blockData[tblock].transparent){
world.setBlockPower(tx,ty,tz,null,side,dimension)
}
}
}
world.setTimeout(t,tickTime*2, x,y,z,dimension)
}
}
var logicGateGetFacing = function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
switch(block){
case this.id | NORTH:
case this.id | SLAB | NORTH:
return "north"
case this.id | SOUTH:
case this.id | SLAB | SOUTH:
return "south"
case this.id | EAST:
case this.id | SLAB | EAST:
return "east"
case this.id | WEST:
case this.id | SLAB | WEST:
return "west"
}
}
var logicGateCanHavePower = function(rx,ry,rz,x,y,z,dimension,world){
var tx = rx, ty = ry, tz = rz, on
var block = world.getBlock(rx,ry,rz,dimension)
switch(block){
case this.id | NORTH | SLAB:
on = true
case this.id | NORTH:
tz++
break
case this.id | SOUTH | SLAB:
on = true
case this.id | SOUTH:
tz--
break
case this.id | EAST | SLAB:
on = true
case this.id | EAST:
tx++
break
case this.id | WEST | SLAB:
on = true
case this.id | WEST:
tx--
break
}
if(on && tx === x && ty === y && tz === z){
return 15
}
return 0
}
var signOnplace = function(x,y,z, dimension, player,world){
var block = world.getBlock(x,y,z,dimension)
var tags = {sign:true}
var rot = round(player.ry*16/Math.PId)
if((block & STAIR) === STAIR) rot = round(rot/4)*4
tags.rot = rot
world.setTags(x,y,z,tags,false,dimension)
}
var signOnclick = function(x,y,z,dimension,world,p){
if(p.holding && blockData[p.holding].dye){
world.setTagByName(x,y,z, "color",colors.dye[blockData[p.holding].dye].slice(),false,dimension)
}else if(p.holding && p.holding === blockIds.glowInkSac){
let side = getSignSide(world.getTags(x,y,z,dimension),p) ? "glow2" : "glow"
world.setTagByName(x,y,z, side,true,false,dimension)
}else{
p.connection.send({type:"openContainer",data:"sign",x,y,z,dimension})
}
}
var itemFrameOnclick = function(x,y,z, dimension,world, p){
var prev = world.getTagByName(x,y,z,"block",dimension) || 0
if(!prev && p.holding) world.setTagByName(x,y,z, "block",p.holding,false,dimension)
else{
var rot = world.getTagByName(x,y,z,"rot",dimension) || 0
rot++
if(rot >= 8) rot = 0
world.setTagByName(x,y,z, "rot",rot,false,dimension)
}
}
let doorToggle = function(x,y,z,dimension,world){
var b = world.getBlock(x,y,z,dimension)
var o = (b & DOOR) !== DOOR
var shapeId = o ? (this.id | SLAB) : (this.id | DOOR)
var setId = o ? (this.id | DOOR) : (this.id | SLAB)
var set
if(o){
if((shapeId | NORTH) === b){
set = setId | EAST
}else if((shapeId | EAST) === b){
set = setId | SOUTH
}else if((shapeId | SOUTH) === b){
set = setId | WEST
}else if((shapeId | WEST) === b){
set = setId | NORTH
}
}else{
if((shapeId | NORTH) === b){
set = setId | WEST
}else if((shapeId | WEST) === b){
set = setId | SOUTH
}else if((shapeId | SOUTH) === b){
set = setId | EAST
}else if((shapeId | EAST) === b){
set = setId | NORTH
}
}
world.setBlock(x,y,z,set, false,false,false,false,dimension)
doorSound(x,y,z,this.name === "ironDoor"?"iron_door":"wooden_door",!o,world)
}
let trapdoorToggle = function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension)
let target
switch(block){
case this.id | TRAPDOOR | NORTH:
target = this.id | TRAPDOOROPEN | NORTH
break
case this.id | TRAPDOOR | SOUTH:
target = this.id | TRAPDOOROPEN | SOUTH
break
case this.id | TRAPDOOR | EAST:
target = this.id | TRAPDOOROPEN | EAST
break
case this.id | TRAPDOOR | WEST:
target = this.id | TRAPDOOROPEN | WEST
break
}
world.setBlock(x,y,z,target,false,false,false,false,dimension)
doorSound(x,y,z,this.name === "ironTrapdoor"?"iron_trapdoor":"wooden_trapdoor",true,world)
}
let trapdoorOpenToggle = function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension)
let target
switch(block){
case this.id | TRAPDOOROPEN | NORTH:
target = this.id | TRAPDOOR | NORTH
break
case this.id | TRAPDOOROPEN | SOUTH:
target = this.id | TRAPDOOR | SOUTH
break
case this.id | TRAPDOOROPEN | EAST:
target = this.id | TRAPDOOR | EAST
break
case this.id | TRAPDOOROPEN | WEST:
target = this.id | TRAPDOOR | WEST
break
}
world.setBlock(x,y,z,target,false,false,false,false,dimension)
doorSound(x,y,z,this.name === "ironTrapdoor"?"iron_trapdoor":"wooden_trapdoor",false,world)
}
function clickBed(x,y,z,dimension,world,p){
if(dimension !== "") return world.explode(x,y,z,5,false,dimension)
p.spawnPoint.x = x
p.spawnPoint.y = y+1
p.spawnPoint.z = z
p.connection.send({type:"message",data:"Respawn point set",fromServer:true})
if(world.skyLight < 0.5){
let block = world.getBlock(x,y,z,dimension)
y += 0.25
p.rx = Math.PI2
switch(block & ROTATION){
case NORTH:
z += 0.5
p.ry = Math.PI
break
case SOUTH:
z -= 0.5
p.ry = 0
break
case EAST:
x += 0.5
p.ry = Math.PI2
break
case WEST:
x -= 0.5
p.ry = -Math.PI2
break
}
p.setRot(p.rx,p.ry,p.ry,true)
p.tp(x,y,z)
p.connection.send({type:"sleep"})
}else p.connection.send({type:"message",data:"Too bright to sleep",fromServer:true})
}
function sit(x,y,z,dimension,world,p){
if(x !== undefined){
p.tp(x,y,z)
p.riding = null
const block = world.getBlock(x,y,z,dimension)
switch(block & ROTATION){
case NORTH:
p.ry = Math.PI
break
case SOUTH:
p.ry = 0
break
case EAST:
p.ry = Math.PI2
break
case WEST:
p.ry = -Math.PI2
break
}
p.setRot(p.rx,p.ry,p.ry,true)
}
p.sitting = true
p.flying = false
p.velx = p.vely = p.velz = 0
p.connection.send({type:"sit",riding:p.riding})
}
const liquidData = {
getLevel:function(block){
switch(block){
case this.id | LAYER1:
return 1
case this.id | LAYER2:
return 2
case this.id | LAYER3:
return 3
case this.id | LAYER4:
return 4
case this.id | LAYER5:
return 5
case this.id | LAYER6:
return 6
case this.id | LAYER7:
return 7
case this.id | LAYER8:
case this.id:
return 8
default:
return 0
}
},
getLevelBlock:function(l){
switch(l){
case 1:
return this.id | LAYER1
case 2:
return this.id | LAYER2
case 3:
return this.id | LAYER3
case 4:
return this.id | LAYER4
case 5:
return this.id | LAYER5
case 6:
return this.id | LAYER6
case 7:
return this.id | LAYER7
case 8:
return this.id | LAYER8
}
},
getLevelAt:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
return this.getLevel(block)
},
isThisHere:function(x,y,z,d,world){
var b = world.getBlock(x,y,z,d)
return b && blockData[b].id === this.id
},
isThis:function(b){
return b && blockData[b].id === this.id
},
isSourceAt:function(x,y,z,d,world){
var b = world.getBlock(x,y,z,d)
return b === this.id
},
tryFlowTo:function(x,y,z,dimension,level,world,fromSource=false){
let block = world.getBlock(x,y,z,dimension)
const data = blockData[block]
if(data.liquid){
if(this.id === block) return !fromSource//source blocks must spread around other source blocks when above
else if(this.id === data.id) return true
}
if(!block || data.liquidBreakable || data.liquid && this.density > data.density){
world.setBlock(x,y,z,this.getLevelBlock(level),false,false,false,false,dimension)
if(data.liquidBreakable === "drop"){
world.addItems(x,y,z,dimension,0,0,0,block,true)
world.blockParticles(block,x,y,z,30, "break",dimension)
world.blockSound(block, "dig", x,y,z)
}
return true
}
},
flow:function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension)
if(!this.isThis(block)) return
let source = block === this.id
let level = this.getLevel(block)
let down = world.getBlock(x,y-1,z,dimension)
if(!source){
if(this.canDuplicate && (world.getBlock(x,y,z+1,dimension) === this.id)+(world.getBlock(x,y,z-1,dimension) === this.id)+(world.getBlock(x+1,y,z,dimension) === this.id)+(world.getBlock(x-1,y,z,dimension) === this.id) >= 2 && (down || down === this.id)){
return world.setBlock(x,y,z,this.id, false,false,false,false,dimension) //if two or more sources surrounding, turn into source
}
let levelTarget = level
if(this.isThisHere(x,y+1,z,dimension,world)){
levelTarget = 8
}else{
let around = max(this.getLevelAt(x,y,z+1,dimension,world), this.getLevelAt(x,y,z-1,dimension,world), this.getLevelAt(x+1,y,z,dimension,world), this.getLevelAt(x-1,y,z,dimension,world))
around = this.getLevelDifference(around,dimension)
if(around !== levelTarget) levelTarget = around
if(levelTarget <= 0) return world.setBlock(x,y,z,0, false,false,false,false,dimension)
}
if(level !== levelTarget){
level = levelTarget
world.setBlock(x,y,z,this.getLevelBlock(level), false,false,false,false,dimension)
}
}else{
let above = world.getBlock(x,y+1,z,dimension)
if(blockData[above].liquid && blockData[above].density > this.density){
world.setBlock(x,y,z,above,false,false,false,false,dimension)
world.setBlock(x,y+1,z,block,false,false,false,false,dimension)
return
}
}
let newLevel = this.getLevelDifference(level,dimension)
if(!this.tryFlowTo(x,y-1,z,dimension,8,world,source) && newLevel > 0){
this.tryFlowTo(x,y,z+1,dimension,newLevel,world)
this.tryFlowTo(x,y,z-1,dimension,newLevel,world)
this.tryFlowTo(x+1,y,z,dimension,newLevel,world)
this.tryFlowTo(x-1,y,z,dimension,newLevel,world)
}
},
current:{
x:0,z:0,
ang4:Math.sqrt(0.5),
ang8:Math.sqrt(5)
},
getCurrent:function(bx,by,bz,dimension,level,noNormalize,world){
if(level === undefined) level = this.getLevelAt(bx,by,bz,dimension,world)
let x = this.getLevelAt(bx-1,by,bz,dimension,world)
let X = this.getLevelAt(bx+1,by,bz,dimension,world)
let z = this.getLevelAt(bx,by,bz-1,dimension,world)
let Z = this.getLevelAt(bx,by,bz+1,dimension,world)
let current = this.current
current.x = (X && X < level) + (x > level) - (X > level) - (x && x < level)
current.z = (Z && Z < level) + (z > level) - (Z > level) - (z && z < level)
if(noNormalize) return current
let mag = Math.sqrt(current.x * current.x + current.z * current.z)
current.x /= mag
current.z /= mag
return current
},
isThisLocalHere:function(x,y,z,dimension,blocks,func,world){
return blockData[func.call(world, x, y, z, (func === getBlock ? blocks : dimension))].id === this.id
},
trySpawnFlow:function(x,y,z,dimension,world,level,spread,fromSource=false){
let block = world.getBlock(x,y,z,dimension)
if(blockData[block].liquid && (block&isCube) === block) return !fromSource //source blocks must spread around other source blocks when above
let hasSpawnedUnder = this.onspawnflow && this.onspawnflow(x,y,z,dimension,world)
if(!blockData[block].solid && level > this.getLevel(block)){
world.spawnBlock(x,y,z,this.getLevelBlock(level),dimension,true)
if(!hasSpawnedUnder) spread.push(x,y,z,level)
}
return !blockData[block].solid
},
spawnFlow:async function(x,y,z,dimension,world){
let spread = [x,y,z,8], count = 0
while(spread.length){
let [sx,sy,sz,level] = spread
let newLevel = this.getLevelDifference(level,dimension)
if(newLevel > 0 && max(abs(sx-x),abs(sz-z)) < 16 && abs(sy-y) < 64){
const fromSource = sx === x && sy === y && sz === z
if(!this.trySpawnFlow(sx,sy-1,sz,dimension,world,8,spread,fromSource)){
this.trySpawnFlow(sx+1,sy,sz,dimension,world,newLevel,spread)
this.trySpawnFlow(sx-1,sy,sz,dimension,world,newLevel,spread)
this.trySpawnFlow(sx,sy,sz+1,dimension,world,newLevel,spread)
this.trySpawnFlow(sx,sy,sz-1,dimension,world,newLevel,spread)
}
}
spread.splice(0,4)
if(!((count++)%32)) await yieldThread()
}
}
}
const railData = {
lastConnectSides: {},
isFacing: function(x,y,z,dimension,side,setLastConnectSides){//are there sides of that rail facing in direction
let block = world.getBlock(x,y,z,dimension)
if(!blockData[block].rail) return false
let rot = (block&ROTATION)
if((block&isState) === CUBE || (block&isState) === SLAB){
if(side === "north" || side === "south"){
if(rot === NORTH || rot === SOUTH) return this.lastConnectSides[setLastConnectSides] = true
}else{
if(rot === EAST || rot === WEST) return this.lastConnectSides[setLastConnectSides] = true
}
}else{//corner rail
if(rot === NORTH){
if(side === "south" || side === "west") return this.lastConnectSides[setLastConnectSides] = true
}else if(rot === SOUTH){
if(side === "north" || side === "east") return this.lastConnectSides[setLastConnectSides] = true
}else if(rot === WEST){
if(side === "south" || side === "east") return this.lastConnectSides[setLastConnectSides] = true
}else if(rot === EAST){
if(side === "north" || side === "west") return this.lastConnectSides[setLastConnectSides] = true
}
}
return false
},
isConnected: function(x,y,z,dimension){//returns number of sides connected
let block = world.getBlock(x,y,z,dimension)
if(!blockData[block].rail) return
let rot = (block&ROTATION)
if((block&isState) === CUBE){
if(rot === NORTH || rot === SOUTH) return this.isFacing(x,y,z+1,dimension,"south","north") + this.isFacing(x,y,z-1,dimension,"north","south")
else return this.isFacing(x+1,y,z,dimension,"west","east") + this.isFacing(x-1,y,z,dimension,"east","west")
}else if((block&isState) === SLAB){
if(rot === NORTH) return this.isFacing(x,y+1,z+1,dimension,"south","northUp") + this.isFacing(x,y,z-1,dimension,"north","south")
else if(rot === SOUTH) return this.isFacing(x,y+1,z-1,dimension,"north","southUp") + this.isFacing(x,y,z+1,dimension,"south","north")
else if(rot === EAST) return this.isFacing(x+1,y+1,z,dimension,"west","eastUp") + this.isFacing(x-1,y,z,dimension,"east","west")
else if(rot === WEST) return this.isFacing(x-1,y+1,z,dimension,"east","westUp") + this.isFacing(x+1,y,z,dimension,"west","east")
}else{//corner rail
if(rot === NORTH) return this.isFacing(x,y,z-1,dimension,"north","south")+this.isFacing(x-1,y,z,dimension,"east","west")
else if(rot === SOUTH) return this.isFacing(x,y,z+1,dimension,"south","north")+this.isFacing(x+1,y,z,dimension,"west","east")
else if(rot === WEST) return this.isFacing(x,y,z-1,dimension,"north","south")+this.isFacing(x+1,y,z,dimension,"west","east")
else if(rot === EAST) return this.isFacing(x,y,z+1,dimension,"south","north")+this.isFacing(x-1,y,z,dimension,"east","west")
}
},
railonupdate: function(x,y,z,b,world,dimension){
this.lastConnectSides.north = this.lastConnectSides.south = this.lastConnectSides.east = this.lastConnectSides.west = this.lastConnectSides.northUp = this.lastConnectSides.southUp = this.lastConnectSides.eastUp = this.lastConnectSides.westUp = false
if(this.isConnected(x,y,z,dimension) === 2) return
let {north:curConnectNorth, south:curConnectSouth, east:curConnectEast, west:curConnectWest, northUp:curConnectNorthUp, southUp:curConnectSouthUp, eastUp:curConnectEastUp, westUp:curConnectWestUp} = this.lastConnectSides
//below: is the other rail available for connecting or already connected to this rail
let north = this.isConnected(x,y,z+1,dimension) < 2 || curConnectNorth,
south = this.isConnected(x,y,z-1,dimension) < 2 || curConnectSouth,
east = this.isConnected(x+1,y,z,dimension) < 2 || curConnectEast,
west = this.isConnected(x-1,y,z,dimension) < 2 || curConnectWest,
northUp = this.isConnected(x,y+1,z+1,dimension) < 2 || curConnectNorthUp,
southUp = this.isConnected(x,y+1,z-1,dimension) < 2 || curConnectSouthUp,
eastUp = this.isConnected(x+1,y+1,z,dimension) < 2 || curConnectEastUp,
westUp = this.isConnected(x-1,y+1,z,dimension) < 2 || curConnectWestUp
this.lastConnectSides.north = false
north = north || this.isConnected(x,y-1,z+1,dimension) < 2 || this.lastConnectSides.north
this.lastConnectSides.south = false
south = south || this.isConnected(x,y-1,z-1,dimension) < 2 || this.lastConnectSides.south
this.lastConnectSides.east = false
east = east || this.isConnected(x+1,y-1,z,dimension) < 2 || this.lastConnectSides.east
this.lastConnectSides.west = false
west = west || this.isConnected(x-1,y-1,z,dimension) < 2 || this.lastConnectSides.west
let target = this.id
if(northUp){
target |= SLAB | NORTH
}else if(eastUp){
target |= SLAB | EAST
}else if(southUp){
target |= SLAB | SOUTH
}else if(westUp){
target |= SLAB | WEST
}else if(this.name === "rail" && north && east){
target |= STAIR | SOUTH
}else if(this.name === "rail" && east && south){
target |= STAIR | WEST
}else if(this.name === "rail" && south && west){
target |= STAIR | NORTH
}else if(this.name === "rail" && west && north){
target |= STAIR | EAST
}else if(north || south){
target |= NORTH
}else if(east || west){
target |= EAST
}else return
target |= (b&FLIP)
if(b !== target){
world.setBlock(x,y,z,target,false,false,false,true,dimension)
}
},
onset: function(x,y,z,dimension,world){
world.updateBlock(x,y+1,z+1,false,false,null,null,null,dimension)
world.updateBlock(x,y+1,z-1,false,false,null,null,null,dimension)
world.updateBlock(x+1,y+1,z,false,false,null,null,null,dimension)
world.updateBlock(x-1,y+1,z,false,false,null,null,null,dimension)
world.updateBlock(x,y-1,z+1,false,false,null,null,null,dimension)
world.updateBlock(x,y-1,z-1,false,false,null,null,null,dimension)
world.updateBlock(x+1,y-1,z,false,false,null,null,null,dimension)
world.updateBlock(x-1,y-1,z,false,false,null,null,null,dimension)
if(this.carryRedstone){
let power = world.getRedstoneWirePower(x,y,z,dimension)
let strong = world.getSurroundingBlockPower(x,y,z,dimension) === "strong"
if(strong) power = 15
world.setTagByName(x,y,z,"power",power,false,dimension)
if(power) world.spreadPower(x,y,z,power,dimension)
}
},
ondelete:function(x,y,z,prevTags,prev,dimension,world){
world.updateBlock(x,y+1,z+1,false,false,null,null,null,dimension)
world.updateBlock(x,y+1,z-1,false,false,null,null,null,dimension)
world.updateBlock(x+1,y+1,z,false,false,null,null,null,dimension)
world.updateBlock(x-1,y+1,z,false,false,null,null,null,dimension)
world.updateBlock(x,y-1,z+1,false,false,null,null,null,dimension)
world.updateBlock(x,y-1,z-1,false,false,null,null,null,dimension)
world.updateBlock(x+1,y-1,z,false,false,null,null,null,dimension)
world.updateBlock(x-1,y-1,z,false,false,null,null,null,dimension)
if(this.carryRedstone){
const power = getTagBits(prevTags,"power",this.id)
if(power) world.unspreadPower(x,y,z,power,false,dimension)
}
}
}
for (let i = 0; i < BLOCK_COUNT; i++) {
let baseBlock = blockData[i]
if(baseBlock.item && baseBlock.name !== "bow"){
if(baseBlock.spyglass) baseBlock.shape = shapes.spyglass
else baseBlock.shape = shapes.item
continue
}
let drop = baseBlock.drop || i
let d = baseBlock.drop
let slabBlock = Object.create(baseBlock)
let stairBlock = Object.create(baseBlock)
let crossBlock = Object.create(baseBlock)
let tallcrossBlock = Object.create(baseBlock)
let doorBlock = Object.create(baseBlock)
let torchBlock = Object.create(baseBlock)
let lanternBlock = Object.create(baseBlock)
let lanternHangBlock = Object.create(baseBlock)
let beaconBlock = Object.create(baseBlock)
let cactusBlock = Object.create(baseBlock)
let paneBlock = Object.create(baseBlock)
let portalBlock = Object.create(baseBlock)
let trapdoorBlock = Object.create(baseBlock)
let openTrapdoor = Object.create(baseBlock)
let wallFlatBlock = Object.create(baseBlock)
let fenceBlock = Object.create(baseBlock)
let wallPostBlock = Object.create(baseBlock)
let buttonBlock = Object.create(baseBlock)
let chainBlock = Object.create(baseBlock)
let potBlock = Object.create(baseBlock)
let potCrossBlock = Object.create(baseBlock)
let cornerStairInBlock = Object.create(baseBlock)
let cornerStairOutBlock = Object.create(baseBlock)
let verticalSlabBlock = Object.create(baseBlock)
baseBlock.shape = baseBlock.shapeName ? shapes[baseBlock.shapeName] : shapes.cube
slabBlock.shape = shapes.slab
slabBlock.transparent = true
slabBlock.drop = d || (i | SLAB)
slabBlock.Name += " Slab"
stairBlock.shape = shapes.stair
stairBlock.transparent = true
stairBlock.drop = d || (i | STAIR)
stairBlock.Name += " Stair"
crossBlock.shape = shapes.cross
crossBlock.drop = drop
tallcrossBlock.shape = shapes.tallCross
tallcrossBlock.drop = drop
doorBlock.shape = shapes.door
doorBlock.drop = drop
torchBlock.shape = shapes.torch
torchBlock.drop = drop
lanternBlock.shape = shapes.lantern
lanternHangBlock.shape = shapes.lanternHang
beaconBlock.shape = shapes.beacon
beaconBlock.drop = drop
cactusBlock.shape = shapes.cactus
cactusBlock.drop = drop
paneBlock.shape = shapes.pane
paneBlock.drop = drop
portalBlock.shape = shapes.portal
wallFlatBlock.shape = shapes.wallFlat
wallFlatBlock.drop = drop
trapdoorBlock.shape = shapes.trapdoor
trapdoorBlock.drop = drop
openTrapdoor.shape = shapes.trapdoorOpen
openTrapdoor.drop = drop
fenceBlock.shape = shapes.fence
fenceBlock.transparent = true
fenceBlock.drop = drop
wallPostBlock.shape = shapes.wallpost
wallPostBlock.transparent = true
wallPostBlock.drop = drop
buttonBlock.shape = shapes.button
buttonBlock.drop = drop
chainBlock.shape = shapes.chain
chainBlock.drop = drop
potBlock.shape = shapes.pot
potBlock.drop = drop
potCrossBlock.shape = shapes.potCross
potCrossBlock.drop = drop
cornerStairInBlock.shape = shapes.stairCornerIn
cornerStairInBlock.transparent = true
cornerStairInBlock.drop = d || (i | STAIR)
cornerStairOutBlock.shape = shapes.stairCornerOut
cornerStairOutBlock.transparent = true
cornerStairOutBlock.drop = d || (i | STAIR)
verticalSlabBlock.shape = shapes.verticalSlab
verticalSlabBlock.transparent = true
verticalSlabBlock.drop = d || (i | VERTICALSLAB)
verticalSlabBlock.Name += " Vertical Slab"
if(baseBlock.torch || baseBlock.chain){
slabBlock.drop = i
}
if(baseBlock.door){
var onclick = baseBlock.name === "ironDoor" ? emptyFunc : function(x,y,z,dimension,world){
this.toggle(x,y,z,dimension,world)
}
var onpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension) ? true : false
let block = world.getBlock(x,y,z,dimension)
var open = (block & DOOR) !== DOOR
if(power !== open) this.toggle(x,y,z,dimension,world)
}
baseBlock.toggle = doorToggle.bind(baseBlock)
baseBlock.onclick = onclick.bind(baseBlock)
baseBlock.onpowerupdate = onpowerupdate.bind(baseBlock)
slabBlock.shape = shapes.door2
slabBlock.drop = i
slabBlock.Name = "Inverted "+baseBlock.name
}
if(baseBlock.trapdoor){
var onclick = baseBlock.name === "ironTrapdoor" ? emptyFunc : function(x,y,z,dimension,world){
this.toggle(x,y,z,dimension,world)
}
var onpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension) ? true : false
let block = world.getBlock(x,y,z,dimension)
var open = (block & TRAPDOOR) !== TRAPDOOR
if(power !== open) this.toggle(x,y,z,dimension,world)
}
trapdoorBlock.toggle = trapdoorToggle.bind(baseBlock)
openTrapdoor.toggle = trapdoorOpenToggle.bind(baseBlock)
trapdoorBlock.onclick = onclick.bind(trapdoorBlock)
openTrapdoor.onclick = onclick.bind(openTrapdoor)
trapdoorBlock.onpowerupdate = onpowerupdate.bind(trapdoorBlock)
openTrapdoor.onpowerupdate = onpowerupdate.bind(openTrapdoor)
}
if(baseBlock.bed){
baseBlock.shape = shapes.bed
baseBlock.onclick = clickBed
}
if(baseBlock.rotate) baseBlock.shape = shapes.rotate
if(baseBlock.SW) baseBlock.shape = shapes.SW
if(baseBlock.cactus) potCrossBlock.shape = shapes.cactusPot
if(baseBlock.crop) baseBlock.shape = shapes.crop
if(baseBlock.tallCrop)baseBlock.shape = shapes.tallCrop
if(baseBlock.anvil) baseBlock.shape = shapes.anvil
if(baseBlock._1PixLower) baseBlock.shape = shapes._1PixLower, baseBlock.transparent = true
if(baseBlock.torch) slabBlock.shape = shapes.wallTorch
if(baseBlock.sporeBlossom) baseBlock.shape = shapes.sporeBlossom
if(baseBlock.azalea){
baseBlock.shape = shapes.azalea
potCrossBlock.shape = shapes.azaleaPot
var t = baseBlock.potTex
potCrossBlock.textures = [t[0],t[0],t[1],t[1],t[1],t[1]]
}
if(baseBlock.sunflower) baseBlock.shape = shapes.sunflower
if(baseBlock.sideCross){baseBlock.shape = shapes.sideCross; slabBlock.shape = shapes.bottomCross}
if(baseBlock.layers){
torchBlock.shape = shapes.layer1
torchBlock.solid = true
torchBlock.shadow = false
torchBlock.dropAmount = 1
slabBlock.shape = shapes.layer2
slabBlock.solid = true
slabBlock.shadow = false
slabBlock.dropAmount = 2
stairBlock.shape = shapes.layer3
stairBlock.solid = true
stairBlock.shadow = false
stairBlock.dropAmount = 3
crossBlock.shape = shapes.layer4
crossBlock.solid = true
crossBlock.shadow = false
crossBlock.dropAmount = 4
tallcrossBlock.shape = shapes.layer5
tallcrossBlock.solid = true
tallcrossBlock.shadow = false
tallcrossBlock.dropAmount = 5
lanternBlock.shape = shapes.layer6
lanternBlock.solid = true
lanternBlock.shadow = false
lanternBlock.dropAmount = 6
lanternHangBlock.shape = shapes.layer7
lanternHangBlock.solid = true
lanternHangBlock.shadow = false
lanternHangBlock.dropAmount = 7
doorBlock.shape = shapes.layer8
doorBlock.solid = true
doorBlock.shadow = false
doorBlock.dropAmount = 8
}
if(baseBlock.liquid){
Object.assign(baseBlock,liquidData)
baseBlock.shape = shapes.liquidLayer8
torchBlock.shape = shapes.liquidLayer1
torchBlock.ambientSound = baseBlock.flowSound
slabBlock.shape = shapes.liquidLayer2
slabBlock.ambientSound = baseBlock.flowSound
stairBlock.shape = shapes.liquidLayer3
stairBlock.ambientSound = baseBlock.flowSound
crossBlock.shape = shapes.liquidLayer4
crossBlock.ambientSound = baseBlock.flowSound
tallcrossBlock.shape = shapes.liquidLayer5
tallcrossBlock.ambientSound = baseBlock.flowSound
lanternBlock.shape = shapes.liquidLayer6
lanternBlock.ambientSound = baseBlock.flowSound
lanternHangBlock.shape = shapes.liquidLayer7
lanternHangBlock.ambientSound = baseBlock.flowSound
doorBlock.shape = shapes.liquidLayer8
doorBlock.ambientSound = baseBlock.flowSound
}
if(baseBlock.name === "grass"){
crossBlock.shape = shapes.cube
crossBlock.textures = ["dirt","grassTop","snowGrass","snowGrass","snowGrass","snowGrass"]
crossBlock.solid = true
crossBlock.transparent = false
crossBlock.shadow = true
crossBlock.biomeTintTop = false
crossBlock.biomeTintNorth = false
crossBlock.biomeTintSouth = false
crossBlock.biomeTintEast = false
crossBlock.biomeTintWest = false
tallcrossBlock.shape = shapes._1PixLower
tallcrossBlock.textures = ["dirt","dirtPathTop","dirtPathSide","dirtPathSide","dirtPathSide","dirtPathSide"]
tallcrossBlock.solid = true
tallcrossBlock.transparent = true
tallcrossBlock.cullFace = "same"
tallcrossBlock.shadow = true
tallcrossBlock.biomeTintTop = false
tallcrossBlock.biomeTintNorth = false
tallcrossBlock.biomeTintSouth = false
tallcrossBlock.biomeTintEast = false
tallcrossBlock.biomeTintWest = false
}
if(baseBlock.name === "podzol"){
crossBlock.shape = shapes.cube
crossBlock.textures = ["dirt","podzolTop","snowGrass","snowGrass","snowGrass","snowGrass"]
crossBlock.solid = true
crossBlock.transparent = false
crossBlock.shadow = true
}
if(baseBlock.name === "farmland"){
slabBlock.textures = []
copyArr(baseBlock.textures, slabBlock.textures)
slabBlock.textures[1] = "farmlandMoist"
slabBlock.shape = shapes._1PixLower
}
if(baseBlock.mushroomBlock){
var cap = baseBlock.name
var pore = "mushroomBlockInside"
makeBlock(new Array(6).fill(pore), shapes.cube, slabBlock)
slabBlock.drop = i
makeBlock([pore,cap,pore,pore,pore,pore], shapes.cube, stairBlock)//top only
stairBlock.drop = i
makeBlock([pore,pore,cap,cap,cap,cap], shapes.cube, tallcrossBlock)//all sides
tallcrossBlock.drop = i
makeBlock([pore,cap,cap,pore,pore,pore], shapes.rotate, doorBlock)//top + 1 side
doorBlock.drop = i
makeBlock([pore,cap,cap,pore,cap,pore], shapes.rotate, paneBlock)//top + 2 sides next to each other
paneBlock.drop = i
makeBlock([pore,pore,cap,pore,cap,pore], shapes.rotate, portalBlock)//2 side next to each other
portalBlock.drop = i
makeBlock([pore,pore,cap,pore,pore,pore], shapes.rotate, wallFlatBlock)//1 side
wallFlatBlock.drop = i
//makeBlock([cap,pore,pore,pore,pore,pore], shapes.cube, crossBlock)
//makeBlock([cap,cap,pore,pore,pore,pore], shapes.cube, tallcrossBlock)
//makeBlock([cap,pore,cap,pore,pore,pore], shapes.rotate, portalBlock)
//makeBlock([cap,cap,cap,pore,pore,pore], shapes.rotate, wallFlatBlock)
}
if(baseBlock.cake) baseBlock.shape = shapes.cake
if(baseBlock.stonecutter) baseBlock.shape = shapes.stonecutter
if(baseBlock.itemFrame){
baseBlock.shape = shapes.itemFrame
baseBlock.onclick = itemFrameOnclick
baseBlock.tagBits = null
}
if(baseBlock.name === "redstoneLamp"){
makeBlock(new Array(6).fill("redstoneLampOn"), shapes.cube, slabBlock)
slabBlock.lightLevel = 15
}
if(baseBlock.name === "endPortalFrame"){
baseBlock.shape = shapes.endPortalFrame
makeBlock(baseBlock.textures, shapes.endPortalFrameWithEyeOfEnder, slabBlock)
}
if(baseBlock.name === "furnace"){
var arr = baseBlock.textures.slice()
arr[3] = "furnaceFrontOn"
makeBlock(arr, shapes.rotate, slabBlock)
slabBlock.lightLevel = 13
}
if(baseBlock.name === "jungleLeaves"){
makeBlock(new Array(6).fill("floweringJungleLeaves"), shapes.cube, fenceBlock, null, baseBlock.Name+" with fruit")
fenceBlock.transparent = true
}
if(baseBlock.name === "redBerryLeaves" || baseBlock.name === "blueBerryLeaves"){
makeBlock(new Array(6).fill(baseBlock.textures[2]+"NoBerries"), shapes.cube, fenceBlock, null, baseBlock.Name+" without berries")
fenceBlock.transparent = true
}
if(baseBlock.fire){
baseBlock.shape = shapes.fire
slabBlock.shape = shapes.sideFire
stairBlock.shape = shapes.bottomFire
}
if(baseBlock.name === "endRod"){
baseBlock.shape = shapes.endRod
slabBlock.shape = shapes.endRodSW
}
if(baseBlock.fenceGate){
baseBlock.shape = shapes.fenceGate
baseBlock.transparent = true
slabBlock.shape = shapes.fenceGateWall
stairBlock.shape = shapes.fenceGateOpen
doorBlock.shape = shapes.fenceGateWallOpen
doorBlock.transparent = true
baseBlock.onclick = (function(x,y,z,dimension){
var b = world.getBlock(x,y,z,dimension)
var set
var id = this.id
let o = false
switch(b){
case id | CUBE | NORTH:
set = id | STAIR | NORTH
o = true
break
case id | CUBE | SOUTH:
set = id | STAIR | SOUTH
o = true
break
case id | CUBE | EAST:
set = id | STAIR | EAST
o = true
break
case id | CUBE | WEST:
set = id | STAIR | WEST
o = true
break
case id | SLAB | NORTH:
set = id | DOOR | NORTH
o = true
break
case id | SLAB | SOUTH:
set = id | DOOR | SOUTH
o = true
break
case id | SLAB | EAST:
set = id | DOOR | EAST
o = true
break
case id | SLAB | WEST:
set = id | DOOR | WEST
o = true
break
case id | STAIR | NORTH:
set = id | CUBE | NORTH
break
case id | STAIR | SOUTH:
set = id | CUBE | SOUTH
break
case id | STAIR | EAST:
set = id | CUBE | EAST
break
case id | STAIR | WEST:
set = id | CUBE | WEST
break
case id | DOOR | NORTH:
set = id | SLAB | NORTH
break
case id | DOOR | SOUTH:
set = id | SLAB | SOUTH
break
case id | DOOR | EAST:
set = id | SLAB | EAST
break
case id | DOOR | WEST:
set = id | SLAB | WEST
break
}
world.setBlock(x,y,z,set,false,false,false,false,dimension)
doorSound(x,y,z,"fence_gate",o,world)
}).bind({id:baseBlock.id})
}
if(baseBlock.barrel){
makeBlock(baseBlock.texturesSW, shapes.SW, slabBlock, null, baseBlock.Name)
makeBlock(baseBlock.texturesDown, shapes.cube, stairBlock, null, baseBlock.Name)
makeBlock(baseBlock.texturesOpen, shapes.cube, crossBlock, null, baseBlock.Name)
makeBlock(baseBlock.texturesSWOpen, shapes.SW, doorBlock, null, baseBlock.Name)
makeBlock(baseBlock.texturesDownOpen, shapes.cube, tallcrossBlock, null, baseBlock.Name)
}
if(baseBlock.chain){
slabBlock.shape = shapes.chainSW
slabBlock.textures = slabBlock.textures.slice()
slabBlock.textures[4] = slabBlock.textures[5] = "chainSW"
}
if(baseBlock.name === "beeNest" || baseBlock.name === "beehive"){
makeBlock(baseBlock.texturesHoney, shapes.rotate, slabBlock)
}
if(baseBlock.name === "sponge"){
makeBlock(baseBlock.wetTexture, shapes.cube, slabBlock)
}
if(baseBlock.campfire){
baseBlock.shape = shapes.campfire
slabBlock.shape = shapes.campfireUnlit
slabBlock.transparent = baseBlock.transparent
slabBlock.shadow = baseBlock.shadow
slabBlock.lightLevel = 0
slabBlock.damageUp = 0
}
if(baseBlock.bamboo){
baseBlock.shape = shapes.bamboo
makeBlock(baseBlock.textures, shapes.bambooSmallLeaf, slabBlock)
slabBlock.shadow = false
slabBlock.transparent = true
makeBlock(baseBlock.textures, shapes.bambooBigLeaf, stairBlock)
stairBlock.shadow = false
stairBlock.transparent = true
makeBlock(baseBlock.textures, shapes.bambooYoung, crossBlock)
crossBlock.shadow = false
crossBlock.transparent = true
makeBlock(baseBlock.textures, shapes.bambooYoungLeaf, tallcrossBlock)
tallcrossBlock.shadow = false
tallcrossBlock.transparent = true
potCrossBlock.shape = shapes.bambooPot
}
if(baseBlock.chest) baseBlock.shape = shapes.chest
if(baseBlock.pressurePlate){
baseBlock.shape = shapes.pressurePlate
baseBlock.transparent = true
baseBlock.shadow = false
baseBlock.solid = false
baseBlock.activate = pressurePlateActivate
baseBlock.onupdate = pressurePlateOnupdate
makeBlock(baseBlock.textures, shapes.pressurePlateActive, slabBlock, baseBlock)
}
if(baseBlock.name === "tomatoPlant"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.cross, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.cross, tallcrossBlock, baseBlock)
crossBlock.drop = "tomato"
crossBlock.dropAmount = [4,8]
tallcrossBlock.drop = "tomato"
tallcrossBlock.dropAmount = [8,16]
}
if(baseBlock.name === "wheat"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.crop, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures5, shapes.crop, doorBlock, baseBlock)
makeBlock(baseBlock.textures6, shapes.crop, torchBlock, baseBlock)
makeBlock(baseBlock.textures7, shapes.crop, lanternBlock, baseBlock)
lanternBlock.drop = baseBlock.fullDrop
}
if(baseBlock.name === "redstoneDust"){
baseBlock.shape = shapes.redstoneDust
makeBlock(new Array(6).fill("redstoneDustLine"), shapes.redstoneDustRotate, slabBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDustL"), shapes.redstoneDustRotate, stairBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDustT"), shapes.redstoneDustRotate, doorBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDust+"), shapes.redstoneDust, paneBlock, baseBlock)
let flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDustDot"), shapes.redstoneDust, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | FLIP] = flip
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDustLine"), shapes.redstoneDustRotate, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | SLAB | FLIP] = flip
let v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | SLAB | FLIP |v[j].bit] = block
}
}
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDustL"), shapes.redstoneDustRotate, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | STAIR | FLIP] = flip
v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | STAIR | FLIP |v[j].bit] = block
}
}
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDustT"), shapes.redstoneDustRotate, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | DOOR | FLIP] = flip
v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | DOOR | FLIP |v[j].bit] = block
}
}
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDust+"), shapes.redstoneDust, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | PANE | FLIP] = flip
}
if(baseBlock.redstoneTorch){
baseBlock.shape = shapes.redstoneTorch
makeBlock(baseBlock.textures, shapes.redstoneWallTorch, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.torch, crossBlock, baseBlock)
crossBlock.lightLevel = 0
crossBlock.textures = new Array(6).fill("redstoneTorchOff")
makeBlock(baseBlock.textures, shapes.wallTorch, stairBlock, baseBlock)
stairBlock.lightLevel = 0
stairBlock.textures = crossBlock.textures
}
if(baseBlock.lever){
baseBlock.shape = shapes.leverWall
makeBlock(baseBlock.textures, shapes.leverWallOn, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.leverFloor, stairBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.leverFloorOn, crossBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.leverCeil, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.leverCeilOn, doorBlock, baseBlock)
}
if(baseBlock.button){
makeBlock(baseBlock.textures, shapes.buttonPushed, slabBlock, baseBlock)
baseBlock.onclick = buttonOnclick.bind(baseBlock)
baseBlock.onupdate = buttonOnupdate.bind(baseBlock)
baseBlock.projectileHit = buttonProjectileHit.bind(baseBlock)
}
if(baseBlock.repeater){
baseBlock.shape = shapes.repeater1
makeBlock(baseBlock.textures, shapes.repeater2, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeater3, stairBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeater4, doorBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeaterOn1, paneBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeaterOn2, portalBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeaterOn3, wallFlatBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeaterOn4, openTrapdoor, baseBlock)
}
if(baseBlock.piston){
var baseBlockTransparent = Object.create(baseBlock)
baseBlockTransparent.transparent = true
//not extended
var textures = baseBlock.textures.slice()
var t = textures[0]
textures[0] = textures[1]
textures[1] = t
var flipped = Object.create(baseBlock)
makeBlock(textures, shapes.flipped, flipped, baseBlock)
blockData[i | FLIP] = flipped
var shape = shapes.SW
t = baseBlock.textures
textures = [t[2],t[2],t[0],t[1],t[2],t[2]]
makeBlock(textures, shape, slabBlock, baseBlock)
//head
t = baseBlock.textures[1]
var t2 = baseBlock.headSideTexture
var t3 = baseBlock.headBackTexture
makeBlock([t3,t,t2,t2,t2,t2], shapes.pistonHead, stairBlock, baseBlockTransparent)
flipped = Object.create(baseBlock)
makeBlock([t,t3,t2,t2,t2,t2], shapes.pistonHeadFlipped, flipped, baseBlockTransparent)
blockData[i | STAIR | FLIP] = flipped
makeBlock([t2,t2,t3,t,t2,t2], shapes.pistonHeadSW, doorBlock, baseBlockTransparent)
//head cut
makeBlock(stairBlock.textures, shapes.pistonHeadCut, crossBlock, baseBlock)
flipped = Object.create(baseBlock)
makeBlock(blockData[i | STAIR | FLIP].textures, shapes.pistonHeadCutFlipped, flipped, baseBlock)
blockData[i | CROSS | FLIP] = flipped
makeBlock(doorBlock.textures, shapes.pistonHeadCutSW, paneBlock, baseBlock)
//open
var textures = baseBlock.textures.slice()
textures[1] = baseBlock.frontOpenTexture
makeBlock(textures, shapes.pistonOpen, tallcrossBlock, baseBlockTransparent)
textures = blockData[i | FLIP].textures.slice()
textures[0] = baseBlock.frontOpenTexture
flipped = Object.create(baseBlock)
makeBlock(textures, shapes.pistonOpenFlipped, flipped, baseBlockTransparent)
blockData[i | TALLCROSS | FLIP] = flipped
var textures = baseBlock.textures.slice()
var temp = textures[2] //side with piston head
textures[2] = textures[0]
textures[3] = baseBlock.frontOpenTexture
textures[0] = textures[1] = temp
makeBlock(textures, shapes.pistonOpenSW, portalBlock, baseBlockTransparent)
}
if(baseBlock.name === "tnt"){
makeBlock(fillTextureArray(baseBlock.superTntTextures), shapes.cube, slabBlock, baseBlock, "Super TNT")
makeBlock(fillTextureArray(baseBlock.ultraTntTextures), shapes.cube, stairBlock, baseBlock, "Ultra TNT")
makeBlock(new Array(6).fill("blank"), shapes.cube, crossBlock, baseBlock)
}
if(baseBlock.name === "observer"){
baseBlock.shape = shapes.rotate
var t = baseBlock.textures
var textures = [t[3],t[2],t[0],t[1],t[4]+"SW",t[5]+"SW"]
makeBlock(textures, shapes.cube, slabBlock, baseBlock)
var flipped = Object.create(baseBlock)
var textures = textures.slice()
var t = textures[1]
textures[1] = textures[0]
textures[0] = t
makeBlock(textures, shapes.flipped, flipped, baseBlock)
blockData[i | SLAB | FLIP] = flipped
//on
textures = baseBlock.textures.slice()
textures[2] += "On"
makeBlock(textures, shapes.rotate, stairBlock, baseBlock)
textures = slabBlock.textures.slice()
textures[1] += "On"
makeBlock(textures, shapes.cube, crossBlock, baseBlock)
var flipped = Object.create(baseBlock)
textures = blockData[i | SLAB | FLIP].textures.slice()
textures[0] += "On"
makeBlock(textures, shapes.flipped, flipped, baseBlock)
blockData[i | CROSS | FLIP] = flipped
}
if(baseBlock.name === "endPortal"){
baseBlock.shape = shapes.endPortal
}
if(baseBlock.pane){
var t = baseBlock.textures
makeBlock([t[2],t[3],t[0],t[1],t[0],t[1]], shapes.horizontalPane, slabBlock, baseBlock)
}
if(baseBlock.coloredRedstoneLamp){
makeBlock(new Array(6).fill(baseBlock.name), shapes.cube, slabBlock)
slabBlock.lightLevel = 15
}
if(baseBlock.name === "sweetBerryBush"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
slabBlock.spikyBush = true
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
stairBlock.spikyBush = true
stairBlock.dropAmount = [1,2]
makeBlock(baseBlock.textures3, shapes.cross, crossBlock, baseBlock)
crossBlock.spikyBush = true
crossBlock.dropAmount = [2,3]
}
if(baseBlock.logicGate){
var t = baseBlock.textures.slice()
t[1] += "On"
makeBlock(t, baseBlock.shape, slabBlock, baseBlock)
baseBlock.onupdate = logicGateOnupdate
baseBlock.onpowerupdate = logicGateOnpowerupdate
baseBlock.ondelete = logicGateOndelete
baseBlock.getFacing = logicGateGetFacing
baseBlock.canHavePower = logicGateCanHavePower
}
if(baseBlock.name === "pointedDripstone"){
makeBlock(new Array(6).fill("pointedDripstoneUpTip"), shapes.cross, baseBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownTip"), shapes.cross, flip, baseBlock)
blockData[i | FLIP] = flip
makeBlock(new Array(6).fill("pointedDripstoneUpBase"), shapes.cross, slabBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownBase"), shapes.cross, flip, baseBlock)
blockData[i | SLAB | FLIP] = flip
makeBlock(new Array(6).fill("pointedDripstoneUpMiddle"), shapes.cross, stairBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownMiddle"), shapes.cross, flip, baseBlock)
blockData[i | STAIR | FLIP] = flip
makeBlock(new Array(6).fill("pointedDripstoneUpFrustum"), shapes.cross, crossBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownFrustum"), shapes.cross, flip, baseBlock)
blockData[i | CROSS | FLIP] = flip
makeBlock(new Array(6).fill("pointedDripstoneUpTipMerge"), shapes.cross, tallcrossBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownTipMerge"), shapes.cross, flip, baseBlock)
blockData[i | TALLCROSS | FLIP] = flip
}
if(baseBlock.sign){
slabBlock.shape = shapes.sign
slabBlock.textures = baseBlock.textures
slabBlock.drop = i
crossBlock.shape = shapes.wallSign
crossBlock.textures = baseBlock.textures
crossBlock.drop = i
baseBlock.shape = shapes.none
baseBlock.transparent = true
baseBlock.shadow = false
baseBlock.solid = false
baseBlock.onplace = signOnplace
baseBlock.tagBits = null
baseBlock.onclick = signOnclick
stairBlock.shape = shapes.none
}
if(baseBlock.name === "composter"){
baseBlock.shape = shapes.composter
makeBlock(baseBlock.textures, shapes.composter2, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter3, stairBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter4, crossBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter5, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter6, doorBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter7, torchBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter8, lanternBlock, baseBlock)
}
if(baseBlock.name === "cocoa"){
baseBlock.shape = shapes.cocoaStage0
baseBlock.textures.fill("cocoaStage0")
makeBlock(new Array(6).fill("cocoaStage1"), shapes.cocoaStage1, slabBlock, baseBlock)
makeBlock(new Array(6).fill("cocoaStage2"), shapes.cocoaStage2, stairBlock, baseBlock)
stairBlock.dropAmount = [2,3]
}
if(baseBlock.name === "beetroots"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
crossBlock.drop = ["beetrootSeeds","beetroot"]
crossBlock.dropAmount = [1,4]
}
if(baseBlock.name === "potatoes"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
crossBlock.dropAmount = [1,5]
}
if(baseBlock.name === "carrots"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
crossBlock.dropAmount = [2,5]
}
if(baseBlock.name === "dropper" || baseBlock.name === "dispenser"){
baseBlock.shape = shapes.rotate
makeBlock(baseBlock.upTextures, shapes.cube, slabBlock)
makeBlock(baseBlock.downTextures, shapes.cube, stairBlock)
}
if(baseBlock.name === "hopper"){
baseBlock.shape = shapes.hopper
makeBlock(baseBlock.textures, shapes.hopperWall, slabBlock, baseBlock)
}
if(baseBlock.name === "comparator"){
baseBlock.shape = shapes.comparator
makeBlock(baseBlock.textures, shapes.comparatorOn, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.comparatorSubtract, stairBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.comparatorSubtractOn, doorBlock, baseBlock)
}
if(baseBlock.name === "daylightDetector"){
baseBlock.shape = shapes.daylightDetector
makeBlock(baseBlock.invertedTextures, shapes.daylightDetector, slabBlock, baseBlock)
}
if(baseBlock.commandBlock){
let flip = Object.create(baseBlock)
makeBlock(baseBlock.errorTextures, shapes.cube, flip, baseBlock)
blockData[i | FLIP] = flip
makeBlock(baseBlock.sideTextures, shapes.SW, slabBlock, baseBlock)
flip = Object.create(baseBlock)
makeBlock(baseBlock.sideErrorTextures, shapes.SW, flip, baseBlock)
blockData[i | SLAB | FLIP] = flip
let v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(flip.textures, v[j].rotateTimes) //rotate textures around
blockData[i | SLAB | FLIP |v[j].bit] = block
}
}
makeBlock(baseBlock.flipTextures, shapes.flipped, stairBlock, baseBlock)
flip = Object.create(baseBlock)
makeBlock(baseBlock.flipErrorTextures, shapes.flipped, flip, baseBlock)
blockData[i | STAIR | FLIP] = flip
}
if(baseBlock.name === "sugarCane"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures, shapes.cross, slabBlock, baseBlock)
slabBlock.tint = baseBlock.purpleTint
}
if(baseBlock.name === "bow"){
baseBlock.shape = shapes.item
baseBlock.textures = new Array(6).fill(baseBlock.pullTextures[0])
makeBlock(new Array(6).fill(baseBlock.pullTextures[1]), shapes.item, slabBlock)
makeBlock(new Array(6).fill(baseBlock.pullTextures[2]), shapes.item, stairBlock)
makeBlock(new Array(6).fill(baseBlock.pullTextures[3]), shapes.item, crossBlock)
}
if(baseBlock.beacon){
baseBlock.shape = shapes.beacon
}
if(baseBlock.name === "pitcherCrop"){
baseBlock.shape = shapes.pitcherCropStage0
makeBlock(baseBlock.textures1, shapes.pitcherCropStage1, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.pitcherCropStage1, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.pitcherCropStage3, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.pitcherCropStage3, tallcrossBlock, baseBlock)
}
if(baseBlock.name === "torchflower"){
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
crossBlock.drop = "torchflower"
}
if(baseBlock.groundLeaves){
baseBlock.shape = shapes.flat
if(baseBlock.thickTexture) makeBlock(new Array(6).fill(baseBlock.thickTexture), shapes.flat, slabBlock, baseBlock, "Thick "+baseBlock.Name)
}
if(baseBlock.flowerbed){
baseBlock.shape = shapes.flowerbed1
makeBlock(baseBlock.textures, shapes.flowerbed2, slabBlock, baseBlock)
slabBlock.drop = i
makeBlock(baseBlock.textures, shapes.flowerbed3, stairBlock, baseBlock)
stairBlock.drop = i
makeBlock(baseBlock.textures, shapes.flowerbed4, doorBlock, baseBlock)
doorBlock.drop = i
}
if(baseBlock.name === "fern"){
baseBlock.shape = shapes.cross
slabBlock.shape = shapes.fern
slabBlock.randomRotateOnSpawn = true
}
if(baseBlock.carpet){
baseBlock.shape = shapes.carpet
baseBlock.shadow = false
baseBlock.transparent = true
baseBlock.drop = i
verticalSlabBlock.shape = shapes.wallCarpet
verticalSlabBlock.shadow = false
verticalSlabBlock.transparent = true
verticalSlabBlock.drop = i
verticalSlabBlock.Name = "Wall "+baseBlock.Name
}
if(baseBlock.coralBlock){
makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.cube, slabBlock,baseBlock, "Dead "+baseBlock.Name)
}
if(baseBlock.coralFan){
baseBlock.shape = shapes.coralFan
makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.coralFan, slabBlock,baseBlock, "Dead "+baseBlock.Name)
makeBlock(baseBlock.textures, shapes.coralWallFan, stairBlock,baseBlock)
makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.coralWallFan, verticalSlabBlock,baseBlock)
}
if(baseBlock.rail){
baseBlock.shape = shapes.rail
makeBlock(baseBlock.textures, shapes.railDiagonal, slabBlock,baseBlock)
if(baseBlock.name === "rail"){
makeBlock(new Array(6).fill("railCorner"), shapes.rail, stairBlock,baseBlock)
}
if(baseBlock.name === "poweredRail"){
let flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("poweredRailOn"), shapes.rail, flip,baseBlock)
blockData[i | FLIP] = flip
let v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | FLIP | v[j].bit] = block
}
}
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("poweredRailOn"), shapes.railDiagonal, flip,baseBlock)
blockData[i | SLAB | FLIP] = flip
v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | SLAB | FLIP | v[j].bit] = block
}
}
}
Object.assign(baseBlock,railData)
}
if(baseBlock.name === "cornPlant"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.tallCross, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.tallCross, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures5, shapes.tallCross, doorBlock, baseBlock)
doorBlock.dropAmount = [2,3]
}
if(baseBlock.chair){
baseBlock.shape = shapes.chair
baseBlock.onclick = sit
}
blockData[i | SLAB] = slabBlock
blockData[i | STAIR] = stairBlock
blockData[i | CROSS] = crossBlock
blockData[i | TALLCROSS] = tallcrossBlock
blockData[i | DOOR] = doorBlock
blockData[i | TORCH] = torchBlock
blockData[i | LANTERN] = lanternBlock
blockData[i | LANTERNHANG] = lanternHangBlock
if(baseBlock.beacon) blockData[i | BEACON] = beaconBlock
if(baseBlock.cactus) blockData[i | CACTUS] = cactusBlock
blockData[i | PANE] = paneBlock
blockData[i | PORTAL] = portalBlock
blockData[i | WALLFLAT] = wallFlatBlock
blockData[i | TRAPDOOR] = trapdoorBlock
blockData[i | TRAPDOOROPEN] = openTrapdoor
blockData[i | FENCE] = fenceBlock
blockData[i | WALLPOST] = wallPostBlock
if(baseBlock.button) blockData[i | BUTTON] = buttonBlock
if(baseBlock.chain) blockData[i | CHAIN] = chainBlock
if(baseBlock.pot) blockData[i | POT] = potBlock
blockData[i | POTCROSS] = potCrossBlock
blockData[i | CORNERSTAIRIN] = cornerStairInBlock
blockData[i | CORNERSTAIROUT] = cornerStairOutBlock
blockData[i | VERTICALSLAB] = verticalSlabBlock
let v
if(baseBlock.shape.rotate || baseBlock.shape.flip){
let t = baseBlock.textures
v = baseBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(baseBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | v[j].bit] = block
}
}
}
v = slabBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = slabBlock.textures
if (v[j]) {
let block = Object.create(slabBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | SLAB | v[j].bit] = block
}
}
v = stairBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = stairBlock.textures
if (v[j]) {
let block = Object.create(stairBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | STAIR | v[j].bit] = block
}
}
v = doorBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = doorBlock.textures
if (v[j]) {
let block = Object.create(doorBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | DOOR | v[j].bit] = block
}
}
v = paneBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = paneBlock.textures
if (v[j]) {
let block = Object.create(paneBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | PANE | v[j].bit] = block
}
}
v = portalBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = portalBlock.textures
if (v[j]) {
let block = Object.create(portalBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes)
blockData[i | PORTAL | v[j].bit] = block
}
}
v = wallFlatBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(wallFlatBlock)
block.shape = v[j]
blockData[i | WALLFLAT | v[j].bit] = block
}
}
v = trapdoorBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(trapdoorBlock)
block.shape = v[j]
blockData[i | TRAPDOOR | v[j].bit] = block
}
}
v = openTrapdoor.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(openTrapdoor)
block.shape = v[j]
blockData[i | TRAPDOOROPEN | v[j].bit] = block
}
}
v = buttonBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j] && blockData[i].button) {
let block = Object.create(buttonBlock)
block.shape = v[j]
blockData[i | BUTTON | v[j].bit] = block
}
}
v = cornerStairInBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(cornerStairInBlock)
block.shape = v[j]
blockData[i | CORNERSTAIRIN | v[j].bit] = block
}
}
v = cornerStairOutBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(cornerStairOutBlock)
block.shape = v[j]
blockData[i | CORNERSTAIROUT | v[j].bit] = block
}
}
v = verticalSlabBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(verticalSlabBlock)
block.shape = v[j]
blockData[i | VERTICALSLAB | v[j].bit] = block
}
}
}
}
let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,
BUTTON,CHAIN,POT,POTCROSS,CORNERSTAIRIN,CORNERSTAIROUT,VERTICALSLAB,
//if you change this, change debugStick and server side
LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,
FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
let isCube, isState
let prevConstVersion = null
function verMoreThan(a,b){
a = a.split(".").map(r => parseInt(r))
b = b.split(".").map(r => parseInt(r))
if(a[0] > b[0]) return true
if(a[1] > b[1] && a[0] === b[0]) return true
if(a[2] > b[2] && a[1] === b[1]) return true
}
function bin(n){
return parseInt(n,2)
}
function constVersion(v){
if(v === prevConstVersion) return
prevConstVersion = v
isCube = 0xff
//let verNum = v.replace(/(Alpha|Beta) /, '')//.replace(/(?<=\..*)\./g, '') //second regex removes the periods after the first
//if(verMoreThan(verNum, "1.0.3") || verNum==="1.0.3"){
CUBE = 0
LAYER2=SLAB =          0b10000000000000 // 9th bit
LAYER3=STAIR =        0b100000000000000 // 10th bit
LAYER4=CROSS =        0b110000000000000
LAYER5=TALLCROSS =0b1001110000000000000
LAYER6=LANTERN =    0b10010000000000000
LAYER7=LANTERNHANG=0b100010000000000000
BEACON =           0b100110000000000000
CACTUS =           0b101000000000000000
POT =              0b101010000000000000
POTCROSS =         0b101110000000000000
LAYER1 = TORCH =   0b110000000000000000
CHAIN =            0b110010000000000000
LAYER8 = DOOR =   0b1000010000000000000
PORTAL =          0b1000100000000000000
WALLFLAT =        0b1000110000000000000
PANE =           0b10001000000000000000
TRAPDOOR =        0b1010000000000000000
TRAPDOOROPEN =   0b10000000000000000000
FENCE =          0b11000000000000000000
WALLPOST =       0b11000100000000000000
//WALL = 0x6400<<5
//WALLU = 0x6600<<5 //wall withe exteion under another wall
//FENCQ = 0x4100<<5 //fence (one extension)
BUTTON =         0b10000100000000000000
//CARPET    =      0b10000110000000000000
CORNERSTAIRIN =      0b1000000000000000
CORNERSTAIROUT =     0b1010000000000000
VERTICALSLAB =       0b1100000000000000
FLIP      =               0b10000000000 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH =                  0b100000000000
EAST =                  0b1000000000000
WEST =                  0b1100000000000
ROTATION =              0b1100000000000 // Mask for the direction bits
isCube =                   0b1111111111 // Mask for block id bits
isState =        0b11111110000000000000
/*}else if(verMoreThan(verNum, "1.0.0") || verNum === "1.0.0"){
CUBE = 0
LAYER2 = SLAB = 0x100 // 9th bit
LAYER3 = STAIR = 0x200 // 10th bit
LAYER4 = CROSS = 0x300
FLIP = 0x400 // 11th bit
LAYER5 = TALLCROSS = 0x700
LAYER6 = LANTERN = 0x900
LAYER7 = LANTERNHANG=0x1100
BEACON = 0x1300
CACTUS = 0x1400
POT = 0x1500
POTCROSS = 0x1700
LAYER1 = TORCH = 0x1800
CHAIN = 0x1900
LAYER8 = DOOR = 0x2100
PORTAL = 0x2200
WALLFLAT = 0x2300
PANE = 0x4400
TRAPDOOR = 0x2800
TRAPDOOROPEN=0x4000
FENCE = 0x6000
WALLPOST = 0x6200
//WALL = 0x6400
//WALLU = 0x6600 //wall withe exteion under another wall
//FENCQ = 0x4100 //fence (one extension)
BUTTON = 0x4200
CARPET    = 0x4300
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
}else{
CUBE      = 0
LAYER2 = SLAB      = 0x100 // 9th bit
LAYER3 = STAIR     = 0x200 // 10th bit
LAYER4 = CROSS     = 0x2000
LAYER5 = TALLCROSS = 0x2200
LAYER8 = DOOR      = 0x2400
LAYER1 = TORCH     = 0x2600
LAYER6 = LANTERN   = 0x2800
LAYER7 = LANTERNHANG=0x3000
BEACON    = 0x4200
CACTUS    = 0x4400
PANE      = 0x4600
PORTAL    = 0x5000
WALLFLAT  = 0x4800
TRAPDOOR  = 0x5200
TRAPDOOROPEN=0x5400
FENCE     = 0x6000
WALLPOST  = 0x6200
//WALL      = 0x6400
//WALLU     = 0x6600 //wall withe exteion under another wall
//FENCQ     = 0x6800 //fence (one extension)
BUTTON    = 0x7000
CHAIN     = 0x7200
POT       = 0x8000
POTCROSS  = 0x8200
CARPET    = 0x8400
FLIP      = 0x400 // 11th bit
NORTH     = 0 // 12th and 13th bits for the 4 directions
SOUTH     = 0x800
EAST      = 0x1000
WEST      = 0x1800
ROTATION  = 0x1800 // Mask for the direction bits
}*/
}
constVersion(version)
{//Commands
let copiedBlocks
function fillBlocks(x,y,z,x2,y2,z2, blockID, dimension,world){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
for(var X=x; x2>=X; X++){
for(var Y=y; y2>=Y; Y++){
for(var Z=z; z2>=Z; Z++){
world.setBlock(X,Y,Z,blockID, false,false,false,false,dimension)
}
}
}
}
function copy(x,y,z,x2,y2,z2, dimension,world){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
copiedBlocks = [];
for(var X=x; x2>=X; X++){
var xRow = [];
for(var Y=y; y2>=Y; Y++){
var yRow = []
for(var Z=z; z2>=Z; Z++){
yRow.push(world.getBlock(X,Y,Z,dimension), world.getTags(X,Y,Z,dimension));
}
xRow.push(yRow);
}
copiedBlocks.push(xRow);
}
}
function paste(x,y,z,dimension,world){
for(var X = 0; X<copiedBlocks.length; X++){
var xRow = copiedBlocks[X];
for(var Y=0; Y<xRow.length; Y++){
var yRow = xRow[Y];
for(var Z=0; Z<yRow.length/2; Z++){
var block = yRow[Z*2]
world.setBlock(X+x,Y+y,Z+z,block,false,false,false,false,dimension)
var tags = yRow[z*2+1]
if(tags) world.setTags(X+x,Y+y,Z+z, tags,false, dimension)
}
}
}
}
function replaceBlocks(x,y,z,x2,y2,z2, replace, into, dimension,world){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
for(var X=x; x2>=X; X++){
for(var Y=y; y2>=Y; Y++){
for(var Z=z; z2>=Z; Z++){
if(world.getBlock(X,Y,Z,dimension) === replace){
world.setBlock(X,Y,Z,into, false,false,false,false,dimension)
}
}
}
}
}
function fromPlayer(p,world){
p.prevPosCmd = [round(p.x), round(p.y), round(p.z)]
world.sendPlayer({type:"clientCmd",data:"fromPlayer",args:{x:round(p.x),y:round(p.y),z:round(p.z)}},p.id)
}
function fillToPlayer(id,p,world){
//fills at player feet
fillBlocks(p.prevPosCmd[0], p.prevPosCmd[1]-1, p.prevPosCmd[2], round(p.x), round(p.y-1), round(p.z), id, p.dimension,world)
world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}
function copyToPlayer(p,world){
copy(p.prevPosCmd[0], p.prevPosCmd[1]-1, p.prevPosCmd[2], round(p.x), round(p.y-1), round(p.z), p.dimension,world);
p.copiedBlocksCmd = copiedBlocks
world.sendPlayer({type:"clientCmd",data:"copySelect",args:{w:copiedBlocks.length,h:copiedBlocks[0].length,d:copiedBlocks[0][0].length}},p.id)
}
function pasteAtPlayer(p,world){
copiedBlocks = p.copiedBlocksCmd
paste(round(p.x), round(p.y-1), round(p.z), p.dimension,world)
world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}
function replaceAtPlayer(replace,into,p,world){
replaceBlocks(p.prevPosCmd[0], p.prevPosCmd[1]-1, p.prevPosCmd[2], round(p.x), round(p.y-1), round(p.z), replace, into, p.dimension, world)
world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}
let cancelShape = 0
async function hcyl(width, height, depth, id, X,Y,Z, dimension,world) {
let cid = cancelShape
let w2 = width * width
let d2 = depth * depth
let w3 = (width - 1.2) * (width - 1.2)
let d3 = (depth - 1.2) * (depth - 1.2)
for (let x = floor(-width); x <= ceil(width); x++) {
for (let y = floor(-height); y <= ceil(height); y++) {
for (let z = floor(-depth); z <= ceil(depth); z++) {
let n = x * x / w2 + z * z / d2
let n2 = x * x / w3 + z * z / d3
if (n < 1 && n2 >= 1) {
world.setBlock(round(X + x), round(Y + y), round(Z + z), id, false,false,false,false, dimension)
await sleep(10)
if(cancelShape > cid) return
}
}
}
}
}
async function cyl(width, height, depth, id, X,Y,Z, dimension,world) {
let cid = cancelShape
let w2 = width * width
let d2 = depth * depth
for (let x = floor(-width); x <= ceil(width); x++) {
for (let y = floor(-height); y <= ceil(height); y++) {
for (let z = floor(-depth); z <= ceil(depth); z++) {
let n = x * x / w2 + z * z / d2
if (n < 1) {
world.setBlock(round(X + x), round(Y + y), round(Z + z), id, false,false,false,false, dimension)
await sleep(10)
if(cancelShape > cid) return
}
}
}
}
}
async function sphereoid(w, h, d, id, X,Y,Z, dimension,world) {
let cid = cancelShape
let w2 = w * w
let h2 = h * h
let d2 = d * d
let w3 = (w - 1.5) * (w - 1.5)
let h3 = (h - 1.5) * (h - 1.5)
let d3 = (d - 1.5) * (d - 1.5)
for (let y = floor(-h); y <= ceil(h); y++) {
for (let x = floor(-w); x <= ceil(w); x++) {
for (let z = floor(-d); z <= ceil(d); z++) {
let n = x * x / w2 + y * y / h2 + z * z / d2
let n2 = x * x / w3 + y * y / h3 + z * z / d3
if (n < 1 && n2 >= 1) {
world.setBlock(round(X + x), round(Y + y), round(Z + z), id, false,false,false,false, dimension)
await sleep(10)
if(cancelShape > cid) return
}
}
}
}
}
async function ball(w, h, d, id, X,Y,Z, dimension,world) {
let cid = cancelShape
let w2 = w * w
let h2 = h * h
let d2 = d * d
for (let y = floor(-h); y <= ceil(h); y++) {
for (let x = floor(-w); x <= ceil(w); x++) {
for (let z = floor(-d); z <= ceil(d); z++) {
let n = x * x / w2 + y * y / h2 + z * z / d2
if (n < 1) {
world.setBlock(round(X + x), round(Y + y), round(Z + z), id, false,false,false,false, dimension)
await sleep(10)
if(cancelShape > cid) return
}
}
}
}
}
/*function parsePosition(x,px,int=false){//stuff inside by Trexler
let ret
if(x.startsWith('~+')){
ret = px+parseFloat(x.split("+")[1])
}else if(x.startsWith('~-')){
ret = px-parseFloat(x.split("-")[1])
}else{
ret = x.startsWith('~')?px:parseFloat(x)
}
if(int) ret = round(ret)
return ret
}*/
function parseTarget(str,pos,world){
if(str === "@s"){
return [pos]
}else if(str === "@a"){
let a = world.players.slice()
return a
}else if(str === "@e"){
return world.entities.slice()
}else if(str === "@p"){
let closest = Infinity, cp = undefined
for(let P of world.players){
let d = dist3(pos.x,pos.y,pos.z,P.x,P.y,P.z)
if(d < closest){
closest = d
cp = P
}
}
return [cp]
}else{
let p = getPlayerByUsername(str,world)
return p ? [p] : []
}
}
/*
types can be: root,literal,argument,redirect
if func exists, the node can be run with it at the end of stack
next is array of node ids
*/
/*let defaultServerCommandNodes = [
{
type:"root",
next:[
'fromPlayer', 'fillToPlayer', 'copyToPlayer', 'pasteAtPlayer', 'replaceToPlayer', 'cancelFrom', 'shape', 'cancelShape',
'give', 'kill', 'time', 'weather', 'teleportToPlayer', 'teleport', 'playSound', 'title', 'setBlock', 'getBlock', 'setTag', 'getTag',
'echo', 'var', 'solve', 'getPos', 'wait', 'getTime', 'blockInfo', 'seed', 'trigger', 'effect', 'clear', 'clearHistory',
'gameMode', 'spectatePlayer', 'reloadChunks', 'ban', 'unban', 'whitelist', 'online', 'sendEval', 'help'
]
},
,];const lateraaa=[//todo below
{
type:"literal",
id:"fromPlayer",
name: "fromPlayer",
info: "Sets starting position to player position",
func: (args,pos,scope,world) => fromPlayer(pos,world),
anonymousFunc: null
},
{
type:"literal",
id:"fillToPlayer",
name: "fillToPlayer",
next:["blockNameFillToPlayer"],
info: "Fills from starting position to player position",
anonymousFunc: null,
func: (args,pos,scope,world) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
fillToPlayer(id,pos,world)
},
},
{
type:"literal",
name: "copyToPlayer",
info: "Copys blocks from starting position to player position",
func: (args,pos,scope,world) => copyToPlayer(pos,world),
anonymousFunc: null
},
{
type:"literal",
name: "pasteAtPlayer",
info: "Pastes copied blocks at the player's position",
func: (args,pos,scope,world) => pasteAtPlayer(pos,world),
anonymousFunc: null
},
{
type:"literal",
name: "replaceToPlayer",
args: ["replace_what", "with_what"],
argValues:{replace_what:"type:block",with_what:"type:block"},
func: (args,pos,scope,world) => {
let replace = blockIds[args.replace_what]
if(!args.replace_what) replace = 0
let into = blockIds[args.with_what]
if(!args.with_what) into = 0
replaceAtPlayer(replace,into,pos,world)
},
anonymousFunc: null
},
{
type:"literal",
name:"cancelFrom",
info:"Delete starting position",
client:true
},
{
type:"literal",
name: "shape",
info: "Type can be: sphere, hollowSphere, cylinder, hollowCylinder",
args: ["type","width", "height", "depth", "block_name", "x", "y", "z"],
argValues: {block_name:"type:block",x:"type:x",y:"type:y",z:"type:z",type:["sphere","hollowSphere","cylinder","hollowCylinder"],width:"type:number",height:"type:number",depth:"type:number"},
func: (args,pos,scope,world) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
let x = args.x ? parseFloat(args.x) : pos.x,
y = args.y ? parseFloat(args.y) : pos.y,
z = args.z ? parseFloat(args.z) : pos.z,
width = parseFloat(args.width) || 0,
height = parseFloat(args.height) || 0,
depth = parseFloat(args.depth) || 0
if(args.type === "sphere") return ball(width, height, depth, id, x,y,z, pos.dimension, world)
else if(args.type === "hollowSphere") return sphereoid(width, height, depth, id, x,y,z, pos.dimension, world)
else if(args.type === "cylinder") return cyl(width, height, depth, id, x,y,z, pos.dimension, world)
else if(args.type === "hollowCylinder") return hcyl(width, height, depth, id, x,y,z, pos.dimension, world)
else return ["No such shape: "+args.type,"error"]
}
},
{
type:"literal",
name:"cancelShape",
info:"Stop generating shapes currently being generated.",
func: () => {
cancelShape++
}
},
{
type:"literal",
name: "give",
args: ["target", "block_name", "amount"],
argValues:{block_name:"type:block",target:["type:player","@s","@a","@p"],amount:"type:number"},
info: "Gives the target the the specified amount of specified blocks",
func: (args,pos,scope,world) => {
let id = blockIds[args.block_name]
let amount = parseInt(args.amount) || 1
let arr = parseTarget(args.target,pos,world)
if(arr){
for(let i of arr){
world.addItems(i.x,i.y,i.z,i.dimension,0,0,0,id,false,amount)
}
}else return ["No such target: "+args.target,"error"]
}
},
{
type:"literal",
name: "kill",
args: ["target","message"],
argValues:{target:["type:player","@s","@a","@e","@p"]},
info: "Target can be: @s, your username, someone's uername, @a, @e",
func: (args,pos,scope,world) => {
if(world.settings.killCmdOff) return ["Kill command is disabled on this world.","error"]
args.target = args.target || "@s"
let arr = parseTarget(args.target,pos,world)
if(arr){
for(let i of arr){
if(i.type === "Player"){
world.sendPlayer({type:"kill", data:args.message || pos.username+" killed "+(args.target === "@a" ? "everyone" : args.target)+" with the kill command."},i.id)
}else{
world.deleteEntity(i.id)
}
}
}else return ["No such target: "+args.target,"error"]
}
},
{
type:"literal",
name: "time",
args: ["mode","n"],
argValues:{mode:["set","add","subtract"],n:["day","night","type:number"]},
info: "mode can be: set, add, subtract. n is the time to set to. 1000 is a day. n an also be: day, night",
func: (args,pos,scope,world) => {
let time
if(args.n === "day") time = 500
else if(args.n === "night") time = 0
else time = parseInt(args.n) || 0
if(args.mode === "set"){
world.time = time
}else if(args.mode === "add"){
world.time += time
}else if(args.mode === "subtract"){
world.time -= time
}else{
return ["No such mode: "+args.mode,"error"]
}
}
},
{
type:"literal",
name: "weather",
args: ["w"],
argValues:{w:["clear","rain","snow"]},
info: "w is the weather to set to. It can be clear, rain, or snow",
func: (args,pos,scope,world) => {
if(args.w === "rain") world.weather = "rain"
else if(args.w === "snow") world.weather = "snow"
else world.weather = ""
}
},
{
type:"literal",
name:"teleportToPlayer",
names:["tpPlayer","tpp","tptp"],
args: ["to_who","who"],
argValues:{to_who:["@s","type:player"],who:["@s","type:player"]},
info: "Teleport player [who] to [to_who]. who is optional.",
func: (args,pos,scope,world) => {
let to = parseTarget(args.to_who,pos,world)
to = to && to[0]
let who = parseTarget(args.who,pos,world)
if(!to) return ["Player doesn't exsist: "+args.to_who,"error"]
if(!who || !who.length) who = [pos]
for(let e of who) world.sendPlayer({type:"tp",x:to.x,y:to.y,z:to.z,dimension:to.dimension},e.id)
}
},
//Trexler made this command but it has been modified
{
type:"literal",
name: "teleport",
names:["tp"],
args: ["target","x","y","z","dimension"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension",target:["@s","type:player"]},
info: "x, y, and z are the coordinates to teleport to. dimension is optional.",
func: (args,pos,scope,world) => {
let target = parseTarget(args.target,pos,world)
if(!target || !target[0]) return ["No such target: "+args.target,"error"]
if(!args.x || !args.y || !args.z) return ["You need to set the coordinates.","error"]
let px = pos.x, py = pos.y, pz = pos.z
let x = parsePosition(args.x,px)
let y = parsePosition(args.y,py)
let z = parsePosition(args.z,pz)
if(isNaN(x)) x = px
if(isNaN(y)) y = py
if(isNaN(z)) z = pz
let dimension = args.dimension || pos.dimension
for(let t of target) world.sendPlayer({type:"tp",x,y,z,dimension},t.id)
}
},
{
type:"literal",
name:"playSound",
args:["sound", "volume", "pitch"],
argValues:{sound:"type:sound",volume:"type:number",pitch:"type:number"},
info:"Plays a sound. Sound can be any sound, for example: click, block.grass.dig1, entity.generic.explode1. Volume is a number from 0 to 1.",
func: (args,pos,scope,world) => {
if(!args.sound) return ["The first argument (sound) is required.","error"]
let volume = parseFloat(args.volume) || 1
let pitch = parseFloat(args.pitch) || 1
world.playSound(null,null,null,args.sound, volume, pitch)
//return ["That sound doesn't exist.","error"]
}
},
{
type:"literal",
name:"title",
args:['text','subtext','color','fadeIn','fadeOut','stay'],
argValues:{fadeIn:"type:number",fadeOut:"type:number",stay:"type:number"},
info:"Shows text on screen. fadeIn and fadeOut and stay are miliseconds.",
func: (args,pos,scope,world) => {
args.text = args.text || "/title"
args.fadeIn = (args.fadeIn || args.fadeIn === 0) ? parseFloat(args.fadeIn) : 500
args.fadeOut = (args.fadeOut || args.fadeOut === 0) ? parseFloat(args.fadeOut) : 2000
args.stay = (args.stay || args.stay === 0) ? parseFloat(args.stay) : 1000
world.sendAll({type:"title",data:args.text,sub:args.subtext,color:args.color,fadeIn:args.fadeIn,fadeOut:args.fadeOut,stay:args.stay})
}
},
{
type:"literal",
name:"setBlock",
args:["x","y","z","dimension","block"],
argValues:{block:"type:block",x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension"},
info:"Sets a block at a specified position.",
func: (args,pos,scope,world) => {
let block = blockIds[args.block]
if(block === undefined) block = parseInt(args.block)
if(!blockData[block]) return ["No such block "+block,"error"]
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
world.setBlock(x,y,z,block,false,false,false,false,dimension)
}
},
{
type:"literal",
name:"getBlock",
args:["x","y","z","dimension"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension"},
info:"Gets a block at the specified position and sets a variable called block_name.",
func: (args,pos,scope,world) => {
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
scope.block_name = blockData[world.getBlock(x,y,z,dimension)].name
}
},
{
type:"literal",
name:"setTag",
args:["x","y","z","dimension","tag_name","tag_data"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension"},
info:"Sets a specified tag at a specified position. tag_name can be JSON or raw text.",
func: (args,pos,scope,world) => {
let data
try{
data = JSON.parse(args.tag_data)
}catch{
data = args.tag_data
}
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
try{
world.setTagByName(x,y,z,args.tag_name,data, false,dimension)
}catch(e){
return [e.message,"error"]
}
}
},
{
type:"literal",
name:"getTag",
args:["x","y","z","dimension","tag_name"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension"},
info:"Gets a specified tag at the specified position and sets a variable called tag_data. tag_data will be JSON string if not a string.",
func: (args,pos,scope,world) => {
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
scope.tag_data = world.getTagByName(x,y,z,args.tag_name,dimension)
if(typeof scope.tag_data !== "string") scope.tag_data = JSON.stringify(scope.tag_data)
}
},
/*{
name:"online",
noCheats: true,
info: "Lists people that are in this world.",
func: (args,pos,scope,world) => {
let arr = world.players.map(u => u.username)
let str = "<span style='color:lime;'>"+arr.length + " players online: " + arr.join(", ")
let bannedLength = 0
for(let b in world.banned) bannedLength ++
if(bannedLength){
str += "<br>"
str += bannedLength + " players banned: "
for(let b in world.banned) str += b + ", "
str = str.slice(0,str.length-2)
}
if(world.whitelist){
str += "<br>"
str += world.whitelist.length + " players whitelisted: "+world.whitelist.join(", ")
}
return [str,""]
}
},*-/
{
type:"literal",
name:"echo",
args:["data"],
info:"Outputs data.",
func: args => {
return [args.data+"",""]
}
},
{
type:"literal",
name:"var",
args:["name","value"],
info:"Set a variable to a value. Value can be empty.",
func: (args,pos,scope) => {
if(!args.name) return ["Error: name required.","error"]
scope[args.name] = args.value
}
},
{
type:"literal",
name:"solve",
args:["value1","operation","value2"],
argValues:{operation:["+","-","/","*","<",">","=","round","floor","ceil","sin","cos","tan","sqrt","%"]},
info:"Calculate operation on value1 and value2 and sets a variabled 