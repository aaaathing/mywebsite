"use strict"
const version = "Beta 1.1.1"
let win, isNode = false
try{
win = window
}catch{
win = module.exports
isNode = true
}
let workerCount, workerURL
if(isNode){
workerCount = 1//require("os").cpus()
workerURL = __dirname+"/worker.js"
win.Worker = require("worker_threads").Worker
}else{
workerCount = navigator.hardwareConcurrency
workerURL = URL.createObjectURL(new Blob([document.querySelector("#workerCode").text], { type: "text/javascript" }))
}
win.version = version
workerCount = (workerCount || 4) - 1 || 1
{
// I'm throwing stuff in the window scope since I can't be bothered to figure out how all this fancy import export stuff works
let workers = win.workers = []
let allWorkers = win.allWorkers = []
let waitingJobs = [], waitingMsgs = []
for (let i = 0, count = workerCount; i < count; i++) { // Generate between 1 and (processors - 1) workers.
let worker = new win.Worker(workerURL)
worker.id = i
let doNewJob = function(){
workers.push(worker)
if(waitingMsgs[worker.id].length){
waitingMsgs[worker.id].shift()()
}else if(waitingJobs.length){
waitingJobs.shift()()
}
}
let onmessage = function(e){
let data = isNode ? e : e.data
if(data === "started") return doNewJob()
let [promise, resolve, onProgress] = worker.theJob
if(data.progress){
return onProgress(data.progress)
}
resolve(data)
doNewJob()
}
if(isNode) worker.on("message",onmessage)
else worker.onmessage = onmessage
//workers.push(worker)//done when started
allWorkers.push(worker)
waitingMsgs.push([])
}
win.doWork = function(data,onProgress) {
let job = []
let promise = new Promise(resolve => {
job[1] = resolve
let worker = workers.shift()
if(!worker){
waitingJobs.push(() => {
worker = workers.shift()
worker.theJob = job
worker.postMessage(data)
})
}else{
worker.theJob = job
worker.postMessage(data)
}
})
job[0] = promise
job[2] = onProgress
return promise
}
function sendMsg(data,id){
let job = []
let promise = new Promise(resolve => {
job[1] = resolve
let worker = allWorkers[id]
if(!workers.includes(worker)){
waitingMsgs[id].push(() => {
worker = allWorkers[id]
workers.splice(workers.indexOf(worker),1)
worker.theJob = job
worker.postMessage(data)
})
}else{
workers.splice(workers.indexOf(worker),1)
worker.theJob = job
worker.postMessage(data)
}
})
job[0] = promise
return promise
}
win.sendAllWorkers = async function(msg){
let p = []
for(let i=0; i<allWorkers.length; i++){
p.push(sendMsg(msg,i))
}
await Promise.all(p)
}
}
const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2, tan } = Math;
const rand = function(a,b){
if(arguments.length === 2){
return (Math.random()*(b-a))+a
}else if(arguments.length === 1){
return Math.random()*a
}else return Math.random()
}
const avg = function(){
var res = 0, c = 0
for(var i=0; i<arguments.length; i++){
if(!arguments[i] && arguments[i] !== 0) continue
res += arguments[i]
c++
}
res /= c
return res
}
/*const divideWithRemainder = function(a,b){
var n=a/b
var f=floor(n)
var r=n-f
n=f
r=floor(r*b)
return {n,r}
}*/
const mod = function(a,b){
return a - floor(a/b)*b
}
Math.PI2 = Math.PI / 2
Math.PI4 = Math.PI / 4
Math.PId = Math.PI * 2
function xyArrayHas(arr,arr2,x,y,z,arrLen=arr.length,arr2Len=arr2&&arr2.length){
for(var i=0; i<arrLen; i+=4){
if(arr[i] === x && arr[i+1] === y && arr[i+2] === z){
return true
}
}
if(arr2){
for(var i=0; i<arr2Len; i+=4){
if(arr2[i] === x && arr2[i+1] === y && arr2[i+2] === z){
return true
}
}
}
}
//from https://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers
function insertSorted(array, value) {
let low = 0,
high = array.length;
while (low < high) {
let mid = (low + high) >>> 1;
if (array[mid] < value) low = mid + 1;
else high = mid;
}
array.splice(low,0,value)
return array
}
function emptyIfNullish(v){
return v||v===0 ? v : ""
}
// Shh don't tell anyone I'm override native objects
String.prototype.hashCode = function() {
var hash = 0, i, chr;
if (this.length === 0) return hash;
for (i = 0; i < this.length; i++) {
chr   = this.charCodeAt(i);
hash  = ((hash << 5) - hash) + chr;
hash |= 0; // Convert to 32bit integer
}
return hash;
}
Uint8Array.prototype.toString = function() {
let str = ""
for (let i = 0; i < this.length; i++) {
str += String.fromCharCode(this[i])
}
return btoa(str)
}
/*Uint8Array.prototype.toJSON = function(){
return "BitArray("+this.length*8+")"
}*/
function atoarr(data){
let bytes = atob(data)
let arr = new Uint8Array(bytes.length)
for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i)
return arr
}
function chunkString (str, len) {
const size = Math.ceil(str.length/len)
const r = Array(size)
let offset = 0
for (let i = 0; i < size; i++) {
r[i] = str.substr(offset, len)
offset += len
}
return r
}
function chunkArray(array,chunkSize){
let chunks = []
for (let i = 0; i < array.length; i += chunkSize) {
const chunk = array.slice(i, i + chunkSize);
chunks.push(chunk)
}
return chunks
}
function hex2bin(hex){//from https://stackoverflow.com/questions/45053624/convert-hex-to-binary-in-javascript
hex = hex.toLowerCase()
var out = "";
for(var c of hex) {
switch(c) {
case '0': out += "0000"; break;
case '1': out += "0001"; break;
case '2': out += "0010"; break;
case '3': out += "0011"; break;
case '4': out += "0100"; break;
case '5': out += "0101"; break;
case '6': out += "0110"; break;
case '7': out += "0111"; break;
case '8': out += "1000"; break;
case '9': out += "1001"; break;
case 'a': out += "1010"; break;
case 'b': out += "1011"; break;
case 'c': out += "1100"; break;
case 'd': out += "1101"; break;
case 'e': out += "1110"; break;
case 'f': out += "1111"; break;
default: return "";
}
}
return out;
}
function sleep(ms) {
return new Promise(resolve => setTimeout(resolve, ms))
}
const generateID = () => "" + Date.now().toString(36) + (Math.random() * 1000000 | 0).toString(36)
function map(v, min, max, min2, max2){
return min2 + (max2 - min2) * ((v - min) / (max - min));
}
function mapFrom(v, min, max){
return (v - min) / (max - min)
}
function mapClamped(v, min, max){
return Math.min(Math.max(((v - min) / (max - min)),0),1);
}
function lerp(t, a, b) {
return a + t * (b - a);
}
function dist2(x,y,x2,y2){
let xDist = x - x2
let yDist = y - y2
return sqrt((xDist*xDist)+(yDist*yDist))
}
function dist3(x,y,z,x2,y2,z2){
let xDist = x - x2
let yDist = y - y2
let zDist = z - z2
return sqrt((xDist*xDist)+(yDist*yDist)+(zDist*zDist))
}
function dist3Sq(x,y,z,x2,y2,z2){
let xDist = x - x2
let yDist = y - y2
let zDist = z - z2
return (xDist*xDist)+(yDist*yDist)+(zDist*zDist)
}
function mag(x,y,z) {
return sqrt(x * x + y * y + z * z)
}
function angleOf(x,y,fromx,fromy){
let a = atan2(x - fromx, y - fromy)
if(a<0) a+=Math.PId
return a
}
function line3DConncected(endX, endY, endZ, startX, startY, startZ, array){
var x1 = Math.round(endX), y1 = Math.round(endY), z1 = Math.round(endZ), x0 = Math.round(startX), y0 = Math.round(startY), z0 = Math.round(startZ);
var dx = Math.abs(x1 - x0);
var dy = Math.abs(y1 - y0);
var dz = Math.abs(z1 - z0);
var stepX = x0 < x1 ? 1 : -1;
var stepY = y0 < y1 ? 1 : -1;
var stepZ = z0 < z1 ? 1 : -1;
var hypotenuse = Math.sqrt(dx*dx + dy*dy + dz*dz);
var tMaxX = hypotenuse*0.5 / dx;
var tMaxY = hypotenuse*0.5 / dy;
var tMaxZ = hypotenuse*0.5 / dz;
var tDeltaX = hypotenuse / dx;
var tDeltaY = hypotenuse / dy;
var tDeltaZ = hypotenuse / dz;
while (x0 !== x1 || y0 !== y1 || z0 !== z1){
if (tMaxX < tMaxY) {
if (tMaxX < tMaxZ) {
x0 = x0 + stepX;
tMaxX = tMaxX + tDeltaX;
} else if (tMaxX > tMaxZ){
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
} else{
x0 = x0 + stepX;
tMaxX = tMaxX + tDeltaX;
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
}
} else if (tMaxX > tMaxY){
if (tMaxY < tMaxZ) {
y0 = y0 + stepY;
tMaxY = tMaxY + tDeltaY;
} else if (tMaxY > tMaxZ){
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
} else{
y0 = y0 + stepY;
tMaxY = tMaxY + tDeltaY;
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
}
} else{
if (tMaxY < tMaxZ) {
y0 = y0 + stepY;
tMaxY = tMaxY + tDeltaY;
x0 = x0 + stepX;
tMaxX = tMaxX + tDeltaX;
} else if (tMaxY > tMaxZ){
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
} else{
x0 = x0 + stepX;
tMaxX = tMaxX + tDeltaX;
y0 = y0 + stepY;
tMaxY = tMaxY + tDeltaY;
z0 = z0 + stepZ;
tMaxZ = tMaxZ + tDeltaZ;
}
}
array.push(x0, y0, z0);
}
}
//https://www.geeksforgeeks.org/bresenhams-algorithm-for-3-d-line-drawing/
function line3D(x2, y2, z2, x1, y1, z1, array){
x1 = round(x1)
y1 = round(y1)
z1 = round(z1)
x2 = round(x2)
y2 = round(y2)
z2 = round(z2)
array.push(x1, y1, z1);
let dx = abs(x2 - x1);
let dy = abs(y2 - y1);
let dz = abs(z2 - z1);
let xs;
let ys;
let zs;
if (x2 > x1) {
xs = 1;
} else {
xs = -1;
}
if (y2 > y1) {
ys = 1;
} else {
ys = -1;
}
if (z2 > z1) {
zs = 1;
} else {
zs = -1;
}
// Driving axis is X-axis"
if (dx >= dy && dx >= dz) {
let p1 = 2 * dy - dx;
let p2 = 2 * dz - dx;
while (x1 != x2) {
x1 += xs;
if (p1 >= 0) {
y1 += ys;
p1 -= 2 * dx;
}
if (p2 >= 0) {
z1 += zs;
p2 -= 2 * dx;
}
p1 += 2 * dy;
p2 += 2 * dz;
array.push(x1, y1, z1);
}
// Driving axis is Y-axis"
} else if (dy >= dx && dy >= dz) {
let p1 = 2 * dx - dy;
let p2 = 2 * dz - dy;
while (y1 != y2) {
y1 += ys;
if (p1 >= 0) {
x1 += xs;
p1 -= 2 * dy;
}
if (p2 >= 0) {
z1 += zs;
p2 -= 2 * dy;
}
p1 += 2 * dx;
p2 += 2 * dz;
array.push(x1, y1, z1);
}
// Driving axis is Z-axis"
} else {
let p1 = 2 * dy - dz;
let p2 = 2 * dx - dz;
while (z1 != z2) {
z1 += zs;
if (p1 >= 0) {
y1 += ys;
p1 -= 2 * dz;
}
if (p2 >= 0) {
x1 += xs;
p2 -= 2 * dz;
}
p1 += 2 * dy;
p2 += 2 * dx;
array.push(x1, y1, z1);
}
}
}
let emptyFunc = function(){}
// await window.yieldThread() will pause the current task until the event loop is cleared
{
const channel = new MessageChannel()
let toYield = {}, toYieldId = 0
channel.port1.onmessage = e => {
toYield[e.data]()
delete toYield[e.data]
}
win.yieldThread = function() {
return new Promise(resolve => {
let id = toYieldId++
toYield[id] = resolve
channel.port2.postMessage(id)
})
}
}
function mapFrom(v, min, max){
return ((v - min) / (max - min))
}
function preferMiddle(x,middle,resMin,resMax){
//x is 0 to 1
//middle is a big number between resMin and resMax
let prevMiddle = middle
middle = mapFrom(middle,resMin,resMax)
if(x>middle){
x = mapFrom(x,middle,1)
x **= 2
x = lerp(x,prevMiddle,resMax)
}else{
x = mapFrom(x,middle,0)
x **= 2
x = lerp(x,prevMiddle,resMin)
}
return x
}
function preferMiddleSimple(x){
let px = x
x = (x-0.5)*2
x**=3
x = x/2+0.5
return x
}
{//Begin
let tickSpeed = 20
let tickTime = 1000/tickSpeed
function fillTextureArray(textures){
if (textures.length === 3) {
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
} else if (textures.length === 2) {
// Top and bottom are the first texture, sides are the second.
textures[2] = textures[1];
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
textures[1] = textures[0];
}else if(textures.length === 4){
textures[4] = textures[5] = textures[3]
textures[3] = textures[2]
}
return textures
}
let sit
let generator = {
height: 80, // Height of the hills
smooth: 0.01, // Smoothness of the terrain
extra: 30, // Extra height added to the world.
caveSize: 0.00, // Redefined right above where it's used
biomeSmooth: 0.007, // Smoothness of biomes
}
win.generator = generator //for mods
const {doWork, sendAllWorkers, yieldThread} = win
const maxHeight = 319
const minHeight = -64
const weatherHeight = 192
const minEntityY = minHeight-40
const netherHeight = 127
const waterHeight = 62
const blockData = [
{
name: "air",
id: 0,
textures: new Array(6).fill("none"),
transparent: true,
shadow: false,
hidden: true
},
{
name: "grass",
Name: "Grass Block",
textures: [ "dirt", "grassTop", "grassSide" ],
hardness: 0.6,
blastResistance:0.6,
drop:"dirt",
type:"ground",
grassSound: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isSnow = blockData[top].name === "snow" || blockData[top].name === "snowBlock"
if(b === blockIds.grass && isSnow){
world.setBlock(x,y,z,blockIds.grass | CROSS,false,false,false,false,dimension)
}else if(b === (blockIds.grass | CROSS) && !isSnow){
world.setBlock(x,y,z,blockIds.grass,false,false,false,false,dimension)
}
},
compostChance:0.3,
category:"nature",
craftSlabs:true, craftStairs:true,
},
{ name: "dirt", Name:"Dirt", hardness:0.5, blastResistance:0.5, type:"ground",category:"nature",
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
},
{ name: "stone", Name:"Stone", drop:"cobblestone", type:"rock1",category:"nature", hardness:5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "bedrock", Name:"Bedrock", category:"nature", hardness:1000, blastResistance:3600000, stoneSound:true, pistonPush:false, pistonPull:false},
{ name: "sand", Name:"Sand", hardness:0.5, blastResistance:0.5,fallingDust:[212/255, 195/255, 148/255], category:"nature",
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
digSound: ["sand.dig1", "sand.dig2", "sand.dig3", "sand.dig4"],
stepSound: ["sand.step1", "sand.step2","sand.step3","sand.step4","sand.step5"]},
{ name: "gravel", Name:"Gravel", hardness:0.6, blastResistance:0.6, type:"ground",category:"nature",fallingDust:[132/255, 126/255, 124/255],
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
drop: function(){
if(round(random(10)) === 1) return "flint"
else return "gravel"
},
digSound: ["gravel.dig1", "gravel.dig2", "gravel.dig3", "gravel.dig4"],
stepSound: ["gravel.step1", "gravel.step2","gravel.step3","gravel.step4"]},
{
name: "leaves",
Name: "Leaves",
transparent: true,
shadow:false,
cullFace:"never",
hardness: 0.2,
blastResistance:0.2,
type:"plant2",
category:"nature",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "oakSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
decreaseLight:1
},
{
name: "glass",
Name:"Glass",
transparent: true,
shadow: false,
hardness: 0.3,
blastResistance:0.3,
type: "glass",
category:"build",
glassSound: true
},
{ name: "cobblestone", Name:"Cobblestone", hardness:2, blastResistance:6, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "mossyCobble", Name:"Mossy Cobblestone", hardness:2, blastResistance:6, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "stoneBricks", Name:"Stone Bricks", hardness:1.5, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "mossyStoneBricks", Name:"Mossy Stone Bricks", hardness:1.5, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "bricks", Name:"Bricks", hardness:2, type:"rock1",category:"build", stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "coalOre", Name:"Coal Ore", hardness:3, type:"rock1",category:"nature", drop:"coal", stoneSound:true, experience:0.1},
{ name: "ironOre", Name:"Iron Ore", hardness:3, type:"rock2",category:"nature", drop:"rawIron", stoneSound:true, dropAmount:[1,3]},
{ name: "goldOre", Name:"Gold Ore", hardness:3, type:"rock3",category:"nature", drop:"rawGold", stoneSound:true, dropAmount:[1,3]},
{ name: "diamondOre", Name:"Diamond Ore", hardness:3, type:"rock3",category:"nature", drop:"diamond", stoneSound:true, experience:1, dropAmount:[1,3]},
{ name: "redstoneOre", Name:"Redstone Ore", hardness:3, type:"rock3",category:"nature", stoneSound:true, drop:"redstone", dropAmount:[6,9], experience:0.3},
{ name: "lapisOre", Name:"Lapis Lazuli Ore", hardness:3, type:"rock2",category:"nature", drop:"lapisLazuli", stoneSound:true, experience:0.5, dropAmount:[1,3]},
{ name: "emeraldOre", Name:"Emerald Ore", hardness:3, type:"rock3",category:"nature", drop:"emerald", stoneSound:true, experience:1.5, dropAmount:[1,3]},
{ name: "coalBlock", Name:"Block of Coal", hardness:5, type:"rock1",category:"build", stoneSound:true, burnChance:0.4, burnTime:50},
{ name: "ironBlock", Name:"Block of Iron", hardness:5, type:"metal2",category:"build", stoneSound:true},
{ name: "goldBlock", Name:"Block of Gold", hardness:3, type:"metal3",category:"build", stoneSound:true},
{ name: "diamondBlock", Name:"Block of Diamond", hardness:3, type:"metal3",category:"build", stoneSound:true},
{
name: "redstoneBlock", Name:"Block of Redstone", hardness:5, type:"metal1",category:"redstone", stoneSound:true,
onset:function(x,y,z,dimension,world){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z, 16,dimension)
},
ondelete: function(x,y,z,prevTags,prev,dimension,world){
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z, 16,false,dimension)
},
damage:1,
dieMessage: () => username+" died from radiation from block of redstone."
},
{ name: "lapisBlock", Name:"Block of Lapis Lazuli", hardness:3, type:"metal2",category:"build", stoneSound:true},
{ name: "emeraldBlock", Name:"Block of Emerald", hardness:5, type:"metal3",category:"build", stoneSound:true},
{ name: "oakPlanks", Name:"Oak Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "oakLog",
Name:"Oak Log",
textures: [ "logTop", "logSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "acaciaPlanks", Name:"Acacia Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "acaciaLog",
Name:"Acacia Log",
textures: [ "acaciaLogTop", "acaciaLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "birchPlanks", Name:"Birch Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "birchLog",
Name:"Birch Log",
textures: [ "birchLogTop", "birchLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "darkOakPlanks", Name:"Dark Oak Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "darkOakLog",
Name:"Dark Oak Log",
textures: [ "darkOakLogTop", "darkOakLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "junglePlanks", Name:"Jungle Planks", type:"wood",category:"build", hardness:2,woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "jungleLog",
Name:"Jungle Log",
textures: [ "jungleLogTop", "jungleLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "sprucePlanks", Name:"Spruce Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40, craftSlabs:true, craftStairs:true},
{
name: "spruceLog",
Name:"Spruce Log",
textures: [ "spruceLogTop", "spruceLogSide" ],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{ name: "whiteWool", Name:"White Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "orangeWool", Name:"Orange Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "magentaWool", Name:"Magenta Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "lightBlueWool", Name:"Light Blue Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "yellowWool", Name:"Yellow Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "limeWool", Name:"Lime Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "pinkWool", Name:"Pink Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "grayWool", Name:"Gray Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "lightGrayWool", Name:"Light Gray Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "cyanWool", Name:"Cyan Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "purpleWool", Name:"Purple Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "blueWool", Name:"Blue Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "brownWool", Name:"Brown Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "greenWool", Name:"Green Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "redWool", Name:"Red Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "blackWool", Name:"Black Wool",hardness:0.8, clothSound:true, shearBreakTime:0.2, type:"wool",category:"build", burnChance: 0.2, burnTime: 30},
{ name: "whiteConcrete", Name:"White Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "orangeConcrete", Name:"Orange Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "magentaConcrete", Name:"Magenta Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "lightBlueConcrete", Name:"Light Blue Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "yellowConcrete", Name:"Yellow Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "limeConcrete", Name:"Lime Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "pinkConcrete", Name:"Pink Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "grayConcrete", Name:"Gray Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "lightGrayConcrete", Name:"Light Gray Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "cyanConcrete", Name:"Cyan Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "purpleConcrete", Name:"Purple Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "blueConcrete", Name:"Blue Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "brownConcrete", Name:"Brown Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "greenConcrete", Name:"Green Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "redConcrete", Name:"Red Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{ name: "blackConcrete", Name:"Black Concrete",hardness:1.8, type:"rock1",category:"build", stoneSound:true},
{
name: "bookshelf",
Name:"Bookshelf",
textures: [ "oakPlanks", "bookshelf" ],
stoneSound: true,
type:"wood",
category:"decoration",
burnChance:0.4,
burnTime:30
},
{ name: "netherrack",
Name:"Netherrack",
hardness:0.4,
type:"rock1",
category:"nature",
burnTime:Infinity,
digSound: ["netherrack.dig1", "netherrack.dig2", "netherrack.dig3", "netherrack.dig4", "netherrack.dig5", "netherrack.dig6"],
stepSound: ["netherrack.step1", "netherrack.step2","netherrack.step3","netherrack.step4","netherrack.step5","netherrack.step6"],
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "soulSand",
Name:"Soul Sand",
category:"nature",
speedFactor: 0.5,
canHaveSoulFire: true,
digSound: ["soul_sand.dig1", "soul_sand.dig2", "soul_sand.dig3", "soul_sand.dig4", "soul_sand.dig5", "soul_sand.dig6","soul_sand.step7","soul_sand.step8","soul_sand.step9"],
stepSound: ["soul_sand.step1", "soul_sand.step2","soul_sand.step3","soul_sand.step4","soul_sand.step5","soul_sand.step6"],
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name: "glowstone",
Name:"Glowstone",
hardness:0.3,
type:"rock1",
category:"decoration",
lightLevel: 15,
glassSound: true,
shadow:false,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "netherBricks",
Name:"Nether Bricks",
category:"build",
craftSlabs:true, craftStairs:true,
digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
{ name: "redNetherBricks",
Name:"Red Nether Bricks",
category:"build",
craftSlabs:true, craftStairs:true,
digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
{
name: "netherQuartzOre", 
Name:"Nether Quartz Ore",
category:"nature",
digSound: ["nether_ore.dig1", "nether_ore.dig2", "nether_ore.dig3", "nether_ore.dig4"],
stepSound: ["nether_ore.step1", "nether_ore.step2","nether_ore.step3","nether_ore.step4","nether_ore.step5"],
drop: "quartz",
dropAmount: [1,2],
hardness:3,
blastResistance:3,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name: "quartzBlock",
Name:"Block of Quartz",
category:"build",
textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"],
stoneSound: true,
hardness:1.5,
blastResistance:6,
craftSlabs:true, craftStairs:true,
},
{
name: "quartzPillar",
Name:"Pillar",
category:"build",
textures: ["quartzPillarTop", "quartzPillar"],
stoneSound: true,
hardness:1.5,
blastResistance:6
},
{
name: "chiseledQuartzBlock",
Name:"Chiseled Quartz Block",
category:"build",
textures: ["chiseledQuartzBlockTop", "chiseledQuartzBlock"],
stoneSound: true,
hardness:1.5,
blastResistance:6
},
{ name: "chiseledStoneBricks", Name:"Chiseled Stone Bricks",category:"build", hardness:1.5, blastResistance:6, stoneSound:true},
{ name: "smoothStone", Name:"Smooth Stone",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{ name: "andesite", Name:"Andesite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{ name: "polishedAndesite", Name:"Polished Andesite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "diorite", Name:"Diorite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{ name: "polishedDiorite", Name:"Polished Diorite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "granite", Name:"Granite", stoneSound:true,category:"nature", hardness:1.5, blastResistance:6, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{ name: "polishedGranite", Name:"Polished Granite",category:"build", hardness:1.5, blastResistance:6, stoneSound:true, craftSlabs:true, craftStairs:true},
{ // I swear, if y'all don't stop asking about TNT every 5 minutes!
name: "tnt",
Name:"TNT",
textures: ["tntBottom", "tntTop", "tntSides"],
superTntTextures: ["superTntBottom","superTntTop","superTnt"],
ultraTntTextures: ["ultraTntBottom","ultraTntTop","ultraTnt"],
//onupdate: function(x,y,z){
//  explode(x,y,z,5)
//}, flint and steel explodes it
explode: function(x,y,z, how,dimension,world){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
var e = new entities[entityIds.PrimedTNT](x,y,z)
world.addEntity(e,false,dimension)
world.playSound(x,y,z, "random.fuse")
switch(how){
case "explosion":
e.timeLimit = rand(10,30)
}
},
superTntExplode: function(x,y,z,dimension,world){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
var e = new entities[entityIds.PrimedSuperTNT](x,y,z)
world.addEntity(e,false,dimension)
world.playSound(x,y,z, "random.fuse")
},
ultraTntExplode: function(x,y,z,dimension,world){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
var e = new entities[entityIds.PrimedUltraTNT](x,y,z)
world.addEntity(e,false,dimension)
world.playSound(x,y,z, "random.fuse")
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension)
if(power > 0) this.explode(x,y,z,null,dimension,world)
},
onset:function(x,y,z,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension)
if(power > 0) this.explode(x,y,z,null,dimension,world)
},
burnChance:0.6,
onburn:function(x,y,z,dimension,world){
this.explode(x,y,z,null,dimension,world)
},
category:"redstone",
grassSound: true
},
{
name: "portal",
solid:false,
shadow: false,
portal: true,
transparent:true,
cullFace:"same",
lightLevel: 11,
flatIcon:true,
drop:"air",
glassSound: true,
ambientSound:"portal.portal",
pistonPush:false,
pistonPull:false,
hidden:true,
ontouch: function(x,y,z,dimension,ent){
ent.portalEffect += 2.5
if(ent.portalEffect >= 100 && ent.portalFadeOutEffect <= 0){
if(ent.type === "Player") ent.connection.send({type:"portalOut"})
ent.portalFadeOutEffect = 100
if(ent.dimension === ""){
ent.x /= 8, ent.z /= 8
}else{
ent.x *= 8, ent.z *= 8
}
ent.tp(ent.x,ent.y,ent.z,ent.dimension === "nether" ? "" : "nether")
ent.doingPortal = blockIds.portal
ent.world.playSound(x,y,z,"portal.travel")
if(ent.type === "Player") ent.addAchievment("Into the Nether")
}
},
searchForPortal:function(x,y,z,dimension,world){
for(let x2=0; x2<128; x2++) for(let y2=0; y2<128; y2++) for(let z2=0; z2<128; z2++) {
let x3 = x+((x2%2)?-(x2+1)/2:x2/2)//alternate back and forth, example: 0, -1, 1, -2, 2
let y3 = y+((y2%2)?-(y2+1)/2:y2/2)
let z3 = z+((z2%2)?-(z2+1)/2:z2/2)
if(blockData[world.getBlock(x3,y3,z3,dimension)].name === "portal") return [x3,y3,z3]
}
},
doneLoading:function(p,world){
let portal = this.searchForPortal(round(p.x),round(p.y),round(p.z),p.dimension,world)
if(portal){
p.tp(portal[0],portal[1]-0.5+p.height*0.5,portal[2])
p.lastY = p.y
}else{
let portalFill = 0, px = round(p.x), py = round(p.y), pz = round(p.z) //cant use p2 because just finished loading
let dy = 32
mainLoop:for(let y = 32; y<128; y++){
for(let x=px-2; x<px+2; x++) for(let z=pz-2; z<pz+2; z++){
if(blockData[world.getBlock(x,y,z,p.dimension)].solid){
portalFill = 0
continue mainLoop
}
}
portalFill++, dy = y
if(portalFill === 6) break mainLoop
}
if(portalFill === 6){
let x = px, z = pz, y = dy
if(rand() > 0.5){
world.setBlock(x-2,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x+1,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
//layer2
world.setBlock(x-2,y-4,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-4,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x,y-4,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x+1,y-4,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-2,y-3,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-3,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x+1,y-3,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-2,y-2,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-2,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z,blockIds.portal|PORTAL|NORTH,false,false,false,false,p.dimension)
world.setBlock(x+1,y-2,z,blockIds.obsidian,false,false,false,false,p.dimension)
//layer5
world.setBlock(x-2,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x-1,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x+1,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
}else{
world.setBlock(x,y-5,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-5,z-1,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-5,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-5,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
//layer2
world.setBlock(x,y-4,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-4,z-1,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-4,z,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-4,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z-1,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-3,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z-1,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z,blockIds.portal|PORTAL|EAST,false,false,false,false,p.dimension)
world.setBlock(x,y-2,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
//layer5
world.setBlock(x,y-1,z-2,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-1,z-1,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-1,z,blockIds.obsidian,false,false,false,false,p.dimension)
world.setBlock(x,y-1,z+1,blockIds.obsidian,false,false,false,false,p.dimension)
}
p.tp(x,dy-5+0.5+p.height*0.5,z)
p.lastY = p.y
}else world.sendAll({type:"message",fromServer:true,data:"§cFailed to find and place portal"})
}
}
},
{ name: "obsidian", Name:"Obsidian", stoneSound:true, type:"rock4",category:"nature", hardness:50, blastResistance:1200, pistonPush:false, pistonPull:false, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
//the old redstone dust added before this version of minekhan was public (early 2021)
/*{
name:"redstoneDust",
onupdate: function(x,y,z){
var neigbors = [
world.getBlock(x+1,y,z),
world.getBlock(x-1,y,z),
world.getBlock(x,y,z+1),
world.getBlock(x,y,z-1),
world.getBlock(x,y+1,z),
world.getBlock(x,y-1,z)
];
if(neigbors.includes(blockIds.redstoneBlock) || neigbors.includes(blockIds.redstoneDustOn)){
world.setBlock(x,y,z, blockIds.redstoneDustOn, false, true)
}
}
},
{
name:"redstoneDustOn",
hidden: true,
onupdate: function(x,y,z){
var checked = []
function touchingSource(x,y,z, t){
t = t || 0;
t ++;
var neighbors = [
[x+1,y,z],
[x-1,y,z],
[x,y,z+1],
[x,y,z-1],
[x,y+1,z],
[x,y-1,z]
];
for(var i=0; i<neighbors.length; i++){
var value = neighbors[i];
var block = world.getBlock(value[0], value[1], value[2])
if(block === blockIds.redstoneBlock){
return true;
}
if(t<10){
if( !(checked.includes[value]) && (block === blockIds.redstoneDust || block === blockIds.buffer) && touchingSource(value[0], value[1], value[2], t)){
checked.push(value);
return true
};
}
}
return false;
}
if(!touchingSource(x,y,z)){
world.setBlock(x,y,z, blockIds.redstoneDust);
}
//world.setBlock(x,y,z, blockIds.redstoneDust);
}
},*/
{
name:"redstone",
Name:"Redstone Dust",
item:true,
useAs:"redstoneDust",
category:"redstone",
},
{
name:"redstoneDust",
textures:"redstoneDustDot",
shadow:false,
transparent:true,
solid:false,
hidden:true,
smoothLight:false,
damage:(x,y,z,dimension,world) => world.getPower(x,y,z,dimension)/15,
dieMessage: () => username+" died from radiation from redstone dust.",
drop: "redstone",
carryRedstone:true,
tagBits:{
north:[0,1],
south:[1,1],
east:[2,1],
west:[3,1],
northUp:[4,1],
southUp:[5,1],
eastUp:[6,1],
westUp:[7,1],
northDown:[8,1],
southDown:[9,1],
eastDown:[10,1],
westDown:[11,1],
up:[12,1],
down:[13,1]
},
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
let tags = world.getTags(x,y,z,dimension)
let north, south, east, west
let northUp = getTagBits(tags,"northUp",this.id), southUp = getTagBits(tags,"southUp",this.id), eastUp = getTagBits(tags,"eastUp",this.id), westUp = getTagBits(tags,"westUp",this.id)
let northDown = getTagBits(tags,"northDown",this.id), southDown = getTagBits(tags,"southDown",this.id), eastDown = getTagBits(tags,"eastDown",this.id), westDown = getTagBits(tags,"westDown",this.id)
let up, down
let pnorthUp = northUp, psouthUp = southUp, peastUp = eastUp, pwestUp = westUp,
pnorthDown = northDown, psouthDown = southDown, peastDown = eastDown, pwestDown = westDown
let above = world.getBlock(x,y+1,z)
if(above && !blockData[above].transparent){
westUp = eastUp = southUp = northUp = up = false
}else{
westUp = this.connectable(x+1,y+1,z,"westUp",dimension,b,world)
eastUp = this.connectable(x-1,y+1,z,"eastUp",dimension,b,world)
southUp = this.connectable(x,y+1,z-1,"southUp",dimension,b,world)
northUp = this.connectable(x,y+1,z+1,"northUp",dimension,b,world)
up = this.connectable(x,y+1,z,"up",dimension,b,world)
}
westDown = this.connectable(x+1,y-1,z,"westDown",dimension,b,world)
eastDown = this.connectable(x-1,y-1,z,"eastDown",dimension,b,world)
southDown = this.connectable(x,y-1,z-1,"southDown",dimension,b,world)
northDown = this.connectable(x,y-1,z+1,"northDown",dimension,b,world)
down = this.connectable(x,y-1,z,"down",dimension,b,world)
west = westUp || westDown || this.connectable(x+1,y,z,"west",dimension,b,world)
east = eastUp || eastDown || this.connectable(x-1,y,z,"east",dimension,b,world)
south = southUp || southDown || this.connectable(x,y,z-1,"south",dimension,b,world)
north = northUp || northDown || this.connectable(x,y,z+1,"north",dimension,b,world)
if(north + south + east + west === 1){
//make it a line. it can't be half of a line
if(north) south = true
if(south) north = true
if(east) west = true
if(west) east = true
}
if(up || down){
north = south = east = west = true
}
world.setTagByName(x,y,z,"north",north,true,dimension,true)
world.setTagByName(x,y,z,"south",south,true,dimension,true)
world.setTagByName(x,y,z,"east",east,true,dimension,true)
world.setTagByName(x,y,z,"west",west,true,dimension,true)
world.setTagByName(x,y,z,"northUp",northUp,true,dimension,true)
world.setTagByName(x,y,z,"southUp",southUp,true,dimension,true)
world.setTagByName(x,y,z,"eastUp",eastUp,true,dimension,true)
world.setTagByName(x,y,z,"westUp",westUp,true,dimension,true)
world.setTagByName(x,y,z,"northDown",northDown,true,dimension,true)
world.setTagByName(x,y,z,"southDown",southDown,true,dimension,true)
world.setTagByName(x,y,z,"eastDown",eastDown,true,dimension,true)
world.setTagByName(x,y,z,"westDown",westDown,true,dimension,true)
world.setTagByName(x,y,z,"up",up,true,dimension,true)
world.setTagByName(x,y,z,"down",down,false,dimension,false)//notice last one not lazy and not remote
//set texture and stuff
let sum = north + south + east + west
let block = this.id //dot
if(sum === 2){
if(north && west) block = this.id | STAIR | EAST
else if(west && south) block = this.id | STAIR | SOUTH
else if(south && east) block = this.id | STAIR | WEST
else if(east && north) block = this.id | STAIR | NORTH
else{
if(north || south) block = this.id | SLAB | NORTH
if(east || west) block = this.id | SLAB | EAST
}
}else if(sum === 3){
if(east && west){
if(north) block = this.id | DOOR | NORTH
else block = this.id | DOOR | SOUTH
}else if(north && south){
if(east) block = this.id | DOOR | WEST
else block = this.id | DOOR | EAST
}
}else if(sum === 4) block = this.id | PANE
if((b & FLIP) === FLIP) block |= FLIP //blue redstone
if(world.getBlock(x,y,z,dimension) !== block){
world.setBlock(x,y,z,block,false,false,false,true,dimension)
//world.updateBlock(x,y,z,false,false,null,null,null,dimension)
}
if(pnorthUp != northUp) world.updateBlock(x,y+1,z+1,false,false,null,null,null,dimension), world.unspreadPower(x,y+1,z+1,world.getPower(x,y+1,z+1,dimension), true,dimension)
if(psouthUp != southUp) world.updateBlock(x,y+1,z-1,false,false,null,null,null,dimension), world.unspreadPower(x,y+1,z-1,world.getPower(x,y+1,z-1,dimension), true,dimension)
if(pwestUp != westUp) world.updateBlock(x+1,y+1,z,false,false,null,null,null,dimension), world.unspreadPower(x+1,y+1,z,world.getPower(x+1,y+1,z,dimension), true,dimension)
if(peastUp != eastUp) world.updateBlock(x-1,y+1,z,false,false,null,null,null,dimension), world.unspreadPower(x-1,y+1,z,world.getPower(x-1,y+1,z,dimension), true,dimension)
if(pnorthDown != northDown) world.updateBlock(x,y-1,z+1,false,false,null,null,null,dimension), world.unspreadPower(x,y-1,z+1,world.getPower(x,y-1,z+1,dimension), true,dimension)
if(psouthDown != southDown) world.updateBlock(x,y-1,z-1,false,false,null,null,null,dimension), world.unspreadPower(x,y-1,z-1,world.getPower(x,y-1,z-1,dimension), true,dimension)
if(pwestDown != westDown) world.updateBlock(x+1,y-1,z,false,false,null,null,null,dimension), world.unspreadPower(x+1,y-1,z,world.getPower(x+1,y-1,z,dimension), true,dimension)
if(peastDown != eastDown) world.updateBlock(x-1,y-1,z,false,false,null,null,null,dimension), world.unspreadPower(x-1,y-1,z,world.getPower(x-1,y-1,z,dimension), true,dimension)
//above: number != boolean
this.onpowerupdate(x,y,z,x,y,z,false,dimension,world)
},
onset:function(x,y,z,dimension,world){
//this.onupdate(x,y,z,null,null,null,null,null,dimension)
let power = world.getRedstoneWirePower(x,y,z,dimension)
var strong = world.getSurroundingBlockPower(x,y,z,dimension) === "strong"
if(strong) power = 15
world.setTagByName(x,y,z,"power",power,false,dimension)
if(power) world.spreadPower(x,y,z,power,dimension)
},
ondelete:function(x,y,z,tags,prev,dimension,world){
const power = getTagBits(tags,"power",this.id)
if(power) world.unspreadPower(x,y,z,power,false,dimension)
if(getTagBits(tags,"north",this.id)){
var block = world.getBlock(x,y,z+1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z+1, null, "south",dimension)
}
}
if(getTagBits(tags,"south",this.id)){
var block = world.getBlock(x,y,z-1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z-1, null, "north",dimension)
}
}
if(getTagBits(tags,"west",this.id)){
var block = world.getBlock(x+1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x+1,y,z, null, "east",dimension)
}
}
if(getTagBits(tags,"east",this.id)){
var block = world.getBlock(x-1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x-1,y,z, null, "west",dimension)
}
}
var block = world.getBlock(x,y-1,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y-1,z, null, "top",dimension)
}
//update the diagnolly connecting redstone
if(getTagBits(tags,"northUp",this.id)) world.updateBlock(x,y+1,z+1,false,false,null,null,null,dimension), world.unspreadPower(x,y+1,z+1,world.getPower(x,y+1,z+1,dimension), true,dimension)
if(getTagBits(tags,"southUp",this.id)) world.updateBlock(x,y+1,z-1,false,false,null,null,null,dimension), world.unspreadPower(x,y+1,z-1,world.getPower(x,y+1,z-1,dimension), true,dimension)
if(getTagBits(tags,"westUp",this.id)) world.updateBlock(x+1,y+1,z,false,false,null,null,null,dimension), world.unspreadPower(x+1,y+1,z,world.getPower(x+1,y+1,z,dimension), true,dimension)
if(getTagBits(tags,"eastUp",this.id)) world.updateBlock(x-1,y+1,z,false,false,null,null,null,dimension), world.unspreadPower(x-1,y+1,z,world.getPower(x-1,y+1,z,dimension), true,dimension)
if(getTagBits(tags,"northDown",this.id)) world.updateBlock(x,y-1,z+1,false,false,null,null,null,dimension), world.unspreadPower(x,y-1,z+1,world.getPower(x,y-1,z+1,dimension), true,dimension)
if(getTagBits(tags,"southDown",this.id)) world.updateBlock(x,y-1,z-1,false,false,null,null,null,dimension), world.unspreadPower(x,y-1,z-1,world.getPower(x,y-1,z-1,dimension), true,dimension)
if(getTagBits(tags,"westDown",this.id)) world.updateBlock(x+1,y-1,z,false,false,null,null,null,dimension), world.unspreadPower(x+1,y-1,z,world.getPower(x+1,y-1,z,dimension), true,dimension)
if(getTagBits(tags,"eastDown",this.id)) world.updateBlock(x-1,y-1,z,false,false,null,null,null,dimension), world.unspreadPower(x-1,y-1,z,world.getPower(x-1,y-1,z,dimension), true,dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
if(x===sx && y===sy && z===sz && !blockPowerChanged){
var tags = world.getTags(x,y,z,dimension)
if(getTagBits(tags,"power",this.id)){
if(getTagBits(tags,"north",this.id) && world.getBlockPower(x,y,z+1, "south",dimension) !== "weak"){
var block = world.getBlock(x,y,z+1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z+1, "weak", "south",dimension)
}
}
if(getTagBits(tags,"south",this.id) && world.getBlockPower(x,y,z-1, "north",dimension) !== "weak"){
var block = world.getBlock(x,y,z-1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z-1, "weak", "north",dimension)
}
}
if(getTagBits(tags,"west",this.id) && world.getBlockPower(x+1,y,z, "east",dimension) !== "weak"){
var block = world.getBlock(x+1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x+1,y,z, "weak", "east",dimension)
}
}
if(getTagBits(tags,"east",this.id) && world.getBlockPower(x-1,y,z, "west",dimension) !== "weak"){
var block = world.getBlock(x-1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x-1,y,z, "weak", "west",dimension)
}
}
}else{
if(world.getBlockPower(x,y,z+1, "south",dimension)){
var block = world.getBlock(x,y,z+1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z+1, null, "south",dimension)
}
}
if(world.getBlockPower(x,y,z-1, "north",dimension)){
block = world.getBlock(x,y,z-1,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y,z-1, null, "north",dimension)
}
}
if(world.getBlockPower(x+1,y,z, "east",dimension)){
block = world.getBlock(x+1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x+1,y,z, null, "east",dimension)
}
}
if(world.getBlockPower(x-1,y,z, "west",dimension)){
block = world.getBlock(x-1,y,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x-1,y,z, null, "west",dimension)
}
}
}
var target = getTagBits(tags,"power",this.id) ? "weak" : null
if(target !== world.getBlockPower(x,y-1,z, "top",dimension)){
var block = world.getBlock(x,y-1,z,dimension)
if(block && !blockData[block].transparent){
world.setBlockPower(x,y-1,z, target, "top",dimension)
}
}
}else if(blockPowerChanged){
var shouldBeOn = /*world.getRedstoneWirePower(x,y,z) || */world.getSurroundingBlockPower(x,y,z,dimension) === "strong"
var power = world.getPower(x,y,z,dimension)
if(shouldBeOn && !power){
world.setPower(x,y,z,15,false,dimension)
world.spreadPower(x,y,z,15,dimension)
}else if(!shouldBeOn && power){
world.unspreadPower(x,y,z,15,true,dimension)
}
}
},
connectables: ["redstoneBlock", "redstoneLamp", "tnt", "redstoneTorch", "lever", "redstoneConnector","is:button", "piston","pistonSticky","is:pressurePlate","dropper","dispenser","target","is:coloredRedstoneLamp","noteBlock", "daylightDetector","is:commandBlock"],
connectable: function(x,y,z, d,dimension, b,world) {
var id = world.getBlock(x,y,z,dimension)
if(!id) return false
var up = false, down = false
switch(d){
case "northUp":
case "southUp":
case "eastUp":
case "westUp":
case "up":
up = true
break
case "northDown":
case "southDown":
case "eastDown":
case "westDown":
case "down":
down = true
break
}
if(down && d !== "down"){
var block = world.getBlock(x,y+1,z,dimension)
if(block && !blockData[block].transparent) return false
}
if(up || down) return blockData[id].name === "redstoneDust" && (id & FLIP) === (b & FLIP)
if(blockData[id].name === "redstoneDust" && (id & FLIP) === (b & FLIP)) return true
if(this.connectables.includes(blockData[id].name)) return true
for(var i of this.connectables){
if(i.startsWith("is:")){
if(blockData[id][i.replace("is:","")]) return true
}
}
if(blockData[id].name === "repeater" || blockData[id].name === "notGate"){
var canIt = false
var facing = blockData[id].getFacing(x,y,z,dimension,world)
switch(facing){
case "north":
case "south":
canIt = d === "north" || d === "south"
break
case "east":
case "west":
canIt = d === "east" || d === "west"
}
return canIt
}else if(blockData[id].name === "observer"){
var facing = blockData[id].getFacing(x,y,z,dimension,world)
switch(facing){
case "east":
return d === "east"
case "west":
return d === "west"
case "north":
return d === "south"
case "south":
return d === "north"
}
}else if(blockData[id].logicGate){
var facing = blockData[id].getFacing(x,y,z,dimension,world)
switch(facing){
case "east":
return d === "east" || d === "north" || d === "south"
case "west":
return d === "west" || d === "north" || d === "south"
case "north":
return d === "south" || d === "east" || d === "west"
case "south":
return d === "north" || d === "east" || d === "west"
}
}else if(blockData[id].name === "comparator"){
var facing = blockData[id].getFacing(x,y,z,dimension,world)
var canIt
switch(facing){
case "east":
canIt = canIt || d === "east" || d === "north" || d === "south"
case "west":
canIt = canIt || d === "west" || d === "north" || d === "south"
case "north":
canIt = canIt || d === "south" || d === "east" || d === "west"
case "south":
canIt = canIt || d === "north" || d === "east" || d === "west"
}
switch(facing){
case "north":
case "south":
canIt = canIt || d === "north" || d === "south"
break
case "east":
case "west":
canIt = canIt || d === "east" || d === "west"
}
return canIt
}
return false
}
},
/*{
name: "buffer",
textures: ["bufferTop", "bufferMiddle"],
category:"redstone",
onupdate: function(x,y,z){
setTimeout(() => {
var isOn = world.getBlock(x,y+1,z);
isOn = isOn === blockIds.redstoneDustOn || isOn === blockIds.redstoneBlock;
if(isOn && world.getBlock(x,y-1,z) === blockIds.redstoneDust ){
setTimeout(function(){world.setBlock(x,y-1,z, blockIds.redstoneDustOn)}, 500);
}
}, 10)
}
},*/
{
name:"blueRedstone",
Name:"Blue Redstone Dust",
item:true,
useAs:() => blockIds.redstoneDust | FLIP,
category:"redstone",
},
{ name: "soup",category:"food"},
{ name: "soup2",category:"food"},
{
name: "soup3",
transparent:true,
category:"food"
},
{ name: "soup4",category:"food"},
{ name: "randomSoup",category:"food"},
{
name: "redStain",
transparent: true,
},
{
name:"poision potion",
transparent:true,
crossShape:true,
},
{
name: "light",
textures: "none",
transparent:true,
lightLevel: 15,
solid: false,
iconTexture: "light_15",
flatIcon: true,
shadow: false,
noHitbox:true,
pistonPush:false,
pistonPull:false,
rarity:"epic"
},
{
name: "autumnLeaves",
transparent: true,
cullFace:"never",
burnChance: 0.2,
burnTime: 30,
category:"nature",
decreaseLight:1
},
{
name: "darkLeaves",
transparent: true,
cullFace:"never",
burnChance: 0.2,
burnTime: 30,
category:"nature",
hardness: 0.2,
blastResistance:0.2,
type:"plant2",
drop: function(){
if(rand() > 0.8) return "stick"
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
compostChance:0.3,
grassSound: true,
decreaseLight:1
},
{
name: "redBerryLeaves",
transparent: true,
cullFace:"never",
burnChance: 0.2,
burnTime: 30,
category:"nature",
hardness: 0.2,
blastResistance:0.2,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "greenGrapes"
else if(r === 1) return "purpleGrapes"
else return "stick"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
compostChance:0.3,
grassSound: true,
decreaseLight:1
},
{
name: "blueBerryLeaves",
transparent: true,
cullFace:"never",
burnChance: 0.2,
burnTime: 30,
category:"nature",
hardness: 0.2,
blastResistance:0.2,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "greenGrapes"
else if(r === 1) return "purpleGrapes"
else return "stick"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
compostChance:0.3,
grassSound: true,
decreaseLight:1
},
{
name: "yellowLeaves",
transparent: true,
cullFace:0,
burnChance: 0.2,
burnTime: 30,
category:"nature",
decreaseLight:1,
hardness: 0.2,
},
{ name: "lilyOftheValley",
Name:"Lily of The Valley",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "poppy",
Name:"Poppy",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "dandelion",
Name:"Dandelion",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "blueOrchid",
Name:"Blue Orchid",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
potCross:true
},
{ name: "pinkTulip",
Name:"Pink Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "orangeTulip",
Name:"Orange Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "redTulip",
Name:"Red Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "whiteTulip",
Name:"White Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "azureBluet",
Name:"Azure Bluet",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "cornFlower",
Name:"Cornflower",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "purpleFlower",
Name:"Purple Flower (i don't think this exsists in minecraft)",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
hidden:true
},
{ name: "allium",
Name:"Allium",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "oxeyeDaisy",
Name:"Oxeye Daisy",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "lilac",
Name:"Lilac",
solid: false,
transparent: true,
shadow: false,
textures: "lilacTop",
tallcrossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "roseBush",
Name:"Rose Bush",
solid: false,
transparent: true,
shadow: false,
textures: "roseBushTop",
tallcrossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "peony",
Name:"Peony",
solid: false,
transparent: true,
shadow: false,
textures: "peonyTop",
tallcrossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{ name: "witherRose",
Name:"Wither Rose",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
ontouch: (x,y,z,dimension,ent) => ent.applyEffect("wither",1,2,false),
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name: "TallGrass",
Name:"Grass",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
drop: "wheatSeeds",
dropAmount:[0,1],
dropSelfWhenSheared:true,
shearDropAmount:1,
compostChance:0.5,
liquidBreakable:"drop",
category:"nature"
},
{ 
name: "oakDoor",
Name:"Oak Door",
transparent: true,
shadow: false,
textures: "oakDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "spruceDoor",
Name:"Spruce Door",
transparent: true,
shadow: false,
textures:"spruceDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "ironDoor",
Name:"Iron Door",
transparent: true,
shadow: false,
textures:"ironDoorBottom",
door:true,
stoneSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "darkOakDoor",
Name:"Dark Oak Door",
transparent: true,
shadow: false,
textures:"darkOakDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "birchDoor",
Name:"Birch Door",
transparent: true,
shadow: false,
textures:"birchDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "jungleDoor",
Name:"Jungle Door",
transparent: true,
shadow: false,
textures:"jungleDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "acaciaDoor",
Name:"Acacia Door",
transparent: true,
shadow: false,
textures:"acaciaDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "warpedDoor",
Name:"Warped Door",
transparent: true,
shadow: false,
textures:"warpedDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "crimsonDoor",
Name:"Crimson Door",
transparent: true,
shadow: false,
textures:"crimsonDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name: "torch",
Name:"Torch",
transparent: true,
shadow: false,
torch: true,
lightLevel: 13,
woodSound:true,
solid:false,
category:"decoration"
},
{
name: "soulTorch",
Name:"Soul Torch",
transparent: true,
shadow: false,
torch: true,
lightLevel: 10,
woodSound:true,
solid:false,
category:"decoration"
},
{
name: "lantern",
Name:"Lantern",
transparent: true,
shadow: false,
lightLevel: 13,
iconTexture: "lanternIcon",
lantern: true,
category:"decoration",
digSound: ["lantern.dig1", "lantern.dig2", "lantern.dig3", "lantern.dig4", "lantern.dig5", "lantern.dig6"],
placeSound: ["lantern.place1", "lantern.place2","lantern.place3","lantern.place4","lantern.place5","lantern.place6"]
},
{
name: "soulLantern",
Name:"Soul Lantern",
transparent: true,
shadow: false,
lightLevel: 10,
iconTexture:"soulLanternIcon",
lantern: true,
category:"decoration",
digSound: ["lantern.dig1", "lantern.dig2", "lantern.dig3", "lantern.dig4", "lantern.dig5", "lantern.dig6"],
placeSound: ["lantern.place1", "lantern.place2","lantern.place3","lantern.place4","lantern.place5","lantern.place6"]
},
{
name: "beacon",
Name:"Beacon",
hardness:3,
transparent: true,
shadow: false,
beacon: true,
lightLevel: 15,
glassSound: true,
pistonPush:false,
pistonPull:false,
category:"decoration",
rarity:"rare",
tagBits:null,
beaconBlocks:["ironBlock","goldBlock","emeraldBlock","diamondBlock","netheriteBlock"],
getSize:function(x,y,z,dimension,world){
let minSize
sizeLoop:for(let size=1; size<4; size++){
for(let x2=x-size; x2<=x+size; x2++) for(let z2=z-size; z2<=z+size; z2++){
let block2 = world.getBlock(x2,y-size,z2)
if(!this.beaconBlocks.includes(blockData[block2].name)) break sizeLoop
}
minSize = size
}
return minSize
},
update: function(x,y,z,dimension,world){
let minSize = this.getSize(x,y,z,dimension,world), block = world.getBlock(x,y,z,dimension)
if(minSize){
if(block !== (this.id | BEACON)){
world.setBlock(x,y,z,this.id|BEACON,false,false,false,true,dimension)
}
}else if(block !== this.id) world.setBlock(x,y,z,this.id,false,false,false,true,dimension)
return minSize
},
onplace: function(x,y,z, dimension, player,world){
this.update(x,y,z,dimension,world)
}
},
{
name: "cactus",
Name:"Cactus",
textures: ["cactusBottom", "cactusTop", "cactusSide"],
transparent: true,
cactus: true,
damage: 1,
potCross: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.5,
liquidBreakable:"drop",
category:"nature"
},
{
name: "glassPane",
Name:"Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["glassPaneTop","glassPaneTop","glass","glass","glassPaneSide","glassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "ladder",
Name:"Ladder",
transparent: true,
shadow: false,
wallFlat: true,ladder:true,
hardness:0.4,
type:"wood",
category:"decoration"
},
{
name: "vine",
Name:"Vine",
transparent: true,
shadow: false,
wallFlat: true,ladder:true,
drop:"air",
dropSelfWhenSheared:true,
shearBreakTime:0.35,
liquidBreakable:"drop",
solid:false,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var fx = x, fz = z
switch(b){
case this.id | WALLFLAT | NORTH:
fz++
break
case this.id | WALLFLAT | SOUTH:
fz--
break
case this.id | WALLFLAT | EAST:
fx++
break
case this.id | WALLFLAT | WEST:
fx--
break
}
var block = world.getBlock(fx,y,fz,dimension)
var above = world.getBlock(x,y+1,z,dimension)
if(!world.settings.blocksFall || block && blockData[block].solid || above === b) return
world.setTimeout(function(){
var block = world.getBlock(fx,y,fz,dimension)
var above = world.getBlock(x,y+1,z,dimension)
if(block && blockData[block].solid || above === b) return
world.setBlock(x,y,z, 0,false,false,false,false,dimension)
world.addItems(x,y,z,dimension,0,0,0,b&isCube,true)
world.blockParticles(b,x,y,z,30, "break",dimension)
world.blockSound(b, "dig", x,y,z)
},tickTime,x,y,z,dimension)
},
compostChance:0.5,
category:"nature"
},
{
name: "Water",
textures:["Water","waterFlow"],
transparent: true,
liquid: true,
wet:true,
solid:false,
shadow: false,
cullFace:"never",
blastResistance:100,
hidden:true,
dripThroughBlocks:[43/255, 63/255, 213/255],
getLevelDifference:function(level){return level-1},
canDuplicate:true,
drop:"air",
density:1,
inLiquid:1,
flowSound:"liquid.water",
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var block = world.getBlock(x,y+1,z,dimension)
if (block && blockData[block].name === "Lava") {
return world.setBlock(x,y,z,blockIds.stone,false,false,false,false,dimension)
}
var n = world.getBlock(x,y,z+1,dimension)
var s = world.getBlock(x,y,z-1,dimension)
var e = world.getBlock(x+1,y,z,dimension)
var w = world.getBlock(x-1,y,z,dimension)
if (n && blockData[n].name === "Lava" || s && blockData[s].name === "Lava" || e && blockData[e].name === "Lava" || w && blockData[w].name === "Lava") {
return world.setBlock(x,y,z,blockIds.cobblestone,false,false,false,false,dimension)
}
if(!world.settings.blocksFall) return
var me = this
world.setTimeout(() => me.flow(x,y,z,dimension,world), tickTime*5, x,y,z,dimension)
},
getY:function(x,y,z,dimension){
var block = world.getBlock(x,y,z,dimension)
return (min((this.getLevel(block) || (block ? 8 : 0))*2,14.5)/16)-0.5
},
decreaseLight:1,
},
{
name: "Lava",
textures:["Lava","lavaFlow"],
transparent: true,
liquid: true,
solid:false,
lightLevel:15,
damage:4,
burnEnt:true,
dieMessage: () => username+" tried to swim in lava.",
shadow: false,
blastResistance:100,
hidden:true,
temperature:25,
dripThroughBlocks:[210/255, 59/255, 17/255],
drop:"air",
density:2,
inLiquid:2,
flowSound:"liquid.lava",
getLevelDifference:function(level,dimension){return dimension === "nether" ? level-1 : level-2},
tick:function(x,y,z,dimension,world){
blockData[blockIds.fire].spread(x,y,z,dimension,world)
},
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
let block = world.getBlock(x,y+1,z,dimension)
if (block && blockData[block].name === "Water") {
return world.setBlock(x,y,z,blockIds.obsidian,false,false,false,false,dimension)
}
const under = world.getBlock(x,y-1,z,dimension)
const n = world.getBlock(x,y,z+1,dimension)
const s = world.getBlock(x,y,z-1,dimension)
const e = world.getBlock(x+1,y,z,dimension)
const w = world.getBlock(x-1,y,z,dimension)
if(blockData[under].name === "soulSoil"){
if (blockData[n].name === "ice" || blockData[n].name === "packedIce" || blockData[n].name === "blueIce" || blockData[s].name === "ice" || blockData[s].name === "packedIce" || blockData[s].name === "blueIce" || blockData[e].name === "ice" || blockData[e].name === "packedIce" || blockData[e].name === "blueIce" || blockData[w].name === "ice" || blockData[w].name === "packedIce" || blockData[w].name === "blueIce") {
return world.setBlock(x,y,z,blockIds.basalt,false,false,false,false,dimension)
}
}
if(blockData[under].name === "honeyBlock" || blockData[n].name === "honeyBlock" || blockData[s].name === "honeyBlock" || blockData[e].name === "honeyBlock" || blockData[w].name === "honeyBlock"){
return world.setBlock(x,y,z,blockIds.limestone,false,false,false,false,dimension)
}
if(!world.settings.blocksFall) return
var me = this
world.setTimeout(() => me.flow(x,y,z,dimension,world), tickTime*(dimension === "nether" ? 10 : 30), x,y,z,dimension)
},
getY:function(x,y,z,dimension){
var block = world.getBlock(x,y,z,dimension)
return (min((this.getLevel(block))*2,14.5)/16)-0.5
},
onspawnflow:function(x,y,z,dimension,world){
const under = world.getBlock(x,y-1,z,dimension)
if(under === blockIds.Water){
world.spawnBlock(x,y-1,z,blockIds.stone,dimension,true)
return true
}
},
},
{
name: "craftingTable",
Name:"Crafting Table",
textures: ["oakPlanks","craftingTableTop","craftingTableFront","craftingTableSide"],
onclientclick: () => {changeScene("crafting"); releasePointer()},
woodSound: true,
hardness:2.5,
type:"wood",
category:"items"
},
{
name: "crimsonNylium",
Name:"Crimson Nylium",
textures: ["netherrack", "crimsonNyliumTop", "crimsonNyliumSide"],
nyliumSound: true,
category:"nature",
hardness:0.4,
blastResistance:0.4,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true
},
{
name: "warpedNylium",
Name:"Warped Nylium",
textures: ["netherrack", "warpedNyliumTop", "warpedNyliumSide"],
nyliumSound: true,
category:"nature",
hardness:0.4,
blastResistance:0.4,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true
},
{
name: "crimsonStem",
Name:"Crimson Stem",
textures: ["crimsonStemTop", "crimsonStemSide"],
stemSound: true,
hardness:2,
blastResistance:2,
type:"wood",
category:"nature"
},
{
name: "warpedStem",
Name:"Warped Stem",
textures: ["warpedStemTop", "warpedStemSide"],
stemSound: true,
hardness:2,
blastResistance:2,
type:"wood",
category:"nature"
},
{ name: "netherWartBlock",
Name:"Nether Wart Block",hardness:1,compostChance:0.85,category:"nature",
digSound: ["netherwart.dig1", "netherwart.dig2", "netherwart.dig3", "netherwart.dig4", "netherwart.dig5", "netherwart.dig6"],
stepSound: ["netherwart.step1", "netherwart.step2","netherwart.step3","netherwart.step4","netherwart.step5"],
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "warpedWartBlock",
Name:"Warped Wart Block",hardness:1,compostChance:0.85,category:"nature",
digSound: ["netherwart.dig1", "netherwart.dig2", "netherwart.dig3", "netherwart.dig4", "netherwart.dig5", "netherwart.dig6"],
stepSound: ["netherwart.step1", "netherwart.step2","netherwart.step3","netherwart.step4","netherwart.step5"],
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "shroomlight", lightLevel:15,Name:"Shroomlight",hardness:1,compostChance:0.65,category:"nature",
digSound: ["shroomlight.dig1", "shroomlight.dig2", "shroomlight.dig3", "shroomlight.dig4", "shroomlight.dig5"],
stepSound: ["shroomlight.step1", "shroomlight.step2","shroomlight.step3","shroomlight.step4","shroomlight.step5","shroomlight.step6"]},
{ 
name: "warpedFungus",
Name:"Warped Fungus",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
potCross: true,
compostChance:0.65,
category:"nature",
digSound: ["fungus.dig1", "fungus.dig2", "fungus.dig3", "fungus.dig4", "fungus.dig5", "fungus.dig6"],
growBonemeal: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnNetherMushroom(x&15,y-1,z&15,x,z,"warpedForest")
win.serverRestoreWorldGen()
}
},
{
name: "blackstone",
Name:"Blackstone",
textures: ["blackstoneTop", "blackstone" ],
stoneSound: true,
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true,
},
{ name: "gildedBlackstone", Name:"Gilded Blackstone", category:"nature",stoneSound: true, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
{ name: "polishedBlackstoneBricks", Name:"Polished Blackstone Bricks", category:"build",stoneSound: true, craftSlabs:true, craftStairs:true},
{ name: "chiseledPolishedBlackstone", Name:"Chiseled Polished Blackstone", category:"build",stoneSound: true},
{
name: "netheriteBlock",
Name:"Netherite Block",
type:"rock4",
category:"build",
hardness:50,
blastResistance:1200,
digSound: ["netherite.dig1", "netherite.dig2", "netherite.dig3", "netherite.dig4"],
stepSound: ["netherite.step1", "netherite.step2","netherite.step3","netherite.step4","netherite.step5","netherite.step6"]
},
{
name: "basalt",
Name: "Basalt",
category:"nature",
textures: [ "basaltTop", "basaltSide" ],
basaltSound: true,
hardness:1.25
},
{
name: "polishedBasalt",
Name: "Polished Basalt",
category:"build",
textures: [ "polishedBasaltTop", "polishedBasaltSide" ],
basaltSound: true,
hardness:1.25
},
{ name: "chain", Name:"Chain", category:"build",transparent:true, shadow:false, chain:true, iconTexture:"chainIcon",
digSound: ["chain.dig1", "chain.dig2", "chain.dig3", "chain.dig4"],
stepSound: ["chain.step1", "chain.step2","chain.step3","chain.step4","chain.step5","chain.step6"]},
{ name: "warpedPlanks", Name:"Warped Planks", hardness:2, type:"wood",category:"build", woodSound:true, craftSlabs:true, craftStairs:true},
{ 
name: "warpedTrapdoor",
Name: "Warped Trapdoor",
transparent: true,
shadow: false,
trapdoor: true,
woodSound:true,
category:"build"
},
{
name: "magma", Name:"Magma Block", lightLevel:15,hardness:0.5, type:"rock1",
damage:1,
dieMessage: () => username+" discovered the floor was lava.",
burnTime:Infinity,
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name: "crimsonFungus",
Name: "Crimson Fungus",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
potCross: true,
compostChance:0.65,
category:"nature",
digSound: ["fungus.dig1", "fungus.dig2", "fungus.dig3", "fungus.dig4", "fungus.dig5", "fungus.dig6"],
growBonemeal: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnNetherMushroom(x&15,y-1,z&15,x,z,"crimsonForest")
win.serverRestoreWorldGen()
}
},
{ 
name: "warpedRoots",
Name: "Warped Roots",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
rootSound: true,
compostChance:0.65,
category:"nature",
potCross:true,
potCrossTexture:"warpedRootsPot"
},
{ 
name: "crimsonRoots",
Name: "Crimson Roots",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
rootSound: true,
compostChance:0.65,
category:"nature",
potCross:true,
potCrossTexture:"crimsonRootsPot"
},
{ 
name: "twistingVines",
transparent: true,
solid: false,
shadow: false,
transparent: true,
crossShape: true,
ladder:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isIt = blockData[top].name === "twistingVines" || blockData[top].name === "twistingVinesPlant"
if(isIt){
world.setBlock(x,y,z,blockIds.twistingVinesPlant | CROSS,false,false,false,false,dimension)
}
},
hidden:true,
drop:"twistinVinesPlant"
},
{
name: "twistingVinesPlant",
Name: "Twisting Vines",
transparent: true,
solid: false,
shadow: false,
transparent: true,
crossShape: true,
ladder:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isIt = blockData[top].name === "twistingVines" || blockData[top].name === "twistingVinesPlant"
if(!isIt){
world.setBlock(x,y,z,blockIds.twistingVines | CROSS,false,false,false,false,dimension)
}
},
category:"nature",
},
{
name: "weepingVines",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
ladder:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "weepingVines" || blockData[top].name === "weepingVinesPlant"
if(isIt){
world.setBlock(x,y,z,blockIds.weepingVinesPlant | CROSS,false,false,false,false,dimension)
}
},
hidden:true,
drop:"weepingVinesPlant"
},
{
name: "weepingVinesPlant",
Name:"Weeping Vines",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
ladder:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "weepingVines" || blockData[top].name === "weepingVinesPlant"
if(!isIt){
world.setBlock(x,y,z,blockIds.weepingVines | CROSS,false,false,false,false,dimension)
}
},
category:"nature"
},
{ 
name: "netherSprouts",
Name: "Nether Sprouts",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
compostChance:0.5,
category:"nature",
digSound: ["nether_sprouts.dig1", "nether_sprouts.dig2", "nether_sprouts.dig3", "nether_sprouts.dig4"],
stepSound: ["nether_sprouts.step1", "nether_sprouts.step2","nether_sprouts.step3","nether_sprouts.step4","nether_sprouts.step5"]
},
{ name: "stoneButton", Name:"Stone Button", textures:"stone", category:"redstone",button:true, transparent: true, shadow:false, stone:true },
{ 
name: "RespawnAnchorOff",
category:"items",
textures: ["respawnAnchorBottom", "respawnAnchorTopOff", "respawnAnchorSide0"],
//onupdate: (x,y,z) => {if(world.type !== "nether"){explode(x,y,z,2)}}
},
{ 
name: "RespawnAnchor1",
textures: ["respawnAnchorBottom", "respawnAnchorTop1", "respawnAnchorSide1"],
hidden: true
},
{ 
name: "RespawnAnchor2",
textures: ["respawnAnchorBottom", "respawnAnchorTop2", "respawnAnchorSide2"],
hidden: true
},
{ 
name: "RespawnAnchor3",
textures: ["respawnAnchorBottom", "respawnAnchorTop3", "respawnAnchorSide3"],
hidden: true
},
{ 
name: "RespawnAnchor",
textures: ["respawnAnchorBottom", "respawnAnchorTop", "respawnAnchorSide4"],
hidden: true
},
{
name:"redBed",
Name:"Red Bed",
textures: "bedbottom",
iconTexture: "bedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name: "flintAndSteel",
Name:"Flint & Steel",
textures: "flintAndSteel",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(block === blockIds.tnt){
blockData[blockIds.tnt].explode(x,y,z,null,dimension,world)
item.durability--
}else if(block === (blockIds.tnt | SLAB)){
blockData[blockIds.tnt].superTntExplode(x,y,z,dimension,world)
item.durability--
}else if(block === (blockIds.tnt | STAIR)){
blockData[blockIds.tnt].ultraTntExplode(x,y,z,dimension,world)
item.durability--
}else if(block === blockIds.untnt){
blockData[blockIds.untnt].explode(x,y,z,null,dimension,world)
item.durability--
}else{
var attached = world.getBlock(x,y,z,dimension)
var b = blockIds.fire
if(attached && blockData[attached].canHaveSoulFire) b = blockIds.soulFire
;([x,y,z] = movePositionByFace(face,x,y,z))
switch(face){
case "bottom": b |= STAIR; break
case "north": b |= SLAB | SOUTH; break
case "south": b |= SLAB | NORTH; break
case "east": b |= SLAB | WEST; break
case "west": b |= SLAB | EAST; break
}
item.durability--
if(block === blockIds.obsidian && blockData[blockIds.fire].tryCreatePortal(x,y,z,dimension)) return
world.setBlock(x,y,z,b,false,false,false,false,dimension)
world.playSound(x,y,z, "fire.ignite")
}
},
durability:64,
stackSize:1,
category:"items"
},
{
name: "barrier",
Name:"That Invisible Block with a 🚫 Icon",
textures: "none",
iconTexture: "barrier",
flatIcon:true,
transparent:true,
hardness:Infinity,
pistonPush:false,
pistonPull:false,
category:"items",
rarity:"epic"
},
{
name: "oakSapling",
Name:"Oak Sapling",
crossShape: true,
potCross: true,
transparent: true,
solid: false,
shadow:false,
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnSmallTree(x&15,y-1,z&15,x,z,false)
win.serverRestoreWorldGen()
},
compostChance:0.3,
category:"nature"
},
{ 
name: "crimsonTrapdoor",
Name:"Crimson Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "oakTrapdoor",
Name:"Oak Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "spruceTrapdoor",
Name:"Spruce Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "darkOakTrapdoor",
Name:"Dark Oak Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "birchTrapdoor",
Name:"Birck Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "jungleTrapdoor",
Name:"Jungle Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "acaciaTrapdoor",
Name:"Acaica Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{ 
name: "ironTrapdoor",
Name:"Iron Trapdoor",
transparent: true,
trapdoor: true,
stoneSound: true,
category:"build"
},
{ 
name: "cryingObsidian",
Name:"Obsidian: 😢",
shadow: false,
lightLevel: 10,
stoneSound:true,
type:"rock4",
hardness:50,
blastResistance:1200,
pistonPush:false,
pistonPull:false,
drip:[106/255, 6/255, 187/255],
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{ name: "netherGoldOre",
Name:"Nether Gold Ore",
digSound: ["nether_ore.dig1", "nether_ore.dig2", "nether_ore.dig3", "nether_ore.dig4"],
stepSound: ["nether_ore.step1", "nether_ore.step2","nether_ore.step3","nether_ore.step4","nether_ore.step5"],
drop: "goldNugget",
dropAmount: [1,3],
category:"nature",
hardness:3,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name: "flowerPot",
Name:"Flower Pot",
transparent: true,
shadow: false,
pot: true,
iconTexture:"flowerPotIcon",
flatIcon:true,
category:"decoration",
liquidBreakable:"drop"
},
{
name: "acaciaSapling",
Name:"Acacia Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
compostChance:0.3,
category:"nature",
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnAcacia(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
},
},
{
name: "birchSapling",
Name:"Birch Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
category:"nature",
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnSmallTree(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
},
compostChance:0.3
},
{
name: "darkOakSapling",
Name:"Dark Oak Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
compostChance:0.3,
category:"nature",
liquidBreakable:"drop"
},
{
name: "jungleSapling",
Name:"Jungle Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
compostChance:0.3,
category:"nature",
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnCocoaTree(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
}
},
{
name: "spruceSapling",
Name:"Spruce Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
compostChance:0.3,
category:"nature",
liquidBreakable:"drop",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnSpruce(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
}
},
{
name: "unused_blueOrchidPot",
textures:"error",
transparent: true,
shadow: false,
solid: false,
potCross: true,
hidden:true
},
{
name: "unused_warpedRoots",
textures:"error",
transparent: true,
shadow: false,
solid: false,
potCross: true,
hidden:true,
drop:"warpedRoots",
liquidBreakable:"drop"
},
{
name: "unused_crimsonRoots",
textures:"error",
transparent: true,
shadow: false,
solid: false,
potCross: true,
hidden:true,
drop:"crimsonRoots",
liquidBreakable:"drop"
},
{ name: "whiteCarpet", Name: "White Carpet", textures: "whiteWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "orangeCarpet", Name: "Orange Carpet", textures: "orangeWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "magentaCarpet", Name: "Magenta Carpet", textures: "magentaWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "lightBlueCarpet", Name: "Light Blue Carpet", textures: "lightBlueWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "yellowCarpet", Name: "Yellow Carpet", textures: "yellowWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "limeCarpet", Name: "Lime Carpet", textures: "limeWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "pinkCarpet", Name: "Pink Carpet", textures: "pinkWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "grayCarpet", Name: "Gray Carpet", textures: "grayWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "lightGrayCarpet", Name: "Light Gray Carpet", textures: "lightGrayWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "cyanCarpet", Name: "Cyan Carpet", textures: "cyanWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "purpleCarpet", Name: "Purple Carpet", textures: "purpleWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "blueCarpet", Name: "Blue Carpet", textures: "blueWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "brownCarpet", Name: "Brown Carpet", textures: "brownWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "greenCarpet", Name: "Green Carpet", textures: "greenWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "redCarpet", Name: "Red Carpet", textures: "redWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "blackCarpet", Name: "Black Carpet", textures: "blackWool", category:"decoration",carpet: true, clothSound:true, type:"wool"},
{ name: "polishedBlackstone", Name: "Polished Blackstone", category:"build",stoneSound:true, craftSlabs:true, craftStairs:true},
{ name: "chiseledNetherBricks",
Name: "Chiseled Nether Bricks",
category:"build",
digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
{ name: "crackedNetherBricks",
Name:"Cracked Nether Bricks",
category:"build",
digSound: ["nether_bricks.dig1", "nether_bricks.dig2", "nether_bricks.dig3", "nether_bricks.dig4", "nether_bricks.dig5", "nether_bricks.dig6"],
stepSound: ["nether_bricks.step1", "nether_bricks.step2","nether_bricks.step3","nether_bricks.step4","nether_bricks.step5","nether_bricks.step6"]},
{ name: "smoothBasalt", Name: "Smooth Basalt", basaltSound: true},
{
name: "oakLogSW",
textures: ["logSide","logSide","logTop","logSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "acaciaLogSW",
textures: ["acaciaLogSide","acaciaLogSide","acaciaLogTop","acaciaLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "birchLogSW",
textures: ["birchLogSide","birchLogSide","birchLogTop","birchLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "darkOakLogSW",
textures: ["darkOakLogSide","darkOakLogSide","darkOakLogTop","darkOakLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "jungleLogSW",
textures: ["jungleLogSide","jungleLogSide","jungleLogTop","jungleLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "spruceLogSW",
textures: ["spruceLogSide","spruceLogSide","spruceLogTop","spruceLogSide"],
SW: true, woodSound:true, hidden:true
},
{
name: "crimsonStemSW",
textures: ["crimsonStemSide","crimsonStemSide","crimsonStemTop","crimsonStemSide"],
SW: true, stemSound:true, hidden:true
},
{
name: "warpedStemSW",
textures: ["warpedStemSide","warpedStemSide","warpedStemTop","warpedStemSide"],
SW: true, stemSound:true, hidden:true
},
{
name: "basaltSW",
textures: ["basaltSide","basaltSide","basaltTop","basaltSide"],
SW: true, basaltSound:true, hidden:true
},
{
name: "polishedBasaltSW",
textures: ["polishedBasaltSide","polishedBasaltSide","polishedBasaltTop","polishedBasaltSide"],
SW: true, basaltSound: true, hidden:true
},
{ name:"crimsonPlanks", Name: "Crimson Planks", woodSound:true, hardness:2, type:"wood",category:"build", craftSlabs:true, craftStairs:true },
{
name:"deadBush",
Name:"Dead Bush",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
drop: "stick",
dropAmount: [0,2],
dropSelfWhenSheared:true,
shearDropAmount:1,
liquidBreakable:"drop",
category:"nature",
},
{ name:"stick", Name:"Stick", category:"items",item:true },
{ name:"coal", Name:"Coal", category:"items",item:true },
{ name:"ironIngot", Name:"Iron Ingot", category:"items",item:true },
{ name:"copperIngot", Name:"Copper Ingot", category:"items",item:true },
{ name:"goldIngot", Name:"Gold Ingot", category:"items",item:true },
{ name:"diamond", Name:"Diamond", category:"items",item:true },
{ name:"lapisLazuli", Name:"Lapis Lazuli", category:"items",item:true },
{ name:"emerald", Name:"Emerald", category:"items",item:true },
{ name:"copperOre", Name:"Copper Ore", hardness:3, drop:"rawCopper", dropAmount:[2,5], type:"rock2",category:"nature", stoneSound:true },
{ name:"rawIron", Name:"Raw Iron", category:"items",item:true },
{ name:"rawCopper", Name:"Raw Copper", category:"items",item:true },
{ name:"rawGold", Name:"Raw Gold", category:"items",item:true },
{
name: "netherWart",
Name:"Nether Wart",
transparent: true,
shadow: false,
solid: false,
crop: true,
flatIcon:true,
iconTexture:"netherWartIcon",
compostChance:0.65,
category:"nature",
},
{
name: "wheat",
Name:"Wheat",
transparent: true,
shadow: false,
solid: false,
crop: true,
flatIcon:true,
iconTexture:"wheatIcon",
fullDrop:["wheat","wheatSeeds"],
drop:"wheatSeeds",
liquidBreakable:"drop",
textures:new Array(6).fill('wheatStage0'),
textures1:new Array(6).fill('wheatStage1'),
textures2:new Array(6).fill('wheatStage2'),
textures3:new Array(6).fill('wheatStage3'),
textures4:new Array(6).fill('wheatStage4'),
textures5:new Array(6).fill('wheatStage5'),
textures6:new Array(6).fill('wheatStage6'),
textures7:new Array(6).fill('wheat'),
compostChance:0.65,
category:"nature",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|LANTERN,false,false,false,false,dimension)
}
},
{
name: "lodestone",
Name:"Lodestone",
textures: ["lodestoneTop", "lodestoneSide"]
},
{
name: "anvil",
Name:"Anvil",
transparent: true,
anvil: true,
digSound: "anvil.land",
stepSound: ["stone.step1", "stone.step2","stone.step3","stone.step4","stone.step5","stone.step6"],
onclientclick:function(x,y,z,dimension){
changeScene("anvil")
releasePointer()
},
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
category:"items",
},
{
name: "slimeBlock",
Name:"Slime Block",
transparent: true,
shadow: false,
bounciness: 1,
speedFactor: 0.5,
shapeName:"slimeBlock",
category:"build",
sticky:true,
damageResistance:1,
},
{ 
name:"soulSoil",
Name:"Soul Soil",
speedFactor: 0.5,
canHaveSoulFire: true,
category:"nature",
},
{ name:"blueIce", Name:"Blue Ice", category:"nature",slide:0.9, glassSound: true, temperature:3},
{ name:"ice", Name:"Ice", category:"nature",transparent:true, shadow:false, slide:0.9, glassSound: true, temperature:3},
{ name:"packedIce", Name:"Packed Ice", category:"nature",slide:0.9, glassSound: true, temperature:3},
{ name:"calcite", Name:"Calcite", category:"nature" },
{
name:"furnace",
Name:"Furnace",
textures: ["furnaceTop","furnaceTop","furnaceSide","furnaceFront","furnaceSide","furnaceSide"],
SW: true,
tagBits: null,
setContents: function(x,y,z,dimension,world){
var data = {furnace:true, input:0, fuel:0, output:0, smeltStart:0, burnStart:0, canBurn:false, smelting:false, xp:0}
world.setTags(x, y, z, data,false,dimension)
return data
},
update:function(x,y,z,dimension,world){
let data = world.getTags(x,y,z,dimension)
if(!data) return
let prevSmelting = data.smelting
data.smelting = false
let smeltTo, fuel
if(data.input && data.fuel){
smeltTo = smelts[data.input.id]
fuel = smeltFuel[data.fuel.id]
if(!fuel){
for(let i in smeltFuel){
if(checkCraftType(parseInt(i) || i,data.fuel.id)){
fuel = smeltFuel[i]
break
}
}
}
if(!smeltTo){
for(let i in smelts){
if(checkCraftType(parseInt(i) || i,data.input.id)){
smeltTo = smelts[i]
break
}
}
}
if(smeltTo && fuel) data.smelting = true
}
if(data.smelting){
if(!prevSmelting){
data.smeltStart = Date.now()
data.burnStart = Date.now()
}
var seconds = (Date.now() - data.smeltStart) / 1000
var progress = seconds * 20 //ticks
var burnProgress = (Date.now() - data.burnStart) / 1000
data.progress = progress / smeltTo.time
data.burnProgress = 1-(burnProgress / fuel.time)
if(progress >= smeltTo.time){
var a = floor(progress/smeltTo.time)
for(var i=0; i<a; i++){
data.input.amount --
data.xp += smeltTo.xp
if(data.output){
data.output.amount ++
}else{
data.output = {id:smeltTo.id, amount:1}
}
if(data.input.amount <= 0){
data.input = 0
break
}
}
data.smeltStart += (a/20)*smeltTo.time*1000
world.updateTags(x,y,z,dimension)
}
if(burnProgress >= fuel.time){
data.canBurn = false
}
if(!data.canBurn){
var a = floor(burnProgress/fuel.time)
for(var i=0; i<a; i++){
data.fuel.amount --
if(data.fuel.amount === 0){
data.fuel = 0
break
}
}
world.updateTags(x,y,z,dimension)
data.burnStart += a*fuel.time*1000
data.canBurn = true
}
}
if(!data.smelting){
if((!data.fuel || !data.fuel.id) && data.burnProgress) data.burnProgress = 0
if((!data.input || !data.input.id) && data.progress) data.progress = 0
}
var block = world.getBlock(x,y,z,dimension)
var needs = blockIds.furnace | (block & ROTATION)
if(data.smelting){
needs |= SLAB
}
if(block !== needs){
world.setBlock(x,y,z, needs, false, false, false, true,dimension)//last argument is keepTags
}
},
tick:function(block,x,y,z,dimension,world){
this.update(x,y,z,dimension,world)
},
stoneSound:true,
category:"items",
},
{
name:"blastFurnace",
Name:"Blast Furnace",
textures: ["blastFurnaceTop","blastFurnaceTop","blastFurnaceSide","blastFurnaceFront","blastFurnaceSide","blastFurnaceSide"],
rotate: true,
category:"items",
},
{
name:"smoker",
Name:"Smoker",
textures: ["smokerBottom","smokerTop","smokerSide","smokerFront","smokerSide","smokerSide"],
rotate: true,
category:"items",
},
{
name:"noteBlock",
Name:"Note Block",
tagBits:{
on:[0,1],
note:[1,5]
},
onclick:function(x,y,z,dimension,world){
var note = world.getTagByName(x,y,z,"note",dimension)
if(!note && note !== 0) note = -1
note ++
if(note >= 24) note = 0
world.setTagByName(x,y,z,"note",note,false,dimension)
blockData[blockIds.noteBlock].playNote(x,y,z,dimension,world)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension) ? true : false
var on = world.getTagByName(x,y,z,"on",dimension) || false
if(power !== on) {
world.setTagByName(x,y,z,"on",power,false,dimension)
if(power){
this.playNote(x,y,z,dimension,world)
}
}
},
playNote:function(x,y,z,dimension,world){
var note = world.getTagByName(x,y,z,"note",dimension) || 0
if(!note && note !== 0) return
var pitch = 2**((note-12)/12)
var instrument = "harp"
var block = world.getBlock(x,y-1,z,dimension)
if(block && this.noteTypes[blockData[block].name]) instrument = this.noteTypes[blockData[block].name]
if(block){
for(var i in this.noteTypes){
if(i.startsWith("type:") && i.replace("type:","") === blockData[block].type){
instrument = this.noteTypes[i]
}
}
}
world.playSound(x,y,z, "note."+instrument, 1, pitch)
world.sendAll({
type:"particles", particleType:"NoteParticle",
x,y:y+0.5,z, dimension, data:note
})
},
noteTypes:(function(obj){
var obj2 = {}
for(var i in obj){
if(typeof obj[i] === "string"){
obj2[obj[i]] = i
}else{
for(var i2 of obj[i]){
obj2[i2] = i
}
}
}
return obj2
})({
bass:"type:wood",
snare:["sand","gravel"],
hat:["glass","seaLantern","beacon"],
bd: ['type:rock1', 'type:rock2', 'type:rock3'],
bell: "goldBlock",
flute: ["clay", "honeycombBlock"],
icechime: ["packedIce"],
guitar: "type:wool",
xylobone: ["boneBlock","boneBlockSW"],
iron_xylophone: ["ironBlock"],
cow_bell: "soulSand",
didgeridoo: "pumpkin",
bit: "emeraldBlock",
banjo: ["hayBlock", "hayBlockSW"],
pling: "glowstone"
}),
category:"redstone",
},
{
name:"jukebox",
Name:"Jukebox",
textures: ["jukeboxTop","jukeboxSide"],
category:"items"
},
{
name:"loom",
Name:"Loom",
textures: ["loomBottom","loomTop","loomFront","loomSide","loomSide","loomSide"],
rotate: true,
category:"items"
},
{
name:"sandstone",
Name:"Sandstone",
textures: ["sandstoneBottom", "sandstoneTop", "sandstone"],
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true
},
{ name:"chiseledSandstone",
Name:"Chiseled Sandstone",
textures: ["sandstoneBottom", "sandstoneTop","chiseledSandstone"],
category:"build",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true
},
{ name:"cutSandstone",
Name:"Cut Sandstone",
textures: ["sandstoneBottom", "sandstoneTop","cutSandstone"],
category:"build",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true
},
{ name:"smoothSandstone", Name:"Smooth Sandstone", textures:"sandstoneTop", category:"nature",randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true },
{
name: "DoubleTallGrass",
Name:"Tall Grass",
solid: false,
transparent: true,
shadow: false,
textures: "tallGrassTop",
tallcrossShape: true,
drop:function(){
var r = rand()
if(r > 0.9){
return "tomatoSeeds"
}else if(r > 0.8){
return "corn"
}else if(r > 0.5){
return "wheatSeeds"
}
},
compostChance:0.3,
liquidBreakable:"drop",
category:"nature"
},
{
name:"apple",
Name:"Apple",
item:true,
edible: true,
eatWhenFull: false,
food: 4,
saturation: 2.4,
eatResult: "appleCore",
compostChance:0.65,
category:"food",
},
{
name:"woodenPickaxe",
Name:"Wooden Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 2,
durability: 59,
attackDamage: 2,
category:"tools",
},
{
name:"stonePickaxe",
Name:"Stone Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 4,
durability: 131,
attackDamage: 2,
material:"cobblestone",
category:"tools",
},
{
name:"ironPickaxe",
Name:"Iron Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 6,
durability: 250,
attackDamage: 3,
material:"ironIngot",
category:"tools",
},
{
name:"goldenPickaxe",
Name:"Golden Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 12,
durability: 32,
attackDamage: 4,
material:"goldIngot",
category:"tools",
},
{
name:"diamondPickaxe",
Name:"Diamond Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 8,
durability: 1561,
attackDamage: 5,
material:"diamond",
category:"tools",
},
{ name:"flint", Name:"Flint", item:true, category:"items" },
{
name:"mossBlock",
Name: "Moss Block",
hardness:0.1,
type: "plant2",
compostChance:0.65,
category:"nature"
},
{
name:"mossCarpet",
Name: "Moss Carpet",
textures: "mossBlock",
hardness:0.1,
carpet: true,
compostChance:0.3,
liquidBreakable:"drop",
category:"nature"
},
{
name: "caveVines",
Name:"Cave Vines",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
if(isIt){
world.setBlock(x,y,z,blockIds.caveVinesPlant | CROSS,false,false,false,false,dimension)
}
},
liquidBreakable:"drop",
category:"nature"
},
{
name: "caveVinesPlant",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
if(!isIt){
world.setBlock(x,y,z,blockIds.caveVines | CROSS,false,false,false,false,dimension)
}
},
hidden:true,
drop:"caveVines",
liquidBreakable:"drop"
},
{
name: "caveVinesLit",
Name: "Cave Vines With Glow Berries",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
lightLevel: 14,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
if(isIt){
world.setBlock(x,y,z,blockIds.caveVinesPlantLit | CROSS,false,false,false,false,dimension)
}
},
liquidBreakable:"drop",
category:"nature"
},
{
name: "caveVinesPlantLit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
lightLevel: 14,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y-1,z,dimension)
var isIt = blockData[top].name === "caveVines" || blockData[top].name === "caveVinesPlant" || blockData[top].name === "caveVinesLit" || blockData[top].name === "caveVinesPlantLit"
if(!isIt){
world.setBlock(x,y,z,blockIds.caveVinesLit | CROSS,false,false,false,false,dimension)
}
},
hidden:true,
liquidBreakable:"drop"
},
{
name:"sporeBlossom",
Name:"Spore Blossom",
sporeBlossom: true,
shadow:false,
transparent: true,
compostChance:0.65,
category:"nature"
},
{
name: "rootedDirt",
Name: "Rooted Dirt",
category:"nature",
type:"ground",
hardness:0.5, blastResistance:0.5,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
},
{
name: "hangingRoots",
Name: "Hanging Roots",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
compostChance:0.3,
liquidBreakable:"drop",
category:"nature"
},
{
name:"azalea",
Name:"Azalea",
textures: ["azaleaTop", "azaleaSide"],
potTex:["pottedAzaleaBushTop","pottedAzaleaBushSide"],
azalea: true,
transparent: true,
potCross:true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name:"floweringAzalea",
Name:"Flowering Azalea",
textures: ["floweringAzaleaTop","floweringAzaleaSide"],
potTex:["pottedFloweringAzaleaBushTop","pottedFloweringAzaleaBushSide"],
azalea: true,
transparent: true,
potCross:true,
compostChance:0.85,
liquidBreakable:"drop",
category:"nature",
lightLevel:10//make lush caves brighter
},
{
name:"sunflower",
Name:"Sunflower",
textures:["sunflowerBack","sunflowerFront","sunflowerConnected"],
sunflower: true,
transparent:true,
shadow:false,
iconTexture: "sunflowerFront",
solid:false,
category:"nature"
},
{
name: "bucket",
Name:"Bucket",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(block === blockIds.Water){
item.id = blockIds.waterBucket
world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
if(block === blockIds.Lava){
item.id = blockIds.lavaBucket
world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
if(block === blockIds.powderSnow){
item.id = blockIds.powderSnowBucket
world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
if(block === blockIds.oil){
item.id = blockIds.oilBucket
world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
},
stackSize: 1,
allHitbox: true,
category:"items"
},
{
name: "waterBucket",
Name:"Water Bucket",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(p.survival) item.id = blockIds.bucket
let pos = movePositionByFace(face,x,y,z)
world.setBlock(pos[0],pos[1],pos[2],blockIds.Water,false,false,false,false,dimension)
},
stackSize: 1,
category:"items"
},
{
name: "lavaBucket",
Name:"Lava Bucket",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(p.survival) item.id = blockIds.bucket
let pos = movePositionByFace(face,x,y,z)
world.setBlock(pos[0],pos[1],pos[2],blockIds.Lava,false,false,false,false,dimension)
},
stackSize: 1,
category:"items"
},
{
name: "spawnCow",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Cow](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Cow](x,y,z),false,dimension)
},
category:"items"
},
{
name:"sugarCane",
Name:"Sugar Cane",
iconTexture: "sugarCaneIcon",
flatIcon: true,
solid: false,
transparent: true,
shadow: false,
compostChance:0.5,
category:"nature",
smoothLight:false,
},
{
name:"woodenSword",
Name:"Wooden Swords aren't even sharp!",
item: true,
sword: true,
durability: 59,
attackDamage: 4,
category:"tools"
},
{
name:"stoneSword",
Name:"Stone Sword",
item: true,
sword: true,
durability: 131,
attackDamage: 5,
material:"cobblestone",
category:"tools"
},
{
name:"ironSword",
Name:"Iron Sword",
item: true,
sword: true,
durability: 250,
attackDamage: 6,
material:"ironIngot",
category:"tools"
},
{
name:"goldenSword",
Name:"Golden Sword",
item: true,
sword: true,
durability: 32,
attackDamage: 4,
material:"goldIngot",
category:"tools"
},
{
name:"diamondSword",
Name:"Diamond Sword",
item: true,
sword: true,
durability: 1561,
attackDamage: 7,
material:"diamond",
category:"tools"
},
{ name:"azaleaLeaves",
Name:"Azalea Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
drop: function(){
if(rand() > 0.05){
let r = floor(rand(2))
if(r === 0) return "azalea"
else return "floweringAzalea"
}
},
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
category:"nature",
grassSound: true,
leaves:true
},
{ name:"floweringAzaleaLeaves",
Name:"Flowering Azalea Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
drop: function(){
if(rand() > 0.05){
let r = floor(rand(2))
if(r === 0) return "azalea"
else return "floweringAzalea"
}
},
burnChance: 0.2,
burnTime: 30,
compostChance:0.5,
category:"nature",
grassSound: true,
leaves:true
},
{
name: "spawnPig",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Pig](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Pig](x,y,z),false,dimension)
},
category:"items"
},
{name:"tuff",Name:"Tuff",category:"nature",hardness:1.5},
{name:"deepslate", Name:"Deepslate", textures:["deepslateTop","deepslate"],category:"nature",hardness:3,deepslateSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true, craftSlabs:true, craftStairs:true},
{name:"cobbledDeepslate", Name:"Cobbled Deepslate",deepslateSound:true,category:"nature",hardness:3.5, randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true},
{name:"chiseledDeepslate", Name:"Chiseled Deepslate",category:"build",hardness:3.5,deepslateSound:true},
{name:"polishedDeepslate",Name:"Polished Deepslate",category:"build",hardness:3.5,deepslateSound:true, craftSlabs:true, craftStairs:true},
{name:"deepslateTiles",Name:"Deepslate Tiles",category:"build",hardness:3.5,deepslateSound:true, craftSlabs:true, craftStairs:true},
{name:"deepslateBricks",Name:"Deepslate Bricks",category:"build",hardness:3.5,deepslateBricksSound:true, craftSlabs:true, craftStairs:true},
{name:"crackedDeepslateTiles",Name:"Cracked Deepslate Tiles",category:"build",hardness:3.5,deepslateSound:true},
{name:"crackedDeepslateBricks",Name:"Cracked Deepslate Bricks",category:"build",hardness:3.5,deepslateBricksSound:true},
{name:"deepslateCoalOre",Name:"Deepslate Coal Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"coal", dropAmount:[1,3]},
{name:"deepslateIronOre",Name:"Deepslate Iron Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawIron", dropAmount:[1,3]},
{name:"deepslateCopperOre",Name:"Deepslate Copper Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawCopper", dropAmount:[2,5]},
{name:"deepslateGoldOre",Name:"Deepslate Gold Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"rawGold", dropAmount:[1,3]},
{name:"deepslateDiamondOre",Name:"Deepslate Diamond Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"diamond", dropAmount:[1,3]},
{name:"deepslateRedstoneOre",Name:"Deepslate Redstone Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"redstone", dropAmount:[6,9]},
{name:"deepslateEmeraldOre",Name:"Deepslate Emerald Ore",category:"nature",hardness:4.5,deepslateSound:true, drop:"emerald", dropAmount:[1,3]},
{name:"deepslateLapisOre",Name:"Deepslate Lapis Lazuli Ore",category:"nature",hardness:4.5,deepslateSound:true,drop:"lapisLazuli", dropAmount:[1,3]},
{name:"amethystBlock",Name:"Amethyst Block", category:"nature",hardness:1.5,amethystSound: true},
{name:"amethystShard",Name:"Amythest Shard",category:"items",item:true},
{name:"buddingAmethyst",Name:"Budding Amethyst", category:"nature",hardness:1.5,amethystSound: true},
{name:"smallAmethystBud",Name:"Small Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
lightLevel:1
},
{name:"mediumAmethystBud",Name:"Medium Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
lightLevel:2
},
{name:"largeAmethystBud",Name:"Large Amethyst Bud",category:"nature",hardness:1.5,sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
lightLevel:4
},
{name:"amethystCluster",Name:"Amethyst Cluster",category:"nature",hardness:1.5,sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
drop: "amethystShard",
lightLevel:5
},
{
name:"snowBlock",
Name:"Block of Snow",
textures:"snow",
hardness: 0.2,
drop:"snowball",
dropAmount: 4,
temperature:5,
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"snow",
Name:"Snow Layer",
layers: true,
transparent:true,
shadow:true,
drop:"snowball",
hardness: 0.1,
fallingDust:[248/255, 253/255, 253/255],
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
temperature:5,
liquidBreakable:"drop",
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"powderSnow",
Name:"Powder Snow",
solid:false,
powder: true,
hardness: 0.25,
drop:"air",
transparent:true,
temperature:5,
category:"nature",
},
{
name:"snowball",
Name:"Snowball",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
item.amount--
var pd = p.direction
world.addEntity(new entities[entityIds.Snowball](p.x+pd.x,p.y+pd.y,p.z+pd.z, pd.x*0.8, pd.y*0.8, pd.z*0.8,p.id),false,dimension)
},
useAnywhere:true,
category:"items",
},
{
name:"powderSnowBucket",
Name:"Powder Snow Bucket",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(p.survival) item.id = blockIds.bucket
var pos = movePositionByFace(face,x,y,z)
world.setBlock(pos[0],pos[1],pos[2],blockIds.powderSnow,false,false,false,false,dimension)
},
stackSize: 1,
category:"items",
},
{
name:"bread",
Name:"Bread",
edible: true,
item:true,
eatWhenFull: false,
food: 6,
saturation: 11,
compostChance:0.85,
category:"food",
},
{
name:"boneBlock",
Name:"Bone Block",
textures:["boneBlockTop","boneBlockSide"],
category:"nature",
},
{
name:"farmland",
Name:"Farmland",
textures:["dirt","farmland","dirt"],
_1PixLower: true,
category:"nature",
hardness:0.6, blastResistance:0.5,
type:"ground",
tick:function(block,x,y,z,dimension,world){
var target = this.id
for(var X=x-4;X<=x+4;X++){
for(var Z=z-4;Z<=z+4;Z++){
var b = world.getBlock(X,y,Z,dimension), a = world.getBlock(X,y+1,Z,dimension)
if(b && blockData[b].name === "Water" || a && blockData[a].name === "Water") target = this.id|SLAB
}
}
if(block !== target) world.setBlock(x,y,z,target,false,false,false,false,dimension)
}
},
{
name:"glowBerries",
Name:"Glow Berries",
edible: true,
item:true,
eatWhenFull: false,
food: 2,
saturation: 0.4,
compostChance:0.3,
category:"food",
},
{
name:"hayBlock",
Name:"Hay Bale",
textures:["hayBlockTop","hayBlockSide"],
type:"plant2",
damageResistance:0.8,
burnChance: 0.2,
burnTime: 20,
category:"decoration",
},
{
name:"hayBlockSW",
textures: ["hayBlockSide","hayBlockSide","hayBlockTop","hayBlockSide"],
SW: true,
type:"plant2",
damageResistance:0.8,
compostChance:0.85,
hidden:true
},
{
name:"woodenShovel",
Name:"Wooden Shovel",
item: true,
shovel: true,
durability: 59,
mineSpeed:2,
attackDamage: 2,
category:"tools"
},
{
name:"stoneShovel",
Name:"Stone Shovel",
item: true,
shovel: true,
durability: 131,
mineSpeed:3.6,
attackDamage: 4,
material:"cobblestone",
category:"tools"
},
{
name:"ironShovel",
Name:"Iron Shovel",
item: true,
shovel: true,
durability: 250,
mineSpeed:6,
attackDamage: 4,
material:"ironIngot",
category:"tools"
},
{
name:"goldenShovel",
Name:"Golden Shovel",
item: true,
shovel: true,
durability: 32,
mineSpeed:12,
attackDamage: 2,
material:"goldIngot",
category:"tools"
},
{
name:"diamondShovel",
Name:"Diamond Shovel",
item: true,
shovel: true,
durability: 1561,
mineSpeed:8,
attackDamage: 5,
material:"diamond",
category:"tools"
},
{
name:"woodenAxe",
Name:"Wooden Axe",
item: true,
axe: true,
durability: 59,
mineSpeed:2,
attackDamage: 7,
attackSpeed:0.8,
category:"tools"
},
{
name:"stoneAxe",
Name:"Stone Axe",
item: true,
axe: true,
durability: 131,
mineSpeed:4,
attackDamage: 9,
attackSpeed:0.8,
material:"cobblestone",
category:"tools"
},
{
name:"ironAxe",
Name:"Iron Axe",
item: true,
axe: true,
durability: 250,
mineSpeed:6,
attackDamage: 9,
attackSpeed:0.9,
material:"ironIngot",
category:"tools"
},
{
name:"goldenAxe",
Name:"Golden Axe",
item: true,
axe: true,
durability: 32,
mineSpeed:12,
attackDamage: 7,
attackSpeed:1,
material:"goldIngot",
category:"tools"
},
{
name:"diamondAxe",
Name:"Diamond Axe",
item: true,
axe: true,
durability: 1561,
mineSpeed:8,
attackDamage: 9,
attackSpeed:1,
material:"diamond",
category:"tools"
},
{
name: "strippedOakLog",
Name: "Stripped Oak Log",
textures: ["strippedOakLogTop", "strippedOakLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedOakLogSW",
textures: ["strippedOakLog", "strippedOakLog", "strippedOakLogTop","strippedOakLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedBirchLog",
Name: "Stripped Birch Log",
textures: ["strippedBirchLogTop", "strippedBirchLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedBirchLogSW",
textures: ["strippedBirchLog", "strippedBirchLog", "strippedBirchLogTop","strippedBirchLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedAcaciaLog",
Name: "Stripped Acacia Log",
textures: ["strippedAcaciaLogTop", "strippedAcaciaLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedAcaciaLogSW",
textures: ["strippedAcaciaLog", "strippedAcaciaLog", "strippedAcaciaLogTop","strippedAcaciaLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedJungleLog",
Name: "Stripped Jungle Log",
textures: ["strippedJungleLogTop", "strippedJungleLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedJungleLogSW",
textures: ["strippedJungleLog", "strippedJungleLog", "strippedJungleLogTop","strippedJungleLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedSpruceLog",
Name: "Stripped Spruce Log",
textures: ["strippedSpruceLogTop", "strippedSpruceLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedSpruceLogSW",
textures: ["strippedSpruceLog", "strippedSpruceLog", "strippedSpruceLogTop","strippedSpruceLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name: "strippedDarkOakLog",
Name: "Stripped Dark Oak Log",
textures: ["strippedDarkOakLogTop", "strippedDarkOakLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name: "strippedDarkOakLogSW",
textures: ["strippedDarkOakLog", "strippedDarkOakLog", "strippedDarkOakLogTop","strippedDarkOakLog"],
woodSound:true,
SW: true,
hidden:true
},
{
name:"boneBlockSW",
textures:["boneBlockSide","boneBlockSide","boneBlockTop","boneBlockSide"],
SW: true,
hidden:true
},
{
name:"redMushroom",
Name:"Red Mushroom",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
lightLevel:1,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
growBonemeal: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnHugeMushroom(x&15,y-1,z&15,x,z,false)
win.serverRestoreWorldGen()
}
},
{
name:"brownMushroom",
Name:"Brown Mushroom",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
lightLevel:1,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
growBonemeal: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnHugeMushroom(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
}
},
{
name:"mushroomStem",
Name: "Mushroom Stem",
mushroomBlock:true,
compostChance:0.65,
category:"nature"
},
{
name:"redMushroomBlock",
Name: "Red Mushroom Block",
mushroomBlock:true,
compostChance:0.85,
category:"nature"
},
{
name:"brownMushroomBlock",
Name: "Brown Mushroom Block",
mushroomBlock:true,
compostChance:0.85,
category:"nature"
},
{
name:"mycelium",
Name:"Mycelium",
textures:["dirt","myceliumTop","myceliumSide"],
type:"ground",
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
hardness: 0.6,
blastResistance:0.6,
drop:"dirt",
grassSound: true,
},
{
name:"terracotta",
Name:"Terracotta",
category:"build"
},
{
name:"redTerracotta",
Name:"Terracotta with watermelon juice",
category:"build"
},
{
name:"blueTerracotta",
Name:"Terracotta with blueberry juice",
category:"build"
},
{
name:"cyanTerracotta",
Name:"Terracotta with cyan colored fruit punch",
category:"build"
},
{
name:"grayTerracotta",
Name:"Dusty Terracotta",
category:"build"
},
{
name:"limeTerracotta",
Name:"Terracotta with leaf juice",
category:"build"
},
{
name:"pinkTerracotta",
Name:"Terracotta with fruit punch",
category:"build"
},
{
name:"blackTerracotta",
Name:"Terracotta painted black",
category:"build"
},
{
name:"brownTerracotta",
Name:"Dirty Terracotta",
category:"build"
},
{
name:"greenTerracotta",
Name:"Terracotta with some other leaf juice",
category:"build"
},
{
name:"whiteTerracotta",
Name:"Terracotta with flour",
category:"build"
},
{
name:"orangeTerracotta",
Name:"Orange Terracotta",
category:"build"
},
{
name:"purpleTerracotta",
Name:"Purple Terracotta",
category:"build"
},
{
name:"yellowTerracotta",
Name:"Terracotta with lemon juice",
category:"build"
},
{
name:"magentaTerracotta",
Name:"Magenta Terracotta",
category:"build"
},
{
name:"lightBlueTerracotta",
Name:"Light Blue Terracotta",
category:"build"
},
{
name:"lightGrayTerracotta",
Name:"Light Gray Terracotta",
category:"build"
},
{
name:"redGlazedTerracotta",
Name:"Watermelon Swirl",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"blueGlazedTerracotta",
Name:"Blue Fan",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"cyanGlazedTerracotta",
Name:"Creeper in the skies",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"grayGlazedTerracotta",
Name:"Bunch of Dust",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"limeGlazedTerracotta",
Name:"Overlapping lilies",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"pinkGlazedTerracotta",
Name:"Pink turtle shell",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"blackGlazedTerracotta",
Name:"Red monster",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"brownGlazedTerracotta",
Name:"Mudslide in the ocean",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"greenGlazedTerracotta",
Name:"Camouflaged monster",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"whiteGlazedTerracotta",
Name:"Sun & clouds",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"orangeGlazedTerracotta",
Name:"Flower Monster",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"purpleGlazedTerracotta",
Name:"Sword & pickaxe monster",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"yellowGlazedTerracotta",
Name:"Some kind of bug",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"magentaGlazedTerracotta",
Name:"Arrow",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"lightBlueGlazedTerracotta",
Name:"Monster sticking out tongue and eyes facing opposite direction",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"lightGrayGlazedTerracotta",
Name:"Monster with blue eyes and mouth",
category:"build",
pistonPush:false,
pistonPull:false,
randomRotate:"pattern",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"ancientDebris",
Name:"Ancient Debris",
textures:["ancientDebrisTop","ancientDebrisSide"],
hardness:30,
type:"rock4",
category:"nature",
},
{
name:"wheatSeeds",
Name:"Seeds",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "wheat"
},
compostChance:0.3,
category:"items"
},
{
name:"yellowStainedGlass",
Name: "Yellow Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"whiteStainedGlass",
Name: "White Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"redStainedGlass",
Name: "Red Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"purpleStainedGlass",
Name: "Purple Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"pinkStainedGlass",
Name: "Pink Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"orangeStainedGlass",
Name: "Orange Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"magentaStainedGlass",
Name: "Magenta Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"limeStainedGlass",
Name: "Lime Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"lightGrayStainedGlass",
Name: "Light Gray Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"lightBlueStainedGlass",
Name: "Light Blue Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"greenStainedGlass",
Name: "Green Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"grayStainedGlass",
Name: "Gray Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"cyanStainedGlass",
Name: "Cyan Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"brownStainedGlass",
Name: "Brown Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"blueStainedGlass",
Name: "Blue Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name:"blackStainedGlass",
Name: "Black Stained Glass",
transparent: true,
shadow: false,
hardness: 0.3,
type:"glass",
glassSound: true,
category:"build"
},
{
name: "yellowStainedGlassPane",
Name: "Yellow Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["yellowStainedGlassPaneTop","yellowStainedGlassPaneTop","yellowStainedGlass","yellowStainedGlass","yellowStainedGlassPaneSide","yellowStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "whiteStainedGlassPane",
Name: "White Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["whiteStainedGlassPaneTop","whiteStainedGlassPaneTop","whiteStainedGlass","whiteStainedGlass","whiteStainedGlassPaneSide","whiteStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "redStainedGlassPane",
Name: "Red Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["redStainedGlassPaneTop","redStainedGlassPaneTop","redStainedGlass","redStainedGlass","redStainedGlassPaneSide","redStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "purpleStainedGlassPane",
Name: "Purple Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["purpleStainedGlassPaneTop","purpleStainedGlassPaneTop","purpleStainedGlass","purpleStainedGlass","purpleStainedGlassPaneSide","purpleStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "pinkStainedGlassPane",
Name: "Pink Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["pinkStainedGlassPaneTop","pinkStainedGlassPaneTop","pinkStainedGlass","pinkStainedGlass","pinkStainedGlassPaneSide","pinkStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "orangeStainedGlassPane",
Name: "Orange Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["orangeStainedGlassPaneTop","orangeStainedGlassPaneTop","orangeStainedGlass","orangeStainedGlass","orangeStainedGlassPaneSide","orangeStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "magentaStainedGlassPane",
Name: "Magenta Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["magentaStainedGlassPaneTop","magentaStainedGlassPaneTop","magentaStainedGlass","magentaStainedGlass","magentaStainedGlassPaneSide","magentaStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "limeStainedGlassPane",
Name: "Lime Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["limeStainedGlassPaneTop","limeStainedGlassPaneTop","limeStainedGlass","limeStainedGlass","limeStainedGlassPaneSide","limeStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "lightGrayStainedGlassPane",
Name: "Light Gray Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["lightGrayStainedGlassPaneTop","lightGrayStainedGlassPaneTop","lightGrayStainedGlass","lightGrayStainedGlass","lightGrayStainedGlassPaneSide","lightGrayStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "lightBlueStainedGlassPane",
Name: "Light Blue Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["lightBlueStainedGlassPaneTop","lightBlueStainedGlassPaneTop","lightBlueStainedGlass","lightBlueStainedGlass","lightBlueStainedGlassPaneSide","lightBlueStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "greenStainedGlassPane",
Name: "Green Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["greenStainedGlassPaneTop","greenStainedGlassPaneTop","greenStainedGlass","greenStainedGlass","greenStainedGlassPaneSide","greenStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "grayStainedGlassPane",
Name: "Gray Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["grayStainedGlassPaneTop","grayStainedGlassPaneTop","grayStainedGlass","grayStainedGlass","grayStainedGlassPaneSide","grayStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "cyanStainedGlassPane",
Name: "Cyan Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["cyanStainedGlassPaneTop","cyanStainedGlassPaneTop","cyanStainedGlass","cyanStainedGlass","cyanStainedGlassPaneSide","cyanStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "brownStainedGlassPane",
Name: "Brown Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["brownStainedGlassPaneTop","brownStainedGlassPaneTop","brownStainedGlass","brownStainedGlass","brownStainedGlassPaneSide","brownStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "blueStainedGlassPane",
Name: "Blue Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["blueStainedGlassPaneTop","blueStainedGlassPaneTop","blueStainedGlass","blueStainedGlass","blueStainedGlassPaneSide","blueStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "blackStainedGlassPane",
Name: "Black Stained Glass Pane",
transparent: true,
shadow: false,
hardness: 0.3,
pane:true,
textures: ["blackStainedGlassPaneTop","blackStainedGlassPaneTop","blackStainedGlass","blackStainedGlass","blackStainedGlassPaneSide","blackStainedGlassPaneSide"],
glassSound: true,
category:"build"
},
{
name: "cobweb",
Name:"Cobweb",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
hardness:4,
drop:"air",
dropSelfWhenSheared:true,
shearBreakTime:0.4,
liquidBreakable:"drop",
category:"decoration"
},
{
name: "strippedCrimsonStem",
Name: "Stripped Crimson Stem",
textures: ["strippedCrimsonStemTop", "strippedCrimsonStem"],
hardness:2,
stemSound:true,
category:"build"
},
{
name: "strippedCrimsonStemSW",
textures: ["strippedCrimsonStem", "strippedCrimsonStem", "strippedCrimsonStemTop","strippedCrimsonStem"],
hardness:2,
stemSound:true,
SW: true,
hidden:true
},
{
name: "strippedWarpedStem",
Name: "Stripped Warped Stem",
textures: ["strippedWarpedStemTop", "strippedWarpedStem"],
hardness:2,
stemSound:true,
category:"build"
},
{
name: "strippedWarpedStemSW",
textures: ["strippedWarpedStem", "strippedWarpedStem", "strippedWarpedStemTop","strippedWarpedStem"],
hardness:2,
stemSound:true,
SW: true,
hidden:true
},
{
name: "oakPressurePlate",
Name: "Oak Pressure Plate",
textures: "oakPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "birchPressurePlate",
Name: "Birch Pressure Plate",
textures: "birchPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "sprucePressurePlate",
Name: "Spruce Pressure Plate",
textures: "sprucePlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "junglePressurePlate",
Name: "Jungle Pressure Plate",
textures: "junglePlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "acaciaPressurePlate",
Name: "Acacia Pressure Plate",
textures: "acaciaPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name:"darkOakPressurePlate",
Name: "Dark Oak Pressure Plate",
textures: "darkOakPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "warpedPressurePlate",
Name: "Warped Pressure Plate",
textures: "warpedPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "crimsonPressurePlate",
Name: "Crimson Pressure Plate",
textures: "crimsonPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name: "stonePressurePlate",
Name: "Stone Pressure Plate",
textures: "stone",
pressurePlate: true,
type:"stone",
hardness:0.5,
category:"redstone"
},
{
name: "polishedBlackstonePressurePlate",
textures: "polishedBlackstone",
pressurePlate: true,
type:"stone",
hardness:0.5,
category:"redstone"
},
{
name: "lightWeightedPressurePlate",
textures: "goldBlock",
pressurePlate: true,
type:"stone",
hardness:0.5,
lightWeighted:true,
category:"redstone"
},
{
name: "heavyWeightedPressurePlate",
textures: "ironBlock",
pressurePlate: true,
type:"stone",
hardness:0.5,
heavyWeighted:true,
category:"redstone"
},
{
name:"oakButton",
Name: "Oak Button",
textures:"oakPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"birchButton",
Name: "Birch Button",
textures:"birchPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"acaciaButton",
Name: "Acacia Button",
textures:"acaciaPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"darkOakButton",
Name: "Dark Oak Button",
textures:"darkOakPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"jungleButton",
Name: "Jungle Button",
textures:"junglePlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"spruceButton",
Name: "Spruce Button",
textures:"sprucePlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"warpedButton",
Name: "Warped Button",
textures:"warpedPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"crimsonButton",
Name: "Crimson Button",
textures:"crimsonPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name:"polishedBlackstoneButton",
Name: "Polished Blackstone Button",
textures:"polishedBlackstone",
button:true,
transparent:true,
shadow:false,
stone:true,
category:"redstone"
},
{
name:"copperBlock",
Name:"Block of Copper",
category:"build"
},
{
name:"crackedPolishedBlackstoneBricks",
Name:"Cracked Polished Blackstone Bricks",
category:"build"
},
{
name:"crackedStoneBricks",
Name:"Cracked Stone Bricks",
category:"build"
},
{
name:"woodenHoe",
Name:"Wooden Hoe",
item: true,
hoe: true,
durability: 59,
mineSpeed:2,
attackDamage: 1,
attackSpeed:1,
category:"tools"
},
{
name:"stoneHoe",
Name:"Stone Hoe",
item: true,
hoe: true,
durability: 131,
mineSpeed:4,
attackDamage: 1,
attackSpeed:2,
material:"cobblestone",
category:"tools"
},
{
name:"ironHoe",
Name:"Iron Hoe",
item: true,
hoe: true,
durability: 250,
mineSpeed:6,
attackDamage: 1,
attackSpeed:3,
material:"ironIngot",
category:"tools"
},
{
name:"goldenHoe",
Name:"Golden Hoe",
item: true,
hoe: true,
durability: 32,
mineSpeed:12,
attackDamage: 1,
attackSpeed:1,
material:"goldIngot",
category:"tools"
},
{
name:"diamondHoe",
Name:"Diamond Hoe",
item: true,
hoe: true,
durability: 1561,
mineSpeed:8,
attackDamage: 1,
attackSpeed:4,
material:"diamond",
category:"tools"
},
{
name:"podzol",
Name:"Podzol",
textures:["dirt","podzolTop","podzolSide"],
category:"nature",
hardness:0.5,
blastResistance:0.5,
type:"ground",
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
let top = world.getBlock(x,y+1,z,dimension)
let isSnow = blockData[top].name === "snow" || blockData[top].name === "snowBlock"
if(b === blockIds.podzol && isSnow){
world.setBlock(x,y,z,blockIds.podzol | CROSS,false,false,false,false,dimension)
}else if(b === (blockIds.podzol | CROSS) && !isSnow){
world.setBlock(x,y,z,blockIds.podzol,false,false,false,false,dimension)
}
},
compostChance:0.3,
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
},
{
name:"rawIronBlock",
Name:"Block of Raw Iron",
type:"rock2",
hardness:5,
category:"build"
},
{
name:"rawGoldBlock",
Name:"Block of Raw Gold",
type:"rock3",
hardness:5,
category:"build"
},
{
name:"rawCopperBlock",
Name:"Block of Raw Copper",
type:"rock2",
hardness:5,
category:"build"
},
{
name:"netheriteScrap",
Name:"Netherite Scrap",
item:true,
category:"items"
},
{
name:"netheriteIngot",
Name:"Netherite Ingot",
item:true,
category:"items"
},
{
name:"netheritePickaxe",
Name:"Netherite Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 9,
durability: 2031,
attackDamage: 6,
material:"netheriteIngot",
category:"tools"
},
{
name:"netheriteSword",
Name:"Netherite Sword",
item: true,
sword: true,
durability: 2031,
attackDamage: 8,
material:"netheriteIngot",
category:"tools"
},
{
name:"netheriteAxe",
Name:"Netherite Axe",
item: true,
axe: true,
durability: 2031,
mineSpeed:9,
attackDamage: 10,
attackSpeed:1,
material:"netheriteIngot",
category:"tools"
},
{
name:"netheriteShovel",
Name:"Netherite Shovel",
item: true,
shovel: true,
durability: 2031,
mineSpeed:9,
attackDamage: 6,
material:"netheriteIngot",
category:"tools"
},
{
name:"netheriteHoe",
Name:"Nethrite Hoe",
item: true,
hoe: true,
durability: 2031,
mineSpeed:9,
attackDamage: 1,
attackSpeed:4,
material:"netheriteIngot",
category:"tools"
},
{
name:"cartographyTable",
Name:"Cartograpgy Table",
textures: ["cartographyTableSide3","cartographyTableTop","cartographyTableSide3","cartographyTableSide1","cartographyTableSide2","cartographyTableSide3"],
rotate:true,
category:"items"
},
{
name:"cake",
Name:"Cake",
textures:["cakeBottom","cakeTop","cakeSide"],
cake:true,
transparent:true,
flatIcon:true,
iconTexture:"cake",
compostChance:1,
category:"food"
},
{
name:"smithingTable",
Name:"Smithing Table",
textures:["smithingTableBottom","smithingTableTop","smithingTableFront","smithingTableSide"],
category:"items"
},
{
name:"stonecutter",
Name:"Stonecutter",
textures:["stonecutterBottom","stonecutterTop","stonecutterSide"],
transparent:true,
stonecutter:true,
category:"items"
},
{
name:"itemFrame",
Name:"Item Frame",
transparent:true,
itemFrame:true,
flatIcon:true,
iconTexture:"itemFrameIcon",
category:"items"
},
{
name:"enderPearl",
Name:"Ender Pearl",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
item.amount--
world.addEntity(new entities[entityIds.EnderPearl](p.x,p.y,p.z, p.direction.x, p.direction.y, p.direction.z, p.id),false,dimension)
},
useAnywhere:true,
category:"items"
},
{
name:"ironNugget",
Name:"Iron Nugget",
item:true,
category:"items"
},
{
name:"goldNugget",
Name:"Gold Nugget",
item:true,
category:"items"
},
{
name:"pumpkin",
Name:"Pumpkin",
textures:["pumpkinSide","pumpkinTop","pumpkinSide"],
compostChance:0.65,
category:"nature"
},
{
name:"carvedPumpkin",
Name:"Carved Pumpkin",
textures:["pumpkinSide","pumpkinTop","pumpkinSide","carvedPumpkin","pumpkinSide","pumpkinSide"],
rotate:true,
compostChance:0.65,
category:"nature"
},
{
name:"jackOLantern",
Name:"Jack o'Lantern",
textures:["pumpkinSide","pumpkinTop","pumpkinSide","jackOLantern","pumpkinSide","pumpkinSide"],
lightLevel:15,
rotate:true,
compostChance:0.65,
category:"nature"
},
{
name:"shears",
Name:"Shears",
item:true,
shears:true,
category:"items"
},
{
name:"pumpkinSeeds",
Name:"Pumpkin Seeds",
item:true,
compostChance:0.3,
category:"items"
},
{
name:"melonSeeds",
Name:"Watermelon Seeds",
item:true,
compostChance:0.3,
category:"items"
},
{
name:"melon",
Name:"Watermelon",
textures:["melonSide","melonTop","melonSide"],
hardness:1,
drop:"melonSlice",
dropAmount:[3,7],
compostChance:0.65,
category:"nature"
},
{
name:"melonSlice",
Name:"Slice of Watermelon",
item:true,
edible: true,
food: 2,
saturation: 1.2,
compostChance:0.5,
category:"nature"
},
{
name:"redstoneLamp",
Name:"Redstone Lamp",
//if you chang this, change colored lamps too
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
category:"redstone"
},
{
name:"glowstoneDust",
Name:"Glowstone Dust",
item:true,
category:"items"
},
{
name:"quartz",
Name:"Quartz",
item:true,
category:"items"
},
{
name: "endPortalFrame", 
Name:"End Portal Frame",
textures: ["endStone", "endPortalFrameTop", "endPortalFrameSide"],
category:"items",
blastResistance:3600000,
hardness:Infinity,
lightLevel:1,
glassSound: true,
eyeplace:function(x,y,z,dimension,world){
this.findFullFrame(x+1,y,z,dimension,world)
this.findFullFrame(x-1,y,z,dimension,world)
this.findFullFrame(x,y,z+1,dimension,world)
this.findFullFrame(x,y,z-1,dimension,world)
},
findFullFrame:function(x,y,z,dimension,world){
if(blockData[world.getBlock(x,y,z)].solid) return
let spread = [], spreadAt = [x,y,z,0]
let minX = x, minZ = z
let maxX = x, maxZ = z
while(spreadAt.length){
let [sx,sy,sz] = spreadAt
if(Math.max(Math.abs(x-sx),Math.abs(y-sy),Math.abs(z-sz)) > 2) return //portal area isn't that big
minX = Math.min(minX,sx), minZ = Math.min(minZ,sz)
maxX = Math.max(maxX,sx), maxZ = Math.max(maxZ,sz)
if(!xyArrayHas(spread,spreadAt,sx,sy,sz+1)){
let b = world.getBlock(sx,sy,sz+1,dimension)
if(!blockData[b].solid) spreadAt.push(sx,sy,sz+1,0)
else if(blockData[b].name !== this.name) return
}
if(!xyArrayHas(spread,spreadAt,sx,sy,sz-1)){
let b = world.getBlock(sx,sy,sz-1,dimension)
if(!blockData[b].solid) spreadAt.push(sx,sy,sz-1,0)
else if(blockData[b].name !== this.name) return
}
if(!xyArrayHas(spread,spreadAt,sx+1,sy,sz)){
let b = world.getBlock(sx+1,sy,sz,dimension)
if(!blockData[b].solid) spreadAt.push(sx+1,sy,sz,0)
else if(blockData[b].name !== this.name) return
}
if(!xyArrayHas(spread,spreadAt,sx-1,sy,sz)){
let b = world.getBlock(sx-1,sy,sz,dimension)
if(!blockData[b].solid) spreadAt.push(sx-1,sy,sz,0)
else if(blockData[b].name !== this.name) return
}
spread.push(...spreadAt.splice(0,4))
}
//check if frame is correct
x = minX-1, z = minZ-1
if(world.getBlock(x+1,y,z,dimension) !== (this.id | SLAB | SOUTH)) return
if(world.getBlock(x+2,y,z,dimension) !== (this.id | SLAB | SOUTH)) return
if(world.getBlock(x+3,y,z,dimension) !== (this.id | SLAB | SOUTH)) return
if(world.getBlock(x+4,y,z+1,dimension) !== (this.id | SLAB | EAST)) return
if(world.getBlock(x+4,y,z+2,dimension) !== (this.id | SLAB | EAST)) return
if(world.getBlock(x+4,y,z+3,dimension) !== (this.id | SLAB | EAST)) return
if(world.getBlock(x+1,y,z+4,dimension) !== (this.id | SLAB | NORTH)) return
if(world.getBlock(x+2,y,z+4,dimension) !== (this.id | SLAB | NORTH)) return
if(world.getBlock(x+3,y,z+4,dimension) !== (this.id | SLAB | NORTH)) return
if(world.getBlock(x,y,z+1,dimension) !== (this.id | SLAB | WEST)) return
if(world.getBlock(x,y,z+2,dimension) !== (this.id | SLAB | WEST)) return
if(world.getBlock(x,y,z+3,dimension) !== (this.id | SLAB | WEST)) return
//place the frame
world.setBlock(x+1,y,z+1,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+2,y,z+1,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+3,y,z+1,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+1,y,z+2,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+2,y,z+2,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+3,y,z+2,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+1,y,z+3,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+2,y,z+3,blockIds.endPortal,false,false,false,false,dimension)
world.setBlock(x+3,y,z+3,blockIds.endPortal,false,false,false,false,dimension)
world.playSound(x+2,y,z+2,"end_portal.endportal")
}
},
{
name: "eyeOfEnder",
Name:"Eye of Ender",
flatIcon:true,
item:true,
placeSound:["end_portal.eyeplace1","end_portal.eyeplace2","end_portal.eyeplace3"],
category:"items"
},
{
name:"endStone",
Name:"End Stone",
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"redSand",
Name:"Red Sand",
hardness:0.5,
fallingDust:[178/255, 94/255, 26/255],
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
category:"nature",
digSound: ["sand.dig1", "sand.dig2", "sand.dig3", "sand.dig4"],
stepSound: ["sand.step1", "sand.step2","sand.step3","sand.step4","sand.step5"]
},
{
name:"redSandstone",
Name:"Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop", "redSandstone"],
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true
},
{ name:"chiseledRedSandstone",
Name:"Chiseled Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop","chiseledRedSandstone"],
category:"build",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true
},
{ name:"cutRedSandstone",
Name:"Cut Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop","cutRedSandstone"],
category:"build",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,
craftSlabs:true, craftStairs:true
},
{ name:"smoothRedSandstone", Name:"Smooth Red Sandstone", textures:"redSandstoneTop", category:"nature", randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true, craftSlabs:true, craftStairs:true },
{
name:"purpurBlock",
Name:"Purpur Block",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"purpurPillar",
Name:"Purpur Pillar",
textures:["purpurPillarTop","purpurPillar"],
category:"build"
},
{
name:"purpurPillarSW",
textures:["purpurPillar","purpurPillar","purpurPillarTop","purpurPillar"],
SW: true,
hidden:true
},
{
name:"prismarine",
Name:"Prismarine",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"prismarineBricks",
Name:"Prismarine Bricks",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"darkPrismarine",
Name:"Dark Prismarine",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"prismarineCrystals",
Name:"Prismarine Crystals",
category:"items",
item:true
},
{
name:"prismarineShard",
Name:"Prismarine Shard",
item:true,
category:"items"
},
{
name:"seaLantern",
Name:"Sea Lantern",
lightLevel:15,
hardness:0.3,
category:"decoration"
},
{
name:"oakLeaves",
Name: "Oak Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "oakSapling"
else{
return rand() > 0.8 ? "orange" : "apple"
}
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "acaciaLeaves",
Name:"Acacia Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "acaciaSapling"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "birchLeaves",
Name:"Birch Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "birchSapling"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "darkOakLeaves",
Name:"Dark Oak Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "darkOakSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "jungleLeaves",
Name:"Jungle Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "jungleSapling"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name: "spruceLeaves",
Name:"Spruce Leaves",
transparent: true,
cullFace:"never",
hardness:0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "spruceSapling"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature"
},
{
name:"spyglass",
Name:"Spyglass",
textures:"spyglassModel",
iconTexture:"spyglass",
item:true,
spyglass:true,
category:"items"
},
{
name:"egg",
Name:"Egg",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
item.amount--
world.addEntity(new entities[entityIds.Egg](p.x+pd.x,p.y+pd.y,p.z+pd.z, pd.x*0.8, pd.y*0.8, pd.z*0.8, p.id),false,dimension)
},
useAnywhere:true,
category:"items"
},
{
name:"noodles",
Name:"Noodles",
item:true,
category:"food",
hidden:true
},
{
name:"bowl",
Name:"Bowl",
item:true,
category:"items"
},
{
name:"mushroomStew",
Name:"Mushroom Stew",
edible: true,
item:true,
eatWhenFull: false,
food: 6,
saturation: 7.2,
eatResult:"bowl",
category:"food"
},
{
name:"ramen",
Name:"Ramen! Yum!",
edible: true,
item:true,
eatWhenFull: true,
food: 8,
saturation: 10,
eatResult:"bowl",
category:"food",
hidden:true
},
{
name:"orange",
Name:"Orange",
edible: true,
item:true,
eatWhenFull: false,
food: 4,
saturation: 2.4,
category:"food"
},
{
name:"fern",
Name:"Fern",
solid: false,
transparent: true,
shadow: false,
flatIcon: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature",
potCross:true
},
{
name: "largeFern",
Name:"Large Fern",
solid: false,
transparent: true,
shadow: false,
textures: "largeFernTop",
tallcrossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name:"fire",
fire:true,
damage:1,
burnEnt:true,
transparent:true,
shadow:false,
solid:false,
lightLevel:15,
ambientSound:"fire.fire",
temperature:20,
smoothLight:false,
hidden:true,
liquidBreakable:true,
noHitbox:true,
tagBits:{
age:[0,8]
},
getAttached:function(x,y,z,block,dimension,getBlockOnly,world){
var ax = x, ay = y, az = z
switch(block){
case this.id:
ay--
break
case this.id | STAIR:
ay++
break
case this.id | SLAB | NORTH:
az++
break
case this.id | SLAB | SOUTH:
az--
break
case this.id | SLAB | EAST:
ax++
break
case this.id | SLAB | WEST:
ax--
break
}
var attached = world.getBlock(ax,ay,az,dimension)
if(getBlockOnly) return attached
else return [attached,ax,ay,az]
},
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var block = this.getAttached(x,y,z,b,dimension,true,world)
if(!block || !blockData[block].solid && !blockData[block].liquid) world.setBlock(x,y,z,0,false,false,false,false,dimension)
},
tick:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var attached = this.getAttached(x,y,z,block,dimension,false,world)
var ax = attached[1], ay = attached[2], az = attached[3]
attached = attached[0]
var age = world.getTagByName(x,y,z,"age",dimension)
if(!age) age = 0
age += rand(10,11)
//finish burning
if(age >= 15 && (!attached || !blockData[attached].burnTime)){
return world.setBlock(x,y,z,0,false,false,false,false,dimension)
}
if(attached && blockData[attached].burnTime && age > blockData[attached].burnTime){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
world.setBlock(ax,ay,az,0,false,false,false,false,dimension)
return
}
if(age > 255) age = 255
world.setTagByName(x,y,z,"age",age,false,dimension)
if(world.weather === "rain" && world.weatherAmount > 0.5){
let top = world.getSolidTop(x,z,dimension)
if(y > top) world.setBlock(x,y,z,0,false,false,false,false,dimension) //rain extinguish
}
this.spread(x,y,z,dimension,world)
},
spread:function(x,y,z,dimension,world){
for(var i=x-1; i<=x+1; i++){
for(var j=y-1; j<=y+4; j++){
for(var k=z-1; k<=z+1; k++){
var block = world.getBlock(i,j,k,dimension)
if(block && blockData[block].burnChance && rand() < blockData[block].burnChance){
if(blockData[block].onburn) blockData[block].onburn(i,j,k,dimension,world)
var block
let rx, ry, rz
//find a place where the fire can go
for(var t=0; t<6; t++){
rx = i, ry = j, rz = k
switch(floor(rand(6))){
case 0:
block = this.id
ry++
break
case 1:
block = this.id | STAIR
ry--
break
case 2:
block = this.id | SLAB | NORTH
rz--
break
case 3:
block = this.id | SLAB | SOUTH
rz++
break
case 4:
block = this.id | SLAB | EAST
rx--
break
case 5:
block = this.id | SLAB | WEST
rx++
break
}
if(!world.getBlock(rx,ry,rz,dimension)) break
}
if(!world.getBlock(rx,ry,rz,dimension)) world.setBlock(rx,ry,rz,block,false,false,false,false,dimension)
}
}
}
}
},
tryCreatePortalZ:function(x,y,z,dimension){ //weird portals are allowed
let spread = [], spreadAt = [x,y,z,0], maxSpread = 23, block
while(spreadAt.length){
let [sx,sy,sz,i] = spreadAt.splice(0,4)
spread.push(sx,sy,sz,i)
if(max(abs(sx-x),abs(sy-y),abs(sz-z)) > maxSpread) return
block = world.getBlock(sx,sy,sz+1,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy,sz+1)){
if(!blockData[block].solid) spreadAt.push(sx,sy,sz+1,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy,sz-1,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy,sz-1)){
if(!blockData[block].solid) spreadAt.push(sx,sy,sz-1,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy+1,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy+1,sz)){
if(!blockData[block].solid) spreadAt.push(sx,sy+1,sz,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy-1,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy-1,sz)){
if(!blockData[block].solid) spreadAt.push(sx,sy-1,sz,i+1)
else if(block !== blockIds.obsidian) return
}
}
for(let i=0; i<spread.length; i+=4){
world.setBlock(spread[i],spread[i+1],spread[i+2],blockIds.portal|PORTAL|EAST,false,false,false,false,dimension)
}
return true
},
tryCreatePortalX:function(x,y,z,dimension){ //weird portals are allowed
let spread = [], spreadAt = [x,y,z,0], maxSpread = 23, block
while(spreadAt.length){
let [sx,sy,sz,i] = spreadAt.splice(0,4)
spread.push(sx,sy,sz,i)
if(max(abs(sx-x),abs(sy-y),abs(sz-z)) > maxSpread) return
block = world.getBlock(sx+1,sy,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx+1,sy,sz)){
if(!blockData[block].solid) spreadAt.push(sx+1,sy,sz,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx-1,sy,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx-1,sy,sz)){
if(!blockData[block].solid) spreadAt.push(sx-1,sy,sz,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy+1,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy+1,sz)){
if(!blockData[block].solid) spreadAt.push(sx,sy+1,sz,i+1)
else if(block !== blockIds.obsidian) return
}
block = world.getBlock(sx,sy-1,sz,dimension)
if(!xyArrayHas(spread,spreadAt,sx,sy-1,sz)){
if(!blockData[block].solid) spreadAt.push(sx,sy-1,sz,i+1)
else if(block !== blockIds.obsidian) return
}
}
for(let i=0; i<spread.length; i+=4){
world.setBlock(spread[i],spread[i+1],spread[i+2],blockIds.portal|PORTAL|NORTH,false,false,false,false,dimension)
}
return true
},
tryCreatePortal:function(x,y,z,dimension){
return this.tryCreatePortalZ(x,y,z,dimension) || this.tryCreatePortalX(x,y,z,dimension)
}
},
{
name: "endRod",
Name:"End Rod",
transparent: true,
shadow: false,
lightLevel: 15,
category:"decoration"
},
{
name: "oakWood",
Name:"Oak Wood",
textures: "logSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "acaciaWood",
Name:"Acacia Wood",
textures: "acaciaLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "birchWood",
Name:"Birch Wood",
textures: "birchLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "darkOakWood",
Name:"Dark Oak Wood",
textures: "darkOakLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "jungleWood",
Name:"Jungle Wood",
textures: "jungleLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "spruceWood",
Name:"Spruce Wood",
textures: "spruceLogSide",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "crimsonHyphae",
textures: "crimsonStemSide",
stemSound: true,
hardness:2,
type:"wood",
category:"nature"
},
{
name: "warpedHyphae",
textures: "warpedStemSide",
stemSound: true,
hardness:2,
type:"wood",
category:"nature"
},
{
name: "strippedOakWood",
Name:"Stripped Oak Wood",
textures: "strippedOakLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedAcaciaWood",
Name:"Stripped Acacia Wood",
textures: "strippedAcaciaLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedBirchWood",
Name:"Stripped Birch Wood",
textures: "strippedBirchLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedDarkOakWood",
Name:"Stripped Dark Oak Wood",
textures: "strippedDarkOakLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedJungleWood",
Name:"Stripped Jungle Wood",
textures: "strippedJungleLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedSpruceWood",
Name:"Stripped Spruce Wood",
textures: "strippedSpruceLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name: "strippedCrimsonHyphae",
textures: "strippedCrimsonStem",
stemSound: true,
hardness:2,
type:"wood",
category:"build"
},
{
name: "strippedWarpedHyphae",
textures: "strippedWarpedStem",
stemSound: true,
hardness:2,
type:"wood",
category:"build"
},
{
name:"oakFenceGate",
Name:"Oak Fence Gate",
textures:"oakPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"acaciaFenceGate",
Name:"Acacia Fence Gate",
textures:"acaciaPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"birchFenceGate",
Name:"Birch Fence Gate",
textures:"birchPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"darkOakFenceGate",
Name:"Dark Oak Fence Gate",
textures:"darkOakPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"jungleFenceGate",
Name:"Jungle Fence Gate",
textures:"junglePlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"spruceFenceGate",
Name:"Spruce Fence Gate",
textures:"sprucePlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"crimsonFenceGate",
Name:"Crimson Fence Gate",
textures:"crimsonPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"warpedFenceGate",
Name:"Warped Fence Gate",
textures:"warpedPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{ 
name: "kelp",
Name:"Kelp",
flatIcon:true,
iconTexture:"kelpIcon",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isIt = blockData[top].name === "kelp" || blockData[top].name === "kelpPlant"
if(isIt){
world.setBlock(x,y,z,blockIds.kelpPlant | CROSS,false,false,false,false,dimension)
}
},
category:"nature"
},
{ 
name: "kelpPlant",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var top = world.getBlock(x,y+1,z,dimension)
var isIt = blockData[top].name === "kelp" || blockData[top].name === "kelpPlant"
if(!isIt){
world.setBlock(x,y,z,blockIds.kelp | CROSS,false,false,false,false,dimension)
}
},
hidden:true
},
{
name:"seagrass",
Name:"Seagrass",
iconTexture:"seagrassIcon",
transparent: true,
solid: false,
shadow: false,
crop:true,
category:"nature"
},
{
name:"tallSeagrass",
Name:"Tall Seagrass",
textures:"tallSeagrassTop",
transparent: true,
solid: false,
shadow: false,
tallCrop:true,
category:"nature"
},
{
name:"barrel",
Name:"Barrel",
textures:["barrelBottom","barrelTop","barrelSide"],
texturesOpen:fillTextureArray(["barrelBottom","barrelTopOpen","barrelSide"]),
texturesSW:fillTextureArray(["barrelSide","barrelSide","barrelTop","barrelSide"]),
texturesSWOpen:fillTextureArray(["barrelSide","barrelSide","barrelTopOpen","barrelSide"]),
texturesDown:fillTextureArray(["barrelTop","barrelBottom","barrelSide"]),
texturesDownOpen:fillTextureArray(["barrelTopOpen","barrelBottom","barrelSide"]),
woodSound:true,
barrel:true,
category:"items",
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {chest:true, contents:new Array(27).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.chest && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
},
{
name:"endStoneBricks",
Name:"End Stone Bricks",
stoneSound:true,
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"beeNest",
Name:"Bee Nest",
textures:["beeNestBottom","beeNestTop","beeNestSide","beeNestFront","beeNestSide","beeNestSide"],
texturesHoney:["beeNestBottom","beeNestTop","beeNestSide","beeNestFrontHoney","beeNestSide","beeNestSide"],
rotate:true,
category:"nature"
},
{
name:"beehive",
Name:"Beehive",
textures:["beehiveEnd","beehiveEnd","beehiveSide","beehiveFront","beehiveSide","beehiveSide"],
texturesHoney:["beehiveEnd","beehiveEnd","beehiveSide","beehiveFrontHoney","beehiveSide","beehiveSide"],
rotate:true,
category:"items"
},
{
name:"honeyBlock",
Name:"Block of Honey",
textures:"honeyBlockBottom",
transparent:true,
shapeName:"honeyBlock",
damageResistance:0.8,
category:"build",
sticky:true
},
{
name:"honeycomb",
Name:"Honeycomb",
item:true,
category:"items"
},
{
name:"honeycombBlock",
Name:"Honeycomb Block",
category:"build"
},
{
name:"coarseDirt",
Name:"Coarse Dirt",
hardness:1,
type:"ground",
category:"nature",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"]
},
{
name:"inkSac",
Name:"Ink Sac",
item:true,
category:"items"
},
{
name:"glowInkSac",
Name:"Glow Ink Sac",
item:true,
category:"items"
},
{
name:"glowItemFrame",
Name:"Glow Item Frame",
transparent:true,
itemFrame:true,
flatIcon:true,
iconTexture:"glowItemFrameIcon",
category:"items"
},
{
name:"glowLichen",
Name:"Glow Lichen",
transparent: true,
shadow: false,
wallFlat: true,
flatIcon:true,
solid:false,
lightLevel:7,
compostChance:0.5,
category:"nature"
},
{
name:"sponge",
Name:"Sponge",
wetTexture:new Array(6).fill("wetSponge"),
category:"items",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true
},
{
name:"cutCopper",
Name:"Cut Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"exposedCopper",
Name:"Exposed Block of Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"exposedCutCopper",
Name:"Exposed Cut Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"weatheredCopper",
Name:"Weathered Block of Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"weatheredCutCopper",
Name:"Weathered Cut Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"oxidizedCopper",
Name:"Oxidized Block of Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"oxidizedCutCopper",
Name:"Oxidized Cut Copper",
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"quartzBricks",
Name:"Quartz Bricks",
stoneSound:true,
category:"build",
craftSlabs:true, craftStairs:true
},
{
name:"campfire",
Name:"Campfire",
flatIcon:true,
iconTexture:"campfire",
textures: "campfireLogLit",
campfire:true,
shadow:false,
lightLevel:15,
transparent:true,
woodSound:true,
drop:"campfire",
category:"items",
damageUp:2,
burnEnt:true,
smoothLight:false,
blastResistance:2,
hardness:2,
activate:function(x,y,z,dimension,block,ent){
if(ent.burning && block === (this.id | SLAB) && onBoxEnt(x,y,z,1,1,1,ent)){
world.setBlock(x,y,z,this.id,false,false,false,false,dimension)
}
}
},
{
name:"soulCampfire",
Name:"Soul Campfire",
flatIcon:true,
iconTexture:"soulCampfire",
textures: "soulCampfireLogLit",
campfire:true,
shadow:false,
lightLevel:10,
transparent:true,
woodSound:true,
drop:"soulCampfire",
category:"items",
damageUp:4,
burnEnt:true,
smoothLight:false,
blastResistance:2,
hardness:2,
activate:function(x,y,z,dimension,block,ent){
if(ent.burning && block === (this.id | SLAB) && onBoxEnt(x,y,z,1,1,1,ent)){
world.setBlock(x,y,z,this.id,false,false,false,false,dimension)
}
}
},
{
name:"bambooShoot",
Name:"Bamboo Shoot",
textures:"bambooStage0",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
liquidBreakable:"drop",
category:"nature",
potCross:true
},
{
name:"bambooStalk",
Name:"Bamboo",
iconTexture:"bamboo",
flatIcon:true,
bamboo:true,
shadow: false,
potCross:true,
transparent:true,
drop:"bambooStalk",
hardness:1,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
liquidBreakable:"drop",
category:"nature"
},
{
name:"chest",
Name:"Chest",
textures:/*"christmasChestSide",//*/"chestFront",//christmas
transparent:true,
chest:true,
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {chest:true, contents:new Array(27).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.chest && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
category:"items"
},
{
name:"boneMeal",
Name:"Bone \"Meal\"",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
item.amount--
if(blockData[block].grow){
blockData[block].grow(x,y,z,dimension,world)
}else if(blockData[block].growBonemeal){
blockData[block].growBonemeal(x,y,z,dimension,world)
}else return true
world.glint(x,y,z,dimension)
},
category:"items"
},
{
name:"clay",
Name:"Clay",
hardness:0.6,
type:"ground",
digSound: ["dirt.dig1", "dirt.dig2", "dirt.dig3", "dirt.dig4"],
stepSound: ["dirt.step1", "dirt.step2","dirt.step3","dirt.step4"],
drop:"clayBall",
dropAmount:4,
category:"nature"
},
{
name:"clayBall",
Name:"Clay Ball",
item:true,
category:"items"
},
{
name:"brick",
Name:"Brick",
item:true,
category:"items"
},
{
name:"charcoal",
Name:"Charcoal",
item:true,
category:"items"
},
{
name:"appleCore",
Name:"Apple Core",
item:true,
category:"items"
},
{
name:"tintedGlass",
Name:"Tinted Glass",
transparent: true,
shadow: true,
hardness: 0.3,
type: "glass",
glassSound: true,
category:"build"
},
{
name:"tomato",
Name:"Tomato",
item:true,
edible:true,
eatWhenFull: false,
food: 3,
saturation: 2,
eatResult:"tomatoSeeds",
category:"nature"
},
{
name:"tomatoPlant",
Name:"Tomato Plant",
textures:new Array(6).fill("tomatoPlantStage0"),
textures1:new Array(6).fill("tomatoPlantStage1"),
textures2:new Array(6).fill("tomatoPlantStage2"),
textures3:new Array(6).fill("tomatoPlantStage3"),
textures4:new Array(6).fill("tomatoPlantStage4"),
iconTexture:"tomatoPlantStage3",
flatIcon:true,
shadow:false,
transparent:true,
solid:false,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
category:"nature",
liquidBreakable:"drop",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|TALLCROSS,false,false,false,false,dimension)
}
},
{
name:"tomatoSeeds",
Name:"Tomato Seeds",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland"){
return "tomatoPlant"
}else{
Messages.write("tomato seeds need to be planted on farmland")
p.lastPlace = Date.now()
}
},
category:"nature"
},
{
name:"newCactusFruit",
Name:"New Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
cactusFruit:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.3,
liquidBreakable:true,
category:"nature"
},
{
name:"greenCactusFruit",
Name:"Green Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
cactusFruit:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.4,
liquidBreakable:true,
category:"nature"
},
{
name:"redCactusFruit",
Name:"Red Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
edible: true,
eatWhenFull: false,
food: 2,
saturation: 1,
cactusFruit:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.5,
liquidBreakable:true,
category:"food"
},
{
name:"purpleCactusFruit",
Name:"Purple Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
edible: true,
eatWhenFull: false,
food: 3,
saturation: 2,
cactusFruit:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
needsSupportingBlocks(x,y,z,b,world,dimension)
},
compostChance:0.6,
liquidBreakable:true,
category:"food"
},
{
name:"cherry",
Name:"Cherry",
item:true,
edible:true,
eatWhenFull: false,
food: 1,
saturation: 1,
compostChance:0.5,
category:"food"
},
{
name:"cherryLog",
Name:"Cherry Log",
textures:["cherryLogTop","cherryLog"],
woodSound:true,
hardness:2,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name:"cherryLogSW",
textures: ["cherryLog","cherryLog","cherryLogTop","cherryLog"],
rotate: true,
woodSound:true,
hidden:true
},
{
name:"greenCherryLeaves", //Before minecraft 1.20 update
Name:"Green Cherry Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "cherrySapling"
else return "cherry"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
grassSound: true,
category:"nature",
hidden:true
},
{
name:"cherryLeaves",
Name:"Cherry Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "cherrySapling"
else if(rand() > 0.5) return "cherry"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
grassSound: true,
category:"nature"
},
{
name:"cherrySapling",
Name:"Cherry Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
category:"nature",
grow: function(x,y,z,dimension,world){
win.serverSaveWorldGen()
world.getChunk(x,z,dimension).spawnCherryTree(x&15,y-1,z&15,x,z,true)
win.serverRestoreWorldGen()
}
},
{
name:"cherryWood",
Name:"Cherry Wood",
textures: "cherryLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name:"slingshot",
Name:"Slingshot",
item:true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
var pd = p.direction
world.addEntity(new entities[entityIds.SlingshotShot](p.x,p.y,p.z,pd.x,pd.y,pd.z),false,dimension)
},
useAnywhere:true,
stackSize:1,
category:"tools"
},
{
name:"redstoneTorch",
Name:"Redstone Torch",
transparent: true,
shadow: false,
redstoneTorch: true,
lightLevel: 7,
woodSound:true,
solid:false,
flatIcon:true,
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
if(world.getPower(x,y,z,dimension) === 16){ //is torch on?
var b = world.getBlock(x,y+1,z,dimension)
if(b && !blockData[b].transparent){
world.setBlockPower(x,y+1,z, "strong", "bottom",dimension) //torch is under this block
}
b = world.getBlock(x,y-1,z,dimension)
if(b && blockData[b].carryRedstone){
world.setPower(x,y-1,z,15,false,dimension)
world.spreadPower(x,y-1,z,15,dimension)
}
}
},
onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var that = this
world.setTimeout(function(){
//find block it's attached to
var me = world.getBlock(x,y,z,dimension)
var ax=x,ay=y,az=z
var wall = that.id | SLAB
var wallOff = that.id | STAIR
switch(me){
case wall | NORTH:
case wallOff | NORTH:
az++
break
case wall | SOUTH:
case wallOff | SOUTH:
az--
break
case wall | EAST:
case wallOff | EAST:
ax++
break
case wall | WEST:
case wallOff | WEST:
ax--
break
default:
ay--
}
var block = world.getBlock(ax,ay,az,dimension)
//see if the torch should be on of off
var on = world.getPower(ax,ay,az,dimension) || world.getBlockPower(ax,ay,az,null,dimension) ? false : true
var target = me
if(on){
switch(me){
case wallOff | NORTH:
target = wall | NORTH
break
case wallOff | SOUTH:
target = wall | SOUTH
break
case wallOff | EAST:
target = wall | EAST
break
case wallOff | WEST:
target = wall | WEST
break
case that.id | CROSS:
target = that.id
}
}else{
switch(me){
case wall | NORTH:
target = wallOff | NORTH
break
case wall | SOUTH:
target = wallOff | SOUTH
break
case wall | EAST:
target = wallOff | EAST
break
case wall | WEST:
target = wallOff | WEST
break
case that.id:
target = that.id | CROSS
}
}
//set it
if(me !== target) {
world.setBlock(x,y,z,target,false,false,false,false,dimension)
if(on){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,16,dimension)
}else{
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
}
var b = world.getBlock(x,y+1,z,dimension)
if(b && !blockData[b].transparent){
world.setBlockPower(x,y+1,z, on ? "strong" : null, "bottom",dimension) //torch is under this block
}
b = world.getBlock(x,y-1,z,dimension)
if(b && blockData[b].carryRedstone){
if(on){
world.setPower(x,y-1,z,15,false,dimension)
world.spreadPower(x,y-1,z,15,dimension)
}else{
world.unspreadPower(x,y-1,z,15,true,dimension)
}
}
}
},tickTime*2, x,y,z,dimension)
},
onset:function(x,y,z,dimension,world){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,16,dimension)
},
ondelete:function(x,y,z,prevTags,prev,dimension,world){
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
var b = world.getBlock(x,y+1,z,dimension)
if(b && !blockData[b].transparent){
world.setBlockPower(x,y+1,z, null, "bottom",dimension) //torch is under this block
}
b = world.getBlock(x,y-1,z,dimension)
if(b && blockData[b].carryRedstone){
world.unspreadPower(x,y-1,z,15,true,dimension)
}
},
category:"redstone"
},
{
name:"redstoneConnector",
Name:"Block That Redstone Dust Connects To",
stoneSound:true,
category:"redstone"
},
{
name:"lever",
Name:"Lever",
transparent:true,
shadow:false,
solid:false,
lever:true,
flatIcon:true,
onclick:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var me = blockData[blockIds.lever]
var wall = me.id
var wallOn = me.id | SLAB
var ax = x, ay = y, az = z
var dir
switch(block){
case wall | NORTH:
case wallOn | NORTH:
az++
dir = "south"
break
case wall | SOUTH:
case wallOn | SOUTH:
az--
dir = "north"
break
case wall | EAST:
case wallOn | EAST:
ax++
dir = "east"
break
case wall | WEST:
case wallOn | WEST:
ax--
dir = "west"
break
case me.id | STAIR:
case me.id | CROSS:
ay --
dir = "top"
break
case me.id | TALLCROSS:
case me.id | DOOR:
ay ++
dir = "bottom"
break
}
var target, on
switch(block){
case wall | NORTH:
on = true
target = wallOn | NORTH
break
case wall | SOUTH:
on = true
target = wallOn | SOUTH
break
case wall | EAST:
on = true
target = wallOn | EAST
break
case wall | WEST:
on = true
target = wallOn | WEST
break
case wallOn | NORTH:
on = false
target = wall | NORTH
break
case wallOn | SOUTH:
on = false
target = wall | SOUTH
break
case wallOn | EAST:
on = false
target = wall | EAST
break
case wallOn | WEST:
on = false
target = wall | WEST
break
case me.id | STAIR:
on = true
target = me.id | CROSS
break
case me.id | CROSS:
on = false
target = me.id | STAIR
break
case me.id | TALLCROSS:
on = true
target = me.id | DOOR
break
case me.id | DOOR:
on = false
target = me.id | TALLCROSS
break
}
world.setBlock(x,y,z,target,false,false,false,false,dimension)
if(on){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,15,dimension)
}else{
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
}
var a = world.getBlock(ax,ay,az,dimension)
if(a && !blockData[a].transparent){
world.setBlockPower(ax,ay,az,on ? "strong" : null,dir,dimension)
}
},
ondelete:function(x,y,z,prevTags,prevBlock,dimension,world){
if(getTagBits(prevTags,"power",this.id)){
world.unspreadPower(x,y,z,16,false,dimension)
var block = prevBlock
var me = blockData[blockIds.lever]
var wall = me.id
var wallOn = me.id | SLAB
var ax = x, ay = y, az = z
var dir
switch(block){
case wall | NORTH:
case wallOn | NORTH:
az++
dir = "south"
break
case wall | SOUTH:
case wallOn | SOUTH:
az--
dir = "north"
break
case wall | EAST:
case wallOn | EAST:
ax++
dir = "east"
break
case wall | WEST:
case wallOn | WEST:
ax--
dir = "west"
break
case me.id | STAIR:
case me.id | CROSS:
ay --
dir = "top"
break
case me.id | TALLCROSS:
case me.id | DOOR:
ay ++
dir = "bottom"
break
}
var a = world.getBlock(ax,ay,az,dimension)
if(a && !blockData[a].transparent){
world.setBlockPower(ax,ay,az,null,dir,dimension)
}
}
},
category:"redstone"
},
{
name:"repeater",
Name:"Redstone Repeater",
flatIcon:true,
iconTexture:"repeaterIcon",
repeater:true,
transparent:true,
onupdate:function(x,y,z,b,w,sx,sy,sz,dimension){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
},
ondelete:function(x,y,z,prevTags,prevBlock,dimension,world){
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(x,y,z+1,null,"south",dimension)
world.setBlockPower(x,y,z-1,null,"north",dimension)
world.setBlockPower(x+1,y,z,null,"east",dimension)
world.setBlockPower(x-1,y,z,null,"west",dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var fx = x, fy = y, fz = z //from
var tx = x, ty = y, tz = z //pointing to
var side //side of block it's pointing to
var block = world.getBlock(x,y,z,dimension)
var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
switch(block){
case d1 | NORTH:
case d2 | NORTH:
case d3 | NORTH:
case d4 | NORTH:
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
fz--
tz++
side = "south"
break
case d1 | SOUTH:
case d2 | SOUTH:
case d3 | SOUTH:
case d4 | SOUTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
fz++
tz--
side = "north"
break
case d1 | EAST:
case d2 | EAST:
case d3 | EAST:
case d4 | EAST:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
fx--
tx++
side = "east"
break
case d1 | WEST:
case d2 | WEST:
case d3 | WEST:
case d4 | WEST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
fx++
tx--
side = "west"
break
}
if(fx === x && fy === y && fz === z) return console.log("doesn't match up") //doesn't match up
var delay
switch(block){
case d1 | NORTH:
case d1 | SOUTH:
case d1 | EAST:
case d1 | WEST:
case D1 | NORTH:
case D1 | SOUTH:
case D1 | EAST:
case D1 | WEST:
delay = 1
break
case d2 | NORTH:
case d2 | SOUTH:
case d2 | EAST:
case d2 | WEST:
case D2 | NORTH:
case D2 | SOUTH:
case D2 | EAST:
case D2 | WEST:
delay = 2
break
case d3 | NORTH:
case d3 | SOUTH:
case d3 | EAST:
case d3 | WEST:
case D3 | NORTH:
case D3 | SOUTH:
case D3 | EAST:
case D3 | WEST:
delay = 3
break
case d4 | NORTH:
case d4 | SOUTH:
case d4 | EAST:
case d4 | WEST:
case D4 | NORTH:
case D4 | SOUTH:
case D4 | EAST:
case D4 | WEST:
delay = 4
break
}
if(!delay) return console.log("delay hasn't been set")
var on = false
switch(block){ //todo: make it an if loop
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
on = true
}
var tblock = world.getBlock(tx,ty,tz,dimension)
if(tblock && blockData[tblock].carryRedstone){
if(on){
if(world.getPower(tx,ty,tz,dimension) !== 15){
world.setPower(tx,ty,tz,15,false,dimension)
world.spreadPower(tx,ty,tz,15,dimension)
}
}
}else if(tblock && !blockData[tblock].transparent){
if(on){
world.setBlockPower(tx,ty,tz,"strong",side,dimension)
}else{
world.setBlockPower(tx,ty,tz,null,side,dimension)
}
}
var shouldBeOn = world.getRepeaterPower(x,y,z,fx,fy,fz,dimension) || world.getBlockPower(fx,fy,fz,null,dimension) ? true : false
if(on === shouldBeOn) return
var t = function(){
block = world.getBlock(x,y,z,dimension)
var on = world.getRepeaterPower(x,y,z,fx,fy,fz,dimension) || world.getBlockPower(fx,fy,fz,null,dimension) ? true : false //should it be on?
var isOn = false
switch(block){ //todo: make it an if loop
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
isOn = true
}
if(on !== isOn) {
var target
var f = "north"
switch(block){
case d1 | NORTH:
target = D1
break
case d2 | NORTH:
target = D2
break
case d3 | NORTH:
target = D3
break
case d4 | NORTH:
target = D4
break
case D1 | NORTH:
target = d1
break
case D2 | NORTH:
target = d2
break
case D3 | NORTH:
target = d3
break
case D4 | NORTH:
target = d4
break
case d1 | SOUTH:
target = D1, f = "south"
break
case d2 | SOUTH:
target = D2, f = "south"
break
case d3 | SOUTH:
target = D3, f = "south"
break
case d4 | SOUTH:
target = D4, f = "south"
break
case D1 | SOUTH:
target = d1, f = "south"
break
case D2 | SOUTH:
target = d2, f = "south"
break
case D3 | SOUTH:
target = d3, f = "south"
break
case D4 | SOUTH:
target = d4, f = "south"
break
case d1 | EAST:
target = D1, f = "east"
break
case d2 | EAST:
target = D2, f = "east"
break
case d3 | EAST:
target = D3, f = "east"
break
case d4 | EAST:
target = D4, f = "east"
break
case D1 | EAST:
target = d1, f = "east"
break
case D2 | EAST:
target = d2, f = "east"
break
case D3 | EAST:
target = d3, f = "east"
break
case D4 | EAST:
target = d4, f = "east"
break
case d1 | WEST:
target = D1, f = "west"
break
case d2 | WEST:
target = D2, f = "west"
break
case d3 | WEST:
target = D3, f = "west"
break
case d4 | WEST:
target = D4, f = "west"
break
case D1 | WEST:
target = d1, f = "west"
break
case D2 | WEST:
target = d2, f = "west"
break
case D3 | WEST:
target = d3, f = "west"
break
case D4 | WEST:
target = d4, f = "west"
break
}
switch(f){
case "north":
break
case "south":
target |= SOUTH
break
case "east":
target |= EAST
break
case "west":
target |= WEST
}
if(block !== target) world.setBlock(x,y,z,target,false,false,false,false,dimension)
var tblock = world.getBlock(tx,ty,tz,dimension)
if(on){
if(tblock && blockData[tblock].carryRedstone){
if(world.getPower(tx,ty,tz,dimension) !== 15){
world.setPower(tx,ty,tz,15,false,dimension)
world.spreadPower(tx,ty,tz,15,dimension)
}
}else if(tblock && !blockData[tblock].transparent){
world.setBlockPower(tx,ty,tz,"strong",side,dimension)
}
}else{
if(tblock && blockData[tblock].carryRedstone){
world.unspreadPower(tx,ty,tz,15,true,dimension)
}else if(tblock && !blockData[tblock].transparent){
world.setBlockPower(tx,ty,tz,null,side,dimension)
}
}
}//end if repeater power changed
}
world.setTimeout(t,tickTime*delay*2, x,y,z,dimension)
},
onclick:function(x,y,z,dimension){
var me = blockData[blockIds.repeater]
var block = world.getBlock(x,y,z,dimension)
var d1 = me.id, d2 = me.id | SLAB, d3 = me.id | STAIR, d4 = me.id | DOOR //delay
var D1 = me.id | PANE, D2 = me.id | PORTAL, D3 = me.id | WALLFLAT, D4 = me.id | TRAPDOOROPEN //delay for on repeaters
var target
switch(block){
case d1 | NORTH:
target = d2 | NORTH
break
case d2 | NORTH:
target = d3 | NORTH
break
case d3 | NORTH:
target = d4 | NORTH
break
case d4 | NORTH:
target = d1 | NORTH
break
case D1 | NORTH:
target = D2 | NORTH
break
case D2 | NORTH:
target = D3 | NORTH
break
case D3 | NORTH:
target = D4 | NORTH
break
case D4 | NORTH:
target = D1 | NORTH
break
case d1 | SOUTH:
target = d2 | SOUTH
break
case d2 | SOUTH:
target = d3 | SOUTH
break
case d3 | SOUTH:
target = d4 | SOUTH
break
case d4 | SOUTH:
target = d1 | SOUTH
break
case D1 | SOUTH:
target = D2 | SOUTH
break
case D2 | SOUTH:
target = D3 | SOUTH
break
case D3 | SOUTH:
target = D4 | SOUTH
break
case D4 | SOUTH:
target = D1 | SOUTH
break
case d1 | EAST:
target = d2 | EAST
break
case d2 | EAST:
target = d3 | EAST
break
case d3 | EAST:
target = d4 | EAST
break
case d4 | EAST:
target = d1 | EAST
break
case D1 | EAST:
target = D2 | EAST
break
case D2 | EAST:
target = D3 | EAST
break
case D3 | EAST:
target = D4 | EAST
break
case D4 | EAST:
target = D1 | EAST
break
case d1 | WEST:
target = d2 | WEST
break
case d2 | WEST:
target = d3 | WEST
break
case d3 | WEST:
target = d4 | WEST
break
case d4 | WEST:
target = d1 | WEST
break
case D1 | WEST:
target = D2 | WEST
break
case D2 | WEST:
target = D3 | WEST
break
case D3 | WEST:
target = D4 | WEST
break
case D4 | WEST:
target = D1 | WEST
break
}
world.setBlock(x,y,z,target,false,false,false,false,dimension)
},
getFacing:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
var f
switch(block){
case d1 | NORTH:
case d2 | NORTH:
case d3 | NORTH:
case d4 | NORTH:
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
f = "north"
break
case d1 | SOUTH:
case d2 | SOUTH:
case d3 | SOUTH:
case d4 | SOUTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
f = "south"
break
case d1 | EAST:
case d2 | EAST:
case d3 | EAST:
case d4 | EAST:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
f = "east"
break
case d1 | WEST:
case d2 | WEST:
case d3 | WEST:
case d4 | WEST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
f = "west"
break
}
return f
},
canHavePower:function(/*repeater*/rx,ry,rz,/*other thing*/x,y,z,dimension,world){
var tx = rx, ty = ry, tz = rz
var block = world.getBlock(rx,ry,rz,dimension)
var d1 = this.id, d2 = this.id | SLAB, d3 = this.id | STAIR, d4 = this.id | DOOR //delay
var D1 = this.id | PANE, D2 = this.id | PORTAL, D3 = this.id | WALLFLAT, D4 = this.id | TRAPDOOROPEN //delay for on repeaters
switch(block){
case d1 | NORTH:
case d2 | NORTH:
case d3 | NORTH:
case d4 | NORTH:
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
tz++
break
case d1 | SOUTH:
case d2 | SOUTH:
case d3 | SOUTH:
case d4 | SOUTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
tz--
break
case d1 | EAST:
case d2 | EAST:
case d3 | EAST:
case d4 | EAST:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
tx++
break
case d1 | WEST:
case d2 | WEST:
case d3 | WEST:
case d4 | WEST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
tx--
break
}
var on = false
switch(block){ //todo: make it an if loop
case D1 | NORTH:
case D2 | NORTH:
case D3 | NORTH:
case D4 | NORTH:
case D1 | SOUTH:
case D2 | SOUTH:
case D3 | SOUTH:
case D4 | SOUTH:
case D1 | EAST:
case D2 | EAST:
case D3 | EAST:
case D4 | EAST:
case D1 | WEST:
case D2 | WEST:
case D3 | WEST:
case D4 | WEST:
on = true
}
if(on && tx === x && ty === y && tz === z){
return 15
}
return 0
},
category:"redstone"
},
{
name:"piston",
Name:"Piston",
textures:["pistonBack","pistonFront","pistonSide"],
piston:true,
headSideTexture:"pistonHeadSide",
frontOpenTexture:"pistonFrontOpen",
headBackTexture:"pistonFront",
onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var extended = false, facing, attachedHead = false
switch(block){
case this.id:
facing = "top"
break
case this.id | FLIP:
facing = "bottom"
break
case this.id | SLAB | NORTH:
facing = "north"
break
case this.id | SLAB | SOUTH:
facing = "south"
break
case this.id | SLAB | EAST:
facing = "east"
break
case this.id | SLAB | WEST:
facing = "west"
break
case this.id | TALLCROSS:
facing = "top"
extended = true
break
case this.id | TALLCROSS | FLIP:
facing = "bottom"
extended = true
break
case this.id | PORTAL | NORTH:
facing = "north"
extended = true
break
case this.id | PORTAL | SOUTH:
facing = "south"
extended = true
break
case this.id | PORTAL | EAST:
facing = "east"
extended = true
break
case this.id | PORTAL | WEST:
facing = "west"
extended = true
break
default:
return //parts like piston heads shouldn't do the calculations when power changes
}
if(extended){
switch(facing){
case "top":
if(world.getBlock(x,y+1,z,dimension) === (this.id | STAIR)) attachedHead = true
break
case "bottom":
if(world.getBlock(x,y-1,z,dimension) === (this.id | STAIR | FLIP)) attachedHead = true
break
case "north":
if(world.getBlock(x,y,z-1,dimension) === (this.id | DOOR | NORTH)) attachedHead = true
break
case "south":
if(world.getBlock(x,y,z+1,dimension) === (this.id | DOOR | SOUTH)) attachedHead = true
break
case "east":
if(world.getBlock(x-1,y,z,dimension) === (this.id | DOOR | EAST)) attachedHead = true
break
case "west":
if(world.getBlock(x+1,y,z,dimension) === (this.id | DOOR | WEST)) attachedHead = true
break
}
}
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
if(power && !extended){
this.extend(x,y,z,facing,dimension,world)
}else if(!power && extended && attachedHead){
this.retract(x,y,z,facing,dimension,world)
}
},
onupdate:function(x,y,z,b,w,sx,sy,sz,dimension){ //onupdate is run when placed
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
},
onbreak:function(x,y,z, prevBlock, prevTags,dimension,world){
//dissapear if it isn't connected (it = piston heads and piston open)
let tx = x, ty = y, tz = z
switch(prevBlock){
case this.id | TALLCROSS:
case this.id | STAIR | FLIP:
ty++
break
case this.id | TALLCROSS | FLIP:
case this.id | STAIR:
ty--
break
case this.id | PORTAL | NORTH:
case this.id | DOOR | SOUTH:
tz--
break
case this.id | PORTAL | SOUTH:
case this.id | DOOR | NORTH:
tz++
break
case this.id | PORTAL | EAST:
case this.id | DOOR | WEST:
tx--
break
case this.id | PORTAL | WEST:
case this.id | DOOR | EAST:
tx++
break
default:
return //unextended pistons
}
world.setBlock(tx,ty,tz,0,false,false,false,false,dimension)
},
extend:function(x,y,z, facing,dimension,world){
var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
var head, headCut, open
switch(facing){
case "top":
open = this.id | TALLCROSS
head = this.id | STAIR
headCut = this.id | CROSS
ty ++
my = 1
break
case "bottom":
open = this.id | TALLCROSS | FLIP
head = this.id | STAIR | FLIP
headCut = this.id | CROSS | FLIP
ty --
my = -1
break
case "north":
open = this.id | PORTAL | NORTH
head = this.id | DOOR | NORTH
headCut = this.id | PANE | NORTH
tz --
mz = -1
break
case "south":
open = this.id | PORTAL | SOUTH
head = this.id | DOOR | SOUTH
headCut = this.id | PANE | SOUTH
tz ++
mz = 1
break
case "east":
open = this.id | PORTAL | EAST
head = this.id | DOOR | EAST
headCut = this.id | PANE | EAST
tx --
mx = -1
break
case "west":
open = this.id | PORTAL | WEST
head = this.id | DOOR | WEST
headCut = this.id | PANE | WEST
tx ++
mx = 1
break
default:
return console.log("oh no! piston isn't facing anywhere")
}
var push = getPistonPushedBlocks(x,y,z,mx,my,mz,dimension,world)
if(push === false) return
world.setBlock(x,y,z,open,false,false,false,false,dimension)
var e = new entities[entityIds.MovingBlock](headCut,x,y,z,tx,ty,tz, tickTime*2, true)
e.endAs = head
world.addEntity(e,false,dimension)
//world.setTimeout(function(){
//	e.changeBlock(head)
//}, tickTime*1.5)
for(var i=0; i<push.length; i+=4){
var bx = push[i], by = push[i+1], bz = push[i+2]
var tags = world.getTags(bx,by,bz,dimension)
world.setBlock(bx,by,bz,0,false,false,false,false,dimension)
world.addEntity(new entities[entityIds.MovingBlock](push[i+3],bx,by,bz,bx+mx,by+my,bz+mz, tickTime*2, true, tags),false,dimension)
}
},
retract:function(x,y,z, facing,dimension,world){
var tx = x, ty = y, tz = z
var head, headCut, body
switch(facing){
case "top":
body = this.id
head = this.id | STAIR
headCut = this.id | CROSS
ty ++
break
case "bottom":
body = this.id | FLIP
head = this.id | STAIR | FLIP
headCut = this.id | CROSS | FLIP
ty --
break
case "north":
body = this.id | SLAB | NORTH
head = this.id | DOOR | NORTH
headCut = this.id | PANE | NORTH
tz --
break
case "south":
body = this.id | SLAB | SOUTH
head = this.id | DOOR | SOUTH
headCut = this.id | PANE | SOUTH
tz ++
break
case "east":
body = this.id | SLAB | EAST
head = this.id | DOOR | EAST
headCut = this.id | PANE | EAST
tx --
break
case "west":
body = this.id | SLAB | WEST
head = this.id | DOOR | WEST
headCut = this.id | PANE | WEST
tx ++
break
default:
return console.log("oh no! piston isn't facing anywhere")
}
world.setBlock(tx,ty,tz,0,false,false,false,false,dimension)
var e = new entities[entityIds.MovingBlock](head,tx,ty,tz,x,y,z, tickTime*2)
world.addEntity(e,false,dimension)
//world.setTimeout(function(){
//	e.changeBlock(headCut)
//}, tickTime*0.5)
world.setTimeout(function(){
world.setBlock(x,y,z,body,false,false,false,false,dimension)
}, tickTime*2)
},
category:"redstone"
},
{
name:"smoothQuartz",
Name:"Smooth Quartz Block",
textures:"quartzBlockBottom",
stoneSound:true,
category:"build"
},
{
name:"pistonSticky",
Name:"Sticky Piston",
textures:["pistonBack","pistonFrontSticky","pistonSide"],
piston:true,
headSideTexture:"pistonHeadSide",
frontOpenTexture:"pistonFrontOpen",
headBackTexture:"pistonFront",
category:"redstone",
onpowerupdate: function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var extended = false, facing, attachedHead = false
switch(block){
case this.id:
facing = "top"
break
case this.id | FLIP:
facing = "bottom"
break
case this.id | SLAB | NORTH:
facing = "north"
break
case this.id | SLAB | SOUTH:
facing = "south"
break
case this.id | SLAB | EAST:
facing = "east"
break
case this.id | SLAB | WEST:
facing = "west"
break
case this.id | TALLCROSS:
facing = "top"
extended = true
break
case this.id | TALLCROSS | FLIP:
facing = "bottom"
extended = true
break
case this.id | PORTAL | NORTH:
facing = "north"
extended = true
break
case this.id | PORTAL | SOUTH:
facing = "south"
extended = true
break
case this.id | PORTAL | EAST:
facing = "east"
extended = true
break
case this.id | PORTAL | WEST:
facing = "west"
extended = true
break
default:
return //parts like piston heads shouldn't do the calculations when power changes
}
if(extended){
switch(facing){
case "top":
if(world.getBlock(x,y+1,z,dimension) === (this.id | STAIR)) attachedHead = true
break
case "bottom":
if(world.getBlock(x,y-1,z,dimension) === (this.id | STAIR | FLIP)) attachedHead = true
break
case "north":
if(world.getBlock(x,y,z-1,dimension) === (this.id | DOOR | NORTH)) attachedHead = true
break
case "south":
if(world.getBlock(x,y,z+1,dimension) === (this.id | DOOR | SOUTH)) attachedHead = true
break
case "east":
if(world.getBlock(x-1,y,z,dimension) === (this.id | DOOR | EAST)) attachedHead = true
break
case "west":
if(world.getBlock(x+1,y,z,dimension) === (this.id | DOOR | WEST)) attachedHead = true
break
}
}
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
if(power && !extended){
this.extend(x,y,z,facing,dimension,world)
}else if(!power && extended && attachedHead){
this.retract(x,y,z,facing,dimension,world)
}
},
onupdate:function(x,y,z,b,w,sx,sy,sz,dimension){ //onupdate is run when placed
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
},
onbreak:function(x,y,z, prevBlock, prevTags,dimension,world){
//dissapear if it isn't connected (it = piston heads and piston open)
let tx = x, ty = y, tz = z
switch(prevBlock){
case this.id | TALLCROSS:
case this.id | STAIR | FLIP:
ty++
break
case this.id | TALLCROSS | FLIP:
case this.id | STAIR:
ty--
break
case this.id | PORTAL | NORTH:
case this.id | DOOR | SOUTH:
tz--
break
case this.id | PORTAL | SOUTH:
case this.id | DOOR | NORTH:
tz++
break
case this.id | PORTAL | EAST:
case this.id | DOOR | WEST:
tx--
break
case this.id | PORTAL | WEST:
case this.id | DOOR | EAST:
tx++
break
default:
return //unextended pistons
}
world.setBlock(tx,ty,tz,0,false,false,false,false,dimension)
},
extend:function(x,y,z, facing,dimension,world){
var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
var head, headCut, open
switch(facing){
case "top":
open = this.id | TALLCROSS
head = this.id | STAIR
headCut = this.id | CROSS
ty ++
my = 1
break
case "bottom":
open = this.id | TALLCROSS | FLIP
head = this.id | STAIR | FLIP
headCut = this.id | CROSS | FLIP
ty --
my = -1
break
case "north":
open = this.id | PORTAL | NORTH
head = this.id | DOOR | NORTH
headCut = this.id | PANE | NORTH
tz --
mz = -1
break
case "south":
open = this.id | PORTAL | SOUTH
head = this.id | DOOR | SOUTH
headCut = this.id | PANE | SOUTH
tz ++
mz = 1
break
case "east":
open = this.id | PORTAL | EAST
head = this.id | DOOR | EAST
headCut = this.id | PANE | EAST
tx --
mx = -1
break
case "west":
open = this.id | PORTAL | WEST
head = this.id | DOOR | WEST
headCut = this.id | PANE | WEST
tx ++
mx = 1
break
default:
return console.log("oh no! piston isn't facing anywhere")
}
var push = getPistonPushedBlocks(x,y,z,mx,my,mz,dimension,world)
if(push === false) return
world.setBlock(x,y,z,open,false,false,false,false,dimension)
var e = new entities[entityIds.MovingBlock](headCut,x,y,z,tx,ty,tz, tickTime*2, true)
for(var i=0; i<push.length; i+=4){
var bx = push[i], by = push[i+1], bz = push[i+2]
var tags = world.getTags(bx,by,bz,dimension)
world.setBlock(bx,by,bz,0,false,false,false,false,dimension)
world.addEntity(new entities[entityIds.MovingBlock](push[i+3],bx,by,bz,bx+mx,by+my,bz+mz, tickTime*2, true, tags),false,dimension)
}
e.endAs = head
world.addEntity(e,false,dimension)
//world.setTimeout(function(){
//	e.changeBlock(head)
//}, tickTime*1.5)
},
retract:function(x,y,z, facing,dimension,world){
var tx = x, ty = y, tz = z, mx = 0, my = 0, mz = 0
var head, headCut, body
switch(facing){
case "top":
body = this.id
head = this.id | STAIR
headCut = this.id | CROSS
ty ++
my = 1
break
case "bottom":
body = this.id | FLIP
head = this.id | STAIR | FLIP
headCut = this.id | CROSS | FLIP
ty --
my = -1
break
case "north":
body = this.id | SLAB | NORTH
head = this.id | DOOR | NORTH
headCut = this.id | PANE | NORTH
tz --
mz = -1
break
case "south":
body = this.id | SLAB | SOUTH
head = this.id | DOOR | SOUTH
headCut = this.id | PANE | SOUTH
tz ++
mz = 1
break
case "east":
body = this.id | SLAB | EAST
head = this.id | DOOR | EAST
headCut = this.id | PANE | EAST
tx --
mx = -1
break
case "west":
body = this.id | SLAB | WEST
head = this.id | DOOR | WEST
headCut = this.id | PANE | WEST
tx ++
mx = 1
break
default:
return console.log("oh no! piston isn't facing anywhere")
}
world.setBlock(tx,ty,tz,0,false,false,false,false,dimension)
var e = new entities[entityIds.MovingBlock](head,tx,ty,tz,x,y,z, tickTime*2)
world.addEntity(e,false,dimension)
//world.setTimeout(function(){
//	e.changeBlock(headCut)
//}, tickTime*0.5)
world.setTimeout(function(){
world.setBlock(x,y,z,body,false,false,false,false,dimension)
}, tickTime*2)
var pull = getPistonPulledBlocks(x,y,z,mx,my,mz,dimension,world)
if(pull){
for(var i=0; i<pull.length; i+=4){
var bx = pull[i], by = pull[i+1], bz = pull[i+2]
var tags = world.getTags(bx,by,bz,dimension)
world.setBlock(bx,by,bz,0,false,false,false,false,dimension)
world.addEntity(new entities[entityIds.MovingBlock](pull[i+3],bx,by,bz,bx-mx,by-my,bz-mz, tickTime*2, true, tags),false,dimension)
}
}
}
},
{
name:"observer",
Name:"Observer",
textures:["observerTop","observerTop","observerBack","observerFront","observerSide","observerSide"],
blastResistance:3.5,
hardness:3,
getFacing:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var facing
switch(block){
case this.id | NORTH:
case this.id | STAIR | NORTH:
facing = "north"
break
case this.id | SOUTH:
case this.id | STAIR | SOUTH:
facing = "south"
break
case this.id | EAST:
case this.id | STAIR | EAST:
facing = "east"
break
case this.id | WEST:
case this.id | STAIR | WEST:
facing = "west"
break
case this.id | SLAB:
case this.id | CROSS:
facing = "bottom"
break
case this.id | SLAB | FLIP:
case this.id | CROSS | FLIP:
facing = "top"
break
default:
return
}
return facing
},
detected:function(x,y,z,sx,sy,sz,world, detected = false,dimension){ //if detected is true, it will send a signal no matter what
var block = world.getBlock(x,y,z,dimension)
var facing, tx = 0, ty = 0, tz = 0, onBlock
switch(block){
case this.id | NORTH:
facing = "north"
tz = -1
onBlock = this.id | STAIR | NORTH
break
case this.id | SOUTH:
facing = "south"
tz = 1
onBlock = this.id | STAIR | SOUTH
break
case this.id | EAST:
facing = "east"
tx = -1
onBlock = this.id | STAIR | EAST
break
case this.id | WEST:
facing = "west"
tx = 1
onBlock = this.id | STAIR | WEST
break
case this.id | SLAB:
facing = "bottom"
ty = -1
onBlock = this.id | CROSS
break
case this.id | SLAB | FLIP:
facing = "top"
ty = 1
onBlock = this.id | CROSS | FLIP
break
default:
return
}
if(!(x+tx === sx && y+ty === sy && z+tz === sz) && !detected) return
world.setTimeout(function(){
var curBlock = world.getBlock(x,y,z,dimension)
if(!(curBlock && blockData[curBlock].name === "observer")) return
world.setBlock(x,y,z,onBlock, false,true,false,false,dimension)
let blockBehind = world.getBlock(x-tx,y-ty,z-tz,dimension)
if(blockBehind && blockData[blockBehind].carryRedstone){
world.setPower(x-tx,y-ty,z-tz, 15,false,dimension)
world.spreadPower(x-tx,y-ty,z-tz, 15,dimension)
}
world.setTimeout(function(){
let curBlock = world.getBlock(x,y,z,dimension)
if(!(curBlock && blockData[curBlock].name === "observer")) return
blockBehind = world.getBlock(x-tx,y-ty,z-tz,dimension)
world.setBlock(x,y,z,block, false,true,false,false,dimension)
if(blockBehind && blockData[blockBehind].carryRedstone) world.unspreadPower(x-tx,y-ty,z-tz, 15, true,dimension)
}, tickTime*2)
}, tickTime, x,y,z,dimension)
},
onupdate:function(x,y,z,block,world,sx,sy,sz,dimension){
this.detected(x,y,z,sx,sy,sz,world,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.detected(x,y,z,x,y,z,world,true,dimension)
},
canHavePower:function(rx,ry,rz, x,y,z, dimension,world){
var block = world.getBlock(rx,ry,rz,dimension)
var tx = 0, ty = 0, tz = 0
switch(block){
case this.id | STAIR | NORTH:
tz = -1
break
case this.id | STAIR | SOUTH:
tz = 1
break
case this.id | STAIR | EAST:
tx = -1
break
case this.id | STAIR | WEST:
tx = 1
break
case this.id | CROSS:
ty = -1
break
case this.id | CROSS | FLIP:
ty = 1
break
default:
return
}
if(rx-tx === x && ry-ty === y && rz-tz === z) return 15
return 0
},
category:"redstone"
},
{
name:"string",
Name:"String",
item:true,
category:"items"
},
{
name:"redDye",
Name:"Red Dye",
item:true,
dye:"red",
category:"items"
},
{
name:"lightGrayDye",
Name:"Light Gray Dye",
item:true,
dye:"lightGray",
category:"items"
},
{
name:"lightBlueDye",
Name:"Light Blue Dye",
item:true,
dye:"lightBlue",
category:"items"
},
{
name:"magentaDye",
Name:"Magenta Dye",
item:true,
dye:"magenta",
category:"items"
},
{
name:"yellowDye",
Name:"Yellow Dye",
item:true,
dye:"yellow",
category:"items"
},
{
name:"purpleDye",
Name:"Purple Dye",
item:true,
dye:"purple",
category:"items"
},
{
name:"orangeDye",
Name:"Orange Dye",
item:true,
dye:"orange",
category:"items"
},
{
name:"whiteDye",
Name:"White Dye",
item:true,
dye:"white",
category:"items"
},
{
name:"greenDye",
Name:"Green Dye",
item:true,
dye:"green",
category:"items"
},
{
name:"brownDye",
Name:"Brown Dye",
item:true,
dye:"brown",
category:"items"
},
{
name:"blackDye",
Name:"Black Dye",
item:true,
dye:"black",
category:"items"
},
{
name:"pinkDye",
Name:"Pink Dye",
item:true,
dye:"pink",
category:"items"
},
{
name:"limeDye",
Name:"Lime Dye",
item:true,
dye:"lime",
category:"items"
},
{
name:"grayDye",
Name:"Gray Dye",
item:true,
dye:"gray",
category:"items"
},
{
name:"cyanDye",
Name:"Cyan Dye",
item:true,
dye:"cyan",
category:"items"
},
{
name:"blueDye",
Name:"Blue Dye",
item:true,
dye:"blue",
category:"items"
},
{
name:"endPortal",
flatIcon:true,
solid:false,
transparent:true,
blastResistance: 3600000,
lightLevel:15,
pistonPush:false,
pistonPull:false,
hidden:true,
drop:"air",
ontouch: function(x,y,z,dimension,ent){
let nx, ny, nz
if(ent.dimension === ""){
nx = round(rand(-64,64))
nz = round(rand(-64,64))
ny = ent.y
}else{
let spawn = ent.spawnPoint || ent.world.spawnPoint
nx = spawn.x
ny = spawn.y
nz = spawn.z
}
ent.tp(nx,ny,nz,ent.dimension === "end" ? "" : "end")
ent.doingPortal = blockIds.endPortal
ent.world.playSound(x,y,z,"portal.travel")
if(ent.type === "Player"){
ent.addAchievment("Into the End")
if(ent.dimension === "" && !ent.didEndPoem && !ent.cheats){
ent.didEndPoem = true
ent.connection.send({type:"doEndPoem"})
}
}
},
doneLoading:function(p,world){
if(p.dimension === "end"){
let ny
ny = world.getSolidTop(round(p.x),round(p.z),p.dimension)+0.5+p.height*0.5
if(ny < 25) ny = 25
p.tp(p.x,ny,p.z)
if(!world.getBlock(p.x,floor(ny-p.height*0.5),p.z,p.dimension)){
world.setBlock(p.x,floor(ny-p.height*0.5),p.z,blockIds.obsidian,false,false,false,false,p.dimension)
}
}
}
},
{
name:"thatch",
Name:"Thatch",
type:"plant2",
burnChance: 0.2,
burnTime: 20,
compostChance:0.85,
category:"build"
},
{
name:"pearlescentFroglight",
Name:"Pearlescent Froglight",
textures:["pearlescentFroglightTop","pearlescentFroglightSide"],
lightLevel:15,
shadow:false,
category:"nature"
},
{
name:"verdantFroglight",
Name:"Verdant Froglight",
textures:["verdantFroglightTop","verdantFroglightSide"],
lightLevel:15,
shadow:false,
category:"nature"
},
{
name:"ochreFroglight",
Name:"Ochre Froglight",
textures:["ochreFroglightTop","ochreFroglightSide"],
lightLevel:15,
shadow:false,
category:"nature"
},
{
name:"mangroveLeaves",
Name:"Mangrove Leaves",
transparent: true,
cullFace:"never",
hardness: 0.2,
type:"plant2",
leaves:true,
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return ""//mangrove propagule here
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
grassSound: true,
category:"nature"
},
{
name:"mangroveLog",
Name:"Mangrove Log",
textures:["mangroveLogTop","mangroveLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name:"strippedMangroveLog",
Name:"Stripped Mangrove Log",
textures:["strippedMangroveLogTop","strippedMangroveLog"],
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build",
log:true
},
{
name:"mangroveLogSW",
textures: ["mangroveLog","mangroveLog","mangroveLogTop","mangroveLog"],
SW: true, woodSound:true, hidden:true
},
{
name:"strippedMangroveLogSW",
textures: ["strippedMangroveLog","strippedMangroveLog","strippedMangroveLogTop","strippedMangroveLog"],
SW: true, woodSound:true, hidden:true
},
{name:"mangrovePlanks", Name:"Mangrove Planks", type:"wood", category:"build",hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
{ 
name: "mangroveDoor",
Name:"Mangrove Door",
transparent: true,
shadow: false,
textures: "mangroveDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{ 
name: "mangroveTrapdoor",
Name:"Mangrove Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{
name:"mangroveButton",
Name: "Mangrove Button",
textures:"mangrovePlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{
name: "mangrovePressurePlate",
Name: "Mangrove Pressure Plate",
textures: "mangrovePlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name:"mangroveFenceGate",
Name:"Mangrove Fence Gate",
textures:"mangrovePlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name:"mangroveRoots",
textures:["mangroveRootsTop","mangroveRootsSide"],
transparent:true,
type:"wood",
hardness:0.7,
blastResistance:0.7,
cullFace:"never",
compostChance:0.3,
category:"nature"
},
{
name:"muddyMangroveRoots",
textures:["muddyMangroveRootsTop","muddyMangroveRootsSide"],
type:"wood",
hardness:0.7,
blastResistance:0.7,
category:"nature"
},
{
name: "mangroveWood",
Name:"Mangrove Wood",
textures: "mangroveLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name: "strippedMangroveWood",
Name:"Stripped Mangrove Wood",
textures: "strippedMangroveLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"build"
},
{
name:"mud",
Name:"Mud",
hardness:0.5,
blastResistance:0.5,
type:"ground",
digSound: ["mud.break1", "mud.break2", "mud.break3", "mud.break4", "mud.break5", "mud.break6"],
stepSound: ["mud.step1", "mud.step2","mud.step3","mud.step4","mud.step5","mud.step6"],
category:"nature"
},
{
name:"mudBricks",
Name:"Mud Bricks",
category:"build",
hardness:1.5,
},
{
name:"packedMud",
Name:"Packed Mud",
randomRotate:true,randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
category:"build",
hardness:1
},
{
name:"reinforcedDeepslate",
textures:["reinforcedDeepslateBottom","reinforcedDeepslateTop","reinforcedDeepslateSide"],
blastResistance:1200,
hardness:55,
pistonPush:false,
pistonPull:false,
category:"build"
},
{
name:"redRedstoneLamp",
Name:"Red Redstone Lamp",
textures:"redstoneLamp",
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
coloredRedstoneLamp:true,
category:"redstone"
},
{
name:"yellowRedstoneLamp",
Name:"Yellow Redstone Lamp",
textures:"redstoneLamp",
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
coloredRedstoneLamp:true,
category:"redstone"
},
{
name:"greenRedstoneLamp",
Name:"Green Redstone Lamp",
textures:"redstoneLamp",
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
coloredRedstoneLamp:true,
category:"redstone"
},
{
name:"blueRedstoneLamp",
Name:"Blue Redstone Lamp",
textures:"redstoneLamp",
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var block = this.id
if(power){
block = this.id | SLAB
}
if(world.getBlock(x,y,z,dimension) !== block) world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
coloredRedstoneLamp:true,
category:"redstone"
},
{
name:"soulFire",
fire:true,
damage:2,
burnEnt:true,
transparent:true,
shadow:false,
solid:false,
lightLevel:15,
ambientSound:"fire.fire",
temperature:20,
smoothLight:false,
hidden:true,
noHitbox:true,
getAttached:function(x,y,z,block,dimension,getBlockOnly,world){
var ax = x, ay = y, az = z
switch(block){
case this.id:
ay--
break
case this.id | STAIR:
ay++
break
case this.id | SLAB | NORTH:
az++
break
case this.id | SLAB | SOUTH:
az--
break
case this.id | SLAB | EAST:
ax++
break
case this.id | SLAB | WEST:
ax--
break
}
var attached = world.getBlock(ax,ay,az,dimension)
if(getBlockOnly) return attached
else return [attached,ax,ay,az]
},
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
var block = this.getAttached(x,y,z,b,dimension,true,world)
if(!block || !blockData[block].canHaveSoulFire) world.setBlock(x,y,z,0,false,false,false,false,dimension)
},
},
{
name:"sweetBerries",
Name:"Sweet Berries (they're spiky)",
item:true,
edible:true,
food:4,
saturation: 1.2,
eatResult: "stick",
useAs: "sweetBerryBush",
compostChance:0.3,
category:"food"
},
{
name:"sweetBerryBush",
textures:"sweetBerryBushStage0",
textures1:new Array(6).fill("sweetBerryBushStage1"),
textures2:new Array(6).fill("sweetBerryBushStage2"),
textures3:new Array(6).fill("sweetBerryBushStage3"),
flatIcon:true,
solid: false,
transparent: true,
shadow: false,
smoothLight:false,
hidden:true,
drop:"sweetBerries",
liquidBreakable:"drop",
category:"nature"
},
{
name:"smallDripleaf",
Name:"Small Dripleaf",
textures:"smallDripleafStemBottom",
shapeName:"smallDripleaf",
solid: false,
transparent: true,
shadow: false,
smoothLight:false,
liquidBreakable:"drop",
category:"nature"
},
{
name:"bigDripleaf",
Name:"Big Dripleaf",
textures:"bigDripleafStem",
shapeName:"bigDripleaf",
crossShape:true,
transparent: true,
shadow: false,
smoothLight:false,
liquidBreakable:"drop",
onupdate:function(x,y,z,block,world,sx,sy,sz,dimension){
var me = blockIds.bigDripleaf
var top = world.getBlock(x,y+1,z,dimension)
var isIt = top === me || top === (me | CROSS)
if(block === me && isIt){
world.setBlock(x,y,z,me | CROSS,false,false,false,false,dimension)
}else if(block === (me | CROSS) && !isIt){
world.setBlock(x,y,z,me,false,false,false,false,dimension)
}
},
category:"nature"
},
{
name:"orGate",
Name:"OR Gate",
textures:["smoothStone","orGate","repeaterSide"],
shapeName:"logicGate",
transparent: true,
shadow: false,
logicGate:true,
shouldBeOn:function(x,y,z,dimension,px,pz,world){
return (world.getRepeaterPower(x,y,z,x-pz,y,z-px,dimension) || world.getBlockPower(x-pz,y,z-px,null,dimension)
|| world.getRepeaterPower(x,y,z,x+pz,y,z+px,dimension) || world.getBlockPower(x+pz,y,z+px,null,dimension)) ? true : false
},
category:"redstone"
},
{
name:"andGate",
Name:"AND Gate",
textures:["smoothStone","andGate","repeaterSide"],
shapeName:"logicGate",
transparent: true,
shadow: false,
logicGate:true,
shouldBeOn:function(x,y,z,dimension,px,pz,world){
return ((world.getRepeaterPower(x,y,z,x-pz,y,z-px,dimension) || world.getBlockPower(x-pz,y,z-px,null,dimension))
&& (world.getRepeaterPower(x,y,z,x+pz,y,z+px,dimension) || world.getBlockPower(x+pz,y,z+px,null,dimension))) ? true : false
},
category:"redstone"
},
{
name:"notGate",
Name:"NOT Gate",
textures:["smoothStone","notGate","repeaterSide"],
shapeName:"logicGate",
transparent: true,
shadow: false,
logicGate:true,
shouldBeOn:function(x,y,z,dimension,px,pz,world){
return !(world.getRepeaterPower(x,y,z,x-px,y,z-pz,dimension) || world.getBlockPower(x-px,y,z-pz,null,dimension)) ? true : false
},
category:"redstone"
},
{
name:"xorGate",
Name:"XOR Gate",
textures:["smoothStone","xorGate","repeaterSide"],
shapeName:"logicGate",
transparent: true,
shadow: false,
logicGate:true,
shouldBeOn:function(x,y,z,dimension,px,pz,world){
var a = world.getRepeaterPower(x,y,z,x-pz,y,z-px,dimension) || world.getBlockPower(x-pz,y,z-px,null,dimension)
var b = world.getRepeaterPower(x,y,z,x+pz,y,z+px,dimension) || world.getBlockPower(x+pz,y,z+px,null,dimension)
return ((a||b)&&!(a&&b)) ? true : false
},
category:"redstone"
},
{
name:"dripstoneBlock",
Name:"Dripstone Block",
type:"rock1",
hardness:1.5,
blastResistance:1,
randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true,
category:"nature"
},
{
name:"pointedDripstone",
Name:"Sharp Dripstone",
flatIcon:true,
iconTexture:"pointedDripstone",
transparent: true,
shadow: false,
hardness:1.5,
blastResistance:3,
type:"rock1",
drop:"pointedDripstone",
pointing:function(x,y,z,d,world){
var b = world.getBlock(x,y,z,d)
if(blockData[b].name === this.name) return (b & FLIP) === FLIP ? -1 : 1
},
onupdate:function(x,y,z,block,world,sx,sy,sz,dimension){
var down = (block & FLIP) === FLIP
var pointing = down ? -1 : 1
if(down){
var attached = world.getBlock(x,y+1,z,dimension)
if(world.settings.blocksFall && (!attached || !blockData[attached].solid)){
world.setBlock(x,y,z, 0, false,false,false,false,dimension)
world.addEntity(new entities[entityIds.BlockEntity](block, x,y,z),false,dimension)
return
}
}else{
if(needsSupportingBlocks(x,y,z, this.id,world,dimension)) return
}
var target = down ? this.id | FLIP : this.id
if(this.pointing(x,y+pointing,z,dimension,world) === pointing && this.pointing(x,y+pointing*2,z,dimension,world) !== pointing) target |= CROSS //frustum
else if(this.pointing(x,y+pointing,z,dimension,world) === pointing && !this.pointing(x,y-pointing,z,dimension,world)) target |= SLAB //base
else if(this.pointing(x,y+pointing,z,dimension,world) === pointing) target |= STAIR //middle
else if(this.pointing(x,y+pointing,z,dimension,world) === -pointing) target |= TALLCROSS //tip merge
if(block !== target) world.setBlock(x,y,z,target,false,false,false,false,dimension)
},
spawnUpdate:function(x,y,z,block,world,dimension){
let down = (block & FLIP) === FLIP
let pointing = down ? -1 : 1
let target = down ? this.id | FLIP : this.id
if(this.pointing(x,y+pointing,z,dimension,world) === pointing && this.pointing(x,y+pointing*2,z,dimension,world) !== pointing) target |= CROSS //frustum
else if(this.pointing(x,y+pointing,z,dimension,world) === pointing && !this.pointing(x,y-pointing,z,dimension,world)) target |= SLAB //base
else if(this.pointing(x,y+pointing,z,dimension,world) === pointing) target |= STAIR //middle
else if(this.pointing(x,y+pointing,z,dimension,world) === -pointing) target |= TALLCROSS //tip merge
if(block !== target) world.spawnBlock(x,y,z,target,dimension, true)
},
category:"nature"
},
{
name:"oakSign",
Name:"Oak sign",
textures:"oakPlanks",
poleTop:"logTop",
poleSide:"logSide",
iconTexture:"oakSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"birchSign",
Name:"Birch Sign",
textures:"birchPlanks",
poleTop:"birchLogTop",
poleSide:"birchLogSide",
iconTexture:"birchSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"acaciaSign",
Name:"Acacia Sign",
textures:"acaciaPlanks",
poleTop:"acaciaLogTop",
poleSide:"acaciaLogSide",
iconTexture:"acaciaSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"jungleSign",
Name:"Jungle Sign",
textures:"junglePlanks",
poleTop:"jungleLogTop",
poleSide:"jungleLogSide",
iconTexture:"jungleSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"spruceSign",
Name:"Spruce Sign",
textures:"sprucePlanks",
poleTop:"spruceLogTop",
poleSide:"spruceLogSide",
iconTexture:"spruceSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"darkOakSign",
Name:"Dark Oak Sign",
textures:"darkOakPlanks",
poleTop:"darkOakLogTop",
poleSide:"darkOakLogSide",
iconTexture:"darkOakSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
color:[0.85,0.7,0.2],
category:"decoration"
},
{
name:"mangroveSign",
Name:"Mangrove Sign",
textures:"mangrovePlanks",
poleTop:"mangroveLogTop",
poleSide:"mangroveLog",
iconTexture:"mangroveSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"composter",
Name:"Make bonemeal",
textures:"composter",
transparent:true,
blastResistance:0.6,
hardness:0.6,
woodSound:true,
type:"wood",
getLevel:function(block){
var id = this.id
switch(block){
case id:
return 0
case id | SLAB:
return 1
case id | STAIR:
return 2
case id | CROSS:
return 3
case id | TALLCROSS:
return 4
case id | DOOR:
return 5
case id | TORCH:
return 6
case id | LANTERN:
return 7
}
},
onclick:function(x,y,z,dimension,world,p,holdObj){
if(!holdObj || !blockData[holdObj.id].compostChance) return true
let id = blockIds.composter
let target = id
let block = world.getBlock(x,y,z,dimension)
let add = rand() <= blockData[holdObj.id].compostChance
switch(block){
case id:
target |= SLAB
break
case id | SLAB:
target |= STAIR
break
case id | STAIR:
target |= CROSS
break
case id | CROSS:
target |= TALLCROSS
break
case id | TALLCROSS:
target |= DOOR
break
case id | DOOR:
target |= TORCH
break
case id | TORCH:
target |= LANTERN
break
case id | LANTERN:
if(add) world.addItems(x,y,z+0.5,dimension,0,0,0,blockIds.boneMeal,true, 1)
}
holdObj.amount--
if(add) world.setBlock(x,y,z,target,false,false,false,false,dimension)
world.glint(x,y,z,dimension)
},
category:"items"
},
{
name:"cocoaBeans",
Name:"Cocoa Beans",
item:true,
useAs:"cocoa",
category:"items"
},
{
name:"cocoa",
textures:"cocoaStage0",
hardness:0.2,
blastResistance:3,
transparent:true,
shadow:false,
drop:"cocoaBeans",
woodSound:true,
hidden:true,
liquidBreakable:"drop"
},
{
name:"cookie",
Name:"Cookie",
item:true,
edible: true,
food: 2,
saturation: 0.4,
compostChance:0.85,
category:"food"
},
{
name:"pumpkinPie",
Name:"Pumpkin Pie",
item:true,
edible: true,
food: 8,
saturation: 4.8,
compostChance:1,
category:"food"
},
{
name:"rawChicken",
Name:"Raw Chicken",
item:true,
edible: true,
food: 2,
saturation: 1.2,
category:"food"
},
{
name:"cookedChicken",
Name:"Cooked Chicken",
item:true,
edible: true,
food: 6,
saturation: 7.2,
category:"food"
},
{
name:"rawCod",
Name:"Raw Cod",
item:true,
edible: true,
food: 2,
saturation: 0.4,
category:"food"
},
{
name:"cookedCod",
Name:"Cooked Cod",
item:true,
edible: true,
food: 5,
saturation: 6,
category:"food"
},
{
name:"rawMutton",
Name:"Raw Mutton",
item:true,
edible: true,
food: 2,
saturation: 1.2,
category:"food"
},
{
name:"cookedMutton",
Name:"Cooked Mutton",
item:true,
edible: true,
food: 6,
saturation: 9.6,
category:"food"
},
{
name:"rawPorkchop",
Name:"Raw Porkchop",
item:true,
edible: true,
food: 3,
saturation: 1.8,
category:"food"
},
{
name:"cookedPorkchop",
Name:"Cooked Porkchop",
item:true,
edible: true,
food: 8,
saturation: 12.8,
category:"food"
},
{
name:"rawRabbit",
Name:"Raw Rabbit",
item:true,
edible: true,
food: 3,
saturation: 1.8,
category:"food"
},
{
name:"cookedRabbit",
Name:"Cooked Rabbit",
item:true,
edible: true,
food: 5,
saturation: 6,
category:"food"
},
{
name:"rawSalmon",
Name:"Raw Salmon",
item:true,
edible: true,
food: 2,
saturation: 0.4,
category:"food"
},
{
name:"cookedSalmon",
Name:"Cooked Salmon",
item:true,
edible: true,
food: 6,
saturation: 9.6,
category:"food"
},
{
name:"tropicalFish",
Name:"Tropical Fish",
item:true,
edible: true,
food: 1,
saturation: 0.2,
category:"food"
},
{
name:"beetroot",
Name:"Beetroot",
item:true,
edible: true,
food: 1,
saturation: 1.2,
compostChance:0.65,
category:"food"
},
{
name:"beetrootSoup",
Name:"Beetroot Soup",
item:true,
edible: true,
food: 7.2,
saturation: 13.2,
eatResult:"bowl",
category:"food",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|CROSS,false,false,false,false,dimension)
}
},
{
name:"carrot",
Name:"Carrot",
item:true,
edible: true,
food: 3,
saturation: 3.6,
compostChance:0.65,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "carrots"
},
category:"food"
},
{
name:"goldenCarrot",
Name:"Golden Carrot",
item:true,
edible: true,
food: 6,
saturation: 14.4,
category:"food"
},
{
name:"rabbitStew",
Name:"Rabbit Stew",
item:true,
edible: true,
food: 10,
saturation: 12,
category:"food"
},
{
name:"goldenApple",
Name:"Golden Apple",
item:true,
edible: true,
food: 4,
saturation: 9.6,
category:"food",
rarity:"rare"
},
{
name:"rawBeef",
Name:"Raw Beef",
item:true,
edible: true,
food: 3,
saturation: 1.8,
category:"food"
},
{
name:"cookedBeef",
Name:"stake cooked befe",
item:true,
edible: true,
food: 8,
saturation: 12.8,
category:"food"
},
{
name:"potato",
Name:"Potato",
item:true,
edible: true,
food: 1,
saturation: 0.6,
compostChance:0.85,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "potatoes"
},
category:"food",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|CROSS,false,false,false,false,dimension)
}
},
{
name:"bakedPotato",
Name:"Baked Potato",
item:true,
edible: true,
food: 5,
saturation: 6,
compostChance:0.85,
category:"food"
},
{
name:"sugar",
Name:"Sugar",
item:true,
category:"items"
},
{
name:"milkBucket",
Name:"Milk Bucket",
item:true,
category:"items"
},
{
name:"beetrootSeeds",
Name:"Beetroot Seeds",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "beetroots"
},
category:"items"
},
{
name:"beetroots",
textures:"beetrootsStage0",
textures1:new Array(6).fill("beetrootsStage1"),
textures2:new Array(6).fill("beetrootsStage2"),
textures3:new Array(6).fill("beetrootsStage3"),
transparent: true,
shadow: false,
solid: false,
crop: true,
drop:"beetrootSeeds",
hidden:true,
liquidBreakable:"drop"
},
{
name:"potatoes",
textures:"potatoesStage0",
textures1:new Array(6).fill("potatoesStage1"),
textures2:new Array(6).fill("potatoesStage2"),
textures3:new Array(6).fill("potatoesStage3"),
transparent: true,
shadow: false,
solid: false,
crop: true,
drop:"potato",
hidden:true,
liquidBreakable:"drop"
},
{
name:"carrots",
textures:"carrotsStage0",
textures1:new Array(6).fill("carrotsStage1"),
textures2:new Array(6).fill("carrotsStage2"),
textures3:new Array(6).fill("carrotsStage3"),
transparent: true,
shadow: false,
solid: false,
crop: true,
drop:"carrot",
hidden:true,
liquidBreakable:"drop",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|CROSS,false,false,false,false,dimension)
}
},
{
name:"mudPie",
Name:"Mud Pie",
item:true,
edible: true,
food: 1,
saturation: 1,
category:"food"
},
{
name:"purpleGrapes",
Name:"Purple Grapes",
item:true,
edible: true,
food: 3,
saturation: 3,
category:"food"
},
{
name:"greenGrapes",
Name:"Green Grapes",
item:true,
edible: true,
food: 3,
saturation: 3,
category:"food"
},
{
name:"oakChair",
Name:"Oak Chair",
textures:"oakPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"lightGrayBed",
Name:"Light Gray Bed",
textures: "lightGrayBedbottom",
iconTexture: "lightGrayBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"lightBlueBed",
Name:"Light Blue Bed",
textures: "lightBlueBedbottom",
iconTexture: "lightBlueBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"magentaBed",
Name:"Magenta Bed",
textures: "magentaBedbottom",
iconTexture: "magentaBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"yellowBed",
Name:"Yellow Bed",
textures: "yellowBedbottom",
iconTexture: "yellowBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"purpleBed",
Name:"Purple Bed",
textures: "purpleBedbottom",
iconTexture: "purpleBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"orangeBed",
Name:"Orange Bed",
textures: "orangeBedbottom",
iconTexture: "orangeBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"whiteBed",
Name:"White Bed",
textures: "whiteBedbottom",
iconTexture: "whiteBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"greenBed",
Name:"Green Bed",
textures: "greenBedbottom",
iconTexture: "greenBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"brownBed",
Name:"Brown Bed",
textures: "brownBedbottom",
iconTexture: "brownBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"blackBed",
Name:"Black Bed",
textures: "blackBedbottom",
iconTexture: "blackBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"pinkBed",
Name:"Pink Bed",
textures: "pinkBedbottom",
iconTexture: "pinkBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"limeBed",
Name:"Lime Bed",
textures: "limeBedbottom",
iconTexture: "limeBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"grayBed",
Name:"Gray Bed",
textures: "grayBedbottom",
iconTexture: "grayBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"cyanBed",
Name:"Cyan Bed",
textures: "cyanBedbottom",
iconTexture: "cyanBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"blueBed",
Name:"Blue Bed",
textures: "blueBedbottom",
iconTexture: "blueBedIcon",
flatIcon: true,
transparent: true,
bed: true,
bounciness: 0.6,
category:"items"
},
{
name:"quicksand",
Name:"Quicksand",
quicksand:true,
solid:false,
category:"nature"
},
{
name:"bow",
Name:"Bow",
pullTextures:["bow","bowPulling0","bowPulling1","bowPulling2"],
useAnywhere:true,
item:true,
stackSize:1,
category:"tools"
},
{
name:"arrow",
Name:"Arrow",
textures:"arrowIcon",
item:true,
category:"items"
},
{
name:"glisteringMelonSlice",
Name:"Slice of Watermelon With Unedible Gold",
item:true,
category:"items"
},
{
name:"untnt",
Name:"UnTNT",
textures:["untntBottom","untntTop","untnt"],
explode:function(x,y,z,how,dimension,world){
world.setBlock(x,y,z,0,false,false,false,false,dimension)
var e = new entities[entityIds.PrimedUnTNT](x,y,z)
world.addEntity(e,false,dimension)
world.playSound(x,y,z, "random.fuse")
switch(how){
case "explosion":
e.timeLimit = rand(10,30)
}
},
burnChance:0.6,
onburn:function(x,y,z,dimension,world){
this.explode(x,y,z,null,dimension,world)
},
category:"redstone"
},
{
name:"crimsonSign",
Name:"Crimson Sign",
textures:"crimsonPlanks",
poleTop:"crimsonStemTop",
poleSide:"crimsonStemSide",
iconTexture:"crimsonSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"warpedSign",
Name:"Warped Sign",
textures:"warpedPlanks",
poleTop:"warpedStemTop",
poleSide:"warpedStemSide",
iconTexture:"warpedSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{
name:"dropper",
Name:"Dropper",
textures:["furnaceTop","furnaceTop","furnaceSide","dropperFront","furnaceSide","furnaceSide"],
upTextures:fillTextureArray(["furnaceTop","dropperFrontVertical","furnaceTop"]),
downTextures:fillTextureArray(["dropperFrontVertical","furnaceTop","furnaceTop"]),
stoneSound:true,
category:"redstone",
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {dispenser:true, contents:new Array(9).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.dispenser && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var tags = world.getTags(x,y,z,dimension)
var on = tags && tags.on || false
if(power !== on) {
world.setTagByName(x,y,z,"on",power,false,dimension)
if(power){
var me = this
world.setTimeout(function(){
world.playSound(x,y,z, "click")
if(!tags || !tags.contents) return
var items = tags.contents.filter(r => r)
var idx = floor(rand(items.length))
if(!items[idx]) return
idx = tags.contents.indexOf(items[idx]), items = tags.contents
var vx = 0, vy = 0, vz = 0, ix = x, iy = y, iz = z, tx = x, ty = y, tz = z
switch(block){
case me.id | NORTH:
vz = -0.25
iz -= 0.75
tz--
break
case me.id | SOUTH:
vz = 0.25
iz += 0.75
tz++
break
case me.id | EAST:
vx = -0.25
ix -= 0.75
tx--
break
case me.id | WEST:
vx = 0.25
ix += 0.75
tx++
break
case me.id | SLAB:
vy = 0.25
iy += 0.75
ty++
break
case me.id | STAIR:
vy = -0.25
iy -= 0.75
ty--
break
}
if(!putItemInContainer(tx,ty,tz,dimension,items[idx].id,items[idx].durability,items[idx].customName,false,world)){
world.addItems(ix,iy,iz,dimension,vx,vy,vz,items[idx].id, false, 1, items[idx].durability, items[idx].customName)
}
items[idx].amount--
if(items[idx].amount <= 0) items[idx] = 0
world.setTags(x,y,z,tags,false,dimension)
},tickTime*4, x,y,z,dimension)
}
}
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
},
{
name:"dispenser",
Name:"Dispenser",
textures:["furnaceTop","furnaceTop","furnaceSide","dispenserFront","furnaceSide","furnaceSide"],
upTextures:fillTextureArray(["furnaceTop","dispenserFrontVertical","furnaceTop"]),
downTextures:fillTextureArray(["dispenserFrontVertical","furnaceTop","furnaceTop"]),
stoneSound:true,
category:"redstone",
hardness:3.5,
type:"rock2",
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {dispenser:true, contents:new Array(9).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.dispenser && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
var tags = world.getTags(x,y,z,dimension)
var on = tags && tags.on || false
if(power !== on) {
world.setTagByName(x,y,z,"on",power,false,dimension)
if(power){
var me = this
world.setTimeout(function(){
world.playSound(x,y,z, "click")
if(!tags || !tags.contents) return
var items = tags.contents.filter(r => r)
var idx = floor(rand(items.length))
if(!items[idx]) return
idx = tags.contents.indexOf(items[idx]), items = tags.contents
var vx = 0, vy = 0, vz = 0, ix = x, iy = y, iz = z
switch(block){
case me.id | NORTH:
vz = -0.25
iz--
break
case me.id | SOUTH:
vz = 0.25
iz++
break
case me.id | EAST:
vx = -0.25
ix--
break
case me.id | WEST:
vx = 0.25
ix++
break
case me.id | SLAB:
vy = 0.25
iy++
break
case me.id | STAIR:
vy = -0.25
iy--
break
}
var front = world.getBlock(ix,iy,iz,dimension)
if(front && blockData[front].solid) return
var data = blockData[items[idx].id]
var minus = true
if(data.name === "arrow") world.addEntity(new entities[entityIds.Arrow](ix,iy,iz,vx*4,vy*4,vz*4),false,dimension)
else if(data.name === "boneMeal") data.serveronuse(ix,iy,iz, front,dimension, world,"",items[idx],{}), minus = false
else if(data.name === "snowball") world.addEntity(new entities[entityIds.Snowball](ix,iy,iz,vx*4,vy*4,vz*4),false,dimension)
else if(data.name === "egg") world.addEntity(new entities[entityIds.Egg](ix,iy,iz,vx*4,vy*4,vz*4),false,dimension)
else if(data.name === "bucket"){
var set = false
if(front === blockIds.Water) set = true, items[idx].id = blockIds.waterBucket
if(front === blockIds.Lava) set = true, items[idx].id = blockIds.lavaBucket
if(front === blockIds.powderSnow) set = true, items[idx].id = blockIds.powderSnowBucket
if(front === blockIds.oil) set = true, items[idx].id = blockIds.oilBucket
world.setBlock(ix,iy,iz,0,false,false,false,false,dimension)
minus = false
}else if(data.name === "waterBucket") world.setBlock(ix,iy,iz,blockIds.Water,false,false,false,false,dimension), items[idx].id = blockIds.bucket, minus = false
else if(data.name === "lavaBucket") world.setBlock(ix,iy,iz,blockIds.Lava,false,false,false,false,dimension), items[idx].id = blockIds.bucket, minus = false
else if(data.name === "powderSnowBucket") world.setBlock(ix,iy,iz,blockIds.powderSnow,false,false,false,false,dimension), items[idx].id = blockIds.bucket, minus = false
else if(data.name === "oilBucket") world.setBlock(ix,iy,iz,blockIds.oil,false,false,false,false,dimension), items[idx].id = blockIds.bucket, minus = false
else if(data.name === "tnt") data.explode(ix,iy,iz,null,dimension,world)
else if(data.item) world.addItems(ix,iy,iz,dimension,vx,vy,vz,items[idx].id, false, 1, items[idx].durability, items[idx].customName)
else world.setBlock(ix,iy,iz,items[idx].id,false,false,false,false,dimension)
if(minus) items[idx].amount--
if(items[idx].amount <= 0) items[idx] = 0
world.setTags(x,y,z,tags,false,dimension)
},tickTime*4, x,y,z,dimension)
}
}
},
onset:function(x,y,z,dimension,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
},
{
name:"hopper",
Name:"Hopper",
textures:"hopper",
flatIcon:true,
iconTexture:"hopperIcon",
blastResistance:4.8,
transparent:true,
hardness:3,
type:"metal2",
stoneSound:true,
category:"redstone",
tagBits: null,
setContents:function(x,y,z,dimension,world){
let data = {hopper:true, contents:new Array(5).fill(0)}
world.setTags(x, y, z, data,false,dimension)
return data
},
onbreak:function(x,y,z, block, data,dimension,world){
if(!(data && data.hopper && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i]){
world.addItems(x,y,z,dimension,0,0,0,data[i].id, true, data[i].amount, data[i].durability, data[i].customName)
}
}
},
pushItem:function(x,y,z,dimension,tags,world){
var tx = x, ty = y, tz = z, top, dx = 0, dy = 0, dz = 0
switch(world.getBlock(x,y,z,dimension)){
case this.id:
ty--
dy = -1
top = true
break
case this.id | SLAB | NORTH:
tz++
dz = 1
break
case this.id | SLAB | SOUTH:
tz--
dz = -1
break
case this.id | SLAB | EAST:
tx++
dx = 1
break
case this.id | SLAB | WEST:
tx--
dx = -1
break
}
var to = world.getBlock(tx,ty,tz,dimension)
for(var i=0; i<tags.contents.length; i++){
var item = tags.contents[i]
if(!item || !item.id) continue
var put
if(!to || !blockData[to].solid){
world.addItems(x+dx*0.625,y+dy*0.625,z+dz*0.625,dimension,dx/8,dy/8,dz/8,item.id, false, 1, item.durability, item.customName)
put = true
}else if(blockData[to].name === "furnace"){
var toTags = world.getTags(tx,ty,tz,dimension), toTagName
if(!toTags) toTags = blockData[to].setContents(tx,ty,tz,dimension,this.world)
if(top) toTagName = "input"
else toTagName = "fuel"
var toTag = toTags[toTagName]
if(!toTag){
toTag = {id:item.id,amount:1,durability:item.durability,customName:item.customName}
put = true
}else if(toTag.id === item.id && (!toTag.customName && !item.customName || toTag.customName === item.customName) && toTag.amount < blockData[toTag.id].stackSize){
toTag.amount++
put = true
}
if(put){
toTags[toTagName] = toTag
world.setTags(tx,ty,tz,toTags,false,dimension)
}
}else if(putItemInContainer(tx,ty,tz,dimension,item.id,item.durability,item.customName,false,world)){
put = true
}
if(put){
item.amount--
if(!item.amount) tags.contents[i] = 0
return true
}
}
},
pullItem:function(x,y,z,dimension,myTags,world){
var block = world.getBlock(x,y+1,z,dimension)
var tags = world.getTags(x,y+1,z,dimension)
if(!tags) return
if(blockData[block].name === "furnace"){
var item = tags.output
if(item && item.id){
if(!putItemInContainer(x,y,z,dimension,item.id,item.durability,item.customName,true,world)) return
item.amount--
if(!item.amount) tags.output = 0
world.tagsChanged(x,y,z,tags,false,dimension)
return true
}
}else if(tags.contents) for(var i=0; i<tags.contents.length; i++){
var item = tags.contents[i]
if(item && item.id){
if(!putItemInContainer(x,y,z,dimension,item.id,item.durability,item.customName,true,world)) return
item.amount--
if(!item.amount) tags.contents[i] = 0
world.tagsChanged(x,y,z,tags,false,dimension)
return true
}
}
},
update:function(x,y,z,dimension,world){
if(this.isLocked(x,y,z,dimension,world)) return
var tags = world.getTags(x,y,z,dimension)
if(!tags) tags = this.setContents(x,y,z,dimension,world)
var u = false
if(this.pushItem(x,y,z,dimension,tags,world)) u = true
if(this.pullItem(x,y,z,dimension,tags,world)) u = true
if(u) world.setTags(x,y,z,tags,false,dimension)
},
onupdate:function(x,y,z,block,world,sx,sy,sz,dimension){
var me = this
var t = () => me.update(x,y,z,dimension,world)
world.setTimeout(t, tickTime*8, x,y,z,dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
this.onupdate(x,y,z,null,world,sx,sy,sz,dimension,world)
},
ontagsupdate:function(x,y,z,dimension,tags,world){
this.onupdate(x,y,z,null,world,null,null,null,dimension,world)
},
isLocked:function(x,y,z,dimension,world){
return world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension)
},
itemOnTop(x,y,z,dimension,ent){
let world = ent.world
if(this.isLocked(x,y,z,dimension,world)) return
var amount = ent.amount
while(amount){
if(!putItemInContainer(x,y,z,dimension,ent.block,ent.durability,ent.name,false,world)) break
amount--
}
return amount
}
},
{
name:"target",
Name:"Target",
textures:["targetTop","targetSide"],
hardness:0.5,
blastResistance:0.5,
burnChance: 0.2,
burnTime: 20,
category:"redstone",
grassSound: true,
type:"plant2",
cornerDist:sqrt(0.75),
sideDist:0.5,
projectileHit:function(x,y,z,dimension,ent){
let world = ent.world
var dist = dist3(ent.x+ent.direction.x/2,ent.y+ent.direction.y/2,ent.z+ent.direction.z/2,x,y,z)
var power = round(map(dist,this.sideDist,this.cornerDist,15,0))
world.setPower(x,y,z,power,false,dimension)
world.spreadPower(x,y,z,power,dimension)
world.setTimeout(function(){
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,power,false,dimension)
},tickTime*8, x,y,z,dimension)
}
},
{
name:"comparator",
Name:"Redstone Comparator",
transparent:true,
flatIcon:true,
iconTexture:"comparatorIcon",
category:"redstone",
tagBits:{
output:[0,4]
},
on:function(x,y,z,dimension,dx,dy,dz,subtract,world){
var fx = x-dx, fy = y-dy, fz = z-dz
var backPower = min(max(world.getRepeaterPower(x,y,z,fx,fy,fz,dimension),ceil((getContainerFullness(fx,fy,fz,dimension,world) || 0)*15)),15)
if(world.getBlockPower(fx,fy,fz,null,dimension)) backPower = 15
var sidePower = min(max(world.getRepeaterPower(x,y,z,x-dz,y-dy,z-dx,dimension),world.getRepeaterPower(x,y,z,x+dz,y-dy,z+dx,dimension)),15)
if(subtract) return max(backPower - sidePower, 0)
else return backPower * (sidePower <= backPower)
},
onupdate:function(x,y,z,b,w,sx,sy,sz,dimension){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
},
ontagsupdate:function(x,y,z,dimension,tags,world){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,world)
},
ondelete:function(x,y,z,prevTags,prevBlock,dimension,world){
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(x,y,z+1,null,"south",dimension)
world.setBlockPower(x,y,z-1,null,"north",dimension)
world.setBlockPower(x+1,y,z,null,"east",dimension)
world.setBlockPower(x-1,y,z,null,"west",dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var dx = 0, dy = 0, dz = 0 //direction
var side //side of block it's pointing to
var block = world.getBlock(x,y,z,dimension)
var offCompare = this.id, onCompare = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
var subtractMode
switch(block){
case offSubtract | NORTH:
case onSubtract | NORTH:
subtractMode = true
case offCompare | NORTH:
case onCompare | NORTH:
dz = 1
side = "south"
break
case offSubtract | SOUTH:
case onSubtract | SOUTH:
subtractMode = true
case offCompare | SOUTH:
case onCompare | SOUTH:
dz = -1
side = "north"
break
case offSubtract | EAST:
case onSubtract | EAST:
subtractMode = true
case offCompare | EAST:
case onCompare | EAST:
dx = 1
side = "east"
break
case offSubtract | WEST:
case onSubtract | WEST:
subtractMode = true
case offCompare | WEST:
case onCompare | WEST:
dx = -1
side = "west"
break
}
if(!dx && !dy && !dz) return console.log("doesn't match up") //doesn't match up
var tx = x+dx, ty = y+dy, tz = z+dz
var output = world.getTagByName(x,y,z,"output",dimension) || 0
var power = this.on(x,y,z,dimension,dx,dy,dz,subtractMode,world)
var tblock = world.getBlock(tx,ty,tz,dimension)
if(tblock && blockData[tblock].carryRedstone){
if(output){
var frontPower = world.getPower(tx,ty,tz,dimension)
if(output < frontPower){
world.unspreadPower(tx,ty,tz,frontPower,true,dimension)
}else if(output > frontPower){
world.setPower(tx,ty,tz,output,false,dimension)
world.spreadPower(tx,ty,tz,output,dimension)
}
}
}
if(power === output) return
var me = this
var t = function(){
block = world.getBlock(x,y,z,dimension)
power = me.on(x,y,z,dimension,dx,dy,dz,subtractMode,world)
output = world.getTagByName(x,y,z,"output",dimension) || 0
if(power !== output) {
world.setTagByName(x,y,z,"output",power,false,dimension)
var on = false
switch(block){
case onSubtract | NORTH:
case onCompare | NORTH:
case onSubtract | SOUTH:
case onCompare | SOUTH:
case onSubtract | EAST:
case onCompare | EAST:
case onSubtract | WEST:
case onCompare | WEST:
on = true
}
if((power ? true : false) !== on){
var target
switch(block){
case offCompare | NORTH:
target = onCompare | NORTH
break
case onCompare | NORTH:
target = offCompare | NORTH
break
case offSubtract | NORTH:
target = onSubtract | NORTH
break
case onSubtract | NORTH:
target = offSubtract | NORTH
break
case offCompare | SOUTH:
target = onCompare | SOUTH
break
case onCompare | SOUTH:
target = offCompare | SOUTH
break
case offSubtract | SOUTH:
target = onSubtract | SOUTH
break
case onSubtract | SOUTH:
target = offSubtract | SOUTH
break
case offCompare | EAST:
target = onCompare | EAST
break
case onCompare | EAST:
target = offCompare | EAST
break
case offSubtract | EAST:
target = onSubtract | EAST
break
case onSubtract | EAST:
target = offSubtract | EAST
break
case offCompare | WEST:
target = onCompare | WEST
break
case onCompare | WEST:
target = offCompare | WEST
break
case offSubtract | WEST:
target = onSubtract | WEST
break
case onSubtract | WEST:
target = offSubtract | WEST
break
}
if(block !== target) world.setBlock(x,y,z,target,false,false,false,true,dimension)
}
var tblock = world.getBlock(tx,ty,tz,dimension)
if(power){
if(tblock && blockData[tblock].carryRedstone){
var frontPower = world.getPower(tx,ty,tz,dimension)
if(power < frontPower){
world.unspreadPower(tx,ty,tz,frontPower,true,dimension)
}else if(power > frontPower){
world.setPower(tx,ty,tz,power,false,dimension)
world.spreadPower(tx,ty,tz,power,dimension)
}
}
}else{
if(tblock && blockData[tblock].carryRedstone){
world.unspreadPower(tx,ty,tz,output,true,dimension)
}
}
}//end if power changed
}
world.setTimeout(t,tickTime*2, x,y,z,dimension)
},
onclick:function(x,y,z,dimension,world){
var me = blockData[blockIds.comparator]
var block = world.getBlock(x,y,z,dimension)
var off = me.id, on = me.id | SLAB, offSubtract = me.id | STAIR, onSubtract = me.id | DOOR
var target
switch(block){
case off | NORTH:
target = offSubtract | NORTH
break
case on | NORTH:
target = onSubtract | NORTH
break
case offSubtract | NORTH:
target = off | NORTH
break
case onSubtract | NORTH:
target = on | NORTH
break
case off | SOUTH:
target = offSubtract | SOUTH
break
case on | SOUTH:
target = onSubtract | SOUTH
break
case offSubtract | SOUTH:
target = off | SOUTH
break
case onSubtract | SOUTH:
target = on | SOUTH
break
case off | EAST:
target = offSubtract | EAST
break
case on | EAST:
target = onSubtract | EAST
break
case offSubtract | EAST:
target = off | EAST
break
case onSubtract | EAST:
target = on | EAST
break
case off | WEST:
target = offSubtract | WEST
break
case on | WEST:
target = onSubtract | WEST
break
case offSubtract | WEST:
target = off | WEST
break
case onSubtract | WEST:
target = on | WEST
break
}
world.setBlock(x,y,z,target,false,false,false,true,dimension)
},
getFacing:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var off = this.id, on = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
var f
switch(block){
case off | NORTH:
case on | NORTH:
case offSubtract | NORTH:
case onSubtract | NORTH:
f = "north"
break
case off | SOUTH:
case on | SOUTH:
case offSubtract | SOUTH:
case onSubtract | SOUTH:
f = "south"
break
case off | EAST:
case on | EAST:
case offSubtract | EAST:
case onSubtract | EAST:
f = "east"
break
case off | WEST:
case on | WEST:
case offSubtract | WEST:
case onSubtract | WEST:
f = "west"
break
}
return f
},
canHavePower:function(/*this*/rx,ry,rz,/*other thing*/x,y,z,dimension,world){
var tx = rx, ty = ry, tz = rz
var block = world.getBlock(rx,ry,rz,dimension)
var off = this.id, on = this.id | SLAB, offSubtract = this.id | STAIR, onSubtract = this.id | DOOR
switch(block){
case offSubtract | NORTH:
case onSubtract | NORTH:
case off | NORTH:
case on | NORTH:
tz++
break
case offSubtract | SOUTH:
case onSubtract | SOUTH:
case off | SOUTH:
case on | SOUTH:
tz--
break
case offSubtract | EAST:
case onSubtract | EAST:
case off | EAST:
case on | EAST:
tx++
break
case offSubtract | WEST:
case onSubtract | WEST:
case off | WEST:
case on | WEST:
tx--
break
}
if(tx === x && ty === y && tz === z){
return world.getTagByName(rx,ry,rz,"output",dimension) || 0
}
return 0
}
},
{
name:"acaciaChair",
Name:"Acacia Chair",
textures:"acaciaPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"birchChair",
Name:"Birch Chair",
textures:"birchPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"jungleChair",
Name:"Jungle Chair",
textures:"junglePlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"darkOakChair",
Name:"Dark Oak Chair",
textures:"darkOakPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"spruceChair",
Name:"Spruce Chair",
textures:"sprucePlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"mangroveChair",
Name:"Mangrove Chair",
textures:"mangrovePlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"crimsonChair",
Name:"Crimson Chair",
textures:"crimsonPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"warpedChair",
Name:"Warped Chair",
textures:"warpedPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"blackChair",
Name:"Black Chair",
textures:"blackWool",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name: "spawnCreeper",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Creeper](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Creeper](x,y,z),false,dimension)
},
category:"items"
},
{
name:"gunpowder",
Name:"Gray exploding stuff",
item:true
},
{
name:"rottenFlesh",
Name:"Rotten Flesh",
item:true
},
{
name: "spawnSheep",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Sheep](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Sheep](x,y,z),false,dimension)
},
category:"items"
},
{
name: "spawnChicken",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Chicken](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Chicken](x,y,z),false,dimension)
},
category:"items"
},
{
name:"feather",
Name:"Feather",
item:true
},
{
name: "spawnZombie",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Zombie](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Zombie](x,y,z),false,dimension)
},
category:"items"
},
{
name: "spawnSkeleton",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Skeleton](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Skeleton](x,y,z),false,dimension)
},
category:"items"
},
{
name: "bone",
Name: "Bone",
item: true,
category:"items"
},
{
name:"spawner",
Name:"Mob Spawner",
transparent:true,
blastResistance:5,
hardness:5,
drop:"air",
experience:15,
tagBits:null,
tick:function(block,x,y,z,dimension,world){
let spawn = world.getTagByName(x,y,z,"spawn",dimension)
if(spawn){
world.sendAll({
type:"particles", particleType:"flameCube",
x,y,z,dimension, amount: 20
})
for(let i=0; i<10; i++){
let sx = x+round(rand(-4.5,4))
let sy = y+round(rand(-1.5,1.5))
let sz = z+round(rand(-4.5,4))
let block = world.getBlock(sx,sy,sz,dimension)
if(blockData[block].transparent){
blockData[spawn].spawnMob(sx,sy,sz,dimension,world)
break
}
}
}
},
onclick:function(x,y,z,dimension,world,p){
if(p.holding && blockData[p.holding].spawnMob){
world.setTagByName(x,y,z,"spawn",p.holding,false,dimension)
world.sendAll({
type:"particles", particleType:"flameCube",
x,y,z,dimension, amount: 30
})
}else return true
}
},
{
name:"daylightDetector",
Name:"Daylight detector",
textures:["daylightDetectorSide","daylightDetectorTop","daylightDetectorSide"],
invertedTextures:fillTextureArray(["daylightDetectorSide","daylightDetectorInvertedTop","daylightDetectorSide"]),
transparent:true,
blastResistance:0.2,
hardness:0.2,
woodSound:true,
onclick:function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension)
let me = blockData[blockIds.daylightDetector]
if(block === (me.id | SLAB)) block = me.id
else block = me.id | SLAB
world.setBlock(x,y,z,block,false,false,false,false,dimension)
},
tick:function(block,x,y,z,dimension,world){
let power = round(world.getLight(x, y, z, 0, dimension)*world.skyLight)
if(block === (this.id | SLAB)) power = 15 - power
let prev = world.getPower(x,y,z,dimension)
if(prev !== power){
world.setPower(x,y,z,power,false,dimension)
if(power){
if(power < prev){
world.unspreadPower(x,y,z,prev,false,dimension)
}else if(power > prev){
world.spreadPower(x,y,z,power,dimension)
}
}else{
world.unspreadPower(x,y,z,prev,false,dimension)
}
}
},
onset:function(x,y,z,dimension,world){
this.tick(world.getBlock(x,y,z,dimension),x,y,z,dimension,world)
},
ondelete: function(x,y,z,prevTags,prev,dimension,world){
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z, 16,false,dimension)
},
category:"redstone"
},
{
name:"commandBlock",
Name:"Command Block",
textures:["commandBlockBack",'commandBlockFront','commandBlockSide'],
errorTextures:fillTextureArray(["commandBlockBackError",'commandBlockFrontError','commandBlockSideError']),
sideTextures:["commandBlockSide","commandBlockSide","commandBlockBack","commandBlockFront","commandBlockSide","commandBlockSide"],
sideErrorTextures:["commandBlockSideError","commandBlockSideError","commandBlockBackError","commandBlockFrontError","commandBlockSideError","commandBlockSideError"],
flipTextures:fillTextureArray(["commandBlockFront",'commandBlockBack','commandBlockSide']),
flipErrorTextures:fillTextureArray(["commandBlockFrontError",'commandBlockBackError','commandBlockSideError']),
hardness:Infinity,
commandBlock:true,
tagBits: null,
trigger:function(x,y,z,dimension,world){
let data = world.getTagByName(x,y,z,"data",dimension)
let running = world.getTagByName(x,y,z,"running",dimension)
if(data && !running){
world.setTagByName(x,y,z,"running",true,false,dimension)
runCmd(data,{x,y,z,dimension},world,true, output => {
let outputHTML = "none"
outputHTML = ""
for(let i=0; i<output.length; i+=2){
if(i) outputHTML += "<br>"
outputHTML += Messages.format(output[i])
}
world.setTagByName(x,y,z,"output",outputHTML,false,dimension)
let target
let block = world.getBlock(x,y,z,dimension)
switch(block){
case this.id:
case this.id | FLIP:
target = this.id
break
case this.id | SLAB | NORTH:
case this.id | SLAB | FLIP | NORTH:
target = this.id | SLAB | NORTH
break
case this.id | SLAB | SOUTH:
case this.id | SLAB | FLIP | SOUTH:
target = this.id | SLAB | SOUTH
break
case this.id | SLAB | EAST:
case this.id | SLAB | FLIP | EAST:
target = this.id | SLAB | EAST
break
case this.id | SLAB | WEST:
case this.id | SLAB | FLIP | WEST:
target = this.id | SLAB | WEST
break
case this.id | STAIR:
case this.id | STAIR | FLIP:
target = this.id | STAIR
break
}
if(output && output[output.length-1] === "error") target |= FLIP
if(block !== target) world.setBlock(x,y,z,target,false,false,false,true,dimension)
}).then(() => world.setTagByName(x,y,z,"running",false,false,dimension))
}
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension) ? true : false
var on = world.getTagByName(x,y,z,"on",dimension) || false
if(power !== on) {
world.setTagByName(x,y,z,"on",power,false,dimension)
if(power){
this.trigger(x,y,z,dimension,world)
}
}
},
rarity:"epic",
category:"redstone"
},
{
name:"spiderEye",
item:true,
category:"items"
},
{
name: "spawnSpider",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Spider](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Spider](x,y,z),false,dimension)
},
category:"items"
},
{
name: "spawnCaveSpider",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Spider](pos[0],pos[1],pos[2],true)
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Spider](x,y,z,true),false,dimension)
},
category:"items"
},
{
name: "spawnWolf",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Wolf](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Wolf](x,y,z),false,dimension)
},
category:"items"
},
{
name:"nameTag",
Name:"Name Tag",
item:true,
onserverentityuse:function(ent,holding){
if(ent.mob && holding.customName){
ent.name = holding.customName
ent.world.sendEntityPos(ent)
holding.amount--
}
}
},
{
name:"blazeRod",
Name:"Blaze Rod",
item:true
},
{
name:"blazePowder",
Name:"Blaze Powder",
item:true
},
{
name: "spawnBlaze",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Blaze](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Blaze](x,y,z),false,dimension)
},
category:"items"
},
{
name:"fireCharge",
item:true
},
{
name: "spawnEnderDragon",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.EnderDragon](pos[0],pos[1],pos[2])
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.EnderDragon](x,y,z),false,dimension)
},
category:"items",
hidden:true
},
{
name:"debugStick",
item:true,
hidden:true
},
{
name: "oil",
textures:"oil",
transparent: true,
liquid: true,
solid:false,
shadow: false,
blastResistance:100,
hidden:true,
drop:"air",
burnChance: 1,
burnTime: 15,
density:0.1,
inLiquid:3,
getLevelDifference:function(level){return level-2},
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
if(!world.settings.blocksFall) return
var me = this
world.setTimeout(() => me.flow(x,y,z,dimension,world), tickTime*5, x,y,z,dimension)
},
getY:function(x,y,z,dimension){
var block = world.getBlock(x,y,z,dimension)
return (min((this.getLevel(block) || (block ? 8 : 0))*2,14.5)/16)-0.5
},
},
{
name: "oilBucket",
Name:"Oil Bucket",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
if(p.survival) item.id = blockIds.bucket
var pos = movePositionByFace(face,x,y,z)
world.setBlock(pos[0],pos[1],pos[2],blockIds.oil,false,false,false,false,dimension)
},
stackSize: 1,
category:"items"
},
{ name: "silverBlock", Name:"Block of Silver", hardness:5, type:"metal2",category:"build", stoneSound:true},
{ name: "limestone", Name:"Limestone", type:"rock1",category:"nature", hardness:1.25, blastResistance:0.8, stoneSound:true, randomRotate:"flip",randomRotateTop:true,randomRotateBottom:true,randomRotateNorth:true,randomRotateSouth:true,randomRotateEast:true,randomRotateWest:true},
{
name: "spawnEnderman",
item: true,
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Enderman](pos[0],pos[1],pos[2])
if(item.customName) ent.name = item.customName
world.addEntity(ent,false,dimension)
item.amount--
},
spawnMob: function(x,y,z,dimension,world){
world.addEntity(new entities[entityIds.Enderman](x,y,z),false,dimension)
},
category:"items"
},
{
name:"bambooBlock",
Name:"Block of Bamboo",
textures:["bambooBlockTop","bambooBlock"],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{
name:"bambooBlockSW",
textures: ["bambooBlock","bambooBlock","bambooBlockTop","bambooBlock"],
SW: true, hidden:true
},
{
name:"strippedBambooBlock",
Name:"Stripped Block of Bamboo",
textures:["strippedBambooBlockTop","strippedBambooBlock"],
hardness:2,
woodSound:true,
type:"wood",
category:"nature",
burnChance:0.1,
burnTime:50,
log:true
},
{
name:"strippedBambooBlockSW",
textures: ["strippedBambooBlock","strippedBambooBlock","strippedBambooBlockTop","strippedBambooBlock"],
SW: true, hidden:true
},
{ name: "bambooPlanks", Name:"Bamboo Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
{ name: "bambooMosaic", Name:"Bamboo Mosaic", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
{
name:"bambooButton",
Name: "Bamboo Button",
textures:"bambooPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{ 
name: "bambooDoor",
Name:"Bamboo Door",
transparent: true,
shadow: false,
textures: "bambooDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name:"bambooFenceGate",
Name:"Bamboo Fence Gate",
textures:"bambooPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name: "bambooPressurePlate",
Name: "Bamboo Pressure Plate",
textures: "bambooPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name:"bambooSign",
Name:"Bamboo sign",
textures:"bambooPlanks",
poleTop:"bambooBlockTop",
poleSide:"bambooBlock",
iconTexture:"bambooSign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{ 
name: "bambooTrapdoor",
Name:"Bamboo Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{
name:"strippedCherryLog",
Name:"Stripped Cherry Log",
textures:["strippedCherryLogTop","strippedCherryLog"],
woodSound:true,
hardness:2,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature"
},
{
name:"strippedCherryLogSW",
textures: ["strippedCherryLog","strippedCherryLog","strippedCherryLogTop","strippedCherryLog"],
SW: true, hidden:true
},
{ name: "cherryPlanks", Name:"Cherry Planks", type:"wood",category:"build", hardness:2, woodSound:true, burnChance:0.1, burnTime:40},
{
name:"cherryButton",
Name: "Cherry Button",
textures:"cherryPlanks",
button:true,
transparent: true,
shadow:false,
category:"redstone"
},
{ 
name: "cherryDoor",
Name:"Cherry Door",
transparent: true,
shadow: false,
textures: "cherryDoorBottom",
door:true,
woodSound:true,
hardness:3,
type:"wood",
category:"build"
},
{
name:"cherryFenceGate",
Name:"Cherry Fence Gate",
textures:"cherryPlanks",
fenceGate:true,
hardness:2,
woodSound:true,
type:"wood",
category:"build"
},
{
name: "cherryPressurePlate",
Name: "Cherry Pressure Plate",
textures: "cherryPlanks",
pressurePlate: true,
hardness:0.5,
type:"wood",
category:"redstone"
},
{
name:"cherrySign",
Name:"Cherry sign",
textures:"cherryPlanks",
poleTop:"cherryLogTop",
poleSide:"cherryLog",
iconTexture:"cherrySign",
flatIcon:true,
sign:true,
hardness:1,
woodSound:true,
type:"wood",
category:"decoration"
},
{ 
name: "cherryTrapdoor",
Name:"Cherry Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true,
category:"build"
},
{
name:"cherryChair",
Name:"Cherry Chair",
textures:"cherryPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name:"bambooChair",
Name:"Bamboo Chair",
textures:"bambooPlanks",
chair:true,
transparent:true,
shadow:false,
onclientclick:sit,
category:"items"
},
{
name: "suspicousSand",
Name:"Suspicois Sand",
textures:"suspiciousSand0",
hardness:0.25, blastResistance:0.5,
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
drop:"air"
},
{
name: "suspicousGravel",
Name:"Suspicous Gravel",
textures:"suspiciousGravel0",
hardness:0.25, blastResistance:0.5,
onupdate: function(x,y,z,b,world,sx,sy,sz,dimension){
fall(x,y,z,b,world,false,dimension)
},
ongetexploded:function(x,y,z,b,world,dimension){
fall(x,y,z,b,world,true,dimension)
},
drop:"air"
},
{
name:"pitcherPlant",
Name:"Pitcher Plant",
shapeName:"pitcherPlant",
flatIcon:true,
solid: false,
transparent: true,
shadow: false,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name:"pitcherPod",
Name:"Pitcher Pod",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "pitcherCrop"
},
category:"items"
},
{
name:"pitcherCrop",
textures:"pitcherCropSide",
textures1:new Array(6).fill("pitcherCropBottomStage1"),
textures2:new Array(6).fill("pitcherCropBottomStage2"),
textures3:new Array(6).fill("pitcherCropBottomStage3"),
textures4:new Array(6).fill("pitcherCropBottomStage4"),
transparent: true,
shadow: false,
solid: false,
drop:"pitcherPod",
hidden:true,
liquidBreakable:"drop"
},
{
name: "torchflower",
Name:"\"Torch\" flower",
textures1:new Array(6).fill("torchflowerCropStage0"),
textures2:new Array(6).fill("torchflowerCropStage1"),
drop:"torchflowerSeeds",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
compostChance:0.65,
liquidBreakable:"drop",
category:"nature"
},
{
name:"torchflowerSeeds",
Name:"Torchflower seeds",
item:true,
useAs:function(x,y,z,block,face){
return blockIds.torchflower|SLAB
},
category:"items"
},
{
name:"driedOakLeaves",
Name:"Dried Oak Leaves",
thickTexture:"driedOakLeavesThick",
hardness:0.1,
drop:"air",
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
groundLeaves:true
},
{
name:"driedBirchLeaves",
Name:"Dried Birch Leaves",
hardness:0.1,
drop:"air",
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
groundLeaves:true
},
{
name:"driedSpruceLeaves",
Name:"Dried Spruce Leaves",
hardness:0.1,
drop:"air",
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
groundLeaves:true
},
{
name:"strippedCherryWood",
Name:"Stripped Cherry Wood",
textures: "strippedCherryLog",
hardness:2,
woodSound:true,
type:"wood",
burnChance:0.1,
burnTime:50,
category:"nature",
log:true
},
{
name:"pinkPetals",
Name:"Pink flowers",
textures:["pinkPetalsFlower","pinkPetalsStem"],
iconTexture:"pinkPetals",
flowerbed:true,
solid: false,
transparent: true,
shadow: false,
liquidBreakable:"drop",
category:"nature",
randomRotateOnSpawn:true,
addPetal:function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension), target, rot = block&ROTATION
switch(block & (~ROTATION)){
case this.id:
target = this.id | SLAB
break
case this.id|SLAB:
target = this.id | STAIR
break
case this.id|STAIR:
target = this.id | DOOR
break
}
if(target) world.setBlock(x,y,z,target|rot,false,false,false,false,dimension)
}
},
{
name:"lilyPad",
Name:"Lily Pad",
transparent:true,
shadow:false,
shapeName:"flat",
flatIcon:true,
liquidBreakable:"drop",
category:"nature",
type:"plant2",
allHitbox: true
},
{
name:"lightPanel",
Name:"Light Panel",
transparent:true,
shadow:false,
shapeName:"ceilingPanel",
lightLevel:15,
category:"build",
glassSound:true,
flatIcon:true
},
{
name:"bambooLeaves",
Name: "Bamboo Leaves",
transparent: true,
cullFace:0,
hardness: 0.2,
type:"plant2",
leaves:true,
dropSelfWhenSheared:true,
shearBreakTime:0.05,
burnChance: 0.2,
burnTime: 30,
compostChance:0.3,
grassSound: true,
category:"nature",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(2))
if(r === 0) return "stick"
else if(r === 1) return "bambooShoot"
}
},
},
{
name:"driedBambooLeaves",
Name:"Dried Bamboo Leaves",
hardness:0.1,
drop:"air",
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
groundLeaves:true
},
{
name:"groundBerries",
Name:"Ground Berries",
textures:["groundBerries","groundBerriesStem"],
hardness:0.1,
category:"nature",
grassSound: true,
transparent:true,
shadow:false,
solid:false,
shapeName:"groundBush",
randomRotateOnSpawn:true
},
{
name:"brainCoralBlock",
Name:"Sponge-like Coral Block",
category:"nature",
coralBlock:true
},
{
name:"bubbleCoralBlock",
Name:"Bubble Coral Block",
category:"nature",
coralBlock:true
},
{
name:"fireCoralBlock",
Name:"Fire Coral Block",
category:"nature",
coralBlock:true
},
{
name:"hornCoralBlock",
Name:"Horn Coral Block",
category:"nature",
coralBlock:true
},
{
name:"tubeCoralBlock",
Name:"Tube Coral Block",
category:"nature",
coralBlock:true
},
{
name:"brainCoral",
Name:"Sponge-like Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"bubbleCoral",
Name:"Bubble Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"fireCoral",
Name:"Fire Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"hornCoral",
Name:"Horn Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"tubeCoral",
Name:"Tube Coral (standing)",
category:"nature",
coral:true,
transparent:true,
solid:false,
shadow:false,
potCross:true,
wetgrassSound:true
},
{
name:"brainCoralFan",
Name:"Sponge-like Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"bubbleCoralFan",
Name:"Bubble Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"fireCoralFan",
Name:"Fire Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"hornCoralFan",
Name:"Horn Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"tubeCoralFan",
Name:"Tube Coral Fan",
category:"nature",
coralFan:true,
transparent:true,
solid:false,
shadow:false,
wetgrassSound:true
},
{
name:"minecart",
Name:"Minecart",
textures:"minecartIcon",
item:true,
category:"redstone",
serveronuse: (x,y,z, block, dimension,world,face,item,p) => {
let pos = movePositionByFace(face,x,y,z)
let ent = new entities[entityIds.Minecart](pos[0],pos[1],pos[2])
world.addEntity(ent,false,dimension)
},
},
{
name:"rail",
Name:"Rail",
transparent:true,
shadow:false,
solid:false,
blastResistance:0.7,
hardness:0.7,
rail:true,
category:"redstone",
flatIcon:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
this.railonupdate(x,y,z,b,world,dimension)
},
},
{
name:"poweredRail",
Name:"Powered Rail",
transparent:true,
shadow:false,
solid:false,
blastResistance:0.7,
hardness:0.7,
rail:true,
category:"redstone",
flatIcon:true,
carryRedstone:true,
onupdate:function(x,y,z,b,world,sx,sy,sz,dimension){
let on = world.getTagByName(x,y,z,"power",dimension)
if(on && !(b&FLIP)){
b |= FLIP
world.setBlock(x,y,z,b,false,false,false,true,dimension)
}else if(!on && (b&FLIP)){
b &= ~FLIP
world.setBlock(x,y,z,b,false,false,false,true,dimension)
}
this.railonupdate(x,y,z,b,world,dimension)
},
onpowerupdate:function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
this.onupdate(x,y,z,world.getBlock(x,y,z,dimension),world,sx,sy,sz,dimension)
}
},
{
name:"cornPlant",
textures:"cornStage0",
textures1:new Array(6).fill("cornStage1"),
textures2:new Array(6).fill("cornStage2"),
textures3:new Array(6).fill("cornStage3"),
textures4:new Array(6).fill("cornStage4"),
textures5:new Array(6).fill("cornStage5"),
transparent: true,
shadow: false,
solid: false,
drop:"corn",
hidden:true,
liquidBreakable:"drop",
growBonemeal:function(x,y,z,dimension,world){
world.setBlock(x,y,z, this.id|DOOR,false,false,false,false,dimension)
}
},
{
name:"corn",
Name:"Corn",
item:true,
edible: true,
food: 3,
saturation: 2,
compostChance:0.85,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "cornPlant"
},
category:"food"
},
{
name:"popcornBowl",
Name:"Bowl of Popcorn",
item:true,
edible: true,
food: 4,
saturation: 2,
eatResult:"bowl",
category:"food"
},
];
const BLOCK_COUNT = blockData.length
console.log(BLOCK_COUNT," blocks on server side")
win.SERVER_BLOCK_COUNT = BLOCK_COUNT, win.serverBlockData = blockData
win.emptyFunc = function(){}
let blockIds = {}
win.serverBlockIds = blockIds
let generateBlockIds = {
grass:true, dirt:true, stone: true, gravel: true,
snowBlock: true, snow: true, packedIce:true, ice:true,
Water: true, powderSnow: true, mud:true,
coarseDirt:true, podzol: true,
sand: true, bedrock: true, deepslate: true,
sandstone: true, limestone: true,
mycelium: true, redSand: true, rootedDirt:true,
redSandstone: true, calcite: true,
terracotta: true, lightGrayTerracotta: true, whiteTerracotta: true, yellowTerracotta: true, orangeTerracotta: true,
glass: true,//for testing without shadows
orangeConcrete:true,glowstone:true//also for testing
} //blocks that can be naturally generated
function initBlockData(){
const stoneDigSound = ["stone.dig1", "stone.dig2", "stone.dig3", "stone.dig4"],
stoneStepSound = ["stone.step1", "stone.step2","stone.step3","stone.step4","stone.step5","stone.step6"],
woodDigSound = ["wood.dig1", "wood.dig2", "wood.dig3", "wood.dig4"],
woodStepSound = ["wood.step1", "wood.step2","wood.step3","wood.step4","wood.step5","wood.step6"],
clothDigSound = ["cloth.dig1", "cloth.dig2", "cloth.dig3", "cloth.dig4"],
clothStepSound = ["cloth.step1", "cloth.step2","cloth.step3","cloth.step4"],
glassDigSound = ["glass.dig1", "glass.dig2", "glass.dig3"],
nyliumDigSound = ["nylium.dig1", "nylium.dig2", "nylium.dig3", "nylium.dig4", "nylium.dig5", "nylium.dig6"],
nyliumStepSound = ["nylium.step1", "nylium.step2","nylium.step3","nylium.step4","nylium.step5","nylium.step6"],
stemDigSound = ["stem.dig1", "stem.dig2", "stem.dig3", "stem.dig4", "stem.dig5", "stem.dig6"],
stemStepSound = ["stem.step1", "stem.step2","stem.step3","stem.step4","stem.step5","stem.step6"],
basaltDigSound = ["basalt.dig1", "basalt.dig2", "basalt.dig3", "basalt.dig4", "basalt.dig5"],
basaltStepSound = ["basalt.step1", "basalt.step2","basalt.step3","basalt.step4","basalt.step5","basalt.step6"],
rootDigSound = ["roots.dig1", "roots.dig2", "roots.dig3", "roots.dig4", "roots.dig5", "roots.dig6"],
rootStepSound = ["roots.step1", "roots.step2","roots.step3","roots.step4","roots.step5","roots.step6"],
amethystPlaceSound = ["amethyst.place1","amethyst.place2","amethyst.place3","amethyst.place4"],
amethystDigSound = ["amethyst.dig1","amethyst.dig2","amethyst.dig3","amethyst.dig4"],
amethystStepSound = (function(){var arr=[]; for(var i=0; i<14; i++){arr.push("amethyst.step"+(i+1))};return arr})(),
amethystClusterPlaceSound = ["amethyst_cluster.place1", "amethyst_cluster.place2", "amethyst_cluster.place3", "amethyst_cluster.place4"],
amethystClusterDigSound = ["amethyst_cluster.dig1", "amethyst_cluster.dig2", "amethyst_cluster.dig3", "amethyst_cluster.dig4"],
deepslatePlaceSound = ["deepslate.place1","deepslate.place2","deepslate.place3","deepslate.place4","deepslate.place5","deepslate.place6"],
deepslateStepSound = ["deepslate.step1","deepslate.step2","deepslate.step3","deepslate.step4","deepslate.step5","deepslate.step6"],
deepslateDigSound = ["deepslate.dig1","deepslate.dig2","deepslate.dig3","deepslate.dig4"],
deepslateBricksPlaceSound = [1,2,3,4,5,6].map(v => "deepslate_bricks.place"+v),
deepslateBricksStepSound = [1,2,3,4,5].map(v => "deepslate_bricks.step"+v),
grassDigSound = ["grass.dig1", "grass.dig2", "grass.dig3", "grass.dig4"],
grassStepSound = ["grass.step1", "grass.step2","grass.step3","grass.step4","grass.step5","grass.step6"],
coralDigSound = ["coral.dig1","coral.dig2","coral.dig3","coral.dig4"],
coralStepSound = ["coral.step1","coral.step2","coral.step3","coral.step4","coral.step5","coral.step6"],
wetgrassDigSound = ["wetgrass.dig1","wetgrass.dig2","wetgrass.dig3","wetgrass.dig4"],
wetgrassStepSound = ["wetgrass.step1","wetgrass.step2","wetgrass.step3","wetgrass.step4","wetgrass.step5","wetgrass.step6"]
const defaultTagBits = {
power:[15,5], //extra for power level 16 (power sources)
blockPowerNorth:[20,2],
blockPowerSouth:[22,2],
blockPowerEast:[24,2],
blockPowerWest:[26,2],
blockPowerTop:[28,2],
blockPowerBottom:[30,2],
} /*
tag bits have a index and a count
if tagBits is set to null
- it stores it as a properties of an object,
otherwise
- it stores it in specific bits in a number
*/
// Set defaults on blockData
for (let i = 1; i < BLOCK_COUNT; ++i) {
const data = blockData[i];
data.id = i;
if ( !("textures" in data) ) {
data.textures = new Array(6).fill(data.name);
} else if (typeof data.textures === "string") {
data.textures = new Array(6).fill(data.textures);
} else {
const { textures } = data;
if (textures.length === 3) {
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
} else if (textures.length === 2) {
// Top and bottom are the first texture, sides are the second.
textures[2] = textures[1];
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
textures[1] = textures[0];
}else if(textures.length === 4){
textures[4] = textures[5] = textures[3]
textures[3] = textures[2]
}
}
data.transparent = data.transparent || false
data.shadow = data.shadow !== undefined ? data.shadow : true
data.shade = data.shade !== undefined ? data.shade : true
data.smoothLight = data.smoothLight !== undefined ? data.smoothLight : true //if smoothLight is false, it also needs to be transparent
data.lightLevel = data.lightLevel || 0
if(data.solid === undefined)data.solid = true
//data.breakTime = data.breakTime ? data.breakTime*1000 : 0 //time for breaking, changed to hardness
data.hardness = data.hardness || 0
if(data.dropAmount === undefined) data.dropAmount = 1
if(data.leaves && data.decreaseLight === undefined) data.decreaseLight = 1
if(data.crossShape || data.tallcrossShape || data.sideCross || data.ladder || data.torch || data.lantern || data.chain || data.sunflower || data.crop || data.tallCrop) data.smoothLight = false
if(data.item){
data.transparent = true
data.shadow = false
}
if(data.liquid) data.noHitbox = true
if(!data.stackSize)data.stackSize = 64
if(data.pickaxe){
data.stackSize = 1
data.attackTime = 20/1.2
}
if(data.sword){
data.stackSize = 1
data.attackTime = 20/1.6
}
if(data.shovel){
data.stackSize = 1
data.attackTime = 20/1
}
if(data.axe || data.hoe){
data.stackSize = 1
}
data.tool = data.tool || data.pickaxe || data.sword || data.shovel || data.axe || data.hoe
if(data.attackSpeed) data.attackTime = 20/data.attackSpeed
if(data.tagBits !== null){
if(data.tagBits) Object.assign(data.tagBits,defaultTagBits)
else data.tagBits = defaultTagBits
}
if(data.stoneSound){
data.digSound = stoneDigSound
data.stepSound = stoneStepSound
}
if(data.woodSound){
data.digSound = woodDigSound
data.stepSound = woodStepSound
}
if(data.clothSound){
data.digSound = clothDigSound
data.stepSound = clothStepSound
}
if(data.glassSound){
data.digSound = glassDigSound
data.placeSound = stoneDigSound
}
if(data.nyliumSound){
data.digSound = nyliumDigSound
data.stepSound = nyliumStepSound
}
if(data.stemSound){
data.digSound = stemDigSound
data.stepSound = stemStepSound
}
if(data.basaltSound){
data.digSound = basaltDigSound
data.stepSound = basaltStepSound
}
if(data.rootSound){
data.digSound = rootDigSound
data.stepSound = rootStepSound
}
if(data.amethystSound){
data.placeSound = amethystPlaceSound
data.digSound = amethystDigSound
data.stepSound = amethystStepSound
}
if(data.amethystClusterSound){
data.placeSound = amethystClusterPlaceSound
data.digSound = amethystClusterDigSound
}
if(data.deepslateSound){
data.placeSound = deepslatePlaceSound
data.digSound = deepslateDigSound
data.stepSound = deepslateStepSound
}
if(data.deepslateBricksSound){
data.placeSound = deepslateBricksPlaceSound
data.stepSound = deepslateBricksStepSound
}
if(data.grassSound){
data.digSound = grassDigSound
data.stepSound = grassStepSound
}
if(data.coralBlock){
data.digSound = coralDigSound
data.stepSound = coralStepSound
}
if(data.wetgrassSound){
data.digSound = wetgrassDigSound
data.stepSound = wetgrassStepSound
}
data.Name = data.Name || data.name
data.pistonPush = data.pistonPush !== undefined ? data.pistonPush : true
data.pistonPull = data.pistonPull !== undefined ? data.pistonPull : true
}
blockData.forEach(block => {
blockIds[block.name] = block.id
if(block.SW && block.name.includes("SW")){
let unSw = block.name.replace("SW",'')
if(blockIds[unSw]){
block.drop = unSw
let obj = blockData[blockIds[unSw]]
block.hardness = obj.hardness
block.type = obj.type
block.burnChance = obj.burnChance
block.burnTime = obj.burnTime
block.log = obj.log
obj.swId = block.id
}
}
if(generateBlockIds[block.name]) generateBlockIds[block.name] = block.id
})
//fill the crafts that have less than 9 items. Ex: "thing" => "thing,air,air..."
let arr, arr2 = new Array(9)
for(let i in crafts){
arr = i.split(",")
for(let j = 0; j<9; j++){
if(arr[j]){
arr[j] = getBlockId(arr[j])
}else{
arr.push(0)
}
}
crafts[i].id = getBlockId(crafts[i].name)
if(crafts[i].amount === undefined) crafts[i].amount = 1
craftArrays[arr.join(",")] = arr.slice()
crafts[arr.join(",")] = crafts[i]
//shaped recipes
if(crafts[i].shaped){
var craft2 = Object.assign({},crafts[i])
craft2.hidden = true
var xSpace = 3, ySpace = 3
//find how much empty space there is
for(var x=2; x>=0; x--){
var a = arr[x]
var b = arr[x+3]
var c = arr[x+6]
if(a||b||c){
xSpace = x
break
}
}
for(var y=2; y>=0; y--){
var a = arr[y*3]
var b = arr[(y*3)+1]
var c = arr[(y*3)+2]
if(a||b||c){
ySpace = y
break
}
}
var offsetX = -1, offsetY = -1
for(var x = xSpace; x<3; x++){
offsetX ++
for(var y = ySpace; y<3; y++){
offsetY ++
if(x === xSpace && y === ySpace) continue
arr2.fill(0)
for(var x2 = 0; x2<3; x2++){
for(var y2 = 0; y2<3; y2++){
var b = arr[x2+(y2*3)]
if(b){
var bx = x2 + offsetX
var by = y2 + offsetY
arr2[bx+(by*3)] = b
}
}
}
crafts[arr2.join(",")] = craft2
craftArrays[arr2.join(",")] = arr2.slice()
}
offsetY = -1
}
}
delete crafts[i]
}
win.crafts = crafts
for(let i in craftTypes){
for(let j=0; j<craftTypes[i].length; j++){
craftTypes[i][j] = getBlockId(craftTypes[i][j])
}
}
for(let i in smelts){
smelts[i].id = blockIds[smelts[i].name]
if(blockIds[i]){
smelts[blockIds[i]] = smelts[i]
delete smelts[i]
}
}
for(let i in smeltFuel){
smeltFuel[i].operations = smeltFuel[i].time / 10
smeltFuel[i].ops = smeltFuel[i].operations / smeltFuel[i].time //operations per seconds
if(blockIds[i]){
smeltFuel[blockIds[i]] = smeltFuel[i]
delete smeltFuel[i]
}
}
win.smelts = smelts; win.smeltFuel = smeltFuel
}
const breakTypes = {
plant: "axe",
wood: "axe",
metal1: "pickaxe",
metal2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
metal3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
metal4: ["diamondPickaxe","netheritePickaxe"],
rock1: "pickaxe",
rock2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
rock3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
rock4: ["diamondPickaxe","netheritePickaxe"],
ground: "shovel",
plant2: "hoe",
wool:"air"
}
win.breakTypes = breakTypes
const handBreakable = [
"plant","wood","plant2","ground","wool"
]
win.handBreakable = handBreakable
var allPickaxes = ["woodenPickaxe","stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe","goldenPickaxe"]
var allShovels = ["woodenShovel","stoneShovel","ironShovel","diamondShovel","netheriteShovel","goldenShovel"]
for(var b in breakTypes){
var t = breakTypes[b]
if(t === "pickaxe"){
breakTypes[b] = allPickaxes
}
if(t === "shovel"){
breakTypes[b] = allShovels
}
}
const crafts = {
"oakLog": {name:"oakPlanks", amount:4, shapeless: true},
"acaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
"birchLog": {name:"birchPlanks", amount:4, shapeless: true},
"darkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
"jungleLog": {name:"junglePlanks", amount:4, shapeless: true},
"spruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
"mangroveLog": {name:"mangrovePlanks", amount:4, shapeless:true},
"cherryLog": {name:"cherryPlanks", amount:4, shapeless:true},
"_planks,air,air,_planks": {name:"stick", amount:4, shaped:true},
"oakPlanks,oakPlanks,air,oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"oakDoor", amount:3},
"acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"acaciaDoor", amount:3},
"birchPlanks,birchPlanks,air,birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"birchDoor", amount:3},
"darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks":{name:"darkOakDoor", amount:3},
"junglePlanks,junglePlanks,air,junglePlanks,junglePlanks,air,junglePlanks,junglePlanks":{name:"jungleDoor", amount:3},
"sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks":{name:"spruceDoor", amount:3},
"mangrovePlanks,mangrovePlanks,air,mangrovePlanks,mangrovePlanks,air,mangrovePlanks,mangrovePlanks":{name:"mangroveDoor", amount:3},
"warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks":{name:"warpedDoor", amount:3},
"crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air":{name:"crimsonDoor",amount:3},
"bambooPlanks,bambooPlanks,air,bambooPlanks,bambooPlanks,air,bambooPlanks,bambooPlanks":{name:"bambooDoor", amount:3},
"cherryPlanks,cherryPlanks,air,cherryPlanks,cherryPlanks,air,cherryPlanks,cherryPlanks":{name:"cherryDoor", amount:3},
"ironIngot,ironIngot,air,ironIngot,ironIngot,air,ironIngot,ironIngot,air":{name:"ironDoor",amount:3},
"oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"oakTrapdoor", amount:2},
"birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks":{name:"birchTrapdoor", amount:2},
"darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks":{name:"darkOakTrapdoor", amount:2},
"junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks":{name:"jungleTrapdoor", amount:2},
"sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks":{name:"spruceTrapdoor", amount:2},
"acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks":{name:"acaciaTrapdoor", amount:2},
"mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks":{name:"mangroveTrapdoor", amount:2},
"warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks":{name:"warpedTrapdoor", amount:2},
"crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks":{name:"crimsonTrapdoor", amount:2},
"ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironTrapdoor", amount:2},
"bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks":{name:"bambooTrapdoor", amount:2},
"cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks":{name:"cherryTrapdoor", amount:2},
"redWool,redWool,redWool,_planks,_planks,_planks":{name:"redBed"},
"_planks,_planks,air,_planks,_planks":{name:"craftingTable",shaped:true},
"coal,air,air,stick":{name:"torch",amount:4,shaped:true},
"coal,air,air,stick,air,air,soulSand":{name:"soulTorch",amount:4,shaped:true},
"charcoal,air,air,stick":{name:"torch",amount:4,shaped:true},
"charcoal,air,air,stick,air,air,soulSand":{name:"soulTorch",amount:4,shaped:true},
"coal,coal,coal,coal,coal,coal,coal,coal,coal":{name:"coalBlock"},
"ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironBlock"},
"goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldBlock"},
"diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond":{name:"diamondBlock"},
"lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli":{name:"lapisBlock"},
"emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald":{name:"emeraldBlock"},
"_planks,_planks,_planks,air,stick,air,air,stick":{name:"woodenPickaxe"},
"_stone,_stone,_stone,air,stick,air,air,stick":{name:"stonePickaxe"},
"ironIngot,ironIngot,ironIngot,air,stick,air,air,stick":{name:"ironPickaxe"},
"goldIngot,goldIngot,goldIngot,air,stick,air,air,stick":{name:"goldenPickaxe"},
"diamond,diamond,diamond,air,stick,air,air,stick":{name:"diamondPickaxe"},
"ironIngot,air,air,air,flint": {name:"flintAndSteel"},
"air,_planks,air,air,_planks,air,air,stick": {name:"woodenSword"},
"air,_stone,air,air,_stone,air,air,stick": {name:"stoneSword"},
"air,ironIngot,air,air,ironIngot,air,air,stick": {name:"ironSword"},
"air,goldIngot,air,air,goldIngot,air,air,stick": {name:"goldenSword"},
"air,diamond,air,air,diamond,air,air,stick": {name:"diamondSword"},
"air,air,air,snowBlock,snowBlock,snowBlock": {name:"snow", amount:6},
"snowball,snowball,air,snowball,snowball": {name:"snowBlock"},
"ironIngot,air,ironIngot,air,ironIngot":{name:"bucket"},
"_stone,_stone,_stone,_stone,air,_stone,_stone,_stone,_stone":{name:"furnace"},
"wheat,wheat,wheat":{name:"bread"},
"_planks,air,air,stick,air,air,stick":{name:"woodenShovel"},
"_stone,air,air,stick,air,air,stick":{name:"stoneShovel"},
"ironIngot,air,air,stick,air,air,stick":{name:"ironShovel"},
"goldIngot,air,air,stick,air,air,stick":{name:"goldenShovel"},
"diamond,air,air,stick,air,air,stick":{name:"diamondShovel"},
"_planks,_planks,air,_planks,stick,air,air,stick":{name:"woodenAxe"},
"_stone,_stone,air,_stone,stick,air,air,stick":{name:"stoneAxe"},
"ironIngot,ironIngot,air,ironIngot,stick,air,air,stick":{name:"ironAxe"},
"goldIngot,goldIngot,air,goldIngot,stick,air,air,stick":{name:"goldenAxe"},
"diamond,diamond,air,diamond,stick,air,air,stick":{name:"diamondAxe"},
"birchPlanks,birchPlanks":{name:"birchPressurePlate",shapeless:true},
"oakPlanks,oakPlanks":{name:"oakPressurePlate",shapeless:true},
"junglePlanks,junglePlanks":{name:"junglePressurePlate",shapeless:true},
"sprucePlanks,sprucePlanks":{name:"sprucePressurePlate",shapeless:true},
"darkOakPlanks,darkOakPlanks":{name:"darkOakPressurePlate",shapeless:true},
"acaciaPlanks,acaciaPlanks":{name:"acaciaPressurePlate",shapeless:true},
"mangrovePlanks,mangrovePlanks":{name:"mangrovePressurePlate",shapeless:true},
"warpedPlanks,warpedPlanks":{name:"warpedPressurePlate",shapeless:true},
"crimsonPlanks,crimsonPlanks":{name:"crimsonPressurePlate",shapeless:true},
"stone,stone":{name:"stonePressurePlate",shapeless:true},
"polishedBlackstone,polishedBlackstone":{name:"polishedBlackstone",shapeless:true},
"goldIngot,goldIngot":{name:"lightWeightedPressurePlate",shapeless:true},
"ironIngot,ironIngot":{name:"heavyWeightedPressurePlate",shapeless:true},
"bambooPlanks,bambooPlanks":{name:"bambooPressurePlate",shapeless:true},
"cherryPlanks,cherryPlanks":{name:"cherryPressurePlate",shapeless:true},
"strippedOakLog": {name:"oakPlanks", amount:4, shapeless: true},
"strippedAcaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
"strippedBirchLog": {name:"birchPlanks", amount:4, shapeless: true},
"strippedDarkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
"strippedJungleLog": {name:"junglePlanks", amount:4, shapeless: true},
"strippedSpruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
"strippedMangroveLog": {name:"mangrovePlanks", amount:4, shapeless: true},
"strippedCherryLog": {name:"cherryPlanks", amount:4, shapeless: true},
"warpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
"crimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
"strippedWarpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
"strippedCrimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
"warpedPlanks,air,air,warpedPlanks": {name:"stick", amount:4},
"crimsonPlanks,air,air,crimsonPlanks": {name:"stick", amount:4},
"stone":{name:"stoneButton", shapeless: true},
"oakPlanks":{name:"oakButton", shapeless: true},
"birchPlanks":{name:"birchButton", shapeless: true},
"darkOakPlanks":{name:"darkOakButton", shapeless: true},
"acaciaPlanks":{name:"acaciaButton", shapeless: true},
"sprucePlanks":{name:"spruceButton", shapeless: true},
"junglePlanks":{name:"jungleButton", shapeless: true},
"mangrovePlanks":{name:"mangroveButton", shapeless: true},
"warpedPlanks":{name:"warpedButton", shapeless: true},
"crimsonPlanks":{name:"crimsonButton", shapeless: true},
"polishedBlackstone":{name:"polishedBlackstoneButton", shapeless:true},
"bambooPlanks":{name:"bambooButton", shapeless: true},
"cherryPlanks":{name:"cherryButton", shapeless: true},
"ironBlock": {name:"ironIngot",amount:9,shapeless:true},
"goldBlock": {name:"goldIngot",amount:9,shapeless:true},
"coalBlock": {name:"coal",amount:9,shapeless:true},
"emeraldBlock": {name:"emerald",amount:9,shapeless:true},
"diamondBlock": {name:"diamond",amount:9,shapeless:true},
"copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot":{name:"copperBlock"},
"copperBlock": {name:"copperIngot",amount:9,shapeless:true},
"_planks,_planks,air,air,stick,air,air,stick":{name:"woodenHoe"},
"_stone,_stone,air,air,stick,air,air,stick":{name:"stoneHoe"},
"ironIngot,ironIngot,air,air,stick,air,air,stick":{name:"ironHoe"},
"goldIngot,goldIngot,air,air,stick,air,air,stick":{name:"goldenHoe"},
"diamond,diamond,air,air,stick,air,air,stick":{name:"diamondHoe"},
"rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron":{name:"rawIronBlock"},
"rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold":{name:"rawGoldBlock"},
"rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper":{name:"rawCopperBlock"},
"rawIronBlock":{name:"rawIron",amount:9,shapeless:true},
"rawGoldBlock":{name:"rawGold",amount:9,shapeless:true},
"rawCopperBlock":{name:"rawCopper",amount:9,shapeless:true},
"netheriteScrap,netheriteScrap,netheriteScrap,netheriteScrap,goldIngot,goldIngot,goldIngot,goldIngot":{name:"netheriteIngot"},
"netheriteIngot,netheriteIngot,netheriteIngot,air,stick,air,air,stick":{name:"netheritePickaxe"},
"netheriteIngot,air,air,netheriteIngot,air,air,stick":{name:"netheriteSword"},
"netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteShovel"},
"netheriteIngot,netheriteIngot,air,netheriteIngot,stick,air,air,stick":{name:"netheriteAxe"},
"netheriteIngot,netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteHoe"},
"netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot":{name:"netheriteBlock"},
"netheriteBlock":{name:"netheriteIngot",amount:9,shapeless:true},
"wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat":{name:"hayBlock"},
"hayBlock":{name:"wheat",amount:9,shapeless:true},
"ironIngot":{name:"ironNugget",amount:9,shapeless:true},
"goldIngot":{name:"goldNugget",amount:9,shapeless:true},
"ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget":{name:"ironIngot"},
"goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget":{name:"goldIngot"},
"ironNugget,ironNugget,ironNugget,ironNugget,torch,ironNugget,ironNugget,ironNugget,ironNugget":{name:"lantern"},
"stick,air,stick,stick,stick,stick,stick,air,stick":{name:"ladder",amount:3},
"ironNugget,air,air,ironIngot,air,air,ironNugget":{name:"chain"},
"stone,stone,air,stone,stone":{name:"stoneBricks",amount:4},
"stoneBricks,vine":{name:"mossyStoneBricks",shapeless:true},
"cobblestone,vine":{name:"mossyCobble",shapeless:true},
"chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,netheriteIngot,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks":{name:"lodestone"},
"_planks,_planks,_planks,_planks,redstone,_planks,_planks,_planks,_planks":{name:"noteBlock"},
"_planks,_planks,_planks,_planks,diamond,_planks,_planks,_planks,_planks":{name:"jukebox"},
"ironIngot,ironIngot,ironIngot,ironIngot,furnace,ironIngot,smoothStone,smoothStone,smoothStone":{name:"blastFurnace"},
"air,_log,air,_log,furnace,_log,air,_log":{name:"smoker"},
"carvedPumpkin,torch":{name:"jackOLantern",shapeless:true},
"air,ironIngot,air,ironIngot":{name:"shears"},
"melonSlice":{name:"melonSeeds",shapeless:true},
"melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice":{name:"melon"},
"redstone,redstone,redstone,redstone,redstone,redstone,redstone,redstone,redstone":{name:"redstoneBlock"},
"redstoneBlock":{name:"redstone",amount:9,shapeless:true},
"air,redstone,air,redstone,glowstone,redstone,air,redstone":{name:"redstoneLamp"},
"glowstoneDust,glowstoneDust,air,glowstoneDust,glowstoneDust":{name:"glowstone"},
"cobblestone,quartz,air,quartz,cobblestone":{name:"diorite",amount:2,shaped:true},
"diorite,diorite,air,diorite,diorite":{name:"polishedDiorite",amount:4,shaped:true},
"cobblestone,diorite":{name:"andesite",amount:2,shapeless:true},
"andesite,andesite,air,andesite,andesite":{name:"polishedAndesite",amount:4,shaped:true},
"diorite,quartz":{name:"granite",shapeless:true},
"granite,granite,air,granite,granite":{name:"polishedGranite",amount:4,shaped:true},
"amethystShard,air,air,copperIngot,air,air,copperIngot":{name:"spyglass",shaped:true},
"_planks,air,_planks,air,_planks":{name:"bowl",amount:4,shaped:true},
"redMushroom,brownMushroom,bowl":{name:"mushroomStew",shapeless:true},
"egg,noodles,wheatSeeds,bowl":{name:"ramen",shapeless:true},
"wheat,egg,wheat":{name:"noodles",shaped:true},
"endStone,endStone,air,endStone,endStone":{name:"endStoneBricks",amount:4,shaped:true},
"dirt,gravel,air,gravel,dirt":{name:"coarseDirt",amount:4,shaped:true},
"itemFrame,glowInkSac":{name:"glowItemFrame",shapeless:true},
"copperBlock,copperBlock,air,copperBlock,copperBlock":{name:"cutCopper",amount:4,shaped:true},
"air,stick,air,stick,coal,stick,_log,_log,_log":{name:"campfire"},
"air,stick,air,stick,soulSand,stick,_log,_log,_log":{name:"soulCampfire"},
"_planks,_planks,_planks,_planks,air,_planks,_planks,_planks,_planks":{name:"chest"},
"clayBall,clayBall,air,clayBall,clayBall":{name:"clay",shaped:true},
"brick,brick,air,brick,brick":{name:"bricks",shaped:true},
"brick,air,brick,air,brick":{name:"flowerPot",shaped:true},
"air,amethystShard,air,amethystShard,glass,amethystShard,air,amethystShard":{name:"tintedGlass",amount:2},
"redstone,air,air,stick":{name:"redstoneTorch",shaped:true},
"stick,air,air,_stone":{name:"lever",shaped:true},
"_planks,_planks,_planks,_stone,ironIngot,_stone,_stone,redstone,_stone":{name:"piston"},
"_stone,_stone,_stone,redstone,redstone,quartz,_stone,_stone,_stone":{name:"observer"},
"string,string,air,string,string": {name:"whiteWool"},
"poppy": {name:"redDye", shapeless: true},
"redTulip": {name:"redDye", shapeless: true},
"roseBush": {name:"redDye", shapeless: true,amount:2},
"sunflower": {name:"yellowDye", shapeless: true,amount:2},
"dandelion": {name:"yellowDye", shapeless: true},
"boneMeal":{name:"whiteDye",shapeless:true},
"lilyOftheValley":{name:"whiteDye",shapeless:true},
"azureBluet":{name:"lightGrayDye",shapeless:true},
"oxeyeDaisy":{name:"lightGrayDye",shapeless:true},
"whiteTulip":{name:"lightGrayDye",shapeless:true},
"whiteDye,whiteDye,blackDye":{name:"lightGrayDye",amount:3,shapeless:true},
"grayDye,whiteDye":{name:"lightGrayDye",amount:2,shapeless:true},
"blackDye,whiteDye":{name:"grayDye",amount:2,shapeless:true},
"witherRose":{name:"blackDye",shapeless:true},
"inkSac":{name:"blackDye",shapeless:true},
"redDye,yellowDye":{name:"orangeDye",amount:2,shapeless:true},
"orangeTulip":{name:"orangeDye",shapeless:true},
"greenDye,whiteDye":{name:"limeDye",amount:2,shapeless:true},
"blueOrchid":{name:"lightBlueDye",shapeless:true},
"whiteDye,blueDye":{name:"lightBlueDye",amount:2,shapeless:true},
"blueDye,greenDye":{name:"cyanDye",amount:2,shapeless:true},
"lapisLazuli":{name:"blueDye",shapeless:true},
"cornFlower":{name:"blueDye",shapeless:true},
"redDye,blueDye":{name:"purpleDye",amount:2,shapeless:true},
"purpleDye,pinkDye":{name:"magentaDye",amount:2,shapeless:true},
"redDye,blueDye,whiteDye":{name:"magentaDye",amount:3,shapeless:true},
"redDye,blueDye,pinkDye":{name:"magentaDye",amount:3,shapeless:true},
"allium":{name:"magentaDye",shapeless:true},
"lilac":{name:"magentaDye",amount:2,shapeless:true},
"redDye,whiteDye":{name:"pinkDye",amount:2,shapeless:true},
"pinkTulip":{name:"pinkDye",shapeless:true},
"peony":{name:"pinkDye",amount:2,shapeless:true},
"pinkPetals":{name:"pinkDye",shapeless:true},
"wheat,wheat,air,wheat,wheat":{name:"thatch",shaped:true},
"mud,mangroveRoots":{name:"muddyMangroveRoots",shapeless:true},
"mud,wheat":{name:"packedMud",shapeless:true},
"packedMud,packedMud,air,packedMud,packedMud":{name:"mudBricks",shaped:true},
"pointedDripstone,pointedDripstone,air,pointedDripstone,pointedDripstone":{name:"dripstoneBlock",shaped:true},
"oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,air,stick":{name:"oakSign",amount:3},
"birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,air,stick":{name:"birchSign",amount:3},
"acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,air,stick":{name:"acaciaSign",amount:3},
"junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,air,stick":{name:"jungleSign",amount:3},
"sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,air,stick":{name:"spruceSign",amount:3},
"darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,air,stick":{name:"darkOakSign",amount:3},
"mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,mangrovePlanks,air,stick":{name:"mangroveSign",amount:3},
"warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,air,stick":{name:"warpedSign",amount:3},
"crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,air,stick":{name:"crimsonSign",amount:3},
"bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,bambooPlanks,air,stick":{name:"bambooSign",amount:3},
"cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,cherryPlanks,air,stick":{name:"cherrySign",amount:3},
"_planksSlabs,air,_planksSlabs,_planksSlabs,air,_planksSlabs,_planksSlabs,_planksSlabs,_planksSlabs":{name:"composter"},
"cocoaBeans":{name:"brownDye",shapeless:true},
"wheat,cocoaBeans,wheat":{name:"cookie",shapeless:true,amount:8},
"pumpkin,sugar,egg":{name:"pumpkinPie",shapeless:true},
"beetroot":{name:"redDye",shapeless:true},
"beetroot,beetroot,beetroot,beetroot,beetroot,beetroot,air,bowl":{name:"beetrootSoup"},
"goldNugget,goldNugget,goldNugget,goldNugget,carrot,goldNugget,goldNugget,goldNugget,goldNugget":{name:"goldenCarrot"},
"cookedRabbit,carrot,bakedPotato,redMushroom,bowl":{name:"rabbitStew",shapeless:true},
"cookedRabbit,carrot,bakedPotato,brownMushroom,bowl":{name:"rabbitStew",shapeless:true},
"goldIngot,goldIngot,goldIngot,goldIngot,apple,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldenApple"},
"dirt,waterBucket":{name:"mud",shapeless:true,replace:{waterBucket:"bucket"}},
"waterBucket,air,air,lavaBucket":{name:"obsidian",shaped:true,replace:{waterBucket:"bucket",lavaBucket:"bucket"}},
"waterBucket,lavaBucket":{name:"cobblestone",shapeless:true,replace:{waterBucket:"bucket",lavaBucket:"bucket"}},
"carrot,dirt,mud":{name:"mudPie",shapeless:true},
"ironBlock,ironBlock,ironBlock,air,ironIngot,air,ironIngot,ironIngot,ironIngot":{name:"anvil"},
"air,stick,string,stick,air,string,air,stick,string":{name:"bow"},
"redstoneLamp,redDye":{name:"redRedstoneLamp",shapeless:true},
"redstoneLamp,yellowDye":{name:"yellowRedstoneLamp",shapeless:true},
"redstoneLamp,greenDye":{name:"greenRedstoneLamp",shapeless:true},
"redstoneLamp,blueDye":{name:"blueRedstoneLamp",shapeless:true},
"goldNugget,goldNugget,goldNugget,goldNugget,melonSlice,goldNugget,goldNugget,goldNugget,goldNugget":{name:"glisteringMelonSlice"},
"lightGrayWool,lightGrayWool,lightGrayWool,_planks,_planks,_planks":{name:"lightGrayBed"},
"lightBlueWool,lightBlueWool,lightBlueWool,_planks,_planks,_planks":{name:"lightBlueBed"},
"magentaWool,magentaWool,magentaWool,_planks,_planks,_planks":{name:"magentaBed"},
"yellowWool,yellowWool,yellowWool,_planks,_planks,_planks":{name:"yellowBed"},
"purpleWool,purpleWool,purpleWool,_planks,_planks,_planks":{name:"purpleBed"},
"orangeWool,orangeWool,orangeWool,_planks,_planks,_planks":{name:"orangeBed"},
"whiteWool,whiteWool,whiteWool,_planks,_planks,_planks":{name:"whiteBed"},
"greenWool,greenWool,greenWool,_planks,_planks,_planks":{name:"greenBed"},
"brownWool,brownWool,brownWool,_planks,_planks,_planks":{name:"brownBed"},
"blackWool,blackWool,blackWool,_planks,_planks,_planks":{name:"blackBed"},
"pinkWool,pinkWool,pinkWool,_planks,_planks,_planks":{name:"pinkBed"},
"limeWool,limeWool,limeWool,_planks,_planks,_planks":{name:"limeBed"},
"grayWool,grayWool,grayWool,_planks,_planks,_planks":{name:"grayBed"},
"cyanWool,cyanWool,cyanWool,_planks,_planks,_planks":{name:"cyanBed"},
"blueWool,blueWool,blueWool,_planks,_planks,_planks":{name:"blueBed"},
"oakPlanks,air,air,oakPlanks,oakPlanks,air,stick,stick":{name:"oakChair",shaped:true},
"acaciaPlanks,air,air,acaciaPlanks,acaciaPlanks,air,stick,stick":{name:"acaciaChair",shaped:true},
"birchPlanks,air,air,birchPlanks,birchPlanks,air,stick,stick":{name:"birchChair",shaped:true},
"junglePlanks,air,air,junglePlanks,junglePlanks,air,stick,stick":{name:"jungleChair",shaped:true},
"sprucePlanks,air,air,sprucePlanks,sprucePlanks,air,stick,stick":{name:"spruceChair",shaped:true},
"darkOakPlanks,air,air,darkOakPlanks,darkOakPlanks,air,stick,stick":{name:"darkOakChair",shaped:true},
"mangrovePlanks,air,air,mangrovePlanks,mangrovePlanks,air,stick,stick":{name:"mangroveChair",shaped:true},
"warpedPlanks,air,air,warpedPlanks,warpedPlanks,air,stick,stick":{name:"warpedChair",shaped:true},
"crimsonPlanks,air,air,crimsonPlanks,crimsonPlanks,air,stick,stick":{name:"crimsonChair",shaped:true},
"blackWool,air,air,blackWool,blackWool,air,stick,stick":{name:"blackChair",shaped:true},
"cherryPlanks,air,air,cherryPlanks,cherryPlanks,air,stick,stick":{name:"cherryChair",shaped:true},
"bambooPlanks,air,air,bambooPlanks,bambooPlanks,air,stick,stick":{name:"bambooChair",shaped:true},
"_stone,_stone,_stone,_stone,air,_stone,_stone,redstone,_stone":{name:"dropper"},
"_stone,_stone,_stone,_stone,bow,_stone,_stone,redstone,_stone":{name:"dispenser"},
"ironIngot,air,ironIngot,ironIngot,chest,ironIngot,air,ironIngot":{name:"hopper"},
"air,redstone,air,redstone,hayBlock,redstone,air,redstone":{name:"target"},
"air,redstoneTorch,air,redstoneTorch,quartz,redstoneTorch,stone,stone,stone":{name:"comparator"},
"redstone,lapisLazuli,redstone":{name:"blueRedstone",amount:2,shaped:true},
"gunpowder,sand,gunpowder,sand,gunpowder,sand,gunpowder,sand,gunpowder":{name:"tnt"},
"gunpowder,redSand,gunpowder,redSand,gunpowder,redSand,gunpowder,redSand,gunpowder":{name:"tnt"},
"flint,air,air,stick,air,air,feather":{name:"arrow",shaped:true,amount:4},
"redstoneTorch,redstone,redstoneTorch,stone,stone,stone":{name:"repeater"},
"bone":{name:"boneMeal",amount:3,shapeless:true},
"glass,glass,glass,quartz,quartz,quartz,_planks,_planks,_planks":{name:"daylightDetector",amount:3},
"blazeRod":{name:"blazePowder",amount:2,shapeless:true},
"ice,ice,ice,ice,ice,ice,ice,ice,ice":{name:"packedIce"},
"packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce,packedIce":{name:"blueIce"},
"blazePowder,enderPearl":{name:"eyeOfEnder"},
"bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk,bambooStalk":{name:"bambooBlock"},
"bambooBlock":{name:"bambooPlanks",amount:2,shapeless:true},
"strippedBambooBlock":{name:"bambooPlanks",amount:2,shapeless:true},
"waterBucket,sand":{name:"quicksand",shapeless:true,replace:{waterBucket:"bucket"}},
"glass,glass,glass,glass,glass,glass":{name:"glassPane",shaped:true,amount:48},
"ironIngot,air,ironIngot,ironIngot,ironIngot,ironIngot":{name:"minecart",shaped:true},
"ironIngot,air,ironIngot,ironIngot,stick,ironIngot,ironIngot,air,ironIngot":{name:"rail",amount:16},
"goldIngot,air,goldIngot,goldIngot,stick,goldIngot,goldIngot,redstone,goldIngot":{name:"poweredRail",amount:16},
"corn,bowl":{name:"popcornBowl",shapeless:true}
}
for (let i = 1; i < BLOCK_COUNT; ++i){
const block = blockData[i]
if(block.craftSlabs){
crafts[block.name+","+block.name+","+block.name] = {name:block.name+"|SLAB",amount:6,shaped:true}
}
if(block.craftStairs){
crafts[block.name+",air,air,"+block.name+","+block.name+",air,"+block.name+","+block.name+","+block.name] = {name:block.name+"|STAIR",amount:4}
}
if(block.name.endsWith("Wool")){
let c = block.name.replace("Wool","")
crafts[block.name+","+block.name] = {name:c+"Carpet",shaped:true,amount:32}
}else if(block.name.endsWith("Dye")){
let c = block.name.replace("Dye","")
crafts["whiteWool,"+block.name] = {name:c+"Wool",shapeless:true}
crafts["terracotta,terracotta,terracotta,terracotta,"+block.name+",terracotta,terracotta,terracotta,terracotta"] = {name:c+"Terracotta", amount:8, shapeless:true}
crafts["glass,glass,glass,glass,"+block.name+",glass,glass,glass,glass"] = {name:c+"StainedGlass", amount:8, shapeless:true}
crafts["glassPane,glassPane,glassPane,glassPane,"+block.name+",glassPane,glassPane,glassPane,glassPane"] = {name:c+"StainedGlassPane", amount:8, shapeless:true}
}else if(block.name.endsWith("StainedGlass")){
crafts[block.name+","+block.name+","+block.name+","+block.name+","+block.name+","+block.name] = {name:block.name+"Pane",shaped:true,amount:48}
}
}
//replace anything in crafts starting with _
const craftTypes = {
_planks: ["oakPlanks","birchPlanks","sprucePlanks","junglePlanks","darkOakPlanks","acaciaPlanks","mangrovePlanks","crimsonPlanks","warpedPlanks","cherryPlanks","bambooPlanks","bambooMosaic"],
_planksSlabs: ["oakPlanks|SLAB","birchPlanks|SLAB","sprucePlanks|SLAB","junglePlanks|SLAB","darkOakPlanks|SLAB","acaciaPlanks|SLAB","mangrovePlanks|SLAB","crimsonPlanks|SLAB","warpedPlanks|SLAB","cherryPlanks|SLAB","bambooPlanks|SLAB","bambooMosaic|SLAB"],
_stone: ["stone","cobblestone","deepslate","cobbledDeepslate","blackstone","limestone"],
_log: ["oakLog","birchLog","spruceLog","jungleLog","darkOakLog","acaciaLog","mangroveLog","crimsonStem","warpedStem","cherryLog","bambooBlock"],
_strippedLog: ["strippedOakLog","strippedBirchLog","strippedSpruceLog","strippedJungleLog","strippedDarkOakLog","strippedAcaciaLog","strippedMangroveLog","strippedCrimsonStem","strippedWarpedStem","strippedCherryLog","strippedBambooBlock"],
}
let smelts = {
rawIron: {name:"ironIngot", time:200, xp:0.7},
rawCopper: {name:"copperIngot", time:200, xp:0.7},
rawGold: {name:"goldIngot", time:200, xp:1},
sand: {name:"glass",time:200,xp:0.1, furnace:true},//furnace propertie means it can only be smelted in furnace
cobblestone: {name:"stone",time:200,xp:0.1, furnace:true},
stone: {name:"smoothStone", time:200, xp:0.1, furnace:true},
stoneBricks: {name:"crackedStoneBricks",time:200,xp:0.1, furnace:true},
clay: {name:"terracotta",time:200,xp:0.35},
clayBall: {name:"brick",time:200,xp:0.3},
ancientDebris: {name:"netheriteScrap", time:200, xp:1},
cactus: {name:"greenDye", time:200, xp:0.1},
rawChicken: {name:"cookedChicken",time:200,xp:0.35},
rawBeef: {name:"cookedBeef",time:200,xp:0.35},
rawCod: {name:"cookedCod",time:200,xp:0.35},
rawMutton: {name:"cookedMutton",time:200,xp:0.35},
rawPorkchop: {name:"cookedPorkchop",time:200,xp:0.35},
rawRabbit: {name:"cookedRabbit",time:200,xp:0.35},
rawSalmon: {name:"cookedSalmon",time:200,xp:0.35},
potato: {name:"cookedPotato",time:200,xp:0.35},
_log: {name:"charcoal",time:200,xp:0.15},
_strippedLog: {name:"charcoal",time:200,xp:0.15}
}
let smeltFuel = { //time is in seconds
_log: {time:15},
_planks: {time:15},
coal: {time:80},
stick: {time:5},
coalBlock: {time:690},
lavaBucket: {time:1000},
blazeRod: {time:120},
charcoal: {time:80},
bambooStalk: {time:2.5}
}
let craftArrays = {}
function checkCraftType(a,b){
return craftTypes[a] && craftTypes[a].includes(b) || a === b
}
function getCraft(craft){
main:for(var i in crafts){
if(crafts[i].shapeless) continue
var arr = craftArrays[i]
for(var j=0; j<arr.length; j++){
if(!checkCraftType(arr[j], craft[j])) continue main
}
return i
}
}
function shapelessCraft(craft) {
/*let arr2 = craft;
arr2.sort(function(a, b) {
return a - b;
});
let arr = [];
for(let i in crafts) {
if(!crafts[i].shapeless) continue;
arr = i.split(",");
arr.sort(function(a, b) {
return a - b;
});
let comp = arr.map(num => Number(num));
if(arrayValues(comp,arr2)) {
return i;
}
}*/
main:for(var i in crafts){
if(!crafts[i].shapeless) continue
var arr = craft.slice()
var arr2 = craftArrays[i]
remover:for(var j of arr2){ //remove the ones that exist for this recipe
for(var k=0; k<arr.length; k++){
if(checkCraftType(j,arr[k])){
arr.splice(k,1)
continue remover
}
}
continue main //recipe doesn't have this item
}
if(!arr.length) return i
}
}
function getBlockId(name){
if(typeof name === "number" || name.startsWith("_")) return name
let first = name.indexOf("|")
let id = blockIds[first === -1 ? name : name.substring(0, first)]
if(id===undefined)debugger
if(name.endsWith("|SLAB")) id |= SLAB
if(name.endsWith("|STAIR")) id |= STAIR
return id
}
const achievementTypes = [
//dont change order, because it may cause problems with loading
{
name:"Taking Inventory",
score: 10,
description:"Open your inventory"
},
{
name:"Getting Wood",
score:10,
description:"Punch a tree until a block of wood pops out."
},
{
name:"Benchmaking",
score:10,
description:"Craft a Crafting Table with four blocks of wooden planks."
},
{
name:"Time to Mine!",
score:10,
description:"Use planks and sticks to make a pickaxe."
},
{
name:"Getting an Upgrade",
score:15,
description:"Construct a better pickaxe."
},
{
name:"Bake Bread",
score:15,
description:"Turn wheat into bread."
},
{
name:"Time to Strike!",
score:10,
description:"Use planks and sticks to make a sword."
},
{
name:"DIAMONDS!",
score:20,
description:"Acquire diamonds with your iron tools."
},
{
name:"Diamonds to you!", //how is this possible to code???
score:15,
description:"Throw diamonds at another player."
},
{
name:"Time to Farm!",
score:10,
description:"Make a Hoe."
},
{
name:"Time to plant tomatoes!",
score:10,
description:"Get tomato seeds from Tall Grass."
},
{
name:"Into the Nether",
score:20,
description:"Go into the Nether."
},
{
name:"Hidden In The Depths",
score:20,
description:"Get Ancient Debris"
},
{
name:"Into the End",
score:20,
description:"Go into the End."
},
{
name:"get a hot stick",
score:20,
description:"get a blaze rod"
},
{
name:"Make a bed",
score:10,
description:"Make a bed"
}
]
const achievmentIds = {}
for(let i=0; i<achievementTypes.length; i++){
achievmentIds[achievementTypes[i].name] = i
achievementTypes[i].id = i
}
win.achievmentIds = achievmentIds, win.achievementTypes = achievementTypes
//add something to inventory
function newInvItem(p, id, durability, name){
//look for empty slot
let {inventory} = p
for(let i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i] && inventory.hotbar[i].id === id && (!inventory.hotbar[i].customName && !name || inventory.hotbar[i].customName === name) && inventory.hotbar[i].amount < blockData[inventory.hotbar[i].id].stackSize){
inventory.hotbar[i].amount ++
return true
}
}
for(let i=0; i<inventory.main.length; i++){
if(inventory.main[i] && inventory.main[i].id === id && (!inventory.main[i].customName && !name || inventory.main[i].customName === name) && inventory.main[i].amount < blockData[inventory.main[i].id].stackSize){
inventory.main[i].amount ++;
return true
}
}
for(let i=0; i<inventory.hotbar.length; i++){
if(!inventory.hotbar[i]){
inventory.hotbar[i] = {id:id, amount:1, durability:durability, customName:name}
if(i === inventory.hotbarSlot){
inventory.showName = 1.5
}
return true
}
}
for(let i=0; i<inventory.main.length; i++){
if(!inventory.main[i]){
inventory.main[i] = {id:id, durability:durability, customName:name, amount:1}
return true
}
}
return false
}
function minusOneItem(p,id){
let {inventory} = p
for(let i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i] && inventory.hotbar[i].id === id){
if(p.survival){
inventory.hotbar[i].amount--
if(!inventory.hotbar[i].amount) inventory.hotbar[i] = null
}
return true
}
}
for(let i=0; i<inventory.main.length; i++){
if(inventory.main[i] && inventory.main[i].id === id){
if(p.survival){
inventory.main[i].amount--
if(!inventory.main[i].amount) inventory.main[i] = null
}
return true
}
}
return false
}
function hasItem(p,id){
let {inventory} = p
for(let i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i] && inventory.hotbar[i].id === id){
return true
}
}
for(let i=0; i<inventory.main.length; i++){
if(inventory.main[i] && inventory.main[i].id === id){
return true
}
}
return false
}
/*Format for jigsaw
{
data:array, Contains the blocks in the pallete of the jigsaw
pallete:object, Each letter represents a block name
center:string, The place to connect to the previous jigsaw, must be a letter from data
newJigsaws:object, Jigsaws to generate connected to current jigsaw, the key is a letter from data, the value is the name of a jigsaw pool
newJigsawTries:number, optional, Amount of tries to generate a new jigsaw connected to current jigsaw
onGround:boolean, optional,
flatOnGround:boolean, optional
}
*/
let jigsaws = {
endPortal:{
data:[
`sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss`,
`sssssssss
s       s
s sssss s
s sllls s
s sllls s
s sllls s
s sssss s
s  sss  s
s  sss  s
s  ttt  s
s       s
sss   sss
sls   sls
ssss!ssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s  sss  s
s  ttt  s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s  ---  s
s (   ) s
s (   ) s
s (   ) s
s  ___  s
s  ttt  s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
s       s
sssssssss`,
`sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss
sssssssss`,
],
pallete:{
s:"stoneBricks",
"!":"stoneBricks",
"_":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|e:blockIds.endPortalFrame|e,
"-":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|w:blockIds.endPortalFrame|w,
"(":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|s:blockIds.endPortalFrame|s,
")":(n,e,s,w)=>random()>0.75?blockIds.endPortalFrame|SLAB|n:blockIds.endPortalFrame|n,
l:"Lava"," ":"air",
t:(n,e,s,w)=>blockIds.stoneBricks|STAIR|w,
},
center:"!",
}
}
let jigsawPools = {
endPortal:["endPortal"]
}
/*Format for structures
{
type:string, can be simple or compound
start:array, Jigsaw pool to choose starting jigsaw, randomly chosen
chance:number, How common is it every structureSpacing blocks
getY:function, Return y level of starting jigsaw, not needed if all jigsaws are on ground
maxSize:number, Maximum distance for jigsaws to be from starting jigsaw, Also for determining how far to look for structures
If type is compound:
jigsawCount:number, Target amount of jigsaws to generate in structure, actual amount of jigsaws may be lower
maxTries:number, Maximum tries to generate a jigsaw, will stop generating if amount of jigsaw reaches jigsawCount
}
*/
let structures = [
{
type:"simple",
start:"endPortal",
chance:0.5,
maxSize:16,
getY:(x,z,rnd)=>{
return 10+Math.round(rnd%16)
}
}
]
/*Structure notes
Jigsaws can only have a new jigsaw on the sides, not on top, bottom, or inside.
If a block is undefined in pallete, that block will be ignored.
If a jigsaw is onGround, it can not be more than 16 blocks from center to prevent chunk errors
*/
let structureCheckDist = 0
const structureSpacing = 64
for(let s of structures){
structureCheckDist = Math.max(structureCheckDist,s.maxSize)
s.start = jigsawPools[s.start]
}
structureCheckDist = Math.ceil(structureCheckDist/16)*16
for(let jn in jigsaws){
let s = jigsaws[jn]
let ss = Object.create(s)
let se = Object.create(s)
let sw = Object.create(s)
ss.data = [], se.data = [], sw.data = []
if(s.type === "compound"){
s.nextJigsawPos = [], ss.nextJigsawPos = [], se.nextJigsawPos = [], sw.nextJigsawPos = []
s.newJigsaws = s.newJigsaws || {}
}
let data = []
let w=0, h=s.data.length, d=0
for(let i=0;i<s.data.length;i++){
let rows = s.data[i].split("\n")
w = Math.max(w,rows.length)
for(let j=0;j<rows.length;j++){
let row = rows[j]
d = Math.max(d,row.length)
}
}
for(let i=0;i<s.data.length;i++){
let rows = s.data[i].split("\n")
for(let j=0;j<rows.length;j++){
let row = rows[j]
for(let k=0;k<row.length;k++){
if(s.pallete[row[k]]){
data.push(j,i,k,s.pallete[row[k]])
ss.data.push(w-1-j,i,d-1-k,s.pallete[row[k]])
se.data.push(k,i,j,s.pallete[row[k]])
sw.data.push(d-1-k,i,w-1-j,s.pallete[row[k]])
}
if(row[k] === s.center){
s.centerPos = [j,i,k]
ss.centerPos = [w-1-j,i,d-1-k]
se.centerPos = [k,i,j]
sw.centerPos = [d-1-k,i,w-1-j]
}
if(s.type === "compound" && s.newJigsaws[row[k]]){
let newJigsaws = s.newJigsaws[row[k]]
/*if(!Array.isArray(newJigsaws)){
tempJigsawArr[0] = newJigsaws
newJigsaws = tempJigsawArr
}*/
for(let nj of jigsawPools[newJigsaws]){
s.nextJigsawPos.push([j,i,k,nj])
ss.nextJigsawPos.push([w-1-j,i,d-1-k,nj])
se.nextJigsawPos.push([k,i,j,nj])
sw.nextJigsawPos.push([d-1-k,i,w-1-j,nj])
}
}
}
}
}
s.data = data
s.w = w, s.h = h, s.d = d
ss.w = w, ss.h = h, ss.d = d
se.w = d, se.h = h, se.d = w
sw.w = d, sw.h = h, sw.d = w
s.variants = [s,sw,ss,se]
if(s.type === "compound") s.newJigsawTries = s.nextJigsawPos.length ? (s.newJigsawTries === undefined ? 1 : s.newJigsawTries) : 0
}
function objectify(x, y, z, width, height, textureX, textureY, texXFlip,texYFlip,rotateTex,texW,texH,textureName) {
return {
x: x,
y: y,
z: z,
w: width,
h: height,
tx: textureX,
ty: textureY,
txf: texXFlip,
tyf: texYFlip,
rt:rotateTex,
tw:texW || width,
th:texH || height,
t:textureName
}
}
function customFace(x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th, t){
tw = tw || 16
th = th || 16
return {
x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th,
t,
custom:true
}
}
function generateItemShape(){
var arr = []
var bottom = [],
top = [],
east = [],
west = []
var i
for(i=0; i<16; i++){
bottom.push(objectify(0,i,7.5,16,1,0,(16-i)-1))
top.push(objectify(0,i+1,8.5,16,1,0,16-i-1))
east.push(objectify(i+1,16,7.5,1,16,(16-i)-1,0))
west.push(objectify(i,16,8.5,1,16,(16-i)-1,0))
}
return [bottom,top,
[objectify(16, 16, 8.5, 16, 16, 0, 0, true)],[objectify( 0, 16,  7.5, 16, 16, 0, 0)],
east,west]
}
function layerShape(h){
return [
[objectify(0,0,0,16,16,0,0)],
[objectify(0,h,16,16,16,0,0)],
[objectify(16, h, 16, 16, h, 0, 16-h)],
[objectify( 0, h,  0, 16, h, 0, 16-h)],
[objectify(16, h,  0, 16, h, 0, 16-h)],
[objectify( 0, h, 16, 16, h, 0, 16-h)]
]
}
function liquidLayerShape(h){
return [
[objectify(0,0,0,16,16,0,0),objectify(16,0,0,-16,16,16,0, false,false,false,null,null, "in")],
[objectify(0,h,16,16,16,0,0),objectify(16,h,16,-16,16,16,0, false,false,false,null,null, "in")],
[objectify(16, h, 16, 16, h, 0, 16-h),objectify( 0, h, 16, -16, h, 16, 16-h, false,false,false,null,null, "in")],
[objectify( 0, h,  0, 16, h, 0, 16-h),objectify(16, h,  0, -16, h, 16, 16-h, false,false,false,null,null, "in")],
[objectify(16, h,  0, 16, h, 0, 16-h),objectify(16, h, 16, -16, h, 16, 16-h, false,false,false,null,null, "in")],
[objectify( 0, h, 16, 16, h, 0, 16-h),objectify( 0, h,  0, -16, h, 16, 16-h, false,false,false,null,null, "in")]
]
}
function generateRepeater(delay = 1, on = false){
on = on ? 16 : 0
let torch = on ? "redstoneTorch" : "redstoneTorchOff"
let arr = [
[objectify(0,0,0,16,16,0,0,false,false,null,null,null,"smoothStone")],
[objectify(0,2,16,16,16,on,0),objectify(7,7,14,2,2,7,6,false,false,null,null,null,torch),objectify(7,7,12 - delay*2,2,2,7,6,false,false,null,null,null,torch)], //top
[objectify(16,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,7,14,2,5,7,6,false,false,null,null,null,torch),objectify(9,7,12 - delay*2,2,5,7,6,false,false,null,null,null,torch)], //north
[objectify(0,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,7,12,2,5,7,6,false,false,null,null,null,torch),objectify(7,7,10 - delay*2,2,5,7,6,false,false,null,null,null,torch)],  //south
[objectify(16,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,7,12,2,5,7,6,false,false,null,null,null,torch),objectify(9,7,10 - delay*2,2,5,7,6,false,false,null,null,null,torch)], //east
[objectify(0,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,7,14,2,5,7,6,false,false,null,null,null,torch),objectify(7,7,12 - delay*2,2,5,7,6,false,false,null,null,null,torch)] //west
]
if(on){
arr[0].push(objectify(6,7,9 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(6,5,13 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(10,8,10 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(6,8,12 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(7,8,9 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(9,8,13 - delay*2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[0].push(objectify(6,7,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(6,5,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(10,8,12,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(6,8,14,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(7,8,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(9,8,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
}
return arr
}
function generateComparator(subtractMode,on){
on = on ? 16 : 0
let subtractModeUp = subtractMode ? 1 : 0
let torchSubtract = subtractMode ? "redstoneTorch" : "redstoneTorchOff"
let torch = on ? "redstoneTorch" : "redstoneTorchOff"
let arr = [
[objectify(0,0,0,16,16,0,0,false,false,null,null,null,"smoothStone")],
[objectify(0,2,16,16,16,on,0),objectify(7,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,5,2,2,7,6,false,false,null,null,null,torch),objectify(10,7,5,2,2,7,6,false,false,null,null,null,torch)],
[objectify(16,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(6,7,5,2,5,7,6,false,false,null,null,null,torch),objectify(12,7,5,2,5,7,6,false,false,null,null,null,torch)],
[objectify(0,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,4+subtractModeUp,12,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,3,2,5,7,6,false,false,null,null,null,torch),objectify(10,7,3,2,5,7,6,false,false,null,null,null,torch)],
[objectify(16,2,0,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(9,4+subtractModeUp,12,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(6,7,3,2,5,7,6,false,false,null,null,null,torch),objectify(12,7,3,2,5,7,6,false,false,null,null,null,torch)],
[objectify(0,2,16,16,2,0,14,false,false,null,null,null,"smoothStone"),objectify(7,4+subtractModeUp,14,2,2,7,6,false,false,null,null,null,torchSubtract),objectify(4,7,5,2,5,7,6,false,false,null,null,null,torch),objectify(10,7,5,2,5,7,6,false,false,null,null,null,torch)]
]
if(subtractMode){
arr[0].push(objectify(6,5,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(6,3,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(10,6,12,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(6,6,14,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(7,6,11,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(9,6,15,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
}
if(on){
arr[0].push(objectify(3,7,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(3,5,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(7,8,3,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(3,8,5,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(4,8,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(6,8,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[0].push(objectify(9,7,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[1].push(objectify(9,5,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[2].push(objectify(13,8,3,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[3].push(objectify(9,8,5,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[4].push(objectify(10,8,2,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
arr[5].push(objectify(12,8,6,4,4,6,5,false,false,null,null,null,"redstoneTorch"))
}
return arr
}
function generateRectangleShape(w,h,name){
const offsetX = -w*8
let arr = []
for(let x=0; x<w; x++) for(let y=0; y<h; y++){
if(!textures[name]) continue
let t = name+(x+y*w)
let tex = textureCoords[textureMap[t]]
arr.push(objectify(x*16+offsetX,y*16,8,16,16,0,0,false,false,false,null,null,t))
}
return[[],[],arr,[],[],[]]
}
function generateSpike(verts,x,y,z,tilt,h,t){
verts[2].push(customFace(2+x,y+h,2+tilt+z, 10+x,y+h,2+tilt+z, 10+x,y,4+z, 2+x,y,4+z, 8,0,8,16,t))
verts[3].push(customFace(14+x,y+h,2+tilt+z, 6+x,y+h,2+tilt+z, 6+x,y,0+z, 14+x,y,0+z, 8,0,8,16,t))
verts[4].push(customFace(8+x,y+h,-4+tilt+z, 8+x,y+h,4+tilt+z, 6+x,y,4+z, 6+x,y,-4+z, 8,0,8,16,t))
verts[5].push(customFace(8+x,y+h,6+tilt+z, 8+x,y+h,tilt+z, 10+x,y,0+z, 10+x,y,8+z, 8,0,8,16,t))
}
function addStem1x1(verts,x,z,h){
verts[2].push(customFace(x,h,z, x+1,h,z+1, x+1,0,z+1, x,0,z, 0,4,1,h))
verts[3].push(customFace(x+1,h,z, x,h,z+1, x,0,z+1, x+1,0,z, 0,4,1,h))
verts[4].push(customFace(x+1,h,z+1, x,h,z, x,0,z, x+1,0,z+1, 0,4,1,h))
verts[5].push(customFace(x,h,z+1, x+1,h,z, x+1,0,z, x,0,z+1, 0,4,1,h))
return verts
}
let shapes = {
/*
[
[(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
[(-x, +z), (+x, +z), (+x, -z), (-x, -z)], // minX = 9,  minZ = 10, maxX = 3, maxZ = 4
[(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
[(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
[(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
[(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
]
*/
cube: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
],
},
rotate: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
],
rotate: true
},
flipped:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0, false,true)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0, false,true)], //south
[objectify(16, 16,  0, 16, 16, 0, 0, false,true)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0, false,true)]  //west
]
},
SW:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0, false,false, 2)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0, false,false, 1)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0, false,false, -1)]  //west
],
rotate:true
},
_1PixLower:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 15, 16, 16, 16, 0, 0)], //top
[objectify(16, 15, 16, 16, 15, 0, 1)], //north
[objectify( 0, 15,  0, 16, 15, 0, 1)], //south
[objectify(16, 15,  0, 16, 15, 0, 1)], //east
[objectify( 0, 15, 16, 16, 15, 0, 1)]  //west
],
},
none: {
verts: [[],[],[],[],[],[]],
hitbox:"cube"
},
slab: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
[objectify(16, 8, 16, 16, 8, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0)], //south
[objectify(16, 8,  0, 16, 8, 0, 0)], //east
[objectify( 0, 8, 16, 16, 8, 0, 0)]  //west
],
flip: true
},
verticalSlab:{
verts:[
[objectify(0,0,8,16,8,0,0)],
[objectify(0,16,16,16,8,0,0)],
[objectify(16,16,16,16,16,0,0)],
[objectify(0,16,8,16,16,0,0)],
[objectify(16,16,8,8,16,0,0)],
[objectify(0,16,16,8,16,0,0)]
],
rotate: true
},
stair: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8,  8, 16, 8, 0, 8), objectify( 0, 16,  16, 16, 8, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 16, 8, 0, 0)], //south
[objectify(16, 8, 0, 8, 8, 8, 0), objectify(16, 16, 8, 8, 16, 0, 0)], //east
[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
],
flip: true,
rotate: true
},
stairCornerOut: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8,  16, 16, 16, 0, 0), objectify( 0, 16,  16, 8, 8, 0, 0)], //top
[objectify(8, 16, 16, 8, 8, 0, 0), objectify(16, 8, 16, 16, 8, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 8, 8, 0, 0)], //south
[objectify(16, 8, 0, 16, 8, 0, 0), objectify(8, 8, 8, 8, 16, 0, 0)], //east
[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
],
flip: true,
rotate: true
},
stairCornerIn: {
verts: [
[objectify(0,0,0,16,16,0,0)],
[objectify(8,8,8,8,8,0,0),objectify(0,16,16,16,8,0,0),objectify(0,16,8,8,8,0,0)],
[objectify(16,16,16,16,16,0,0)],
[objectify(8,16,8,8,8,0,0),objectify(0,16,0,8,8,0,0),objectify(0,8,0,16,8,0,0)],
[objectify(8,16,0,8,8,0,0),objectify(16,16,8,8,8,0,0),objectify(16,8,0,16,8,0,0)],
[objectify(0,16,16,16,16,0,0)]
],
flip: true,
rotate: true
},
cross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,0)]  //west
],
hitbox: "cube"
},
sideCross: {
verts: [
[], //bottom
[], //top
[customFace(2,2,16, 14,14,16, 14,14,0, 2,2,0, 0,16,16,-16)], //north
[customFace(14,2,16, 2,14,16, 2,14,0, 14,2,0, 0,16,16,-16)], //south
[customFace(14,14,16, 2,2,16, 2,2,0, 14,14,0, 0,16,16,-16)], //east
[customFace(2,14,16, 14,2,16, 14,2,0, 2,14,0, 0,16,16,-16)]  //west
],
rotate: true,
hitbox: "cube"
},
bottomCross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,16,16,-16)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,16,16,-16)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,16,16,-16)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,16,16,-16)]  //west
],
size: 6,
hitbox: "cube"
},
tallCross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
],
hitbox:"tallCube"
},
door: {
verts: [
[objectify( 0,  0,  0, 16, 3, 16, 0, false,false,false,null,2)], //bottom
[objectify( 0, 16, 3, 16, 3, 16, 0),objectify( 0, 32, 3, 16, 3, 0, 0, false,false,false,null,2)], //top
[objectify(16, 16, 3, 16, 16, 16, 0),objectify(16, 32, 3, 16, 16, 0, 0)], //north
[objectify(0, 32, 0, 16, 16, 0, 0, true),objectify(0, 16, 0, 16, 16, 16, 0, true)], //south
[objectify(16, 16,  0, 3, 16, 16, 0, false,false,false,2),objectify(16, 32,  0, 3, 16, 0, 0, false,false,false,2)], //east
[objectify( 0, 16, 3, 3, 16, 16, 0, false,false,false,2),objectify( 0, 32, 3, 3, 16, 0, 0, false,false,false,2)]  //west
],
rotate: true
},
torchHitbox:{
verts:[
[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
[objectify(9, 10, 9, 2, 10, 7, 6)], //north
[objectify( 7, 10,  7, 2, 10, 7, 6)], //south
[objectify(9, 10,  7, 2, 10, 7, 6)], //east
[objectify( 7, 10, 9, 2, 10, 7, 6)]  //west
],
},
torch: {
verts: [
[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
[objectify(16, 16, 9, 16, 16, 0, 0)], //north
[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
[objectify(9, 16,  0, 16, 16, 0, 0)], //east
[objectify( 7, 16, 16, 16, 16, 0, 0)]  //west
],
hitbox:"torchHitbox"
},
wallTorch: {
verts: [
[customFace(9,4,17, 7,4,17, 7,3,15, 9,3,15, 7,14,2,2)],
[customFace(9,13,11, 7,13,11, 7,14,13, 9,14,13, 7,6,2,2)],
[customFace(16,20,10.6, 0,20,10.6, 0,4,17, 16,4,17, 0,0,16,16)], //north
[customFace(0,19,8.6, 16,19,8.6, 16,3,15, 0,3,15, 0,0,16,16)], //south
[customFace(9,15.5,1.6, 9,23.5,17.6, 9,7.5,24, 9,-0.5,8, 0,0,16,16)], //east
[customFace(7,23.5,17.6, 7,15.5,1.6, 7,-0.5,8, 7,7.5,24, 0,0,16,16)]  //west
],
rotate: true
},
lantern: {
verts: [
[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10)], //north
[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10)], //south
[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2)], //east
[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2)]  //west
],
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
lanternHang: {
verts: [
[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10),objectify(9.5, 16, 8, 3, 3, 11, 2)], //north
[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10),objectify(6.5, 16, 8, 3, 3, 11, 2)], //south
[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2),objectify(8, 14, 6.5, 3, 4, 11, 1)], //east
[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2),objectify(8, 14, 9.5, 3, 4, 11, 1)]  //west
],
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
beacon: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify( 2, 0.001, 2, 12, 12, 0, 0,null,null,null,null,null,"obsidian")], //bottom
[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify( 2, 3, 14, 12, 12, 0, 3,null,null,null,null,null,"obsidian")], //top
[objectify(13, 13, 13, 10, 10, 3, 3),objectify( 16, 16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(14, 3, 14, 12, 3,  0, 3,null,null,null,null,null,"obsidian")], //north
[objectify( 3, 13,  3, 10, 10, 3, 3),objectify( 0,  16,  0,  16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(2,  3, 2,  12, 3,  0, 3,null,null,null,null,null,"obsidian")], //south
[objectify(13, 13,  3, 10, 10, 3, 3),objectify( 16, 16,  0,  16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(14, 3, 2,  12, 3,  0, 3,null,null,null,null,null,"obsidian")], //east
[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, 0, 0,null,null,null,null,null,"glass"),objectify(2,  3, 14, 12, 3,  0, 3,null,null,null,null,null,"obsidian")]  //west
],
size: 6,
},
cactus: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 15, 16, 16, 0, 0)], //north
[objectify( 0, 16,  1, 16, 16, 0, 0)], //south
[objectify(15, 16,  0, 16, 16, 0, 0)], //east
[objectify( 1, 16, 16, 16, 16, 0, 0)]  //west
],
hitbox: "cube"
},
pane: {
verts: [
[objectify( 0,  0,  7, 16, 2, 0, 7)], //bottom
[objectify( 0, 16, 9, 16, 2, 0, 7)], //top
[objectify(16, 16, 9, 16, 16, 0, 0)], //north
[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
[objectify(16, 16, 7, 2, 16, 7, 0)], //east
[objectify(0, 16, 9, 2, 16, 7, 0)]  //west
],
rotate: true
},
horizontalPane: {
verts:[
[objectify(0,7,0,16,16,0,0)],
[objectify(0,9,16,16,16,0,0)],
[objectify(16,9,16,16,2,0,7)],
[objectify(0,9,0,16,2,0,7)],
[objectify(16,9,0,16,2,0,7)],
[objectify(0,9,16,16,2,0,7)]
],
},
portal: {
verts: [
[objectify(0, 0, 7, 16, 2, 0, 0)],
[objectify(0, 16, 9, 16, 2, 0, 0)],
[objectify(16, 16, 9, 16, 16, 0, 0)],
[objectify(0, 16, 7, 16, 16, 0, 0)],
[objectify(16, 16, 7, 2, 16, 0, 0)],
[objectify(0, 16, 9, 2, 16, 0, 0)]
],
rotate: true
},
trapdoor: {
verts: [
[objectify(0, 0, 0, 16, 16, 0, 0)], //bottom
[objectify(0, 3, 16, 16, 16, 0, 0)], //top
[objectify(16, 3, 16, 16, 3, 0, 0)], //north
[objectify(0, 3, 0, 16, 3, 0, 0)], //south
[objectify(16, 3, 0, 16, 3, 0, 0)], //east
[objectify(0, 3, 16, 16, 3, 0, 0)]  //west
],
rotate: true,
flip: true
},
trapdoorOpen: {
verts: [
[objectify(0, 0, 13, 16, 3, 0, 0)], //bottom
[objectify(0, 16, 16, 16, 3, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify(0, 16, 13, 16, 16, 0, 0)], //south
[objectify(16, 16, 13, 3, 16, 0, 0)], //east
[objectify(0, 16, 16, 3, 16, 0, 0)]  //west
],
size: 6,
rotate: true
},
wallFlat: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
[objectify(0, 16, 16, 0, 0, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify(0, 16,  15, 16, 16, 0, 0)], //south
[objectify(0, 0,  0, 0, 0, 0, 0)], //east
[objectify(0, 0, 16, 0, 0, 0, 0)]  //west
],
rotate: true
},
fence: {
verts: [
[objectify(6, 0, 6, 4, 4, 0, 1)], //bottom
[objectify(6, 16, 10, 4, 4, 0, 1)], //top
[objectify(10, 16, 10, 4, 16, 6, 0)], //north
[objectify(6, 16, 6, 4, 16, 6, 0)], //south
[objectify(10, 16, 6, 4, 16, 6, 0)], //east
[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
],
size: 6,
},
wallpost: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4)], //top
[objectify(12, 16, 12, 8, 16, 4, 0)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0)], //east
[objectify(4, 16, 12, 8, 16, 4, 0)]  //west
],
size: 6
},
wall: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 16, 16, 6, 4, 5, 10)], //top
[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 16, 16, 6, 16, 5, 0)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 16, 12, 4, 16, 12, 0)], //east
[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 16, 16, 4, 16, 12, 0)]  //west
],
rotate: true
},
wallu: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 13, 16, 6, 4, 5, 10)], //top
[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 13, 16, 6, 13, 5, 3)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 13, 12, 4, 13, 12, 3)], //east
[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 13, 16, 4, 13, 12, 3)]  //west
],
rotate: true
},
fencq: {
verts: [
[objectify(6, 0, 6, 4, 4, 0, 1),objectify(10, 12, 7, 6, 2, 0, 2),objectify(10, 6, 7, 6, 2, 0, 2)], //bottom
[objectify(6, 16, 10, 4, 4, 0, 1),objectify(10, 15, 9, 6, 2, 0, 2),objectify(10, 9, 9, 6, 2, 0, 2)], //top
[objectify(10, 16, 10, 4, 16, 6, 0),objectify(16, 15, 9, 6, 3, 6, 0),objectify(16, 9, 9, 6, 3, 6, 0)], //north
[objectify(6, 16, 6, 4, 16, 6, 0),objectify(10, 15, 7, 6, 3, 6, 0),objectify(10, 9, 7, 6, 3, 6, 0)], //south
[objectify(10, 16, 6, 4, 16, 6, 0)], //east
[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
],
rotate: true
},
fench: {
verts:[
[objectify(6,0,6,4,4,0,1),objectify(10,12,7,6,2,0,2),objectify(10,6,7,6,2,0,2),objectify(0,12,7,6,2,0,0),objectify(0,6,7,6,2,0,0)],
[objectify(6,16,10,4,4,0,1),objectify(10,15,9,6,2,0,2),objectify(10,9,9,6,2,0,2),objectify(0,15,9,6,2,0,0),objectify(0,9,9,6,2,0,0)],
[objectify(10,16,10,4,16,6,0),objectify(16,15,9,6,3,6,0),objectify(16,9,9,6,3,6,0),objectify(6,15,9,6,3,0,0),objectify(6,9,9,6,3,0,0)],
[objectify(6,16,6,4,16,6,0),objectify(10,15,7,6,3,6,0),objectify(10,9,7,6,3,6,0),objectify(0,15,7,6,3,0,0),objectify(0,9,7,6,3,0,0)],
[objectify(10,16,6,4,16,6,0)],
[objectify(6,16,10,4,16,6,0)]
],
rotate: true
},
button: {
verts: [
[objectify(5, 6, 14, 6, 2, 5, 6)], //bottom
[objectify(5, 10, 16, 6, 2, 5, 6)], //top
[objectify(11, 10, 16, 6, 4, 5, 6)], //north
[objectify(5, 10, 14, 6, 4, 5, 6)], //south
[objectify(11, 10, 14, 2, 4, 5, 6)], //east
[objectify(5, 10, 16, 2, 4, 5, 6)]  //west
],
rotate: true
},
chain: {
verts: [
[objectify(8, 0, 8, 0.5, 0.5, 0, 0)], //bottom
[objectify(8, 16, 8, 0.5, 0.5, 0, 0)], //top
[objectify(9.5, 16, 8, 3, 16, 3, 0)], //north
[objectify(6.5, 16, 8, 3, 16, 3, 0)], //south
[objectify(8, 16, 6.5, 3, 16, 0, 0)], //east
[objectify(8, 16, 9.5, 3, 16, 0, 0)] //west
],
size: 6,
},
pot: {
verts: [
[objectify(5, 0, 5, 6, 6, 5, 10)], //bottom
[objectify(5, 6, 11, 6, 6, 5, 5), objectify(6, 4, 10, 4, 4, -16, 0)], //top
[objectify(11, 6, 11, 6, 6, 5, 10), objectify(11, 6, 6, 6, 6, 5, 10)], //north
[objectify(5, 6, 5, 6, 6, 5, 10), objectify(5, 6, 10, 6, 6, 5, 10)], //south
[objectify(11, 6, 5, 6, 6, 5, 10), objectify(6, 6, 5, 6, 6, 5, 10)], //east
[objectify(5, 6, 11, 6, 6, 5, 10), objectify(10, 6, 11, 6, 6, 5, 10)]  //west
],
size: 6,
},
potCross: {
verts: [
[], //bottom
[], //top
[customFace(2,4,2, 14,4,14, 14,-12,14, 2,-12,2, 0,0)], //north
[customFace(14,4,2, 2,4,14, 2,-12,14, 14,-12,2, 0,0)], //south
[customFace(14,4,14, 2,4,2, 2,-12,2, 14,-12,14, 0,0)], //east
[customFace(2,4,14, 14,4,2, 14,-12,2, 2,-12,14, 0,0)]  //west
],
size: 6
},
carpet: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 1, 16, 16, 16, 0, 0)], //top
[objectify(16, 1, 16, 16, 1, 0, 0)], //north
[objectify( 0, 1,  0, 16, 1, 0, 0)], //south
[objectify(16, 1,  0, 16, 1, 0, 0)], //east
[objectify( 0, 1, 16, 16, 1, 0, 0)]  //west
]
},
wallCarpet:{
verts:[
[objectify(0,0,15,16,1,0,0)],
[objectify(0,16,16,16,1,0,0)],
[objectify(16,16,16,16,16,0,0)],
[objectify(0,16,15,16,16,0,0)],
[objectify(16,16,15,1,16,0,0)],
[objectify(0,16,16,1,16,0,0)]
],
rotate:true
},
bed: {
verts: [
[objectify( 0, 3,  0, 16, 16, 96, 0),objectify( 0, 3,  16, 16, 16, 96, 0),
objectify(0, 0, 0, 3,3,  38,0),
objectify(13, 0, 29, 3,3,38,0),
objectify(0, 0, 29, 3,3, 38,0),
objectify(13, 0, 0, 3,3, 38,0)], //bottom
[objectify( 0, 9, 32, 16, 16, 16, 0),objectify( 0, 9, 16, 16, 16, 0, 0)], //top
[objectify(16, 9, 32, 16, 6, 80, 6),
objectify(3, 3, 3, 3,3,  38,3),
objectify(16, 3, 32, 3,3,32,3),
objectify(3, 3, 32, 3,3, 35,3),
objectify(16, 3, 3, 3,3, 41,3)], //north
[objectify( 0, 9,  0, 16, 6, 80, 0),
objectify(0, 3, 0, 3,3,  32,3),
objectify(13, 3, 29, 3,3,38,3),
objectify(0, 3, 29, 3,3, 41,3),
objectify(13, 3, 0, 3,3, 35,3)], //south
[objectify( 16, 9,  0, 16, 6, 48, 0),objectify( 16, 9,  16, 16, 6, 64, 0),
objectify(3, 3, 0, 3,3,  41,3),
objectify(16, 3, 29, 3,3,35,3),
objectify(3, 3, 29, 3,3, 38,3),
objectify(16, 3, 0, 3,3, 32,3)], //east
[objectify( 0, 9, 32, 16, 6, 64, 6),objectify( 0, 9, 16, 16, 6, 48, 6),
objectify(0, 3, 3, 3,3,  35,3),
objectify(13, 3, 32, 3,3,41,3),
objectify(0, 3, 32, 3,3, 32,3),
objectify(13, 3, 3, 3,3, 38,3)]  //west
],
rotate: true
},
cactusPot: {
verts: [
[], //bottom
[objectify( 6, 1, 10, 4,  4, 6, 6)], //top
[objectify(10, 1, 10, 4, 11, 6, 0)], //north
[objectify( 6, 1,  6, 4, 11, 6, 0)], //south
[objectify(10, 1,  6, 4, 11, 6, 0)], //east
[objectify( 6, 1, 10, 4, 11, 6, 0)]  //west
],
size: 6
},
crop: {
verts: [
[objectify(0,0,0,0,0,0,0)],
[objectify(0,0,0,0,0,0,0)],
[objectify(16,16,4,16,16,0,0),objectify(16,16,12,16,16,0,0)],
[objectify(0,16,12,16,16,0,0),objectify(0,16,4,16,16,0,0)],
[objectify(4,16,0,16,16,0,0),objectify(12,16,0,16,16,0,0)],
[objectify(12,16,16,16,16,0,0),objectify(4,16,16,16,16,0,0)]
],
varients: []
},
anvil: {
verts: [
[objectify(2,0,2,12,12,0,0),objectify(0,10,3,16,10,0,0)],
[objectify(2,4,14,12,12,0,0),objectify(3,5,12,10,8,0,0),objectify(0,16,13,16,10,16,3)],
[objectify(14,4,14,12,4,0,0),objectify(16,16,13,16,6,0,0),objectify(13,5,12,10,1,0,0),objectify(12,10,11,8,5,0,0)],
[objectify(2,4,2,12,4,0,0),objectify(0,16,3,16,6,0,0),objectify(3,5,4,10,1,0,0),objectify(4,10,5,8,5,0,0)],
[objectify(14,4,2,12,4,0,0),objectify(16,16,3,10,6,0,0),objectify(13,5,4,8,1,0,0),objectify(12,10,5,6,5,0,0)],
[objectify(2,4,14,12,4,0,0),objectify(0,16,13,10,6,0,0),objectify(3,5,12,8,1,0,0),objectify(4,10,11,6,5,0,0)]
],
rotate: true
},
/*liquid: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0), objectify(16, 0, 0, -16, 16, 16, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify(16, 16, 16, -16, 16, 16, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0), objectify(0, 16, 16, -16, 16, 16, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0), objectify(16, 16, 0, -16, 16, 16, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0), objectify(16, 16, 16, -16, 16, 16, 0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify(0, 16, 0, -16, 16, 16, 0)]  //west
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},
liquidSurface: {
verts: [
[objectify( 0,    0,  0, 16,   16, 0, 0), objectify(16, 0, 0, -16, 16, 16, 0)], //bottom
[objectify( 0, 14.5, 16, 16,   16, 0, 0), objectify(16, 14.5, 16, -16, 16, 16, 0)], //top
[objectify(16, 14.5, 16, 16, 14.5, 0, 0), objectify(0, 14.5, 16, -16, 14.5, 16, 0)], //north
[objectify( 0, 14.5,  0, 16, 14.5, 0, 0), objectify(16, 14.5, 0, -16, 14.5, 16, 0)], //south
[objectify(16, 14.5,  0, 16, 14.5, 0, 0), objectify(16, 14.5, 16, -16, 14.5, 16, 0)], //east
[objectify( 0, 14.5, 16, 16, 14.5, 0, 0), objectify(0, 14.5, 0, -16, 14.5, 16, 0)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},*/
sporeBlossom: {
verts: [
[objectify( 1, 15.9, 1, 14, 14, -15, 1)], //bottom
[objectify( 1, 15.9, 15, 14, 14, -15, 1)], //top
[customFace(0,15.9,8, 16,15.9,8, 16,11.1,-8, 0,11.1,-8, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,-8, 16,11.1,-8, 16,16,-16,-16)],
[customFace(0,15.9,8, 16,15.9,8, 16,11.1,24, 0,11.1,24, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,24, 16,11.1,24, 16,16,-16,-16)], //southobjectify( 0, 16,  0, 16, 16, 0, 0)
[customFace(8,15.9,0, 8,15.9,16, -8,11.1,16, -8,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, -8,11.1,0, -8,11.1,16, 16,16,-16,-16)],
[customFace(8,15.9,0, 8,15.9,16, 24,11.1,16, 24,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, 24,11.1,0, 24,11.1,16, 16,16,-16,-16)]
],
},
azalea: {
verts: [
[objectify( 0,  8,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0),customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 16,0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0),customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 16,0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0),customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 16,0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0),customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 16,0)]  //west
]
},
azaleaPot: {
verts: [
[objectify( 4,  -7,  4, 8, 8, 4, 4)], //bottom
[objectify( 4, -1, 12, 8, 8, 4, 4)], //top
[objectify(12, -1, 12, 8, 11, 4, 5),customFace(4,-1,4, 12,-1,12, 12,-12,12, 4,-12,4, 20,5,8,11)], //north
[objectify( 4, -1,  4, 8, 11, 4, 5),customFace(12,-1,4, 4,-1,12, 4,-12,12, 12,-12,4, 20,5,8,11)], //south
[objectify(12, -1,  4, 8, 11, 4, 5),customFace(12,-1,12, 4,-1,4, 4,-12,4, 12,-12,12, 20,5,8,11)], //east
[objectify( 4, -1, 12, 8, 11, 4, 5),customFace(4,-1,12, 12,-1,4, 12,-12,4, 4,-12,12, 20,5,8,11)]  //west
]
},
sunflower: {
verts: [
[customFace(0,34,7, 16,34,7, 16,18,11, 0,18,11, 0,0)], //bottom
[customFace(16,34,7, 0,34,7, 0,18,11, 16,18,11, 0,0)], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
],
hitbox:"tallCube"
},
cake:{
verts: [
[objectify(1,0,1,14,14,1,1)],
[objectify(1,8,15,14,14,1,1)],
[objectify(15,8,15,14,8,1,8)],
[objectify(1,8,1,14,8,1,8)],
[objectify(15,8,1,14,8,1,8)],
[objectify(1,8,15,14,8,1,8)]
]
},
stonecutter:{
verts:[
[objectify(0,0,0,16,16,0,0)],
[objectify(0,9,16,16,16,0,0)],
[objectify(16,9,16,16,9,0,7),objectify(16,16,8,16,7,16,9)],
[objectify(0,9,0,16,9,0,7),objectify(0,16,8,16,7,16,9)],
[objectify(16,9,0,16,9,0,7)],
[objectify(0,9,16,16,9,0,7)]
]
},
itemFrame:{
verts: [
[objectify(2,2,15,12,1,-16,0),objectify(3,13,15,10,1,-16,0)],
[objectify(2,14,16,12,1,-16,0),objectify(3,3,16,10,1,-16,0)],
[objectify(14,14,16,12,12,-16,0)],
[objectify(3,13,15.5,10,10,3,3),objectify(2,14,15,11,1,-14,2),objectify(13,14,15,1,11,-3,2),objectify(3,3,15,11,1,-13,13),objectify(2,13,15,1,11,-14,3)],
[objectify(14,14,15,1,12,-16,0),objectify(3,13,15,1,10,-16,0)],
[objectify(2,14,16,1,12,-16,0),objectify(13,13,16,1,10,-16,0)]
],
rotate:true
},
endPortalFrame:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 13, 16, 16, 16, 0, 0)], //top
[objectify(16, 13, 16, 16, 13, 0, 3)], //north
[objectify( 0, 13,  0, 16, 13, 0, 3)], //south
[objectify(16, 13,  0, 16, 13, 0, 3)], //east
[objectify( 0, 13, 16, 16, 13, 0, 3)]  //west
],
rotate:true
},
endPortalFrameWithEyeOfEnder: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 13, 16, 16, 16, 0, 0), objectify( 4, 16, 12, 8, 8, 36, 4)], //top
[objectify(16, 13, 16, 16, 13, 0, 3), objectify( 12, 16, 12, 8, 3, 20, 0)], //north
[objectify( 0, 13,  0, 16, 13, 0, 3), objectify( 4, 16, 4, 8, 3, 20, 0)], //south
[objectify(16, 13,  0, 16, 13, 0, 3), objectify( 12, 16, 4, 8, 3, 20, 0)], //east
[objectify( 0, 13, 16, 16, 13, 0, 3), objectify( 4, 16, 12, 8, 3, 20, 0)]  //west
],
rotate: true
},
fire: {
verts: [
[], //bottom
[], //top
[customFace(16,22.4,15.5, 0,22.4,15.5, 0,0,16, 16,0,16, 0,0), customFace(0,22.4,15.5, 16,22.4,15.5, 16,0,16, 0,0,16, 0,0), customFace(0,20,12, 16,20,12, 16,0,0, 0,0,0, 0,0), customFace(16,20,12, 0,20,12, 0,0,0, 16,0,0, 0,0)], //north
[customFace(16,22.4,0.5, 0,22.4,0.5, 0,0,0, 16,0,0, 0,0), customFace(0,22.4,0.5, 16,22.4,0.5, 16,0,0, 0,0,0, 0,0), customFace(16,20,4, 0,20,4, 0,0,16, 16,0,16, 0,0), customFace(0,20,4, 16,20,4, 16,0,16, 0,0,16, 0,0)], //south
[customFace(15.5,22.4,16, 15.5,22.4,0, 16,0,0, 16,0,16, 0,0), customFace(15.5,22.4,0, 15.5,22.4,16, 16,0,16, 16,0,0, 0,0), customFace(12,20,0, 12,20,16, 0,0,16, 0,0,0, 0,0), customFace(12,20,16, 12,20,0, 0,0,0, 0,0,16, 0,0)], //east
[customFace(0.5,22.4,16, 0.5,22.4,0, 0,0,0, 0,0,16, 0,0), customFace(0.5,22.4,0, 0.5,22.4,16, 0,0,16, 0,0,0, 0,0), customFace(4,20,0, 4,20,16, 16,0,16, 16,0,0, 0,0), customFace(4,20,16, 4,20,0, 16,0,0, 16,0,16, 0,0)]  //west
],
hitbox:"cube"
},
sideFire:{
verts:[
[],
[],
[customFace(16,22.4,14, 0,22.4,14, 0,0,16, 16,0,16, 0,0)],
[customFace(0,22.4,14, 16,22.4,14, 16,0,16, 0,0,16, 0,0)],
[],
[]
],
rotate:true,
hitbox:"cube"
},
bottomFire:{
verts:[
[customFace(0,12,0, 16,12,0, 16,16,16, 0,16,16, 0,0),customFace(16,12,16, 0,12,16, 0,16,0, 16,16,0, 0,0), customFace(16,12,0, 16,12,16, 0,16,16, 0,16,0, 0,0),customFace(0,12,16, 0,12,0, 16,16,0, 16,16,16, 0,0)],
[customFace(16,12,0, 0,12,0, 0,16,16, 16,16,16, 0,0),customFace(0,12,16, 16,12,16, 16,16,0, 0,16,0, 0,0), customFace(0,12,0, 0,12,16, 16,16,16, 16,16,0, 0,0),customFace(16,12,16, 16,12,0, 0,16,0, 0,16,16, 0,0)],
[],
[],
[],
[]
],
hitbox:"cube"
},
endRod: {
verts: [
[objectify( 6, 0,  6, 4, 4, 2, 4)], //bottom
[objectify( 7, 16, 9, 2, 2, 2, 0),objectify(6, 1,  10, 4, 4, 2, 4)], //top
[objectify(9, 16, 9, 2, 15, 0, 0),objectify(10, 1, 10, 4, 1, 2, 2)], //north
[objectify(7, 16, 7, 2, 15, 0, 0),objectify(6, 1,  6, 4, 1, 2, 2)], //south
[objectify(9, 16, 7, 2, 15, 0, 0),objectify(10, 1, 6, 4, 1, 2, 2)], //east
[objectify(7, 16, 9, 2, 15, 0, 0),objectify(6, 1, 10, 4, 1, 2, 2)]  //west
],
flip: true,
},
endRodSW: {
verts: [
[objectify(7, 7, 0, 2, 15, 0, 0),objectify(6, 6,  15, 4, 1, 2, 4)], //bottom
[objectify(7, 9, 15, 2, 15, 0, 0),objectify(6, 10, 16, 4, 1, 2, 4)], //top
[objectify(10, 10, 16, 4, 4, 2, 4)], //north
[objectify( 7, 9, 0, 2, 2, 2, 0),objectify(6, 10,  15, 4, 4, 2, 2)], //south
[objectify(9, 9, 0, 15, 2, 16, 14),objectify(10, 10, 15, 1, 4, 2, 2)], //east
[objectify(7, 9, 15, 15, 2, 16, 14),objectify(6, 10, 16, 1, 4, 2, 2)]  //west
],
rotate: true,
},
door2: {
verts: [
[objectify(0,0,13,16,3,16,0, false,false,false,null,2)],
[objectify(0,32,16,16,3,16,0, false,false,false,null,2)],
[objectify(16,32,16,16,16,0,0),objectify(16,16,16,16,16,16,0)],
[objectify(0,32,13,16,16,0,0, true),objectify(0,16,13,16,16,16,0, true)],
[objectify(16,32,13,3,16,13,0, false,false,false,2),objectify(16,16,13,3,16,29,0, false,false,false,2)],
[objectify(0,32,16,3,16,0,0, false,false,false,2),objectify(0,16,16,3,16,16,0, false,false,false,2)]
],
rotate: true
},
fenceGate: {
verts: [
[objectify(0,5,7,2,2,0,1),objectify(2,12,7,12,2,0,2),objectify(2,6,7,12,2,0,2),objectify(14,5,7,2,2,0,0)],
[objectify(0,16,9,2,2,0,1),objectify(2,15,9,12,2,0,2),objectify(2,9,9,12,2,0,2),objectify(14,16,9,2,2,0,0)],
[objectify(2,16,9,2,11,0,0),objectify(14,15,9,12,3,2,1),objectify(14,9,9,12,3,2,7),objectify(16,16,9,2,11,14,0),objectify(10,12,9,4,3,6,4)],
[objectify(0,16,7,2,11,14,0),objectify(2,15,7,12,3,2,1),objectify(2,9,7,12,3,2,7),objectify(14,16,7,2,11,2,0),objectify(6,12,7,4,3,6,4)],
[objectify(2,16,7,2,11,6,0),objectify(10,12,7,2,3,0,0),objectify(16,16,7,2,11,0,0)],
[objectify(0,16,9,2,11,6,0),objectify(14,16,9,2,11,0,0),objectify(6,12,9,2,3,0,0)]
],
flip: false,
rotate: true
},
fenceGateWall: {
verts: [
[objectify(0,2,7,2,2,0,1),objectify(2,9,7,12,2,0,2),objectify(2,3,7,12,2,0,2),objectify(14,2,7,2,2,0,0)],
[objectify(0,13,9,2,2,0,1),objectify(2,12,9,12,2,0,2),objectify(2,6,9,12,2,0,2),objectify(14,13,9,2,2,0,0)],
[objectify(2,13,9,2,11,0,0),objectify(14,12,9,12,3,2,1),objectify(14,6,9,12,3,2,7),objectify(16,13,9,2,11,14,0),objectify(10,9,9,4,3,6,4)],
[objectify(0,13,7,2,11,14,0),objectify(2,12,7,12,3,2,1),objectify(2,6,7,12,3,2,7),objectify(14,13,7,2,11,2,0),objectify(6,9,7,4,3,6,4)],
[objectify(2,13,7,2,11,6,0),objectify(10,9,7,2,3,0,0),objectify(16,13,7,2,11,0,0)],
[objectify(0,13,9,2,11,6,0),objectify(14,13,9,2,11,0,0),objectify(6,9,9,2,3,0,0)]
],
flip: false,
rotate: true
},
fenceGateOpen: {
verts: [
[objectify(0,5,7,2,2,0,1),objectify(14,12,9,2,6,0,2),objectify(14,6,9,2,6,0,2),objectify(14,5,7,2,2,0,0),objectify(0,12,9,2,6,0,0),objectify(0,6,9,2,6,0,0)],
[objectify(0,16,9,2,2,0,1),objectify(14,15,15,2,6,0,2),objectify(14,9,15,2,6,0,2),objectify(14,16,9,2,2,0,0),objectify(0,15,15,2,6,0,0),objectify(0,9,15,2,6,0,0)],
[objectify(2,16,9,2,11,0,0),objectify(16,15,15,2,9,2,1),objectify(2,15,15,2,9,2,7),objectify(16,16,9,2,11,14,0)],
[objectify(0,16,7,2,11,14,0),objectify(14,12,13,2,3,2,1),objectify(0,12,13,2,3,2,7),objectify(14,16,7,2,11,2,0)],
[objectify(2,16,7,2,11,6,0),objectify(2,12,13,2,3,6,4),objectify(16,16,7,2,11,6,4),objectify(16,12,13,2,3,0,0),objectify(16,15,9,6,3,2,1),objectify(2,15,9,6,3,2,1),objectify(16,9,9,6,3,2,7),objectify(2,9,9,6,3,2,7)],
[objectify(0,16,9,2,11,6,0),objectify(14,16,9,2,11,0,0),objectify(14,12,15,2,3,6,4),objectify(0,12,15,2,3,6,4),objectify(0,15,15,6,3,0,1),objectify(0,9,15,6,3,2,7),objectify(14,15,15,6,3,2,1),objectify(14,9,15,6,3,2,7)]
],
flip: false,
rotate: true
},
fenceGateWallOpen: {
verts: [
[objectify(0,2,7,2,2,0,1),objectify(14,9,9,2,6,0,2),objectify(14,3,9,2,6,0,2),objectify(14,2,7,2,2,0,0),objectify(0,9,9,2,6,0,0),objectify(0,3,9,2,6,0,0)],
[objectify(0,13,9,2,2,0,1),objectify(14,12,15,2,6,0,2),objectify(14,6,15,2,6,0,2),objectify(14,13,9,2,2,0,0),objectify(0,12,15,2,6,0,0),objectify(0,6,15,2,6,0,0)],
[objectify(2,13,9,2,11,0,0),objectify(16,12,15,2,9,2,1),objectify(2,12,15,2,9,2,7),objectify(16,13,9,2,11,14,0)],
[objectify(0,13,7,2,11,14,0),objectify(14,9,13,2,3,2,1),objectify(0,9,13,2,3,2,7),objectify(14,13,7,2,11,2,0)],
[objectify(2,13,7,2,11,6,0),objectify(2,9,13,2,3,6,4),objectify(16,13,7,2,11,6,4),objectify(16,9,13,2,3,0,0),objectify(16,12,9,6,3,2,1),objectify(2,12,9,6,3,2,1),objectify(16,6,9,6,3,2,7),objectify(2,6,9,6,3,2,7)],
[objectify(0,13,9,2,11,6,0),objectify(14,13,9,2,11,0,0),objectify(14,9,15,2,3,6,4),objectify(0,9,15,2,3,6,4),objectify(0,12,15,6,3,0,1),objectify(0,6,15,6,3,2,7),objectify(14,12,15,6,3,2,1),objectify(14,6,15,6,3,2,7)]
],
flip: false,
rotate: true
},
tallCrop: {
verts: [
[],
[],
[objectify(16,32,4,16,16,0,0),objectify(16,32,12,16,16,0,0),objectify(16,16,4,16,16,16,0),objectify(16,16,12,16,16,16,0)],
[objectify(0,32,12,16,16,0,0),objectify(0,32,4,16,16,0,0),objectify(0,16,12,16,16,16,0),objectify(0,16,4,16,16,16,0)],
[objectify(4,32,0,16,16,0,0),objectify(12,32,0,16,16,0,0),objectify(4,16,0,16,16,16,0),objectify(12,16,0,16,16,16,0)],
[objectify(12,32,16,16,16,0,0),objectify(4,32,16,16,16,0,0),objectify(12,16,16,16,16,16,0),objectify(4,16,16,16,16,16,0)]
],
varients: []
},
chainSW: {
verts: [
[objectify(6.5,8,0,3,16,0,0)],
[objectify(6.5,8,16,3,16,0,0)],
[],
[],
[objectify(8,9.5,0,16,3,0,3)],
[objectify(8,9.5,16,16,3,0,3)]
],
rotate:true
},
campfire:{
verts: [
[objectify(1,0,0,4,16,16,0,false,false,1),objectify(11,0,0,4,16,16,0,false,false,1),objectify(0,3,1,16,4,0,4),objectify(0,3,11,16,4,0,4),objectify(5,0,0,6,16,16,10,false,false,1)],
[objectify(1,4,16,4,16,16,0,false,false,1),objectify(11,4,16,4,16,16,0,false,false,1),objectify(0,7,5,16,4,16,0),objectify(0,7,15,16,4,16,0),objectify(5,1,16,6,16,0,10,false,false,1)],
[objectify(5,4,16,4,4,16,4),objectify(15,4,16,4,4,16,4),objectify(16,7,5,16,4,0,0),objectify(16,7,15,16,4,0,0),objectify(11,1,16,6,1,0,15), customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 32,0)],
[objectify(1,4,0,4,4,16,4),objectify(11,4,0,4,4,16,4),objectify(0,7,1,16,4,0,0),objectify(0,7,11,16,4,0,0),objectify(5,1,0,6,1,0,15), customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 32,0)],
[objectify(15,4,0,16,4,16,0),objectify(5,4,0,16,4,0,0),objectify(16,7,1,4,4,16,4),objectify(16,7,11,4,4,16,4), customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 32,0)],
[objectify(11,4,16,16,4,0,0),objectify(1,4,16,16,4,16,0),objectify(0,7,5,4,4,16,4),objectify(0,7,15,4,4,16,4), customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 32,0)]
],
hitbox:"slab"
},
campfireUnlit:{
verts:[
[objectify(1,0,0,4,16,16,0,false,false,1),objectify(11,0,0,4,16,16,0,false,false,1),objectify(0,3,1,16,4,16,0),objectify(0,3,11,16,4,16,0),objectify(5,0,0,6,16,16,10,false,false,1)],
[objectify(1,4,16,4,16,16,0,false,false,1),objectify(11,4,16,4,16,16,0,false,false,1),objectify(0,7,5,16,4,16,0),objectify(0,7,15,16,4,16,0),objectify(5,1,16,6,16,16,10,false,false,1)],
[objectify(5,4,16,4,4,16,4),objectify(15,4,16,4,4,16,4),objectify(16,7,5,16,4,16,0),objectify(16,7,15,16,4,16,0),objectify(11,1,16,6,1,0,15)],
[objectify(1,4,0,4,4,16,4),objectify(11,4,0,4,4,16,4),objectify(0,7,1,16,4,16,0),objectify(0,7,11,16,4,16,0),objectify(5,1,0,6,1,0,15)],
[objectify(15,4,0,16,4,16,0),objectify(5,4,0,16,4,16,0),objectify(16,7,1,4,4,16,4),objectify(16,7,11,4,4,16,4)],
[objectify(11,4,16,16,4,16,0),objectify(1,4,16,16,4,16,0),objectify(0,7,5,4,4,16,4),objectify(0,7,15,4,4,16,4)]
],
hitbox:"slab"
},
bamboo:{
verts:[
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0)],
[objectify(6.5,16,6.5,3,16,0,0)],
[objectify(9.5,16,6.5,3,16,0,0)],
[objectify(6.5,16,9.5,3,16,0,0)]
],
hitbox:"cube"
},
bambooSmallLeaf:{
verts: [
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0),objectify(16,16,8,16,16,48,0)],
[objectify(6.5,16,6.5,3,16,0,0),objectify(0,16,8,16,16,48,0)],
[objectify(9.5,16,6.5,3,16,0,0),objectify(8,16,0,16,16,48,0)],
[objectify(6.5,16,9.5,3,16,0,0),objectify(8,16,16,16,16,48,0)]
],
hitbox:"cube"
},
bambooBigLeaf:{
verts:[
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0),objectify(16,16,8,16,16,32,0)],
[objectify(6.5,16,6.5,3,16,0,0),objectify(0,16,8,16,16,32,0)],
[objectify(9.5,16,6.5,3,16,0,0),objectify(8,16,0,16,16,32,0)],
[objectify(6.5,16,9.5,3,16,0,0),objectify(8,16,16,16,16,32,0)]
],
hitbox:"cube"
},
bambooYoung:{
verts:[
[objectify(7,0,7,2,2,13,4)],
[objectify(7,16,9,2,2,13,0)],
[objectify(9,16,9,2,16,0,0)],
[objectify(7,16,7,2,16,0,0)],
[objectify(9,16,7,2,16,0,0)],
[objectify(7,16,9,2,16,0,0)]
],
hitbox:"cube"
},
bambooYoungLeaf:{
verts:[
[objectify(7,0,7,2,2,13,4)],
[objectify(7,16,9,2,2,13,0)],
[objectify(9,16,9,2,16,0,0),objectify(16,16,8,16,16,48,0)],
[objectify(7,16,7,2,16,0,0),objectify(0,16,8,16,16,48,0)],
[objectify(9,16,7,2,16,0,0),objectify(8,16,0,16,16,48,0)],
[objectify(7,16,9,2,16,0,0),objectify(8,16,16,16,16,47,0)]
],
hitbox:"cube"
},
bambooPot:{
verts:[
[],
[objectify(7,0,9,2,2,13,0)],
[objectify(9,0,9,2,16,0,0),objectify(16,0,8,16,16,16,0)],
[objectify(7,0,7,2,16,0,0),objectify(0,0,8,16,16,16,0, true)],
[objectify(9,0,7,2,16,0,0)],
[objectify(7,0,9,2,16,0,0)]
],
},
chest:{
verts:[
[objectify(1,0,1,14,14,32,0),objectify(7,7,0,2,1,67,0)],
[objectify(1,14,15,14,14,48,0),objectify(7,11,1,2,1,79,0)],
[objectify(15,14,15,14,4,16,0),objectify(15,10,15,14,10,16,5),objectify(9,11,1,2,4,64,1)],
[objectify(1,14,1,14,4,0,0),objectify(1,10,1,14,10,0,5),objectify(7,11,0,2,4,62,1)],
[objectify(15,14,1,14,4,16,0),objectify(15,10,1,14,10,16,5),objectify(9,11,0,1,4,64,1)],
[objectify(1,14,15,14,4,16,0),objectify(1,10,15,14,10,16,5),objectify(7,11,1,1,4,62,1)]
],
rotate:true
},
pressurePlate:{
verts:[
[objectify(1,0,1,14,14,1,1)],
[objectify(1,1,15,14,14,1,1)],
[objectify(15,1,15,14,1,0,0)],
[objectify(1,1,1,14,1,0,0)],
[objectify(15,1,1,14,1,0,0)],
[objectify(1,1,15,14,1,0,0)]
],
},
pressurePlateActive:{
verts:[
[objectify(1,0,1,14,14,1,1)],
[objectify(1,0.5,15,14,14,1,1)],
[objectify(15,0.5,15,14,0.5,0,0)],
[objectify(1,0.5,1,14,0.5,0,0)],
[objectify(15,0.5,1,14,0.5,0,0)],
[objectify(1,0.5,15,14,0.5,0,0)]
]
},
redstoneDust:{
verts:[
[objectify(0,0.25,0,16,16,0,0,false,true)],
[objectify(0,0.25,16,16,16,0,0)],
[objectify(16, 16,  0.25, 16, 16, 0, 0, false,false,false,null,null, "north"), objectify(16, 16,  15.75, 16, 16, 0, 0, false,false,false,null,null, "south")],
[objectify( 0, 16, 15.75, 16, 16, 0, 0, false,false,false,null,null, "south"), objectify( 0, 16, 0.25, 16, 16, 0, 0, false,false,false,null,null, "north")],
[objectify( 0.25, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "east"), objectify( 15.75, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "west")],
[objectify(15.75, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "west"), objectify(0.25, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "east")]
],
hitbox:"carpet"
},
redstoneDustRotate:{
verts:[
[objectify(0,0.25,0,16,16,0,0,false,true)],
[objectify(0,0.25,16,16,16,0,0)],
[objectify(16, 16,  0.25, 16, 16, 0, 0, false,false,false,null,null, "north"), objectify(16, 16,  15.75, 16, 16, 0, 0, false,false,false,null,null, "south")],
[objectify( 0, 16, 15.75, 16, 16, 0, 0, false,false,false,null,null, "south"), objectify( 0, 16, 0.25, 16, 16, 0, 0, false,false,false,null,null, "north")],
[objectify( 0.25, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "east"), objectify( 15.75, 16,  0, 16, 16, 0, 0, false,false,false,null,null, "west")],
[objectify(15.75, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "west"), objectify(0.25, 16, 16, 16, 16, 0, 0, false,false,false,null,null, "east")]
],
rotate:true,
hitbox:"carpet"
},
redstoneTorch:{
verts:[
[objectify(7,0,7,2,2,7,14),objectify(6,10,6,4,4,6,5)],
[objectify(7,10,9,2,2,7,6),objectify(6,8,10,4,4,6,5)],
[objectify(9,10,9,2,10,7,6),objectify(10,11,7,4,4,6,5)],
[objectify(7,10,7,2,10,7,6),objectify(6,11,9,4,4,6,5)],
[objectify(9,10,7,2,10,7,6),objectify(7,11,6,4,4,6,5)],
[objectify(7,10,9,2,10,7,6),objectify(9,11,10,4,4,6,5)]
]
},
redstoneWallTorch:{
verts: [
[customFace(9,4,17, 7,4,17, 7,3,15, 9,3,15, 7,14,2,2),customFace(6,12.5,10, 10,12.5,10, 10,14.5,14, 6,14.5,14, 6,5,4,4)],
[customFace(9,13,11, 7,13,11, 7,14,13, 9,14,13, 7,6,2,2),customFace(10,10.5,10.8, 6,10.5,10.8, 6,12.5,14.8, 10,12.5,14.8, 6,5,4,4)],
[customFace(9,14,13, 7,14,13, 7,4,17, 9,4,17, 7,6,2,10),customFace(10,14,10.6, 6,14,10.6, 6,10,12.2, 10,10,12.2, 6,5,4,4)], //north
[customFace(7,13,11, 9,13,11, 9,3,15, 7,3,15, 7,6,2,10),customFace(6,15,12.6, 10,15,12.6, 10,11,14.2, 6,11,14.2, 6,5,4,4)], //south
[customFace(9,13,11, 9,14,13, 9,4,17, 9,3,15, 7,6,2,10),customFace(7,13.5,9.6, 7,15.5,13.6, 7,11.5,15.2, 7,9.5,11.2, 6,5,4,4)], //east
[customFace(7,14,13, 7,13,11, 7,3,15, 7,4,17, 7,6,2,10),customFace(9,15.5,13.6, 9,13.5,9.6, 9,9.5,11.2, 9,11.5,15.2, 6,5,4,4)]  //west
],
rotate:true
},
leverWall:{
verts:[
[objectify(5,4,13,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,12,7, 9,12,7, 9,8.45,15, 7,8.45,15, 7,6,2,10)],
[objectify(5,12,16,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,13.5,8, 7,13.5,8, 7,10,16, 9,10,16, 7,6,2,10)],
[objectify(11,12,16,6,8,0,0,null,null,null,null,null,"cobblestone")],
[objectify(5,12,13,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,13.5,8, 9,13.5,8, 9,12,7, 7,12,7, 7,6,2,2)],
[objectify(11,12,13,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,12,7, 9,13.5,8, 9,10,16, 9,8.45,15, 7,6,2,10)],
[objectify(5,12,16,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,13.5,8, 7,12,7, 7,8.45,15, 7,10,16, 7,6,2,10)]
],
rotate:true
},
leverWallOn:{
verts:[
[objectify(5,4,13,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,2.5,8, 9,2.5,8, 9,6,16, 7,6,16, 7,6,2,10)],
[objectify(5,12,16,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,4,7, 7,4,7, 7,7.55,15, 9,7.55,15, 7,6,2,10)],
[objectify(11,12,16,6,8,0,0,null,null,null,null,null,"cobblestone")],
[objectify(5,12,13,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,2.5,8, 7,2.5,8, 7,4,7, 9,4,7, 7,6,2,2)],
[objectify(11,12,13,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,2.5,8, 9,4,7, 9,7.55,15, 9,6,16, 7,6,2,10)],
[objectify(5,12,16,3,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,4,7, 7,2.5,8, 7,6,16, 7,7.55,15, 7,6,2,10)]
],
rotate:true
},
leverFloor:{
verts:[
[objectify(5,0,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 7,8,13.5, 7,0,10, 9,0,10, 7,6,2,10)],
[objectify(5,3,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,9,12, 9,9,12, 9,1,8.45, 7,1,8.45, 7,6,2,10)],
[objectify(11,3,12,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 9,8,13.5, 9,9,12, 7,9,12, 7,6,2,2)],
[objectify(5,3,4,6,3,0,0,null,null,null,null,null,"cobblestone")],
[objectify(11,3,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,9,12, 9,8,13.5, 9,0,10, 9,1,8.45, 7,6,2,10)],
[objectify(5,3,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 7,9,12, 7,1,8.45, 7,0,10, 7,6,2,10)]
],
},
leverFloorOn:{
verts:[
[objectify(5,0,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 9,8,2.5, 9,0,6, 7,0,6, 7,6,2,10)],
[objectify(5,3,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,9,4, 7,9,4, 7,1,7.55, 9,1,7.55, 7,6,2,10)],
[objectify(11,3,12,6,3,0,0,null,null,null,null,null,"cobblestone")],
[objectify(5,3,4,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 7,8,2.5, 7,9,4, 9,9,4, 7,6,2,2)],
[objectify(11,3,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 9,9,4, 9,1,7.55, 9,0,6, 7,6,2,10)],
[objectify(5,3,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,9,4, 7,8,2.5, 7,0,6, 7,1,7.55, 7,6,2,10)]
],
},
leverCeil:{
verts:[
[objectify(5,13,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,7,12, 7,7,12, 7,15,8.45, 9,15,8.45, 7,6,2,10)],
[objectify(5,16,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,13.5, 9,8,13.5, 9,16,10, 7,16,10, 7,6,2,10)],
[objectify(11,16,12,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 7,8,13.5, 7,7,12, 9,7,12, 7,6,2,2)],
[objectify(5,16,4,6,3,0,0,null,null,null,null,null,"cobblestone")],
[objectify(11,16,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,13.5, 9,7,12, 9,15,8.45, 9,16,10, 7,6,2,10)],
[objectify(5,16,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,7,12, 7,8,13.5, 7,16,10, 7,15,8.45, 7,6,2,10)]
],
},
leverCeilOn:{
verts:[
[objectify(5,13,4,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(7,7,4, 9,7,4, 9,15,7.55, 7,15,7.55, 7,6,2,10)],
[objectify(5,16,12,6,8,0,0,null,null,null,null,null,"cobblestone"), customFace(9,8,2.5, 7,8,2.5, 7,16,6, 9,16,6, 7,6,2,10)],
[objectify(11,16,12,6,3,0,0,null,null,null,null,null,"cobblestone")],
[objectify(5,16,4,6,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 9,8,2.5, 9,7,4, 7,7,4, 7,6,2,2)],
[objectify(11,16,4,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(9,7,4, 9,8,2.5, 9,16,6, 9,15,7.55, 7,6,2,10)],
[objectify(5,16,12,8,3,0,0,null,null,null,null,null,"cobblestone"), customFace(7,8,2.5, 7,7,4, 7,15,7.55, 7,16,6, 7,6,2,10)]
],
},
buttonPushed:{
verts:[
[objectify(5,6,15,6,1,5,6)],
[objectify(5,10,16,6,1,5,6)],
[objectify(11,10,16,6,4,5,6)],
[objectify(5,10,15,6,4,5,6)],
[objectify(11,10,15,1,4,5,6)],
[objectify(5,10,16,1,4,5,6)]
],
rotate: true
},
repeater1:{
verts:generateRepeater(),
rotate: true
},
repeater2:{
verts:generateRepeater(2),
rotate: true
},
repeater3:{
verts:generateRepeater(3),
rotate: true
},
repeater4:{
verts:generateRepeater(4),
rotate: true
},
repeaterOn1:{
verts:generateRepeater(1,true),
rotate: true
},
repeaterOn2:{
verts:generateRepeater(2,true),
rotate: true
},
repeaterOn3:{
verts:generateRepeater(3,true),
rotate: true
},
repeaterOn4:{
verts:generateRepeater(4,true),
rotate: true
},
//the piston shapes come from https://minekhan-testing.lukep0wers.repl.co
pistonOpen: {
verts: [
[objectify(0,0,0,16,16,0,0)], //bottom
[objectify(0,12,16,16,16,0,0)], //top
[objectify(16,12,16,16,12,0,4)], //north
[objectify(0,12,0,16,12,0,4)], //south
[objectify(16,12,0,16,12,0,4)], //east
[objectify(0,12,16,16,12,0,4)]  //west
]
},
pistonOpenFlipped: {
verts: [
[objectify(0,4,0,16,16,0,0, false,true)],
[objectify(0,16,16,16,16,0,0, false,true)],
[objectify(16,16,16,16,12,0,4, false,true)],
[objectify(0,16,0,16,12,0,4, false,true)],
[objectify(16,16,0,16,12,0,4, false,true)],
[objectify(0,16,16,16,12,0,4, false,true)]
]
},
pistonOpenSW: {
verts: [
[objectify(0,0,4,16,12,0,4)],
[objectify(0,16,16,16,12,0,4, false,false,2)],
[objectify(16,16,16,16,16,0,0)],
[objectify(0,16,4,16,16,0,0)],
[objectify(16,16,4,12,16,0,4, false,false,1)],
[objectify(0,16,16,12,16,0,4, false,false,-1)]
],
rotate:true
},
pistonHead: {
verts: [
[objectify(0,12,0,16,16,0,0)], //b
[objectify(0,16,16,16,16,0,0)], //t
[objectify(16,16,16,16,4,0,0), objectify(10,12,10,4,12,6,4), objectify(10,0,10,4,4,6,9)], //n
[objectify(0,16,0,16,4,0,0), objectify(6,12,6,4,12,6,4), objectify(6,0,6,4,4,6,9)], //s
[objectify(16,16,0,16,4,0,0), objectify(10,12,6,4,12,6,4), objectify(10,0,6,4,4,6,9)], //e
[objectify(0,16,16,16,4,0,0), objectify(6,12,10,4,12,6,4), objectify(6,0,10,4,4,6,9)] //w
]
},
pistonHeadFlipped: {
verts: [
[objectify(0,0,0,16,16,0,0)], //b
[objectify(0,4,16,16,16,0,0)], //t
[objectify(16,4,16,16,4,0,0), objectify(10,20,10,4,12,6,4), objectify(10,8,10,4,4,6,9)], //n
[objectify(0,4,0,16,4,0,0), objectify(6,20,6,4,12,6,4), objectify(6,8,6,4,4,6,9)], //s
[objectify(16,4,0,16,4,0,0), objectify(10,20,6,4,12,6,4), objectify(10,8,6,4,4,6,9)], //e
[objectify(0,4,16,16,4,0,0), objectify(6,20,10,4,12,6,4), objectify(6,8,10,4,4,6,9)] //w
]
},
pistonHeadSW: {
verts: [
[objectify(0,0,0,16,4,0,0),objectify(6,6,4,4,12,6,4),objectify(6,6,16,4,4,6,9)],
[objectify(0,16,4,16,4,0,0),objectify(6,10,16,4,12,6,4, false,true),objectify(6,10,20,4,4,6,9, false,true)],
[objectify(16,16,4,16,16,0,0)],
[objectify(0,16,0,16,16,0,0)],
[objectify(16,16,0,4,16,0,0, false,false,true),objectify(10,10,4,12,4,6,4, false,false,1),objectify(10,10,16,4,4,6,9, false,false,1)],
[objectify(0,16,4,4,16,0,0, false,false,true),objectify(6,10,16,12,4,6,4, false,false,-1),objectify(6,10,20,4,4,6,9, false,false,-1)]
],
rotate:true
},
pistonHeadCut: {
verts: [
[objectify(0,12,0,16,16,0,0)], //b
[objectify(0,16,16,16,16,0,0)], //t
[objectify(16,16,16,16,4,0,0), objectify(10,12,10,4,12,6,4)], //n
[objectify(0,16,0,16,4,0,0), objectify(6,12,6,4,12,6,4)], //s
[objectify(16,16,0,16,4,0,0), objectify(10,12,6,4,12,6,4)], //e
[objectify(0,16,16,16,4,0,0), objectify(6,12,10,4,12,6,4)] //w
]
},
pistonHeadCutFlipped: {
verts: [
[objectify(0,0,0,16,16,0,0)], //b
[objectify(0,4,16,16,16,0,0)], //t
[objectify(16,4,16,16,4,0,0), objectify(10,16,10,4,12,6,4)], //n
[objectify(0,4,0,16,4,0,0), objectify(6,16,6,4,12,6,4)], //s
[objectify(16,4,0,16,4,0,0), objectify(10,16,6,4,12,6,4)], //e
[objectify(0,4,16,16,4,0,0), objectify(6,16,10,4,12,6,4)] //w
]
},
pistonHeadCutSW: {
verts: [
[objectify(0,0,0,16,4,0,0),objectify(6,6,4,4,12,6,4)],
[objectify(0,16,4,16,4,0,0),objectify(6,10,16,4,12,6,4, false,true)],
[objectify(16,16,4,16,16,0,0)],
[objectify(0,16,0,16,16,0,0)],
[objectify(16,16,0,4,16,0,0, false,false,true),objectify(10,10,4,12,4,6,4, false,false,1)],
[objectify(0,16,4,4,16,0,0, false,false,true),objectify(6,10,16,12,4,6,4, false,false,-1)]
],
rotate:true
},
slimeBlock:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0), objectify( 3,  3,  3, 10, 10, 3, 3)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 3, 13, 13, 10, 10, 3, 3)], //top
[objectify(16, 16, 16, 16, 16, 0, 0), objectify(13, 13, 13, 10, 10, 3, 3)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0), objectify( 3, 13,  3, 10, 10, 3, 3)], //south
[objectify(16, 16,  0, 16, 16, 0, 0), objectify(13, 13,  3, 10, 10, 3, 3)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 3, 13, 13, 10, 10, 3, 3)]  //west
],
},
honeyBlock:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0), objectify( 1,  1,  1, 14, 14, 1, 1)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 1, 15, 15, 14, 14, -31, 1)], //top
[objectify(16, 16, 16, 16, 16, 0, 0), objectify(15, 15, 15, 14, 14, -15, 1)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0), objectify( 1, 15,  1, 14, 14, -15, 1)], //south
[objectify(16, 16,  0, 16, 16, 0, 0), objectify(15, 15,  1, 14, 14, -15, 1)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0), objectify( 1, 15, 15, 14, 14, -15, 1)]  //west
],
},
stairCornerOut: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8,  16, 16, 16, 0, 0), objectify( 0, 16,  16, 8, 8, 0, 0)], //top
[objectify(8, 16, 16, 8, 8, 0, 0), objectify(16, 8, 16, 16, 8, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 8, 8, 0, 0)], //south
[objectify(16, 8, 0, 16, 8, 0, 0), objectify(8, 16, 8, 8, 16, 0, 0)], //east
[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
],
flip: true,
rotate: true
},
stairCornerIn: {
verts: [
[objectify(0,0,0,16,16,0,0)],
[objectify(8,8,8,8,8,0,0),objectify(0,16,16,16,8,0,0),objectify(0,16,8,8,8,0,0)],
[objectify(16,16,16,16,16,0,0)],
[objectify(8,16,8,8,8,0,0),objectify(0,16,0,8,8,0,0),objectify(0,8,0,16,8,0,0)],
[objectify(8,16,0,8,8,0,0),objectify(16,16,8,8,8,0,0),objectify(16,8,0,16,8,0,0)],
[objectify(0,16,16,16,16,0,0)]
],
flip: true,
rotate: true
},
endPortal: {
verts: [
[objectify( 0, 8,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
[], //north
[], //south
[], //east
[]  //west
],
},
smallDripleaf:{
verts:[
[objectify(8,21,8,7,7,48,0,false,false,-1),objectify(1,26,1,7,7,48,0,false,false,1),objectify(1,30,8,7,7,48,0,false,false,2)],
[objectify(8,21,15,7,7,48,0,true,false,-1),objectify(1,26,8,7,7,48,0,true,false,1),objectify(1,30,15,7,7,48,0,true)],
[objectify(15,21,15,7,1,32,0),objectify(8,26,8,7,1,32,0),objectify(8,30,15,7,1,32,0),customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 16,0)],
[objectify(8,21,8,7,1,32,0),objectify(1,26,1,7,1,32,0),objectify(1,30,8,7,1,32,0),customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 16,0)],
[objectify(15,21,8,7,1,32,0),objectify(8,26,1,7,1,32,0),objectify(8,30,8,7,1,32,0),customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 16,0)],
[objectify(8,21,15,7,1,32,0),objectify(1,26,8,7,1,32,0),objectify(1,30,15,7,1,32,0),customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 16,0)]
],
rotate:true,
hitbox:"tallCube"
},
bigDripleaf:{
verts:[
[objectify(0,15,0,16,16,32,0)],
[objectify(0,15,16,16,16,32,0,false,true)],
[objectify(16,15,0,16,4,48,0),customFace(2,15,2, 14,15,14, 14,0,14, 2,0,2, 0,0)],
[objectify(0,15,0,16,4,48,0),customFace(14,15,2, 2,15,14, 2,0,14, 14,0,2, 0,0)],
[objectify(0,15,0,16,4,16,0,true),objectify(16,15,0,16,4,16,0),customFace(14,15,14, 2,15,2, 2,0,2, 14,0,14, 0,0)],
[objectify(0,15,16,16,4,16,0),objectify(16,15,16,16,4,16,0),customFace(2,15,14, 14,15,2, 14,0,2, 2,0,14, 0,0)]
],
rotate:true,
hitbox:"cube"
},
logicGate:{
verts:[
[objectify(0,0,0,16,16,0,0)],
[objectify(0,2,16,16,16,0,0)],
[objectify(16,2,16,16,2,0,2)],
[objectify(0,2,0,16,2,0,2)],
[objectify(16,2,0,16,2,0,14)],
[objectify(0,2,16,16,2,0,14)]
],
rotate:true
},
sign:{
verts:[
[objectify(-4,14,7,16,2,0,0),objectify(7,0,7,2,2,7,7, false,false,null,null,null,"poleTop"),objectify(12,14,7,8,2,0,0)],
[objectify(-4,26,9,16,2,0,0),objectify(12,26,9,8,2,0,0)],
[objectify(20,26,9,16,12,0,0),objectify(9,14,9,2,14,0,0, false,false,null,null,null,"poleSide"),objectify(4,26,9,8,12,0,0)],
[objectify(-4,26,7,16,12,0,0),objectify(7,14,7,2,14,0,0, false,false,null,null,null,"poleSide"),objectify(12,26,7,8,12,0,0)],
[objectify(20,26,7,2,12,0,0),objectify(9,14,7,2,14,0,0, false,false,null,null,null,"poleSide")],
[objectify(-4,26,9,2,12,0,0),objectify(7,14,9,2,14,0,0, false,false,null,null,null,"poleSide")]
],
},
wallSign:{
verts:[
[objectify(-4,6,16.7,16,2,0,0),objectify(12,6,16.7,8,2,0,0)],
[objectify(-4,18,18.7,16,2,0,0),objectify(12,18,18.7,8,2,0,0)],
[objectify(20,18,18.7,16,12,0,0),objectify(4,18,18.7,8,12,0,0)],
[objectify(-4,18,16.7,16,12,0,0),objectify(12,18,16.7,8,12,0,0)],
[objectify(20,18,16.7,2,12,0,0)],
[objectify(-4,18,18.7,2,12,0,0)]
],
},
composter:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,2,16,16,16,16,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter2:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,4,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter3:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,6,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter4:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,8,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter5:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,10,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter6:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,12,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter7:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,14,16,16,16,0,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
composter8:{
verts:[
[objectify(0,0,0,16,16,16,0)],
[objectify(0,15,16,16,16,32,0),objectify(0,16,16,14,2,66,0),objectify(14,16,16,2,14,64,0),objectify(2,16,2,14,2,64,14),objectify(0,16,14,2,14,78,2)],
[objectify(16,16,16,16,16,48,0),objectify(16,16,2,16,16,48,0)],
[objectify(0,16,0,16,16,48,0),objectify(0,16,14,16,16,48,0)],
[objectify(16,16,0,16,16,48,0),objectify(2,16,0,16,16,48,0)],
[objectify(0,16,16,16,16,48,0),objectify(14,16,16,16,16,48,0)]
]
},
cocoaStage0:{
verts:[
[objectify(6,7,11,4,4,0,0)],
[objectify(6,12,15,4,4,0,0)],
[objectify(10,12,15,4,5,11,4)],
[objectify(6,12,11,4,5,11,4)],
[objectify(10,12,11,4,5,11,4),objectify(8,16,12,4,4,12,0,true)],
[objectify(6,12,15,4,5,11,4),objectify(8,16,16,4,4,12,0)]
],
rotate:true
},
cocoaStage1:{
verts:[
[objectify(5,5,9,6,6,0,0)],
[objectify(5,12,15,6,6,0,0)],
[objectify(11,12,15,6,7,9,4)],
[objectify(5,12,9,6,7,9,4)],
[objectify(11,12,9,6,7,9,4),objectify(8,16,12,4,4,12,0,true)],
[objectify(5,12,15,6,7,9,4),objectify(8,16,16,4,4,12,0)]
],
rotate:true
},
cocoaStage2:{
verts:[
[objectify(4,3,7,8,8,0,0)],
[objectify(4,12,15,8,8,0,0)],
[objectify(12,12,15,8,9,8,4)],
[objectify(4,12,7,8,9,8,4)],
[objectify(12,12,7,8,9,8,4),objectify(8,16,12,4,4,12,0,true)],
[objectify(4,12,15,8,9,8,4),objectify(8,16,16,4,4,12,0)]
],
rotate:true
},
chair:{
verts:[
[objectify(3,6,0,10,16,0,0),objectify(3,0,14,2,2,0,0),objectify(11,0,14,2,2,0,0),objectify(3,0,0,2,2,0,0),objectify(11,0,0,2,2,0,0)],
[objectify(3,8,16,10,16,0,0),objectify(3,24,16,10,2,0,0)],
[objectify(13,8,16,10,2,0,0),objectify(5,6,16,2,6,0,0),objectify(13,6,16,2,6,0,0),objectify(5,6,2,2,6,0,0),objectify(13,6,2,2,6,0,0),objectify(13,24,16,10,16,0,0)],
[objectify(3,8,0,10,2,0,0),objectify(3,6,14,2,6,0,0),objectify(11,6,14,2,6,0,0),objectify(3,6,0,2,6,0,0),objectify(11,6,0,2,6,0,0),objectify(3,24,14,10,16,0,0)],
[objectify(13,8,0,16,2,0,0),objectify(5,6,0,2,6,0,0),objectify(13,6,0,2,6,0,0),objectify(5,6,14,2,6,0,0),objectify(13,6,14,2,6,0,0),objectify(13,24,14,2,16,0,0)],
[objectify(3,8,16,16,2,0,0),objectify(3,6,2,2,6,0,0),objectify(3,6,16,2,6,0,0),objectify(11,6,2,2,6,0,0),objectify(11,6,16,2,6,0,0),objectify(3,24,16,2,16,0,0)]
],
rotate:true
},
arrow:{
verts:[
[objectify(5.5,8,0,5,16,0,0, false,false,true)],
[objectify(5.5,8,16,5,16,0,0, false,true,true)],
[],
[objectify(5.5,10.5,1,5,5,0,5)],
[objectify(8,10.5,0,16,5,0,0, true)],
[objectify(8,10.5,16,16,5,0,0)]
]
},
spyglass:{
verts:[
[objectify(6.9,2.4,6.9,2.2,2.2,0,0, false,false,false,2,2)],
[objectify(6.9,8.6,9.1,2.2,2.2,0,5, false,false,false,2,2),objectify(7,13.5,9,2,2,0,13)],
[objectify(9.1,8.6,9.1,2.2,6.2,0,7, false,false,false,2,6),objectify(9,13.5,9,2,5,0,2)],
[objectify(6.9,8.6,6.9,2.2,6.2,0,7, false,false,false,2,6),objectify(7,13.5,7,2,5,0,2)],
[objectify(9.1,8.6,6.9,2.2,6.2,0,7, false,false,false,2,6),objectify(9,13.5,7,2,5,0,2)],
[objectify(6.9,8.6,9.1,2.2,6.2,0,7, false,false,false,2,6),objectify(7,13.5,9,2,5,0,2)]
]
},
hopper:{
verts:[
[objectify(0,10,0,16,16,0,0),objectify(4,4,4,8,8,4,4),objectify(6,0,6,4,4,6,6)],
[objectify(0,16,16,13,3,35,0),objectify(0,10,16,16,16,0,0),objectify(3,16,3,13,3,32,13),objectify(0,16,13,3,13,45,3),objectify(13,16,16,3,13,32,0)],
[objectify(16,16,16,16,6,16,0),objectify(12,10,12,8,6,20,6),objectify(10,4,10,4,4,22,12),objectify(13,16,3,10,6,19,0)],
[objectify(0,16,0,16,6,16,0),objectify(4,10,4,8,6,20,6),objectify(6,4,6,4,4,22,12),objectify(3,16,13,10,6,19,0)],
[objectify(16,16,0,16,6,16,0),objectify(12,10,4,8,6,20,6),objectify(10,4,6,4,4,22,12),objectify(3,16,3,10,6,19,0)],
[objectify(0,16,16,16,6,16,0),objectify(4,10,12,8,6,20,6),objectify(6,4,10,4,4,22,12),objectify(13,16,13,10,6,19,0)]
]
},
hopperWall:{
verts:[
[objectify(0,10,0,16,16,-16,0),objectify(4,4,4,8,8,-12,4),objectify(6,4,12,4,4,-10,6)],
[objectify(0,16,16,13,3,19,0),objectify(0,10,16,16,16,-16,0),objectify(3,16,3,13,3,16,13),objectify(0,16,13,3,13,29,3),objectify(13,16,16,3,13,16,0),objectify(6,8,16,4,4,6,12)],
[objectify(16,16,16,16,6,0,0),objectify(12,10,12,8,6,4,6),objectify(13,16,3,10,6,3,0),objectify(10,8,16,4,4,6,12)],
[objectify(0,16,0,16,6,0,0),objectify(4,10,4,8,6,4,6),objectify(3,16,13,10,6,3,0)],
[objectify(16,16,0,16,6,0,0),objectify(12,10,4,8,6,4,6),objectify(10,8,12,4,4,6,12),objectify(3,16,3,10,6,3,0)],
[objectify(0,16,16,16,6,0,0),objectify(4,10,12,8,6,4,6),objectify(6,8,16,4,4,6,12),objectify(13,16,13,10,6,3,0)]
],
rotate:true
},
comparator:{
verts:generateComparator(),
rotate:true
},
comparatorOn:{
verts:generateComparator(false,true),
rotate:true
},
comparatorSubtract:{
verts:generateComparator(true),
rotate:true
},
comparatorSubtractOn:{
verts:generateComparator(true,true),
rotate:true
},
daylightDetector:{
verts:[
[objectify(0,0,0,16,16,0,0)],
[objectify(0,6,16,16,16,0,0)],
[objectify(16,6,16,16,6,0,0)],
[objectify(0,6,0,16,6,0,0)],
[objectify(16,6,0,16,6,0,0)],
[objectify(0,6,16,16,6,0,0)]
],
},
pitcherPlant:{
verts:[
[], //bottom
[], //top
[customFace(2,11,2, 14,11,14, 14,-5,14, 2,-5,2, 0,0,16,16,"pitcherCropBottomStage4"),customFace(2,29,2, 14,29,14, 14,11,14, 2,11,2, 0,0,16,16,"pitcherCropTopStage4")], //north
[customFace(14,11,2, 2,11,14, 2,-5,14, 14,-5,2, 0,0,16,16,"pitcherCropBottomStage4"),customFace(14,29,2, 2,29,14, 2,11,14, 14,11,2, 0,0,16,16,"pitcherCropTopStage4")], //south
[customFace(14,11,14, 2,11,2, 2,-5,2, 14,-5,14, 0,0,16,16,"pitcherCropBottomStage4"),customFace(14,29,14, 2,29,2, 2,11,2, 14,11,14, 0,0,16,16,"pitcherCropTopStage4")], //east
[customFace(2,11,14, 14,11,2, 14,-5,2, 2,-5,14, 0,0,16,16,"pitcherCropBottomStage4"),customFace(2,29,14, 14,29,2, 14,11,2, 2,11,14, 0,0,16,16,"pitcherCropTopStage4")]  //west
],
},
pitcherCropStage0:{
verts:[
[objectify(5,0,5,6,6,5,5,null,null,null,null,null,"pitcherCropBottom")],
[objectify(5,4,11,6,6,5,5,null,null,null,null,null,"pitcherCropTop")],
[objectify(11,4,11,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
[objectify(5,4,5,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
[objectify(11,4,5,6,4,3,10,null,null,null,null,null,"pitcherCropSide")],
[objectify(5,4,11,6,4,3,10,null,null,null,null,null,"pitcherCropSide")]
],
hitbox:"slab"
},
pitcherCropStage1:{
verts:[
[objectify(3,0,3,10,10,3,3,null,null,null,null,null,"pitcherCropBottom")],
[objectify(3,6,13,10,10,3,3,null,null,null,null,null,"pitcherCropTop")],
[objectify(13,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,22,2, 14,22,14, 14,6,14, 2,6,2, 0,0)],
[objectify(3,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,22,2, 2,22,14, 2,6,14, 14,6,2, 0,0)],
[objectify(13,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,22,14, 2,22,2, 2,6,2, 14,6,14, 0,0)],
[objectify(3,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,22,14, 14,22,2, 14,6,2, 2,6,14, 0,0)]
],
hitbox:"cube"
},
pitcherCropStage3:{
verts:[
[objectify(3,0,3,10,10,3,3,null,null,null,null,null,"pitcherCropBottom")],
[objectify(3,6,13,10,10,3,3,null,null,null,null,null,"pitcherCropTop")],
[objectify(13,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,17,2, 14,17,14, 14,1,14, 2,1,2, 0,0),customFace(2,33,2, 14,33,14, 14,17,14, 2,17,2, 16,0)],
[objectify(3,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,17,2, 2,17,14, 2,1,14, 14,1,2, 0,0),customFace(14,33,2, 2,33,14, 2,17,14, 14,17,2, 16,0)],
[objectify(13,6,3,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(14,17,14, 2,17,2, 2,1,2, 14,1,14, 0,0),customFace(14,33,14, 2,33,2, 2,17,2, 14,17,14, 16,0)],
[objectify(3,6,13,10,6,3,10,null,null,null,null,null,"pitcherCropSide"),customFace(2,17,14, 14,17,2, 14,1,2, 2,1,14, 0,0),customFace(2,33,14, 14,33,2, 14,17,2, 2,17,14, 16,0)]
],
hitbox:"tallCube"
},
flat:{
verts:[
[objectify(0,0.25,0,16,16,0,0,false,true)],
[objectify(0,0.25,16,16,16,0,0)],
[],[],[],[]
],
hitbox:"carpet"
},
flowerbed1:{
verts:addStem1x1(addStem1x1(addStem1x1([
[objectify(8,3,8,8,8,0,0,false,true)],
[objectify(8,3,16,8,8,0,0)],
[],[],[],[]
],
11,14,3),
14,10,3),
9,9,3),
hitbox:"layer2",
rotate:true
},
flowerbed2:{
verts:addStem1x1(addStem1x1(addStem1x1([
[objectify(8,3,0,8,16,0,0,false,true)],
[objectify(8,3,8,16,16,0,0)],
[],[],[],[]
],
11,14,3),
14,10,3),
9,9,3),
hitbox:"layer2",
rotate:true
},
flowerbed3:{
verts:addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1([
[objectify(8,3,0,8,16,0,0,false,true),objectify(0,2,0,8,8,8,8,false,true)],
[objectify(8,3,16,8,16,0,0),objectify(0,2,8,8,8,8,8)],
[],[],[],[]
],
11,14,3),
14,10,3),
9,9,3),
6,6,2),
3.5,1.5,2),
1,5,2),
hitbox:"layer2",
rotate:true
},
flowerbed4:{
verts:addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1(addStem1x1([
[objectify(8,3,0,8,16,0,0,false,true),objectify(0,2,0,8,16,8,0,false,true)],
[objectify(8,3,16,8,16,0,0),objectify(0,2,16,8,16,8,0)],
[],[],[],[]
],
11,14,3),
14,10,3),
9,9,3),
6,6,2),
3.5,1.5,2),
1,5,2),
hitbox:"layer2",
rotate:true
},
fern:{
verts:[
[],[],
[customFace(16,10,0, 0,10,0, 0,0,8, 16,0,8, 0,0),customFace(0,10,0, 16,10,0, 16,0,8, 0,0,8, 16,0, -16)],
[customFace(0,10,14, 16,10,14, 16,0,8, 0,0,8, 0,0),customFace(16,10,14, 0,10,14, 0,0,8, 16,0,8, 16,0, -16)],
[customFace(2,10,0, 2,10,16, 8,0,16, 8,0,0, 0,0),customFace(2,10,16, 2,10,0, 8,0,0, 8,0,16, 16,0, -16)],
[customFace(12,10,16, 12,10,0, 8,0,0, 8,0,16, 0,0),customFace(12,10,0, 12,10,16, 8,0,16, 8,0,0, 16,0, -16)]
],
hitbox:"cube",
rotate:true
},
ceilingPanel: {
verts: [
[objectify(0, 13, 0, 16, 16, 0, 0)], //bottom
[objectify(0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 3, 0, 0)], //north
[objectify(0, 16, 0, 16, 3, 0, 0)], //south
[objectify(16, 16, 0, 16, 3, 0, 0)], //east
[objectify(0, 16, 16, 16, 3, 0, 0)]  //west
],
rotate: true
},
groundBush:{
verts:addStem1x1(addStem1x1(addStem1x1([
[objectify(0,2,0,16,16,0,0,false,true,-1), objectify(0,5,0,16,16,0,0,false,true,2), objectify(0,8,0,16,16,0,0,false,true,1)],
[objectify(0,2,16,16,16,0,0,false,false,1),objectify(0,5,16,16,16,0,0,false,false,2),objectify(0,8,16,16,16,0,0,false,false,-1)],
[],[],[],[]
],
5,2,8),
12,5,5),
9,14,8),
hitbox:"slab",
rotate:true
},
coralFan:{
verts:[
[],[],
[customFace(16,9,-6, 0,9,-6, 0,0,8, 16,0,8, 0,0),customFace(0,9,-6, 16,9,-6, 16,0,8, 0,0,8, 16,0, -16)],
[customFace(0,9,22, 16,9,22, 16,0,8, 0,0,8, 0,0),customFace(16,9,22, 0,9,22, 0,0,8, 16,0,8, 16,0, -16)],
[customFace(-6,9,0, -6,9,16, 8,0,16, 8,0,0, 0,0),customFace(-6,9,16, -6,9,0, 8,0,0, 8,0,16, 16,0, -16)],
[customFace(22,9,16, 22,9,0, 8,0,0, 8,0,16, 0,0),customFace(22,9,0, 22,9,16, 8,0,16, 8,0,0, 16,0, -16)]
],
hitbox:"cube"
},
coralWallFan:{
verts:[
[],
[
customFace(16,16,-3.8, 0,16,-3.8, 0,7,16, 16,7,16, 0,0),customFace(0,16,-3.8, 16,16,-3.8, 16,7,16, 0,7,16, 16,0, -16),
customFace(16,0,-3.8, 0,0,-3.8, 0,9,16, 16,9,16, 0,0),customFace(0,0,-3.8, 16,0,-3.8, 16,9,16, 0,9,16, 16,0, -16)],
[],[],[],[]
],
hitbox:"cube",
rotate:true
},
rail:{
verts:[
[objectify(0,1,0,16,16,0,0,false,true)],
[objectify(0,1,16,16,16,0,0)],
[],
[],
[],
[]
],
hitbox:"carpet",
rotate:true
},
railDiagonal:{
verts:[
[customFace(16,17,16, 0,17,16, 0,1,0, 16,1,0, 0,0)],
[customFace(0,17,16, 16,17,16, 16,1,0, 0,1,0, 0,0)],
[],
[],
[],
[]
],
hitbox:"cube",
rotate:true
},
item: {
verts: generateItemShape(),
},
/*cube2: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
cube3: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
cube4: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0),objectify(8,-4,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0),objectify(24,12,8,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0),objectify(8,12,-8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0),objectify(24,12,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},
cube5:{
verts:[
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0),objectify(8,-4,-8,16,16,0,0),objectify(16,8,0,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0),objectify(16,24,16,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0),objectify(24,12,8,16,16,0,0),objectify(32,24,16,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0),objectify(8,12,-8,16,16,0,0),objectify(16,24,0,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0),objectify(24,12,-8,16,16,0,0),objectify(32,24,0,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0),objectify(16,24,16,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},*/
tallCube:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 32, 16, 16, 16, 0, 0)], //top
[objectify(16, 32, 16, 16, 32, 0, 0)], //north
[objectify( 0, 32,  0, 16, 32, 0, 0)], //south
[objectify(16, 32,  0, 16, 32, 0, 0)], //east
[objectify( 0, 32, 16, 16, 32, 0, 0)]  //west
],
}
}
win.serverShapes = shapes
for(var shape = 0; shape < 8; shape ++){
shapes["layer"+(shape+1)] = {
verts: layerShape((shape+1)*2)
}
shapes["liquidLayer"+(shape+1)] = {
verts: liquidLayerShape((shape+1)*2)
}
}
function compareArr(arr, out) {
let minX = 1000
let maxX = -1000
let minY = 1000
let maxY = -1000
let minZ = 1000
let maxZ = -1000
let num = 0
for (let i = 0; i < arr.length; i += 3) {
num = arr[i]
minX = minX > num ? num : minX
maxX = maxX < num ? num : maxX
num = arr[i + 1]
minY = minY > num ? num : minY
maxY = maxY < num ? num : maxY
num = arr[i + 2]
minZ = minZ > num ? num : minZ
maxZ = maxZ < num ? num : maxZ
}
out[0] = minX
out[1] = minY
out[2] = minZ
out[3] = maxX
out[4] = maxY
out[5] = maxZ
return out
}
function copyArr(a, b) {
for (let i = 0; i < a.length; i++) {
b[i] = a[i]
}
}
function arrayValuesEqual(a1,a2){
if(a1.length !== a2.length) return false
let minLen = a1.length
for(var i=0; i<minLen; i++){
if(a1[i] !== a2[i]){
return false
}
}
return true
}
function compareMaps(map1, map2) {//from https://stackoverflow.com/questions/35948335/how-can-i-check-if-two-map-objects-are-equal
let testVal;
if (map1.size !== map2.size) {
return false;
}
for (let [key, val] of map1) {
testVal = map2.get(key);
// in cases of an undefined value, make sure the key
// actually exists on the object so there are no false positives
if (testVal !== val || (testVal === undefined && !map2.has(key))) {
return false;
}
}
return true;
}
let defaultWorldSettings = {
tntExplode:true,
killCmdOff:false,
dayNightCycle: true,
blocksFall: true,
attack: true,
fireSpreads: true,
weatherCycle: true,
mobSpawning: true,
autosave: true
}
let worldSettingKeys = Object.keys(defaultWorldSettings)
win.defaultWorldSettings = defaultWorldSettings
const {DoubleToIEEE, IEEEToDouble} = (function(){
let tempArrayBuffer = new ArrayBuffer(8)
let tempUint32 = new Uint32Array(tempArrayBuffer), tempFloat64 = new Float64Array(tempArrayBuffer)
return {
DoubleToIEEE(f) {
tempFloat64[0] = f
return tempUint32
},
IEEEToDouble(a,b) {
tempUint32[0] = a
tempUint32[1] = b
return tempFloat64[0]
}
}
})()
const textEncoder = new TextEncoder(), textDecoder = new TextDecoder()
class BitArrayBuilder {
//chaning this requires changing server side
constructor() {
this.bitLength = 0
this.data = [] // Byte array
}
add(num, bits) {
if (+num !== +num || +bits !== +bits || +bits < 0) throw new Error("Broken")
num &= -1 >>> 32 - bits
if(Math.log2(num) >= bits) throw new Error("too big")
let index = this.bitLength >>> 3
let openBits = 8 - (this.bitLength & 7)
this.bitLength += bits
while (bits > 0) {
this.data[index] |= openBits >= bits ? num << openBits - bits : num >>> bits - openBits
bits -= openBits
index++
openBits = 8
}
return this // allow chaining like arr.add(x, 16).add(y, 8).add(z, 16)
}
addDouble(num){
let [a,b] = DoubleToIEEE(num)
this.add(a,32), this.add(b,32)
}
addBasicString(str, lenBits = 8){
this.add(min(str.length,255),lenBits)
for(let c of str.substring(0,255)) this.add(c.charCodeAt(0),8)
}
addString(str,lenBits = 8){
if(!str.length) return this.add(0,lenBits)
let arr = textEncoder.encode(str), len = arr.length
this.add(len,lenBits)
this.appendArray(arr.subarray(0,len))
}
/**
* Takes all the bits from another BAB and adds them to this one.
* @param {BitArrayBuilder} bab The BAB to append
*/
append(bab) {
// If our bits are already aligned, just add them directly
if ((this.bitLength & 7) === 0) {
this.data.push(...bab.data)
this.bitLength += bab.bitLength
return
}
// Add them 1 at a time, except for the last one
let bits = bab.bitLength
let i = 0
while (bits > 7) {
this.add(bab.data[i++], 8)
bits -= 8
}
if (bits) {
this.add(bab.data[i] >>> 8 - bits, bits)
}
}
appendArray(arr){//same as above, but for Uint8Array
if ((this.bitLength & 7) === 0) {
this.data.push(...arr)
this.bitLength += arr.length*8
return
}
for(let i of arr) this.add(i, 8)
}
appendInt16Array(arr){//same as above, but for Int16Array
for(let i of arr) this.add(i, 16)
}
get array() {
return new Uint8Array(this.data)
}
/**
* @param {Number} num
* @returns The number of bits required to hold num
*/
static bits(num) {
return Math.ceil(Math.log2(num))
}
}
win.BitArrayBuilder = BitArrayBuilder
class BitArrayOverwriter extends BitArrayBuilder{
constructor(data){
super()
this.data = data
}
skip(bits){
this.bitLength += bits
return this
}
overwrite(num, bits){
if (+num !== +num || +bits !== +bits || +bits < 0) throw new Error("Broken")
num &= -1 >>> 32 - bits
if(Math.log2(num) >= bits) throw new Error("too big")
let index = this.bitLength >>> 3
let openBits = 8 - (this.bitLength & 7)
this.bitLength += bits
while (bits > 0) {
if(openBits >= bits){
this.data[index] = (this.data[index] & (~(((1 << bits)-1)<<(openBits - bits)))) | (num << openBits - bits)
}else{
this.data[index] = (this.data[index] & (~((1 << openBits)-1))) | (num >>> bits - openBits)
}
bits -= openBits
index++
openBits = 8
}
return this // allow chaining like arr.add(x, 16).add(y, 8).add(z, 16)
}
}
win.BitArrayOverwriter = BitArrayOverwriter
class BitArrayReader {
//chaning this requires changing server side
/**
* @param {Uint8Array} array An array of values from 0 to 255
*/
constructor(array, allowPassLength) {
this.data = array // Byte array; values are assumed to be under 256
this.bit = 0
this.allowPassLength = allowPassLength
}
get canRead(){
return this.bit < this.data.length*8
}
read(bits, negative = false) {
let openBits = 32 - bits
let { data, bit } = this
this.bit += bits // Move pointer
if (bit > data.length * 8 && !this.allowPassLength) {
throw new Error("Cannot read more bits")
}
let unread = 8 - (bit & 7)
let index = bit >>> 3
let ret = 0
while (bits > 0) {
let n = data[index] & -1 >>> 32 - unread
ret |= bits >= unread ? n << bits - unread : n >> unread - bits
bits -= unread
unread = 8
index++
}
if (negative) {
// console.log("Negative", ret, ret << openBits >> openBits)
return ret << openBits >> openBits
}
return ret
}
readDouble(){
return IEEEToDouble(this.read(32),this.read(32))
}
readBasicString(lenBits = 8){
let len = this.read(lenBits)
let str = ""
for (let i = 0; i < len; i++) str += String.fromCharCode(this.read(8))
return str
}
readString(lenBits = 8){
let len = this.read(lenBits)
if(!len) return ""
let arr = new Uint8Array(len)
for(let i=0; i<len; i++){
arr[i] = this.read(8)
}
return textDecoder.decode(arr)
}
readToNew(bits, allowPassLength){
let ret = new Uint8Array(ceil(bits/8))
let idx = 0
while(bits){
let next = min(bits,8)
bits -= next
ret[idx] = this.read(next) << (8-next)
idx++
}
return new BitArrayReader(ret, allowPassLength)
}
readToArrayBits(bits){
let ret = new Uint8Array(ceil(bits/8))
let idx = 0
while(bits){
let next = min(bits,8)
bits -= next
ret[idx] = this.read(next) << (8-next)
idx++
}
return ret
}
readToArray(length){
let ret = new Uint8Array(length)
for(let i = 0; i < length; i++){
ret[i] = this.read(8)
}
return ret
}
readToInt16Array(length){
let ret = new Uint8Array(length)
for(let i = 0; i < length; i++){
ret[i] = this.read(16, true)
}
return ret
}
skip(bits){
if (this.bit > this.data.length * 8 && !this.allowPassLength) {
throw new Error("Cannot read more bits")
}
this.bit += bits
}
}
win.BitArrayReader = BitArrayReader
/*
Each item in packetTypes is an array.
The array starts with the name of the packet,
then contains more arrays with property, type, and other things.
These are the types:
string, number, bitArray, array, object, boolean,
replacerNumber, mapObject, json, double, int16Array,
includeIf, constant, basicString, int, uint, byte,
sparseArray
For numbers, there are 3 more items that are
the amount of bits needed and how much to
multiply the number by (for precision) and a
boolean that shows if the number can be negative.
For arrays and mapObjects and sparseArrays, there is another item that is the type
of things that it will contain.
For objects, there is another item that contains
arrays, each with a property and a type.
For replacerNumbers, there are two more items
which contains the bits, then an object that
contain things to replace.
For includeIf, there the property name is replaced
with a function that checks returns a boolean.
If the function returns true, the things in the
3rd item are included.
*/
const packetDimension = ['dimension',"replacerNumber",3,["","nether","end"]]
//const packetInv = ["inv","object",[["inv","bitArray"],["survivStr","bitArray"],[o=>o.x!==undefined,"includeIf",[["x","int"],["y","int"],["z","int"]]]]]
const packetGameMode = ['gameMode',"replacerNumber",2,["creative","survival","hardcore","spectator"]]
const packetSlot = [null,"object",[["id","uint"],["amount","byte"],[o=>o.durability!==undefined,"includeIf",["durability","uint"]],[o=>o.customName,"includeIf",["customName","string"]]]]
const packetP = [
['x',"double"], ['y',"double"], ['z',"double"],packetDimension, ['ry',"double"], ['rx',"double"], ['bodyRot',"double"],
['sneaking',"boolean"], ['username',"string"], ['harmEffect',"number",6,1],
[o=>o.crackPos,'includeIf',[['crackPos',"array",[null,"int"]]]], ['crack',"number",5,1,true], ['burning',"boolean"], ['holding',"uint"], ['walking',"boolean"], ['eating',"boolean"], ['sprinting',"boolean"], ['punchEffect',"number",8,8],
['sleeping',"boolean"], ['sitting',"boolean"], ['swimming',"boolean"], ['usingItem',"boolean"], ['hidden',"boolean"], ['spectating',"basicString"], ['scale',"double"],
["velx","double"],["vely","double"],["velz","double"], ["die","boolean"], ["riding","basicString"], ["onGround","boolean"], ["flying",'boolean']
]
const packetFace = ["face","replacerNumber",3,[undefined/*for no face*/,"bottom","top","north","south","east","west"]]
let packetTypes = [
["connect",["id","basicString"]],
["pos",["data","object",packetP],["afk","boolean"]],
["mySkin", ["data","string"], ["cape","string"]],
["settings", ["data","object",worldSettingKeys.map(r => [r,"boolean"])],["time","double"],["weather","replacerNumber",2,["","rain","snow"]]],
["setBlock", ["data","object",[["x","int"],["y","int"],["z","int"],packetDimension,["block","uint"],["keepTags","boolean"]]]],
["loadSave", /*["data","bitArray"], ["stringChunks","number",8,1]*/ ["mod","string"],["id","basicString"],["name","string"],["activeResourcePacks","array",[null,"string"]],["x","double"],["y","double"],["z","double"],["version","basicString"],["time","double"],["weather","replacerNumber",2,["","rain","snow"]],packetGameMode,["cheats","boolean"],["hotbarSlot","byte"],["flying",'boolean'],["achievments","array",[null,"uint"]]],
//["loadSaveChunk", ["data","bitArray"],["idx","number",8,1]],
["resourcePacks",["activeResourcePacks","array",[null,"string"]]],
["serverCmds",["data","array",[null,"object",["type","basicString"],["name","basicString"],["id","uint"],["next","array",[null,"uint"]],[o=>o.redirect!==undefined,"includeIf",["redirect","uint"]],["info","string"],["argType","basicString"],["func","boolean"],["noCheats","boolean"]]]],
["saveProg",["data","basicString"]],
["canSendPos"],
["setTags",["x","int"],["y","int"],["z","int"],packetDimension,["data","json"],["lazy","boolean"]],
["serverChangeBlock",["x","int"],["y","int"],["z","int"],packetDimension,["place","boolean"],packetFace,["shift","boolean"],["blockMode","uint"]],
["entityPos",["data","bitArray"]],
["entityDelete",["id","basicString"]],
["entityPosAll", ["data","array",[null,"bitArray"]]],
//["entEvent",["id","basicString"],["event","basicString"],["data","json"]],
["particles",["particleType","basicString"],["x","double"],["y","double"],["z","double"],packetDimension,["amount","byte"],["data","json"]],
["achievment",["data","uint"]],
//["hit",["damageType","basicString"],["damage","byte"],["velx","double"],["vely","double"],["velz","double"],["username","string"],["id","basicString"],["message","string"],["x","double"],["y","double"],["z","double"],["holding","json"],["burn","number",8,4],["isEntity","boolean"]],
["harmEffect",["id","basicString"]],
["die",["id","basicString"],["message","string"]],
["message",["username","string"],["data","string"],["fromServer","boolean"]],
["playSound",["x","double"],["y","double"],["z","double"],["data","string"],["volume","double"],["pitch","double"],["hasPos","boolean"]],
["title",["data","string"],["sub","string"],["color","string"],["fadeIn","number",32,1],["fadeOut","number",32,1],["stay","number",32,1]],
["remoteControl",["event","basicString"],["key","basicString"],["x","double"],["y","double"]],
["eval",["data","string"]], ["safeEval",["data","json"]],
["error",["data","string"]],
["joined"],
//["serverCmd",["data","string"],["args","json"],["id","string"],["scope","json"]],
["runCmd",["data","string"]],
["loadChunks",["data","array",[null,"int"]],["loadDistance","number",6,1],packetDimension],
["chunkData",["x","int"],["z","int"],["data","bitArray"],["tops","int16Array"],["solidTops","int16Array"],["biomes","bitArray"],["caveY","int16Array"],["caveBiomes","bitArray"]],
["tp",['x',"double"],['y',"double"],['z',"double"],packetDimension],
//["commandDone",["id","string"],["data","json"],["scope","json"]],
["clientCmd",["data","basicString"],["args","json"]],
["dc",["data","basicString"]],
["fetchUsers"],
//["entClick",["id","string"],["holding","uint"],["fromItem","json"]],
["effects",["data","mapObject",[null,"object",[["name","string"],["level","byte"],["time","int"],["showParticles","boolean"]]]]],
["gameMode",packetGameMode,["spectating","basicString"],["spectateRemoteControl","boolean"]],
["openContainer",["data","string"],["x","int"],["y","int"],["z","int"],packetDimension,["side","boolean"]],
//["containerData",["data","sparseArray",packetSlot]],
["containerChange",["data","sparseArray",packetSlot],["idxs","array",[null,"int"]]],
["hotbar",["slot","byte"]],
["entInteract",["data","basicString"],["hit","boolean"],["cooldown","double"]],
["respawn"],
["health",["health","double"],["food","double"],["foodSaturation","double"],["oxygen","double"],["burning","boolean"],["freezeEffect","uint"],["XP","double"],["level","uint"],["nextLevel","uint"]],
["damage",["x","double"],["y","double"],["z","double"],["lastHealth","double"],["velx","double"],["vely","double"],["velz","double"]],
["jump"], ["sleep"], ["sit",["riding","basicString"]],
["rot",["rx","double"],["ry","double"],["bodyRot","double"]],
["closeContainer"],
["containerChangeFurnace",["burnProgress","double"],["progress","double"]],
["containerChangeAnvil",["rename","string"],["cost","uint"]],
["containerChangeCommandBlock",["data","string"]],
["startBreak",["x","int"],["y","int"],["z","int"]],
["containerChangeSign",["data","string"],["side","boolean"]],
["portalOut"], ["doEndPoem"]
/*["test",
["a",'string'],['n','number',8,4],
["data","array",[null,"string"]],
['n2','number',32,1]
]*/
]
win.unorderedPackets = new Set(["chunkData"])
let packetNames = []
let packetIds = {}, defaultPacketData = [["FROM","string"],["USER","string"],["TO","string"]]
for(let i=0; i<packetTypes.length; i++){
let t = packetTypes[i]
if(!t) throw new Error("after "+packetNames[i-1])
packetIds[t[0]] = i
packetNames[i] = t[0]
t.shift()
t.unshift(...defaultPacketData)
}
win.packetTypes = packetTypes
function packetPartToBitArray(i,bab,v){
switch(i[1]){
case "number":
bab.add((v||0)*i[3],i[2])
break
case "json":
v = v ? JSON.stringify(v) : ""
case "string":
if(v){
v = v+""
bab.addString(v,32)
}else bab.add(0,32)
break
case "bitArray":
if(v){
bab.add(v.length,32)
bab.appendArray(v)
}else bab.add(0,32)
break
case "int16Array":
if(v){
bab.add(v.length,32)
bab.appendInt16Array(v)
}else bab.add(0,32)
break
case "array":
bab.add(v.length,32)
for(let j of v){
packetPartToBitArray(i[2],bab,j)
}
break
case "object":
bab.add(v?1:0,1)
if(v) packetToBitArrayLoop(i[2],v,bab)
break
case "boolean":
bab.add(v?1:0,1)
break
case "replacerNumber":
let idx = i[3].indexOf(v)
if(idx === -1) throw new Error("Unknown replacer number for "+v)
bab.add(idx,i[2])
break
case "mapObject":
bab.add(Object.keys(v).length,32)
for(let j in v){
bab.addString(j,8)
packetPartToBitArray(i[2],bab,v[j])
}
break
case "constant":
bab.add(i[2],8)
break
case "basicString":
bab.addBasicString((v||"")+"")
break
case "int":
case "uint":
bab.add(v,32)
break
case "byte":
bab.add(v,8)
break
case "double":
bab.addDouble(v)
break
case "sparseArray":
bab.add(v.length,32)
for(let j of v){
bab.add(j?1:0,1)
if(j) packetPartToBitArray(i[2],bab,j)
}
break
}
}
function packetToBitArrayLoop(type,obj,bab){
for(let i of type){
if(i[1] === "includeIf"){
if(i[0](obj)){
bab.add(1,1)
packetToBitArrayLoop(i[2],obj,bab)
}else bab.add(0,1)
continue
}
const v = obj[i[0]]
packetPartToBitArray(i,bab,v)
}
}
function packetToBitArray(obj, type, returnBAB){
let bab
if(type){
bab = new BitArrayBuilder()
}else{
let id = packetIds[obj.type]
type = packetTypes[id]
if(!type) throw new Error("Unknown packet type: "+obj.type)
bab = new BitArrayBuilder()
bab.add(id,8)
}
packetToBitArrayLoop(type,obj,bab)
return returnBAB ? bab : bab.array
}
win.packetToBitArray = packetToBitArray
function bitArrayToPacketPart(i,reader){
switch(i[1]){
case "number":
return reader.read(i[2],i[4])/i[3]
case "string":
return reader.readString(32)
case "bitArray":
let len = reader.read(32)
return reader.readToArray(len)
case "array":
let len2 = reader.read(32), arr = []
for(let j=0; j<len2; j++){
arr.push(bitArrayToPacketPart(i[2],reader))
}
return arr
case "object":
if(reader.read(1)){
let obj = {}
bitArrayToPacketLoop(i[2],obj,reader)
return obj
}else return
case "boolean":
return reader.read(1)
case "replacerNumber":
return i[3][reader.read(i[2])]
case "mapObject":
let len3 = reader.read(32)
let obj = {}
for(let j=0; j<len3; j++){
obj[reader.readString()] = bitArrayToPacketPart(i[2],reader)
}
return obj
case "json":
let str2 = reader.readString(32)
return str2 ? JSON.parse(str2) : undefined
case "int16Array":
let len4 = reader.read(32)
return reader.readToInt16Array(len4)
case "constant":
return reader.read(8)
case "basicString":
return reader.readBasicString()
case "int":
return reader.read(32,true)
case "uint":
return reader.read(32)
case "byte":
return reader.read(8)
case "double":
return reader.readDouble()
case "sparseArray":
let len5 = reader.read(32), arr2 = []
for(let j=0; j<len5; j++){
arr2.push(reader.read(1) ? bitArrayToPacketPart(i[2],reader) : undefined)
}
return arr2
}
}
function bitArrayToPacketLoop(type,obj,reader){
for(let i of type){
if(i[1] === "includeIf"){
if(reader.read(1)){
bitArrayToPacketLoop(i[2],obj,reader)
}
continue
}
obj[i[0]] = bitArrayToPacketPart(i,reader)
}
}
function bitArrayToPacket(arr,type){
let reader = arr instanceof BitArrayReader ? arr : new BitArrayReader(arr)
let obj
if(type){
obj = {}
}else{
let id = reader.read(8)
type = packetTypes[id], obj = {type:packetNames[id]}
}
bitArrayToPacketLoop(type,obj,reader)
return obj
}
win.bitArrayToPacket = bitArrayToPacket
function initShapes() {
function mapCoords(rect, face) {
if(rect.custom) return mapCustomCoords(rect)
let x = rect.x
let y = rect.y
let z = rect.z
let w = rect.w
let h = rect.h
let tx = rect.tx
let ty = rect.ty
let tw = rect.tw
let th = rect.th
let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
if(rect.rt){
if(rect.rt === -1){
tex[0] = tx+th
tex[5] = ty+tw
tex[6] = tx+th
tex[7] = ty+tw
tex.unshift(...tex.splice(tex.length-2,2))
}else if(rect.rt === 2){
tex.push(...tex.splice(0,4))
}else{
tex[0] = tx+th
tex[5] = ty+tw
tex[6] = tx+th
tex[7] = ty+tw
tex.push(...tex.splice(0,2))
}
}
if(rect.txf){
tex[0] = tw-(tex[0]-tx)+tx
tex[2] = tw-(tex[2]-tx)+tx
tex[4] = tw-(tex[4]-tx)+tx
tex[6] = tw-(tex[6]-tx)+tx
}
if(rect.tyf){
tex[1] = th-(tex[1]-ty)+ty
tex[3] = th-(tex[3]-ty)+ty
tex[5] = th-(tex[5]-ty)+ty
tex[7] = th-(tex[7]-ty)+ty
}
let pos = null, normal = null
switch(face) {
case 0: // Bottom
pos = [x,y,z, x+w,y,z, x+w,y,z+h, x,y,z+h]
normal = [0,1,0]
break
case 1: // Top
pos = [x,y,z, x+w,y,z, x+w,y,z-h, x,y,z-h]
normal = [0,-1,0]
break
case 2: // North
pos = [x,y,z, x-w,y,z, x-w,y-h,z, x,y-h,z]
normal = [0,0,-1]
break
case 3: // South
pos = [x,y,z, x+w,y,z, x+w,y-h,z, x,y-h,z]
normal = [0,0,1]
break
case 4: // East
pos = [x,y,z, x,y,z+w, x,y-h,z+w, x,y-h,z]
normal = [-1,0,0]
break
case 5: // West
pos = [x,y,z, x,y,z-w, x,y-h,z-w, x,y-h,z]
normal = [1,0,0]
break
}
pos = pos.map(c => c / 16 - 0.5)
let minmax = compareArr(pos, [])
pos.max = minmax.splice(3, 3)
pos.min = minmax
tex = tex.map(c => c / 16 / 16)
return {
pos,
tex,
normal
}
}
function mapCustomCoords(coords){
let {x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th} = coords
let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
let pos = [x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4]
pos = pos.map(c => c / 16 - 0.5)
let minmax = compareArr(pos, [])
pos.max = minmax.splice(3, 3)
pos.min = minmax
tex = tex.map(c => c / 16 / 16)
vec1.set(x2-x,y2-y,z2-z)
vec1.crossProduct(x3-x,y3-y,z3-z,vec3)
vec2.set(x3-x,y3-y,z3-z)
vec2.crossProduct(x4-x,y4-y,z4-z,vec4)
vec3.normalize(), vec4.normalize()
let normal = [(vec3.x+vec4.x)/2, (vec3.y+vec4.y)/2, (vec3.z+vec4.z)/2]
return {pos,tex,normal}
}
// 90 degree clockwise rotation; returns a new shape object
function rotate(shape, bit) {
let verts = shape.verts
let texVerts = shape.texVerts
let pos = []
let normal = []
let tex = []
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
pos[i] = []
tex[i] = []
normal[i] = []
for (let j = 0; j < side.length; j++) {
let face = side[j]
let c = []
pos[i][j] = c
for (let k = 0; k < face.length; k += 3) {
c[k] = face[k + 2]
c[k + 1] = face[k + 1]
c[k + 2] = -face[k]
}
tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
if (i === 0) {
// Bottom
c.push(...c.splice(0, 3))
tex[i][j].push(...tex[i][j].splice(0, 2))
}
if (i === 1) {
// Top
c.unshift(...c.splice(-3, 3))
tex[i][j].unshift(...tex[i][j].splice(-2, 2))
}
let minmax = compareArr(c, [])
c.max = minmax.splice(3, 3)
c.min = minmax
normal[i][j] = shape.normal[i][j].slice()
let temp = normal[i][j][0]
normal[i][j][0] = normal[i][j][2]
normal[i][j][2] = -temp
}
}
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
temp = pos[2] // North
pos[2] = pos[5] // North = West
pos[5] = pos[3] // West = South
pos[3] = pos[4] // South = East
pos[4] = temp // East = North
temp = normal[2] // North
normal[2] = normal[5] // North = West
normal[5] = normal[3] // West = South
normal[3] = normal[4] // South = East
normal[4] = temp // East = North
return {
verts: pos,
texVerts: tex,
normal,
rotate: true,
flip: shape.flip,
size: shape.size,
varients: shape.varients,
bit: bit,
rotated: true,
rotateTimes: (shape.rotateTimes || 0) + 1,
originalVerts: shape.originalVerts,
hitbox: shape.hitbox
}
}
// Reflect over the y plane; returns a new shape object
function flip(shape, bit) {
let verts = shape.verts
let texVerts = shape.texVerts
let pos = []
let normal = []
let tex = []
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
pos[i] = []
tex[i] = []
normal[i] = []
for (let j = 0; j < side.length; j++) {
let face = side[j].slice().reverse()
let c = []
pos[i][j] = c
for (let k = 0; k < face.length; k += 3) {
c[k] = face[k + 2]
c[k + 1] = -face[k + 1]
c[k + 2] = face[k]
}
let minmax = compareArr(c, [])
c.max = minmax.splice(3, 3)
c.min = minmax
tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
normal[i][j] = shape.normal[i][j].slice()
normal[i][j][1] = -normal[i][j][1]
}
}
let temp = pos[0] // Bottom
pos[0] = pos[1] // Bottom = Top
pos[1] = temp // Top = Bottom
temp = tex[0] // Bottom
tex[0] = tex[1] // Bottom = Top
tex[1] = temp // Top = Bottom
temp = normal[0] // Bottom
normal[0] = normal[1] // Bottom = Top
normal[1] = temp // Top = Bottom
return {
verts: pos,
texVerts: tex,
normal,
rotate: shape.rotate,
flip: shape.flip,
size: shape.size,
varients: shape.varients,
bit: bit,
originalVerts: shape.originalVerts
}
}
for (let shape in shapes) {
win.sh = shape
let obj = shapes[shape]
let verts = obj.verts
obj.size = verts[0].length + verts[1].length + verts[2].length + verts[3].length + verts[4].length + verts[5].length
obj.texVerts = []
obj.varients = []
obj.normal = []
if(typeof obj.hitbox === "string"){
obj.hitbox = shapes[obj.hitbox]
}
obj.originalVerts = []
for(let i=0; i<verts.length; i++){
obj.originalVerts[i] = verts[i].slice()
}
// Populate the vertex coordinates
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
let texArr = []
obj.texVerts.push(texArr)
let normal = obj.normal[i] = []
for (let j = 0; j < side.length; j++) {
let face = side[j]
let mapped = mapCoords(face, i)
side[j] = mapped.pos
texArr.push(mapped.tex)
normal[j] = mapped.normal
}
}
if (obj.rotate) {
let v = obj.varients
let east = rotate(obj, 4<<10)
let south = rotate(east, 2<<10)
let west = rotate(south, 6<<10)
v[0] = obj
v[2] = south
v[4] = east
v[6] = west
}
if (obj.flip) {
let v = obj.varients
v[1] = flip(obj,1<<10)
if (obj.rotate) {
v[3] = flip(v[2], 3<<10)
v[5] = flip(v[4], 5<<10)
v[7] = flip(v[6], 7<<10)
}
}
}
function makeBlock(tex,shape,Block, base, Name){
Block.textures = tex
Block.shape = shape
Block.shadow = base ? base.shadow : true
Block.transparent = base ? base.transparent : false
Block.solid = base ? base.solid : true
if(Name) Block.Name = Name
}
function rotTex(tex,n){
tex = tex.slice()
if(n){
for(var i=0; i<n; i++){
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
}
}else{
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
}
return tex
}
var buttonOnclick = function(x,y,z,dimension,world){
var off = this.id | BUTTON
var on = this.id | SLAB
var target = null
switch(world.getBlock(x,y,z,dimension)){
case off | NORTH:
target = on | NORTH
break
case off | SOUTH:
target = on | SOUTH
break
case off | EAST:
target = on | EAST
break
case off | WEST:
target = on | WEST
}
if(target){
world.setBlock(x,y,z,target, false,false,false,false,dimension)
}
}
var buttonProjectileHit = function(x,y,z,dimension,ent){
let world = ent.world
this.onclick(x,y,z,dimension,world)
}
var buttonOnupdate = function(x,y,z,b,world,sx,sy,sz,dimension){
var off = this.id | BUTTON
var on = this.id | SLAB
var target = null
var ax=x,ay=y,az=z, dir
var block = world.getBlock(x,y,z,dimension)
switch(block){
case on | NORTH:
case off | NORTH:
az++
dir = "south"
break
case on | SOUTH:
case off | SOUTH:
az--
dir = "north"
break
case on | EAST:
case off | EAST:
ax++
dir = "east"
break
case on | WEST:
case off | WEST:
ax--
dir = "west"
break
}
var hasPower
switch(block){
case on | NORTH:
target = off | NORTH
hasPower = true
break
case on | SOUTH:
target = off | SOUTH
hasPower = true
break
case on | EAST:
target = off | EAST
hasPower = true
break
case on | WEST:
target = off | WEST
hasPower = true
break
}
if(hasPower && !world.getPower(x,y,z,dimension)){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,16,dimension)
world.setBlockPower(ax,ay,az,"strong",dir,dimension)
world.playSound(x,y,z, "click",1,0.6)
world.setTimeout(function(){
world.setBlock(x,y,z,target, false,false,false,false,dimension)
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(ax,ay,az,null,dir,dimension)
world.playSound(x,y,z, "click",1,0.5)
},this.stone ? tickTime*20 : tickTime*30, x,y,z,dimension)
}
}
var pressurePlateActivate = function(x,y,z,dimension,block,ent,world){
if(this.heavyWeighted || this.lightWeighted) return //not going to do those yet
if(world.getBlock(x,y,z,dimension) === this.id && pressurePlateHasPressure(x,y,z,dimension,world)){
world.setBlock(x,y,z, this.id | SLAB, false,false,false,false,dimension)
}
}
var pressurePlateOnupdate = function(x,y,z,b,world,sx,sy,sz,dimension){
var block = world.getBlock(x,y,z,dimension)
if(block === (this.id | SLAB) && !world.getPower(x,y,z,dimension)){
world.setPower(x,y,z,16,false,dimension)
world.spreadPower(x,y,z,16,dimension)
world.setBlockPower(x,y-1,z,"strong","top",dimension)
world.playSound(x,y,z, "click",1,0.6)
var me = this
var i = setInterval(function(){
if(pressurePlateHasPressure(x,y,z,dimension,world)) return
clearInterval(i)
world.setTimeout(function(){
world.setBlock(x,y,z,me.id, false,false,false,false,dimension)
world.setPower(x,y,z,0,false,dimension)
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(x,y-1,z,null,"top",dimension)
world.playSound(x,y,z, "click",1,0.5)
}, tickTime*20, x,y,z,dimension)
}, tickTime*2)
}
}
var logicGateOnupdate = function(x,y,z,b,w,sx,sy,sz,dimension){
this.onpowerupdate(x,y,z,null,null,null,null,dimension,w)
}
var logicGateOndelete = function(x,y,z,prevTags,prevBlock,dimension,world){
world.unspreadPower(x,y,z,16,false,dimension)
world.setBlockPower(x,y,z+1,null,"south",dimension)
world.setBlockPower(x,y,z-1,null,"north",dimension)
world.setBlockPower(x+1,y,z,null,"east",dimension)
world.setBlockPower(x-1,y,z,null,"west",dimension)
}
var logicGateOnpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var block = world.getBlock(x,y,z,dimension)
var px = 0, pz = 0
switch(block){
case this.id | NORTH:
case this.id | SLAB | NORTH:
pz++
break
case this.id | SOUTH:
case this.id | SLAB | SOUTH:
pz--
break
case this.id | EAST:
case this.id | SLAB | EAST:
px++
break
case this.id | WEST:
case this.id | SLAB | WEST:
px--
break
}
var shouldBeOn = this.shouldBeOn(x,y,z,dimension,px,pz,world)
var isOn = false
var target, tx = x, ty = y, tz = z, side
switch(block){
case this.id | NORTH:
target = this.id | SLAB | NORTH
tz++
side = "south"
break
case this.id | SOUTH:
target = this.id | SLAB | SOUTH
tz--
side = "north"
break
case this.id | EAST:
target = this.id | SLAB | EAST
tx++
side = "east"
break
case this.id | WEST:
target = this.id | SLAB | WEST
tx--
side = "west"
break
case this.id | SLAB | NORTH:
isOn = true
target = this.id | NORTH
tz++
side = "south"
break
case this.id | SLAB | SOUTH:
isOn = true
target = this.id | SOUTH
tz--
side = "north"
break
case this.id | SLAB | EAST:
isOn = true
target = this.id | EAST
tx++
side = "east"
break
case this.id | SLAB | WEST:
isOn = true
target = this.id | WEST
tx--
side = "west"
break
}
var tblock = world.getBlock(tx,ty,tz,dimension)
if(tblock && blockData[tblock].carryRedstone){
if(isOn){
if(world.getPower(tx,ty,tz,dimension) !== 15){
world.setPower(tx,ty,tz,15,false,dimension)
world.spreadPower(tx,ty,tz,15,dimension)
}
}
}else if(tblock && !blockData[tblock].transparent){
if(isOn){
world.setBlockPower(tx,ty,tz,"strong",side,dimension)
}else{
world.setBlockPower(tx,ty,tz,null,side,dimension)
}
}
if(isOn !== shouldBeOn){
var t = function(){
world.setBlock(x,y,z,target,false,false,false,false,dimension)
var tblock = world.getBlock(tx,ty,tz,dimension)
if(shouldBeOn){
if(tblock && blockData[tblock].carryRedstone){
world.setPower(tx,ty,tz,15,false,dimension)
world.spreadPower(tx,ty,tz,15,dimension)
}else if(tblock && !blockData[tblock].transparent){
world.setBlockPower(tx,ty,tz,"strong",side,dimension)
}
}else{
if(tblock && blockData[tblock].carryRedstone){
world.unspreadPower(tx,ty,tz,15,true,dimension)
}else if(tblock && !blockData[tblock].transparent){
world.setBlockPower(tx,ty,tz,null,side,dimension)
}
}
}
world.setTimeout(t,tickTime*2, x,y,z,dimension)
}
}
var logicGateGetFacing = function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
switch(block){
case this.id | NORTH:
case this.id | SLAB | NORTH:
return "north"
case this.id | SOUTH:
case this.id | SLAB | SOUTH:
return "south"
case this.id | EAST:
case this.id | SLAB | EAST:
return "east"
case this.id | WEST:
case this.id | SLAB | WEST:
return "west"
}
}
var logicGateCanHavePower = function(rx,ry,rz,x,y,z,dimension,world){
var tx = rx, ty = ry, tz = rz, on
var block = world.getBlock(rx,ry,rz,dimension)
switch(block){
case this.id | NORTH | SLAB:
on = true
case this.id | NORTH:
tz++
break
case this.id | SOUTH | SLAB:
on = true
case this.id | SOUTH:
tz--
break
case this.id | EAST | SLAB:
on = true
case this.id | EAST:
tx++
break
case this.id | WEST | SLAB:
on = true
case this.id | WEST:
tx--
break
}
if(on && tx === x && ty === y && tz === z){
return 15
}
return 0
}
var signOnplace = function(x,y,z, dimension, player,world){
var block = world.getBlock(x,y,z,dimension)
var tags = {sign:true}
var rot = round(player.ry*16/Math.PId)
if((block & STAIR) === STAIR) rot = round(rot/4)*4
tags.rot = rot
world.setTags(x,y,z,tags,false,dimension)
}
var signOnclick = function(x,y,z,dimension,world,p){
if(p.holding && blockData[p.holding].dye){
world.setTagByName(x,y,z, "color",colors.dye[blockData[p.holding].dye].slice(),false,dimension)
}else if(p.holding && p.holding === blockIds.glowInkSac){
let side = getSignSide(world.getTags(x,y,z,dimension),p) ? "glow2" : "glow"
world.setTagByName(x,y,z, side,true,false,dimension)
}else{
p.connection.send({type:"openContainer",data:"sign",x,y,z,dimension})
}
}
var itemFrameOnclick = function(x,y,z, dimension,world, p){
var prev = world.getTagByName(x,y,z,"block",dimension) || 0
if(!prev && p.holding) world.setTagByName(x,y,z, "block",p.holding,false,dimension)
else{
var rot = world.getTagByName(x,y,z,"rot",dimension) || 0
rot++
if(rot >= 8) rot = 0
world.setTagByName(x,y,z, "rot",rot,false,dimension)
}
}
let doorToggle = function(x,y,z,dimension,world){
var b = world.getBlock(x,y,z,dimension)
var o = (b & DOOR) !== DOOR
var shapeId = o ? (this.id | SLAB) : (this.id | DOOR)
var setId = o ? (this.id | DOOR) : (this.id | SLAB)
var set
if(o){
if((shapeId | NORTH) === b){
set = setId | EAST
}else if((shapeId | EAST) === b){
set = setId | SOUTH
}else if((shapeId | SOUTH) === b){
set = setId | WEST
}else if((shapeId | WEST) === b){
set = setId | NORTH
}
}else{
if((shapeId | NORTH) === b){
set = setId | WEST
}else if((shapeId | WEST) === b){
set = setId | SOUTH
}else if((shapeId | SOUTH) === b){
set = setId | EAST
}else if((shapeId | EAST) === b){
set = setId | NORTH
}
}
world.setBlock(x,y,z,set, false,false,false,false,dimension)
doorSound(x,y,z,this.name === "ironDoor"?"iron_door":"wooden_door",!o,world)
}
let trapdoorToggle = function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension)
let target
switch(block){
case this.id | TRAPDOOR | NORTH:
target = this.id | TRAPDOOROPEN | NORTH
break
case this.id | TRAPDOOR | SOUTH:
target = this.id | TRAPDOOROPEN | SOUTH
break
case this.id | TRAPDOOR | EAST:
target = this.id | TRAPDOOROPEN | EAST
break
case this.id | TRAPDOOR | WEST:
target = this.id | TRAPDOOROPEN | WEST
break
}
world.setBlock(x,y,z,target,false,false,false,false,dimension)
doorSound(x,y,z,this.name === "ironTrapdoor"?"iron_trapdoor":"wooden_trapdoor",true,world)
}
let trapdoorOpenToggle = function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension)
let target
switch(block){
case this.id | TRAPDOOROPEN | NORTH:
target = this.id | TRAPDOOR | NORTH
break
case this.id | TRAPDOOROPEN | SOUTH:
target = this.id | TRAPDOOR | SOUTH
break
case this.id | TRAPDOOROPEN | EAST:
target = this.id | TRAPDOOR | EAST
break
case this.id | TRAPDOOROPEN | WEST:
target = this.id | TRAPDOOR | WEST
break
}
world.setBlock(x,y,z,target,false,false,false,false,dimension)
doorSound(x,y,z,this.name === "ironTrapdoor"?"iron_trapdoor":"wooden_trapdoor",false,world)
}
function clickBed(x,y,z,dimension,world,p){
if(dimension !== "") return world.explode(x,y,z,5,false,dimension)
p.spawnPoint.x = x
p.spawnPoint.y = y+1
p.spawnPoint.z = z
p.connection.send({type:"message",data:"Respawn point set",fromServer:true})
if(world.skyLight < 0.5){
let block = world.getBlock(x,y,z,dimension)
y += 0.25
p.rx = Math.PI2
switch(block & ROTATION){
case NORTH:
z += 0.5
p.ry = Math.PI
break
case SOUTH:
z -= 0.5
p.ry = 0
break
case EAST:
x += 0.5
p.ry = Math.PI2
break
case WEST:
x -= 0.5
p.ry = -Math.PI2
break
}
p.setRot(p.rx,p.ry,p.ry,true)
p.tp(x,y,z)
p.connection.send({type:"sleep"})
}else p.connection.send({type:"message",data:"Too bright to sleep",fromServer:true})
}
function sit(x,y,z,dimension,world,p){
if(x !== undefined){
p.tp(x,y,z)
p.riding = null
const block = world.getBlock(x,y,z,dimension)
switch(block & ROTATION){
case NORTH:
p.ry = Math.PI
break
case SOUTH:
p.ry = 0
break
case EAST:
p.ry = Math.PI2
break
case WEST:
p.ry = -Math.PI2
break
}
p.setRot(p.rx,p.ry,p.ry,true)
}
p.sitting = true
p.flying = false
p.velx = p.vely = p.velz = 0
p.connection.send({type:"sit",riding:p.riding})
}
const liquidData = {
getLevel:function(block){
switch(block){
case this.id | LAYER1:
return 1
case this.id | LAYER2:
return 2
case this.id | LAYER3:
return 3
case this.id | LAYER4:
return 4
case this.id | LAYER5:
return 5
case this.id | LAYER6:
return 6
case this.id | LAYER7:
return 7
case this.id | LAYER8:
case this.id:
return 8
default:
return 0
}
},
getLevelBlock:function(l){
switch(l){
case 1:
return this.id | LAYER1
case 2:
return this.id | LAYER2
case 3:
return this.id | LAYER3
case 4:
return this.id | LAYER4
case 5:
return this.id | LAYER5
case 6:
return this.id | LAYER6
case 7:
return this.id | LAYER7
case 8:
return this.id | LAYER8
}
},
getLevelAt:function(x,y,z,dimension,world){
var block = world.getBlock(x,y,z,dimension)
return this.getLevel(block)
},
isThisHere:function(x,y,z,d,world){
var b = world.getBlock(x,y,z,d)
return b && blockData[b].id === this.id
},
isThis:function(b){
return b && blockData[b].id === this.id
},
isSourceAt:function(x,y,z,d,world){
var b = world.getBlock(x,y,z,d)
return b === this.id
},
tryFlowTo:function(x,y,z,dimension,level,world,fromSource=false){
let block = world.getBlock(x,y,z,dimension)
const data = blockData[block]
if(data.liquid){
if(this.id === block) return !fromSource//source blocks must spread around other source blocks when above
else if(this.id === data.id) return true
}
if(!block || data.liquidBreakable || data.liquid && this.density > data.density){
world.setBlock(x,y,z,this.getLevelBlock(level),false,false,false,false,dimension)
if(data.liquidBreakable === "drop"){
world.addItems(x,y,z,dimension,0,0,0,block,true)
world.blockParticles(block,x,y,z,30, "break",dimension)
world.blockSound(block, "dig", x,y,z)
}
return true
}
},
flow:function(x,y,z,dimension,world){
let block = world.getBlock(x,y,z,dimension)
if(!this.isThis(block)) return
let source = block === this.id
let level = this.getLevel(block)
let down = world.getBlock(x,y-1,z,dimension)
if(!source){
if(this.canDuplicate && (world.getBlock(x,y,z+1,dimension) === this.id)+(world.getBlock(x,y,z-1,dimension) === this.id)+(world.getBlock(x+1,y,z,dimension) === this.id)+(world.getBlock(x-1,y,z,dimension) === this.id) >= 2 && (down || down === this.id)){
return world.setBlock(x,y,z,this.id, false,false,false,false,dimension) //if two or more sources surrounding, turn into source
}
let levelTarget = level
if(this.isThisHere(x,y+1,z,dimension,world)){
levelTarget = 8
}else{
let around = max(this.getLevelAt(x,y,z+1,dimension,world), this.getLevelAt(x,y,z-1,dimension,world), this.getLevelAt(x+1,y,z,dimension,world), this.getLevelAt(x-1,y,z,dimension,world))
around = this.getLevelDifference(around,dimension)
if(around !== levelTarget) levelTarget = around
if(levelTarget <= 0) return world.setBlock(x,y,z,0, false,false,false,false,dimension)
}
if(level !== levelTarget){
level = levelTarget
world.setBlock(x,y,z,this.getLevelBlock(level), false,false,false,false,dimension)
}
}else{
let above = world.getBlock(x,y+1,z,dimension)
if(blockData[above].liquid && blockData[above].density > this.density){
world.setBlock(x,y,z,above,false,false,false,false,dimension)
world.setBlock(x,y+1,z,block,false,false,false,false,dimension)
return
}
}
let newLevel = this.getLevelDifference(level,dimension)
if(!this.tryFlowTo(x,y-1,z,dimension,8,world,source) && newLevel > 0){
this.tryFlowTo(x,y,z+1,dimension,newLevel,world)
this.tryFlowTo(x,y,z-1,dimension,newLevel,world)
this.tryFlowTo(x+1,y,z,dimension,newLevel,world)
this.tryFlowTo(x-1,y,z,dimension,newLevel,world)
}
},
current:{
x:0,z:0,
ang4:Math.sqrt(0.5),
ang8:Math.sqrt(5)
},
getCurrent:function(bx,by,bz,dimension,level,noNormalize,world){
if(level === undefined) level = this.getLevelAt(bx,by,bz,dimension,world)
let x = this.getLevelAt(bx-1,by,bz,dimension,world)
let X = this.getLevelAt(bx+1,by,bz,dimension,world)
let z = this.getLevelAt(bx,by,bz-1,dimension,world)
let Z = this.getLevelAt(bx,by,bz+1,dimension,world)
let current = this.current
current.x = (X && X < level) + (x > level) - (X > level) - (x && x < level)
current.z = (Z && Z < level) + (z > level) - (Z > level) - (z && z < level)
if(noNormalize) return current
let mag = Math.sqrt(current.x * current.x + current.z * current.z)
current.x /= mag
current.z /= mag
return current
},
isThisLocalHere:function(x,y,z,dimension,blocks,func,world){
return blockData[func.call(world, x, y, z, (func === getBlock ? blocks : dimension))].id === this.id
},
trySpawnFlow:function(x,y,z,dimension,world,level,spread,fromSource=false){
let block = world.getBlock(x,y,z,dimension)
if(blockData[block].liquid && (block&isCube) === block) return !fromSource //source blocks must spread around other source blocks when above
let hasSpawnedUnder = this.onspawnflow && this.onspawnflow(x,y,z,dimension,world)
if(!blockData[block].solid && level > this.getLevel(block)){
world.spawnBlock(x,y,z,this.getLevelBlock(level),dimension,true)
if(!hasSpawnedUnder) spread.push(x,y,z,level)
}
return !blockData[block].solid
},
spawnFlow:async function(x,y,z,dimension,world){
let spread = [x,y,z,8], count = 0
while(spread.length){
let [sx,sy,sz,level] = spread
let newLevel = this.getLevelDifference(level,dimension)
if(newLevel > 0 && max(abs(sx-x),abs(sz-z)) < 16 && abs(sy-y) < 64){
const fromSource = sx === x && sy === y && sz === z
if(!this.trySpawnFlow(sx,sy-1,sz,dimension,world,8,spread,fromSource)){
this.trySpawnFlow(sx+1,sy,sz,dimension,world,newLevel,spread)
this.trySpawnFlow(sx-1,sy,sz,dimension,world,newLevel,spread)
this.trySpawnFlow(sx,sy,sz+1,dimension,world,newLevel,spread)
this.trySpawnFlow(sx,sy,sz-1,dimension,world,newLevel,spread)
}
}
spread.splice(0,4)
if(!((count++)%32)) await yieldThread()
}
}
}
const railData = {
lastConnectSides: {},
isFacing: function(x,y,z,dimension,side,setLastConnectSides){//are there sides of that rail facing in direction
let block = world.getBlock(x,y,z,dimension)
if(!blockData[block].rail) return false
let rot = (block&ROTATION)
if((block&isState) === CUBE || (block&isState) === SLAB){
if(side === "north" || side === "south"){
if(rot === NORTH || rot === SOUTH) return this.lastConnectSides[setLastConnectSides] = true
}else{
if(rot === EAST || rot === WEST) return this.lastConnectSides[setLastConnectSides] = true
}
}else{//corner rail
if(rot === NORTH){
if(side === "south" || side === "west") return this.lastConnectSides[setLastConnectSides] = true
}else if(rot === SOUTH){
if(side === "north" || side === "east") return this.lastConnectSides[setLastConnectSides] = true
}else if(rot === WEST){
if(side === "south" || side === "east") return this.lastConnectSides[setLastConnectSides] = true
}else if(rot === EAST){
if(side === "north" || side === "west") return this.lastConnectSides[setLastConnectSides] = true
}
}
return false
},
isConnected: function(x,y,z,dimension){//returns number of sides connected
let block = world.getBlock(x,y,z,dimension)
if(!blockData[block].rail) return
let rot = (block&ROTATION)
if((block&isState) === CUBE){
if(rot === NORTH || rot === SOUTH) return this.isFacing(x,y,z+1,dimension,"south","north") + this.isFacing(x,y,z-1,dimension,"north","south")
else return this.isFacing(x+1,y,z,dimension,"west","east") + this.isFacing(x-1,y,z,dimension,"east","west")
}else if((block&isState) === SLAB){
if(rot === NORTH) return this.isFacing(x,y+1,z+1,dimension,"south","northUp") + this.isFacing(x,y,z-1,dimension,"north","south")
else if(rot === SOUTH) return this.isFacing(x,y+1,z-1,dimension,"north","southUp") + this.isFacing(x,y,z+1,dimension,"south","north")
else if(rot === EAST) return this.isFacing(x+1,y+1,z,dimension,"west","eastUp") + this.isFacing(x-1,y,z,dimension,"east","west")
else if(rot === WEST) return this.isFacing(x-1,y+1,z,dimension,"east","westUp") + this.isFacing(x+1,y,z,dimension,"west","east")
}else{//corner rail
if(rot === NORTH) return this.isFacing(x,y,z-1,dimension,"north","south")+this.isFacing(x-1,y,z,dimension,"east","west")
else if(rot === SOUTH) return this.isFacing(x,y,z+1,dimension,"south","north")+this.isFacing(x+1,y,z,dimension,"west","east")
else if(rot === WEST) return this.isFacing(x,y,z-1,dimension,"north","south")+this.isFacing(x+1,y,z,dimension,"west","east")
else if(rot === EAST) return this.isFacing(x,y,z+1,dimension,"south","north")+this.isFacing(x-1,y,z,dimension,"east","west")
}
},
railonupdate: function(x,y,z,b,world,dimension){
this.lastConnectSides.north = this.lastConnectSides.south = this.lastConnectSides.east = this.lastConnectSides.west = this.lastConnectSides.northUp = this.lastConnectSides.southUp = this.lastConnectSides.eastUp = this.lastConnectSides.westUp = false
if(this.isConnected(x,y,z,dimension) === 2) return
let {north:curConnectNorth, south:curConnectSouth, east:curConnectEast, west:curConnectWest, northUp:curConnectNorthUp, southUp:curConnectSouthUp, eastUp:curConnectEastUp, westUp:curConnectWestUp} = this.lastConnectSides
//below: is the other rail available for connecting or already connected to this rail
let north = this.isConnected(x,y,z+1,dimension) < 2 || curConnectNorth,
south = this.isConnected(x,y,z-1,dimension) < 2 || curConnectSouth,
east = this.isConnected(x+1,y,z,dimension) < 2 || curConnectEast,
west = this.isConnected(x-1,y,z,dimension) < 2 || curConnectWest,
northUp = this.isConnected(x,y+1,z+1,dimension) < 2 || curConnectNorthUp,
southUp = this.isConnected(x,y+1,z-1,dimension) < 2 || curConnectSouthUp,
eastUp = this.isConnected(x+1,y+1,z,dimension) < 2 || curConnectEastUp,
westUp = this.isConnected(x-1,y+1,z,dimension) < 2 || curConnectWestUp
this.lastConnectSides.north = false
north = north || this.isConnected(x,y-1,z+1,dimension) < 2 || this.lastConnectSides.north
this.lastConnectSides.south = false
south = south || this.isConnected(x,y-1,z-1,dimension) < 2 || this.lastConnectSides.south
this.lastConnectSides.east = false
east = east || this.isConnected(x+1,y-1,z,dimension) < 2 || this.lastConnectSides.east
this.lastConnectSides.west = false
west = west || this.isConnected(x-1,y-1,z,dimension) < 2 || this.lastConnectSides.west
let target = this.id
if(northUp){
target |= SLAB | NORTH
}else if(eastUp){
target |= SLAB | EAST
}else if(southUp){
target |= SLAB | SOUTH
}else if(westUp){
target |= SLAB | WEST
}else if(this.name === "rail" && north && east){
target |= STAIR | SOUTH
}else if(this.name === "rail" && east && south){
target |= STAIR | WEST
}else if(this.name === "rail" && south && west){
target |= STAIR | NORTH
}else if(this.name === "rail" && west && north){
target |= STAIR | EAST
}else if(north || south){
target |= NORTH
}else if(east || west){
target |= EAST
}else return
target |= (b&FLIP)
if(b !== target){
world.setBlock(x,y,z,target,false,false,false,true,dimension)
}
},
onset: function(x,y,z,dimension,world){
world.updateBlock(x,y+1,z+1,false,false,null,null,null,dimension)
world.updateBlock(x,y+1,z-1,false,false,null,null,null,dimension)
world.updateBlock(x+1,y+1,z,false,false,null,null,null,dimension)
world.updateBlock(x-1,y+1,z,false,false,null,null,null,dimension)
world.updateBlock(x,y-1,z+1,false,false,null,null,null,dimension)
world.updateBlock(x,y-1,z-1,false,false,null,null,null,dimension)
world.updateBlock(x+1,y-1,z,false,false,null,null,null,dimension)
world.updateBlock(x-1,y-1,z,false,false,null,null,null,dimension)
if(this.carryRedstone){
let power = world.getRedstoneWirePower(x,y,z,dimension)
let strong = world.getSurroundingBlockPower(x,y,z,dimension) === "strong"
if(strong) power = 15
world.setTagByName(x,y,z,"power",power,false,dimension)
if(power) world.spreadPower(x,y,z,power,dimension)
}
},
ondelete:function(x,y,z,prevTags,prev,dimension,world){
world.updateBlock(x,y+1,z+1,false,false,null,null,null,dimension)
world.updateBlock(x,y+1,z-1,false,false,null,null,null,dimension)
world.updateBlock(x+1,y+1,z,false,false,null,null,null,dimension)
world.updateBlock(x-1,y+1,z,false,false,null,null,null,dimension)
world.updateBlock(x,y-1,z+1,false,false,null,null,null,dimension)
world.updateBlock(x,y-1,z-1,false,false,null,null,null,dimension)
world.updateBlock(x+1,y-1,z,false,false,null,null,null,dimension)
world.updateBlock(x-1,y-1,z,false,false,null,null,null,dimension)
if(this.carryRedstone){
const power = getTagBits(prevTags,"power",this.id)
if(power) world.unspreadPower(x,y,z,power,false,dimension)
}
}
}
for (let i = 0; i < BLOCK_COUNT; i++) {
let baseBlock = blockData[i]
if(baseBlock.item && baseBlock.name !== "bow"){
if(baseBlock.spyglass) baseBlock.shape = shapes.spyglass
else baseBlock.shape = shapes.item
continue
}
let drop = baseBlock.drop || i
let d = baseBlock.drop
let slabBlock = Object.create(baseBlock)
let stairBlock = Object.create(baseBlock)
let crossBlock = Object.create(baseBlock)
let tallcrossBlock = Object.create(baseBlock)
let doorBlock = Object.create(baseBlock)
let torchBlock = Object.create(baseBlock)
let lanternBlock = Object.create(baseBlock)
let lanternHangBlock = Object.create(baseBlock)
let beaconBlock = Object.create(baseBlock)
let cactusBlock = Object.create(baseBlock)
let paneBlock = Object.create(baseBlock)
let portalBlock = Object.create(baseBlock)
let trapdoorBlock = Object.create(baseBlock)
let openTrapdoor = Object.create(baseBlock)
let wallFlatBlock = Object.create(baseBlock)
let fenceBlock = Object.create(baseBlock)
let wallPostBlock = Object.create(baseBlock)
let buttonBlock = Object.create(baseBlock)
let chainBlock = Object.create(baseBlock)
let potBlock = Object.create(baseBlock)
let potCrossBlock = Object.create(baseBlock)
let cornerStairInBlock = Object.create(baseBlock)
let cornerStairOutBlock = Object.create(baseBlock)
let verticalSlabBlock = Object.create(baseBlock)
baseBlock.shape = baseBlock.shapeName ? shapes[baseBlock.shapeName] : shapes.cube
slabBlock.shape = shapes.slab
slabBlock.transparent = true
slabBlock.drop = d || (i | SLAB)
slabBlock.Name += " Slab"
stairBlock.shape = shapes.stair
stairBlock.transparent = true
stairBlock.drop = d || (i | STAIR)
stairBlock.Name += " Stair"
crossBlock.shape = shapes.cross
crossBlock.drop = drop
tallcrossBlock.shape = shapes.tallCross
tallcrossBlock.drop = drop
doorBlock.shape = shapes.door
doorBlock.drop = drop
torchBlock.shape = shapes.torch
torchBlock.drop = drop
lanternBlock.shape = shapes.lantern
lanternHangBlock.shape = shapes.lanternHang
beaconBlock.shape = shapes.beacon
beaconBlock.drop = drop
cactusBlock.shape = shapes.cactus
cactusBlock.drop = drop
paneBlock.shape = shapes.pane
paneBlock.drop = drop
portalBlock.shape = shapes.portal
wallFlatBlock.shape = shapes.wallFlat
wallFlatBlock.drop = drop
trapdoorBlock.shape = shapes.trapdoor
trapdoorBlock.drop = drop
openTrapdoor.shape = shapes.trapdoorOpen
openTrapdoor.drop = drop
fenceBlock.shape = shapes.fence
fenceBlock.transparent = true
fenceBlock.drop = drop
wallPostBlock.shape = shapes.wallpost
wallPostBlock.transparent = true
wallPostBlock.drop = drop
buttonBlock.shape = shapes.button
buttonBlock.drop = drop
chainBlock.shape = shapes.chain
chainBlock.drop = drop
potBlock.shape = shapes.pot
potBlock.drop = drop
potCrossBlock.shape = shapes.potCross
potCrossBlock.drop = drop
cornerStairInBlock.shape = shapes.stairCornerIn
cornerStairInBlock.transparent = true
cornerStairInBlock.drop = d || (i | STAIR)
cornerStairOutBlock.shape = shapes.stairCornerOut
cornerStairOutBlock.transparent = true
cornerStairOutBlock.drop = d || (i | STAIR)
verticalSlabBlock.shape = shapes.verticalSlab
verticalSlabBlock.transparent = true
verticalSlabBlock.drop = d || (i | VERTICALSLAB)
verticalSlabBlock.Name += " Vertical Slab"
if(baseBlock.torch || baseBlock.chain){
slabBlock.drop = i
}
if(baseBlock.door){
var onclick = baseBlock.name === "ironDoor" ? emptyFunc : function(x,y,z,dimension,world){
this.toggle(x,y,z,dimension,world)
}
var onpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension) ? true : false
let block = world.getBlock(x,y,z,dimension)
var open = (block & DOOR) !== DOOR
if(power !== open) this.toggle(x,y,z,dimension,world)
}
baseBlock.toggle = doorToggle.bind(baseBlock)
baseBlock.onclick = onclick.bind(baseBlock)
baseBlock.onpowerupdate = onpowerupdate.bind(baseBlock)
slabBlock.shape = shapes.door2
slabBlock.drop = i
slabBlock.Name = "Inverted "+baseBlock.name
}
if(baseBlock.trapdoor){
var onclick = baseBlock.name === "ironTrapdoor" ? emptyFunc : function(x,y,z,dimension,world){
this.toggle(x,y,z,dimension,world)
}
var onpowerupdate = function(x,y,z,sx,sy,sz,blockPowerChanged,dimension,world){
var power = world.getRedstonePower(x,y,z,dimension) || world.getSurroundingBlockPower(x,y,z,dimension) ? true : false
let block = world.getBlock(x,y,z,dimension)
var open = (block & TRAPDOOR) !== TRAPDOOR
if(power !== open) this.toggle(x,y,z,dimension,world)
}
trapdoorBlock.toggle = trapdoorToggle.bind(baseBlock)
openTrapdoor.toggle = trapdoorOpenToggle.bind(baseBlock)
trapdoorBlock.onclick = onclick.bind(trapdoorBlock)
openTrapdoor.onclick = onclick.bind(openTrapdoor)
trapdoorBlock.onpowerupdate = onpowerupdate.bind(trapdoorBlock)
openTrapdoor.onpowerupdate = onpowerupdate.bind(openTrapdoor)
}
if(baseBlock.bed){
baseBlock.shape = shapes.bed
baseBlock.onclick = clickBed
}
if(baseBlock.rotate) baseBlock.shape = shapes.rotate
if(baseBlock.SW) baseBlock.shape = shapes.SW
if(baseBlock.cactus) potCrossBlock.shape = shapes.cactusPot
if(baseBlock.crop) baseBlock.shape = shapes.crop
if(baseBlock.tallCrop)baseBlock.shape = shapes.tallCrop
if(baseBlock.anvil) baseBlock.shape = shapes.anvil
if(baseBlock._1PixLower) baseBlock.shape = shapes._1PixLower, baseBlock.transparent = true
if(baseBlock.torch) slabBlock.shape = shapes.wallTorch
if(baseBlock.sporeBlossom) baseBlock.shape = shapes.sporeBlossom
if(baseBlock.azalea){
baseBlock.shape = shapes.azalea
potCrossBlock.shape = shapes.azaleaPot
var t = baseBlock.potTex
potCrossBlock.textures = [t[0],t[0],t[1],t[1],t[1],t[1]]
}
if(baseBlock.sunflower) baseBlock.shape = shapes.sunflower
if(baseBlock.sideCross){baseBlock.shape = shapes.sideCross; slabBlock.shape = shapes.bottomCross}
if(baseBlock.layers){
torchBlock.shape = shapes.layer1
torchBlock.solid = true
torchBlock.shadow = false
torchBlock.dropAmount = 1
slabBlock.shape = shapes.layer2
slabBlock.solid = true
slabBlock.shadow = false
slabBlock.dropAmount = 2
stairBlock.shape = shapes.layer3
stairBlock.solid = true
stairBlock.shadow = false
stairBlock.dropAmount = 3
crossBlock.shape = shapes.layer4
crossBlock.solid = true
crossBlock.shadow = false
crossBlock.dropAmount = 4
tallcrossBlock.shape = shapes.layer5
tallcrossBlock.solid = true
tallcrossBlock.shadow = false
tallcrossBlock.dropAmount = 5
lanternBlock.shape = shapes.layer6
lanternBlock.solid = true
lanternBlock.shadow = false
lanternBlock.dropAmount = 6
lanternHangBlock.shape = shapes.layer7
lanternHangBlock.solid = true
lanternHangBlock.shadow = false
lanternHangBlock.dropAmount = 7
doorBlock.shape = shapes.layer8
doorBlock.solid = true
doorBlock.shadow = false
doorBlock.dropAmount = 8
}
if(baseBlock.liquid){
Object.assign(baseBlock,liquidData)
baseBlock.shape = shapes.liquidLayer8
torchBlock.shape = shapes.liquidLayer1
torchBlock.ambientSound = baseBlock.flowSound
slabBlock.shape = shapes.liquidLayer2
slabBlock.ambientSound = baseBlock.flowSound
stairBlock.shape = shapes.liquidLayer3
stairBlock.ambientSound = baseBlock.flowSound
crossBlock.shape = shapes.liquidLayer4
crossBlock.ambientSound = baseBlock.flowSound
tallcrossBlock.shape = shapes.liquidLayer5
tallcrossBlock.ambientSound = baseBlock.flowSound
lanternBlock.shape = shapes.liquidLayer6
lanternBlock.ambientSound = baseBlock.flowSound
lanternHangBlock.shape = shapes.liquidLayer7
lanternHangBlock.ambientSound = baseBlock.flowSound
doorBlock.shape = shapes.liquidLayer8
doorBlock.ambientSound = baseBlock.flowSound
}
if(baseBlock.name === "grass"){
crossBlock.shape = shapes.cube
crossBlock.textures = ["dirt","grassTop","snowGrass","snowGrass","snowGrass","snowGrass"]
crossBlock.solid = true
crossBlock.transparent = false
crossBlock.shadow = true
crossBlock.biomeTintTop = false
crossBlock.biomeTintNorth = false
crossBlock.biomeTintSouth = false
crossBlock.biomeTintEast = false
crossBlock.biomeTintWest = false
tallcrossBlock.shape = shapes._1PixLower
tallcrossBlock.textures = ["dirt","dirtPathTop","dirtPathSide","dirtPathSide","dirtPathSide","dirtPathSide"]
tallcrossBlock.solid = true
tallcrossBlock.transparent = true
tallcrossBlock.cullFace = "same"
tallcrossBlock.shadow = true
tallcrossBlock.biomeTintTop = false
tallcrossBlock.biomeTintNorth = false
tallcrossBlock.biomeTintSouth = false
tallcrossBlock.biomeTintEast = false
tallcrossBlock.biomeTintWest = false
}
if(baseBlock.name === "podzol"){
crossBlock.shape = shapes.cube
crossBlock.textures = ["dirt","podzolTop","snowGrass","snowGrass","snowGrass","snowGrass"]
crossBlock.solid = true
crossBlock.transparent = false
crossBlock.shadow = true
}
if(baseBlock.name === "farmland"){
slabBlock.textures = []
copyArr(baseBlock.textures, slabBlock.textures)
slabBlock.textures[1] = "farmlandMoist"
slabBlock.shape = shapes._1PixLower
}
if(baseBlock.mushroomBlock){
var cap = baseBlock.name
var pore = "mushroomBlockInside"
makeBlock(new Array(6).fill(pore), shapes.cube, slabBlock)
slabBlock.drop = i
makeBlock([pore,cap,pore,pore,pore,pore], shapes.cube, stairBlock)//top only
stairBlock.drop = i
makeBlock([pore,pore,cap,cap,cap,cap], shapes.cube, tallcrossBlock)//all sides
tallcrossBlock.drop = i
makeBlock([pore,cap,cap,pore,pore,pore], shapes.rotate, doorBlock)//top + 1 side
doorBlock.drop = i
makeBlock([pore,cap,cap,pore,cap,pore], shapes.rotate, paneBlock)//top + 2 sides next to each other
paneBlock.drop = i
makeBlock([pore,pore,cap,pore,cap,pore], shapes.rotate, portalBlock)//2 side next to each other
portalBlock.drop = i
makeBlock([pore,pore,cap,pore,pore,pore], shapes.rotate, wallFlatBlock)//1 side
wallFlatBlock.drop = i
//makeBlock([cap,pore,pore,pore,pore,pore], shapes.cube, crossBlock)
//makeBlock([cap,cap,pore,pore,pore,pore], shapes.cube, tallcrossBlock)
//makeBlock([cap,pore,cap,pore,pore,pore], shapes.rotate, portalBlock)
//makeBlock([cap,cap,cap,pore,pore,pore], shapes.rotate, wallFlatBlock)
}
if(baseBlock.cake) baseBlock.shape = shapes.cake
if(baseBlock.stonecutter) baseBlock.shape = shapes.stonecutter
if(baseBlock.itemFrame){
baseBlock.shape = shapes.itemFrame
baseBlock.onclick = itemFrameOnclick
baseBlock.tagBits = null
}
if(baseBlock.name === "redstoneLamp"){
makeBlock(new Array(6).fill("redstoneLampOn"), shapes.cube, slabBlock)
slabBlock.lightLevel = 15
}
if(baseBlock.name === "endPortalFrame"){
baseBlock.shape = shapes.endPortalFrame
makeBlock(baseBlock.textures, shapes.endPortalFrameWithEyeOfEnder, slabBlock)
}
if(baseBlock.name === "furnace"){
var arr = baseBlock.textures.slice()
arr[3] = "furnaceFrontOn"
makeBlock(arr, shapes.rotate, slabBlock)
slabBlock.lightLevel = 13
}
if(baseBlock.name === "jungleLeaves"){
makeBlock(new Array(6).fill("floweringJungleLeaves"), shapes.cube, fenceBlock, null, baseBlock.Name+" with fruit")
fenceBlock.transparent = true
}
if(baseBlock.name === "redBerryLeaves" || baseBlock.name === "blueBerryLeaves"){
makeBlock(new Array(6).fill(baseBlock.textures[2]+"NoBerries"), shapes.cube, fenceBlock, null, baseBlock.Name+" without berries")
fenceBlock.transparent = true
}
if(baseBlock.fire){
baseBlock.shape = shapes.fire
slabBlock.shape = shapes.sideFire
stairBlock.shape = shapes.bottomFire
}
if(baseBlock.name === "endRod"){
baseBlock.shape = shapes.endRod
slabBlock.shape = shapes.endRodSW
}
if(baseBlock.fenceGate){
baseBlock.shape = shapes.fenceGate
baseBlock.transparent = true
slabBlock.shape = shapes.fenceGateWall
stairBlock.shape = shapes.fenceGateOpen
doorBlock.shape = shapes.fenceGateWallOpen
doorBlock.transparent = true
baseBlock.onclick = (function(x,y,z,dimension){
var b = world.getBlock(x,y,z,dimension)
var set
var id = this.id
let o = false
switch(b){
case id | CUBE | NORTH:
set = id | STAIR | NORTH
o = true
break
case id | CUBE | SOUTH:
set = id | STAIR | SOUTH
o = true
break
case id | CUBE | EAST:
set = id | STAIR | EAST
o = true
break
case id | CUBE | WEST:
set = id | STAIR | WEST
o = true
break
case id | SLAB | NORTH:
set = id | DOOR | NORTH
o = true
break
case id | SLAB | SOUTH:
set = id | DOOR | SOUTH
o = true
break
case id | SLAB | EAST:
set = id | DOOR | EAST
o = true
break
case id | SLAB | WEST:
set = id | DOOR | WEST
o = true
break
case id | STAIR | NORTH:
set = id | CUBE | NORTH
break
case id | STAIR | SOUTH:
set = id | CUBE | SOUTH
break
case id | STAIR | EAST:
set = id | CUBE | EAST
break
case id | STAIR | WEST:
set = id | CUBE | WEST
break
case id | DOOR | NORTH:
set = id | SLAB | NORTH
break
case id | DOOR | SOUTH:
set = id | SLAB | SOUTH
break
case id | DOOR | EAST:
set = id | SLAB | EAST
break
case id | DOOR | WEST:
set = id | SLAB | WEST
break
}
world.setBlock(x,y,z,set,false,false,false,false,dimension)
doorSound(x,y,z,"fence_gate",o,world)
}).bind({id:baseBlock.id})
}
if(baseBlock.barrel){
makeBlock(baseBlock.texturesSW, shapes.SW, slabBlock, null, baseBlock.Name)
makeBlock(baseBlock.texturesDown, shapes.cube, stairBlock, null, baseBlock.Name)
makeBlock(baseBlock.texturesOpen, shapes.cube, crossBlock, null, baseBlock.Name)
makeBlock(baseBlock.texturesSWOpen, shapes.SW, doorBlock, null, baseBlock.Name)
makeBlock(baseBlock.texturesDownOpen, shapes.cube, tallcrossBlock, null, baseBlock.Name)
}
if(baseBlock.chain){
slabBlock.shape = shapes.chainSW
slabBlock.textures = slabBlock.textures.slice()
slabBlock.textures[4] = slabBlock.textures[5] = "chainSW"
}
if(baseBlock.name === "beeNest" || baseBlock.name === "beehive"){
makeBlock(baseBlock.texturesHoney, shapes.rotate, slabBlock)
}
if(baseBlock.name === "sponge"){
makeBlock(baseBlock.wetTexture, shapes.cube, slabBlock)
}
if(baseBlock.campfire){
baseBlock.shape = shapes.campfire
slabBlock.shape = shapes.campfireUnlit
slabBlock.transparent = baseBlock.transparent
slabBlock.shadow = baseBlock.shadow
slabBlock.lightLevel = 0
slabBlock.damageUp = 0
}
if(baseBlock.bamboo){
baseBlock.shape = shapes.bamboo
makeBlock(baseBlock.textures, shapes.bambooSmallLeaf, slabBlock)
slabBlock.shadow = false
slabBlock.transparent = true
makeBlock(baseBlock.textures, shapes.bambooBigLeaf, stairBlock)
stairBlock.shadow = false
stairBlock.transparent = true
makeBlock(baseBlock.textures, shapes.bambooYoung, crossBlock)
crossBlock.shadow = false
crossBlock.transparent = true
makeBlock(baseBlock.textures, shapes.bambooYoungLeaf, tallcrossBlock)
tallcrossBlock.shadow = false
tallcrossBlock.transparent = true
potCrossBlock.shape = shapes.bambooPot
}
if(baseBlock.chest) baseBlock.shape = shapes.chest
if(baseBlock.pressurePlate){
baseBlock.shape = shapes.pressurePlate
baseBlock.transparent = true
baseBlock.shadow = false
baseBlock.solid = false
baseBlock.activate = pressurePlateActivate
baseBlock.onupdate = pressurePlateOnupdate
makeBlock(baseBlock.textures, shapes.pressurePlateActive, slabBlock, baseBlock)
}
if(baseBlock.name === "tomatoPlant"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.cross, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.cross, tallcrossBlock, baseBlock)
crossBlock.drop = "tomato"
crossBlock.dropAmount = [4,8]
tallcrossBlock.drop = "tomato"
tallcrossBlock.dropAmount = [8,16]
}
if(baseBlock.name === "wheat"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.crop, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures5, shapes.crop, doorBlock, baseBlock)
makeBlock(baseBlock.textures6, shapes.crop, torchBlock, baseBlock)
makeBlock(baseBlock.textures7, shapes.crop, lanternBlock, baseBlock)
lanternBlock.drop = baseBlock.fullDrop
}
if(baseBlock.name === "redstoneDust"){
baseBlock.shape = shapes.redstoneDust
makeBlock(new Array(6).fill("redstoneDustLine"), shapes.redstoneDustRotate, slabBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDustL"), shapes.redstoneDustRotate, stairBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDustT"), shapes.redstoneDustRotate, doorBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDust+"), shapes.redstoneDust, paneBlock, baseBlock)
let flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDustDot"), shapes.redstoneDust, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | FLIP] = flip
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDustLine"), shapes.redstoneDustRotate, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | SLAB | FLIP] = flip
let v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | SLAB | FLIP |v[j].bit] = block
}
}
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDustL"), shapes.redstoneDustRotate, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | STAIR | FLIP] = flip
v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | STAIR | FLIP |v[j].bit] = block
}
}
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDustT"), shapes.redstoneDustRotate, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | DOOR | FLIP] = flip
v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | DOOR | FLIP |v[j].bit] = block
}
}
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("redstoneDust+"), shapes.redstoneDust, flip, baseBlock)
flip.tint = flip.blueTint
blockData[i | PANE | FLIP] = flip
}
if(baseBlock.redstoneTorch){
baseBlock.shape = shapes.redstoneTorch
makeBlock(baseBlock.textures, shapes.redstoneWallTorch, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.torch, crossBlock, baseBlock)
crossBlock.lightLevel = 0
crossBlock.textures = new Array(6).fill("redstoneTorchOff")
makeBlock(baseBlock.textures, shapes.wallTorch, stairBlock, baseBlock)
stairBlock.lightLevel = 0
stairBlock.textures = crossBlock.textures
}
if(baseBlock.lever){
baseBlock.shape = shapes.leverWall
makeBlock(baseBlock.textures, shapes.leverWallOn, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.leverFloor, stairBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.leverFloorOn, crossBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.leverCeil, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.leverCeilOn, doorBlock, baseBlock)
}
if(baseBlock.button){
makeBlock(baseBlock.textures, shapes.buttonPushed, slabBlock, baseBlock)
baseBlock.onclick = buttonOnclick.bind(baseBlock)
baseBlock.onupdate = buttonOnupdate.bind(baseBlock)
baseBlock.projectileHit = buttonProjectileHit.bind(baseBlock)
}
if(baseBlock.repeater){
baseBlock.shape = shapes.repeater1
makeBlock(baseBlock.textures, shapes.repeater2, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeater3, stairBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeater4, doorBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeaterOn1, paneBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeaterOn2, portalBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeaterOn3, wallFlatBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.repeaterOn4, openTrapdoor, baseBlock)
}
if(baseBlock.piston){
var baseBlockTransparent = Object.create(baseBlock)
baseBlockTransparent.transparent = true
//not extended
var textures = baseBlock.textures.slice()
var t = textures[0]
textures[0] = textures[1]
textures[1] = t
var flipped = Object.create(baseBlock)
makeBlock(textures, shapes.flipped, flipped, baseBlock)
blockData[i | FLIP] = flipped
var shape = shapes.SW
t = baseBlock.textures
textures = [t[2],t[2],t[0],t[1],t[2],t[2]]
makeBlock(textures, shape, slabBlock, baseBlock)
//head
t = baseBlock.textures[1]
var t2 = baseBlock.headSideTexture
var t3 = baseBlock.headBackTexture
makeBlock([t3,t,t2,t2,t2,t2], shapes.pistonHead, stairBlock, baseBlockTransparent)
flipped = Object.create(baseBlock)
makeBlock([t,t3,t2,t2,t2,t2], shapes.pistonHeadFlipped, flipped, baseBlockTransparent)
blockData[i | STAIR | FLIP] = flipped
makeBlock([t2,t2,t3,t,t2,t2], shapes.pistonHeadSW, doorBlock, baseBlockTransparent)
//head cut
makeBlock(stairBlock.textures, shapes.pistonHeadCut, crossBlock, baseBlock)
flipped = Object.create(baseBlock)
makeBlock(blockData[i | STAIR | FLIP].textures, shapes.pistonHeadCutFlipped, flipped, baseBlock)
blockData[i | CROSS | FLIP] = flipped
makeBlock(doorBlock.textures, shapes.pistonHeadCutSW, paneBlock, baseBlock)
//open
var textures = baseBlock.textures.slice()
textures[1] = baseBlock.frontOpenTexture
makeBlock(textures, shapes.pistonOpen, tallcrossBlock, baseBlockTransparent)
textures = blockData[i | FLIP].textures.slice()
textures[0] = baseBlock.frontOpenTexture
flipped = Object.create(baseBlock)
makeBlock(textures, shapes.pistonOpenFlipped, flipped, baseBlockTransparent)
blockData[i | TALLCROSS | FLIP] = flipped
var textures = baseBlock.textures.slice()
var temp = textures[2] //side with piston head
textures[2] = textures[0]
textures[3] = baseBlock.frontOpenTexture
textures[0] = textures[1] = temp
makeBlock(textures, shapes.pistonOpenSW, portalBlock, baseBlockTransparent)
}
if(baseBlock.name === "tnt"){
makeBlock(fillTextureArray(baseBlock.superTntTextures), shapes.cube, slabBlock, baseBlock, "Super TNT")
makeBlock(fillTextureArray(baseBlock.ultraTntTextures), shapes.cube, stairBlock, baseBlock, "Ultra TNT")
makeBlock(new Array(6).fill("blank"), shapes.cube, crossBlock, baseBlock)
}
if(baseBlock.name === "observer"){
baseBlock.shape = shapes.rotate
var t = baseBlock.textures
var textures = [t[3],t[2],t[0],t[1],t[4]+"SW",t[5]+"SW"]
makeBlock(textures, shapes.cube, slabBlock, baseBlock)
var flipped = Object.create(baseBlock)
var textures = textures.slice()
var t = textures[1]
textures[1] = textures[0]
textures[0] = t
makeBlock(textures, shapes.flipped, flipped, baseBlock)
blockData[i | SLAB | FLIP] = flipped
//on
textures = baseBlock.textures.slice()
textures[2] += "On"
makeBlock(textures, shapes.rotate, stairBlock, baseBlock)
textures = slabBlock.textures.slice()
textures[1] += "On"
makeBlock(textures, shapes.cube, crossBlock, baseBlock)
var flipped = Object.create(baseBlock)
textures = blockData[i | SLAB | FLIP].textures.slice()
textures[0] += "On"
makeBlock(textures, shapes.flipped, flipped, baseBlock)
blockData[i | CROSS | FLIP] = flipped
}
if(baseBlock.name === "endPortal"){
baseBlock.shape = shapes.endPortal
}
if(baseBlock.pane){
var t = baseBlock.textures
makeBlock([t[2],t[3],t[0],t[1],t[0],t[1]], shapes.horizontalPane, slabBlock, baseBlock)
}
if(baseBlock.coloredRedstoneLamp){
makeBlock(new Array(6).fill(baseBlock.name), shapes.cube, slabBlock)
slabBlock.lightLevel = 15
}
if(baseBlock.name === "sweetBerryBush"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
slabBlock.spikyBush = true
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
stairBlock.spikyBush = true
stairBlock.dropAmount = [1,2]
makeBlock(baseBlock.textures3, shapes.cross, crossBlock, baseBlock)
crossBlock.spikyBush = true
crossBlock.dropAmount = [2,3]
}
if(baseBlock.logicGate){
var t = baseBlock.textures.slice()
t[1] += "On"
makeBlock(t, baseBlock.shape, slabBlock, baseBlock)
baseBlock.onupdate = logicGateOnupdate
baseBlock.onpowerupdate = logicGateOnpowerupdate
baseBlock.ondelete = logicGateOndelete
baseBlock.getFacing = logicGateGetFacing
baseBlock.canHavePower = logicGateCanHavePower
}
if(baseBlock.name === "pointedDripstone"){
makeBlock(new Array(6).fill("pointedDripstoneUpTip"), shapes.cross, baseBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownTip"), shapes.cross, flip, baseBlock)
blockData[i | FLIP] = flip
makeBlock(new Array(6).fill("pointedDripstoneUpBase"), shapes.cross, slabBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownBase"), shapes.cross, flip, baseBlock)
blockData[i | SLAB | FLIP] = flip
makeBlock(new Array(6).fill("pointedDripstoneUpMiddle"), shapes.cross, stairBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownMiddle"), shapes.cross, flip, baseBlock)
blockData[i | STAIR | FLIP] = flip
makeBlock(new Array(6).fill("pointedDripstoneUpFrustum"), shapes.cross, crossBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownFrustum"), shapes.cross, flip, baseBlock)
blockData[i | CROSS | FLIP] = flip
makeBlock(new Array(6).fill("pointedDripstoneUpTipMerge"), shapes.cross, tallcrossBlock, baseBlock)
var flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("pointedDripstoneDownTipMerge"), shapes.cross, flip, baseBlock)
blockData[i | TALLCROSS | FLIP] = flip
}
if(baseBlock.sign){
slabBlock.shape = shapes.sign
slabBlock.textures = baseBlock.textures
slabBlock.drop = i
crossBlock.shape = shapes.wallSign
crossBlock.textures = baseBlock.textures
crossBlock.drop = i
baseBlock.shape = shapes.none
baseBlock.transparent = true
baseBlock.shadow = false
baseBlock.solid = false
baseBlock.onplace = signOnplace
baseBlock.tagBits = null
baseBlock.onclick = signOnclick
stairBlock.shape = shapes.none
}
if(baseBlock.name === "composter"){
baseBlock.shape = shapes.composter
makeBlock(baseBlock.textures, shapes.composter2, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter3, stairBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter4, crossBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter5, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter6, doorBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter7, torchBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.composter8, lanternBlock, baseBlock)
}
if(baseBlock.name === "cocoa"){
baseBlock.shape = shapes.cocoaStage0
baseBlock.textures.fill("cocoaStage0")
makeBlock(new Array(6).fill("cocoaStage1"), shapes.cocoaStage1, slabBlock, baseBlock)
makeBlock(new Array(6).fill("cocoaStage2"), shapes.cocoaStage2, stairBlock, baseBlock)
stairBlock.dropAmount = [2,3]
}
if(baseBlock.name === "beetroots"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
crossBlock.drop = ["beetrootSeeds","beetroot"]
crossBlock.dropAmount = [1,4]
}
if(baseBlock.name === "potatoes"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
crossBlock.dropAmount = [1,5]
}
if(baseBlock.name === "carrots"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
crossBlock.dropAmount = [2,5]
}
if(baseBlock.name === "dropper" || baseBlock.name === "dispenser"){
baseBlock.shape = shapes.rotate
makeBlock(baseBlock.upTextures, shapes.cube, slabBlock)
makeBlock(baseBlock.downTextures, shapes.cube, stairBlock)
}
if(baseBlock.name === "hopper"){
baseBlock.shape = shapes.hopper
makeBlock(baseBlock.textures, shapes.hopperWall, slabBlock, baseBlock)
}
if(baseBlock.name === "comparator"){
baseBlock.shape = shapes.comparator
makeBlock(baseBlock.textures, shapes.comparatorOn, slabBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.comparatorSubtract, stairBlock, baseBlock)
makeBlock(baseBlock.textures, shapes.comparatorSubtractOn, doorBlock, baseBlock)
}
if(baseBlock.name === "daylightDetector"){
baseBlock.shape = shapes.daylightDetector
makeBlock(baseBlock.invertedTextures, shapes.daylightDetector, slabBlock, baseBlock)
}
if(baseBlock.commandBlock){
let flip = Object.create(baseBlock)
makeBlock(baseBlock.errorTextures, shapes.cube, flip, baseBlock)
blockData[i | FLIP] = flip
makeBlock(baseBlock.sideTextures, shapes.SW, slabBlock, baseBlock)
flip = Object.create(baseBlock)
makeBlock(baseBlock.sideErrorTextures, shapes.SW, flip, baseBlock)
blockData[i | SLAB | FLIP] = flip
let v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(flip.textures, v[j].rotateTimes) //rotate textures around
blockData[i | SLAB | FLIP |v[j].bit] = block
}
}
makeBlock(baseBlock.flipTextures, shapes.flipped, stairBlock, baseBlock)
flip = Object.create(baseBlock)
makeBlock(baseBlock.flipErrorTextures, shapes.flipped, flip, baseBlock)
blockData[i | STAIR | FLIP] = flip
}
if(baseBlock.name === "sugarCane"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures, shapes.cross, slabBlock, baseBlock)
slabBlock.tint = baseBlock.purpleTint
}
if(baseBlock.name === "bow"){
baseBlock.shape = shapes.item
baseBlock.textures = new Array(6).fill(baseBlock.pullTextures[0])
makeBlock(new Array(6).fill(baseBlock.pullTextures[1]), shapes.item, slabBlock)
makeBlock(new Array(6).fill(baseBlock.pullTextures[2]), shapes.item, stairBlock)
makeBlock(new Array(6).fill(baseBlock.pullTextures[3]), shapes.item, crossBlock)
}
if(baseBlock.beacon){
baseBlock.shape = shapes.beacon
}
if(baseBlock.name === "pitcherCrop"){
baseBlock.shape = shapes.pitcherCropStage0
makeBlock(baseBlock.textures1, shapes.pitcherCropStage1, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.pitcherCropStage1, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.pitcherCropStage3, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.pitcherCropStage3, tallcrossBlock, baseBlock)
}
if(baseBlock.name === "torchflower"){
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
crossBlock.drop = "torchflower"
}
if(baseBlock.groundLeaves){
baseBlock.shape = shapes.flat
if(baseBlock.thickTexture) makeBlock(new Array(6).fill(baseBlock.thickTexture), shapes.flat, slabBlock, baseBlock, "Thick "+baseBlock.Name)
}
if(baseBlock.flowerbed){
baseBlock.shape = shapes.flowerbed1
makeBlock(baseBlock.textures, shapes.flowerbed2, slabBlock, baseBlock)
slabBlock.drop = i
makeBlock(baseBlock.textures, shapes.flowerbed3, stairBlock, baseBlock)
stairBlock.drop = i
makeBlock(baseBlock.textures, shapes.flowerbed4, doorBlock, baseBlock)
doorBlock.drop = i
}
if(baseBlock.name === "fern"){
baseBlock.shape = shapes.cross
slabBlock.shape = shapes.fern
slabBlock.randomRotateOnSpawn = true
}
if(baseBlock.carpet){
baseBlock.shape = shapes.carpet
baseBlock.shadow = false
baseBlock.transparent = true
baseBlock.drop = i
verticalSlabBlock.shape = shapes.wallCarpet
verticalSlabBlock.shadow = false
verticalSlabBlock.transparent = true
verticalSlabBlock.drop = i
verticalSlabBlock.Name = "Wall "+baseBlock.Name
}
if(baseBlock.coralBlock){
makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.cube, slabBlock,baseBlock, "Dead "+baseBlock.Name)
}
if(baseBlock.coralFan){
baseBlock.shape = shapes.coralFan
makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.coralFan, slabBlock,baseBlock, "Dead "+baseBlock.Name)
makeBlock(baseBlock.textures, shapes.coralWallFan, stairBlock,baseBlock)
makeBlock(new Array(6).fill("dead"+baseBlock.name[0].toUpperCase()+baseBlock.name.substring(1)), shapes.coralWallFan, verticalSlabBlock,baseBlock)
}
if(baseBlock.rail){
baseBlock.shape = shapes.rail
makeBlock(baseBlock.textures, shapes.railDiagonal, slabBlock,baseBlock)
if(baseBlock.name === "rail"){
makeBlock(new Array(6).fill("railCorner"), shapes.rail, stairBlock,baseBlock)
}
if(baseBlock.name === "poweredRail"){
let flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("poweredRailOn"), shapes.rail, flip,baseBlock)
blockData[i | FLIP] = flip
let v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | FLIP | v[j].bit] = block
}
}
flip = Object.create(baseBlock)
makeBlock(new Array(6).fill("poweredRailOn"), shapes.railDiagonal, flip,baseBlock)
blockData[i | SLAB | FLIP] = flip
v = flip.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(flip)
block.shape = v[j]
blockData[i | SLAB | FLIP | v[j].bit] = block
}
}
}
Object.assign(baseBlock,railData)
}
if(baseBlock.name === "cornPlant"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.tallCross, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.tallCross, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures5, shapes.tallCross, doorBlock, baseBlock)
doorBlock.dropAmount = [2,3]
}
if(baseBlock.chair){
baseBlock.shape = shapes.chair
baseBlock.onclick = sit
}
blockData[i | SLAB] = slabBlock
blockData[i | STAIR] = stairBlock
blockData[i | CROSS] = crossBlock
blockData[i | TALLCROSS] = tallcrossBlock
blockData[i | DOOR] = doorBlock
blockData[i | TORCH] = torchBlock
blockData[i | LANTERN] = lanternBlock
blockData[i | LANTERNHANG] = lanternHangBlock
if(baseBlock.beacon) blockData[i | BEACON] = beaconBlock
if(baseBlock.cactus) blockData[i | CACTUS] = cactusBlock
blockData[i | PANE] = paneBlock
blockData[i | PORTAL] = portalBlock
blockData[i | WALLFLAT] = wallFlatBlock
blockData[i | TRAPDOOR] = trapdoorBlock
blockData[i | TRAPDOOROPEN] = openTrapdoor
blockData[i | FENCE] = fenceBlock
blockData[i | WALLPOST] = wallPostBlock
if(baseBlock.button) blockData[i | BUTTON] = buttonBlock
if(baseBlock.chain) blockData[i | CHAIN] = chainBlock
if(baseBlock.pot) blockData[i | POT] = potBlock
blockData[i | POTCROSS] = potCrossBlock
blockData[i | CORNERSTAIRIN] = cornerStairInBlock
blockData[i | CORNERSTAIROUT] = cornerStairOutBlock
blockData[i | VERTICALSLAB] = verticalSlabBlock
let v
if(baseBlock.shape.rotate || baseBlock.shape.flip){
let t = baseBlock.textures
v = baseBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(baseBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | v[j].bit] = block
}
}
}
v = slabBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = slabBlock.textures
if (v[j]) {
let block = Object.create(slabBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | SLAB | v[j].bit] = block
}
}
v = stairBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = stairBlock.textures
if (v[j]) {
let block = Object.create(stairBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | STAIR | v[j].bit] = block
}
}
v = doorBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = doorBlock.textures
if (v[j]) {
let block = Object.create(doorBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | DOOR | v[j].bit] = block
}
}
v = paneBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = paneBlock.textures
if (v[j]) {
let block = Object.create(paneBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | PANE | v[j].bit] = block
}
}
v = portalBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = portalBlock.textures
if (v[j]) {
let block = Object.create(portalBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes)
blockData[i | PORTAL | v[j].bit] = block
}
}
v = wallFlatBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(wallFlatBlock)
block.shape = v[j]
blockData[i | WALLFLAT | v[j].bit] = block
}
}
v = trapdoorBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(trapdoorBlock)
block.shape = v[j]
blockData[i | TRAPDOOR | v[j].bit] = block
}
}
v = openTrapdoor.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(openTrapdoor)
block.shape = v[j]
blockData[i | TRAPDOOROPEN | v[j].bit] = block
}
}
v = buttonBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j] && blockData[i].button) {
let block = Object.create(buttonBlock)
block.shape = v[j]
blockData[i | BUTTON | v[j].bit] = block
}
}
v = cornerStairInBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(cornerStairInBlock)
block.shape = v[j]
blockData[i | CORNERSTAIRIN | v[j].bit] = block
}
}
v = cornerStairOutBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(cornerStairOutBlock)
block.shape = v[j]
blockData[i | CORNERSTAIROUT | v[j].bit] = block
}
}
v = verticalSlabBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(verticalSlabBlock)
block.shape = v[j]
blockData[i | VERTICALSLAB | v[j].bit] = block
}
}
}
}
let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,
BUTTON,CHAIN,POT,POTCROSS,CORNERSTAIRIN,CORNERSTAIROUT,VERTICALSLAB,
//if you change this, change debugStick and server side
LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,
FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
let isCube, isState
let prevConstVersion = null
function verMoreThan(a,b){
a = a.split(".").map(r => parseInt(r))
b = b.split(".").map(r => parseInt(r))
if(a[0] > b[0]) return true
if(a[1] > b[1] && a[0] === b[0]) return true
if(a[2] > b[2] && a[1] === b[1]) return true
}
function bin(n){
return parseInt(n,2)
}
function constVersion(v){
if(v === prevConstVersion) return
prevConstVersion = v
isCube = 0xff
//let verNum = v.replace(/(Alpha|Beta) /, '')//.replace(/(?<=\..*)\./g, '') //second regex removes the periods after the first
//if(verMoreThan(verNum, "1.0.3") || verNum==="1.0.3"){
CUBE = 0
LAYER2=SLAB =          0b10000000000000 // 9th bit
LAYER3=STAIR =        0b100000000000000 // 10th bit
LAYER4=CROSS =        0b110000000000000
LAYER5=TALLCROSS =0b1001110000000000000
LAYER6=LANTERN =    0b10010000000000000
LAYER7=LANTERNHANG=0b100010000000000000
BEACON =           0b100110000000000000
CACTUS =           0b101000000000000000
POT =              0b101010000000000000
POTCROSS =         0b101110000000000000
LAYER1 = TORCH =   0b110000000000000000
CHAIN =            0b110010000000000000
LAYER8 = DOOR =   0b1000010000000000000
PORTAL =          0b1000100000000000000
WALLFLAT =        0b1000110000000000000
PANE =           0b10001000000000000000
TRAPDOOR =        0b1010000000000000000
TRAPDOOROPEN =   0b10000000000000000000
FENCE =          0b11000000000000000000
WALLPOST =       0b11000100000000000000
//WALL = 0x6400<<5
//WALLU = 0x6600<<5 //wall withe exteion under another wall
//FENCQ = 0x4100<<5 //fence (one extension)
BUTTON =         0b10000100000000000000
//CARPET    =      0b10000110000000000000
CORNERSTAIRIN =      0b1000000000000000
CORNERSTAIROUT =     0b1010000000000000
VERTICALSLAB =       0b1100000000000000
FLIP      =               0b10000000000 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH =                  0b100000000000
EAST =                  0b1000000000000
WEST =                  0b1100000000000
ROTATION =              0b1100000000000 // Mask for the direction bits
isCube =                   0b1111111111 // Mask for block id bits
isState =        0b11111110000000000000
/*}else if(verMoreThan(verNum, "1.0.0") || verNum === "1.0.0"){
CUBE = 0
LAYER2 = SLAB = 0x100 // 9th bit
LAYER3 = STAIR = 0x200 // 10th bit
LAYER4 = CROSS = 0x300
FLIP = 0x400 // 11th bit
LAYER5 = TALLCROSS = 0x700
LAYER6 = LANTERN = 0x900
LAYER7 = LANTERNHANG=0x1100
BEACON = 0x1300
CACTUS = 0x1400
POT = 0x1500
POTCROSS = 0x1700
LAYER1 = TORCH = 0x1800
CHAIN = 0x1900
LAYER8 = DOOR = 0x2100
PORTAL = 0x2200
WALLFLAT = 0x2300
PANE = 0x4400
TRAPDOOR = 0x2800
TRAPDOOROPEN=0x4000
FENCE = 0x6000
WALLPOST = 0x6200
//WALL = 0x6400
//WALLU = 0x6600 //wall withe exteion under another wall
//FENCQ = 0x4100 //fence (one extension)
BUTTON = 0x4200
CARPET    = 0x4300
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
}else{
CUBE      = 0
LAYER2 = SLAB      = 0x100 // 9th bit
LAYER3 = STAIR     = 0x200 // 10th bit
LAYER4 = CROSS     = 0x2000
LAYER5 = TALLCROSS = 0x2200
LAYER8 = DOOR      = 0x2400
LAYER1 = TORCH     = 0x2600
LAYER6 = LANTERN   = 0x2800
LAYER7 = LANTERNHANG=0x3000
BEACON    = 0x4200
CACTUS    = 0x4400
PANE      = 0x4600
PORTAL    = 0x5000
WALLFLAT  = 0x4800
TRAPDOOR  = 0x5200
TRAPDOOROPEN=0x5400
FENCE     = 0x6000
WALLPOST  = 0x6200
//WALL      = 0x6400
//WALLU     = 0x6600 //wall withe exteion under another wall
//FENCQ     = 0x6800 //fence (one extension)
BUTTON    = 0x7000
CHAIN     = 0x7200
POT       = 0x8000
POTCROSS  = 0x8200
CARPET    = 0x8400
FLIP      = 0x400 // 11th bit
NORTH     = 0 // 12th and 13th bits for the 4 directions
SOUTH     = 0x800
EAST      = 0x1000
WEST      = 0x1800
ROTATION  = 0x1800 // Mask for the direction bits
}*/
}
constVersion(version)
{//Commands
let copiedBlocks
function fillBlocks(x,y,z,x2,y2,z2, blockID, dimension,world){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
for(var X=x; x2>=X; X++){
for(var Y=y; y2>=Y; Y++){
for(var Z=z; z2>=Z; Z++){
world.setBlock(X,Y,Z,blockID, false,false,false,false,dimension)
}
}
}
}
function copy(x,y,z,x2,y2,z2, dimension,world){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
copiedBlocks = [];
for(var X=x; x2>=X; X++){
var xRow = [];
for(var Y=y; y2>=Y; Y++){
var yRow = []
for(var Z=z; z2>=Z; Z++){
yRow.push(world.getBlock(X,Y,Z,dimension), world.getTags(X,Y,Z,dimension));
}
xRow.push(yRow);
}
copiedBlocks.push(xRow);
}
}
function paste(x,y,z,dimension,world){
for(var X = 0; X<copiedBlocks.length; X++){
var xRow = copiedBlocks[X];
for(var Y=0; Y<xRow.length; Y++){
var yRow = xRow[Y];
for(var Z=0; Z<yRow.length/2; Z++){
var block = yRow[Z*2]
world.setBlock(X+x,Y+y,Z+z,block,false,false,false,false,dimension)
var tags = yRow[z*2+1]
if(tags) world.setTags(X+x,Y+y,Z+z, tags,false, dimension)
}
}
}
}
function replaceBlocks(x,y,z,x2,y2,z2, replace, into, dimension,world){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
for(var X=x; x2>=X; X++){
for(var Y=y; y2>=Y; Y++){
for(var Z=z; z2>=Z; Z++){
if(world.getBlock(X,Y,Z,dimension) === replace){
world.setBlock(X,Y,Z,into, false,false,false,false,dimension)
}
}
}
}
}
function fromPlayer(p,world){
p.prevPosCmd = [round(p.x), round(p.y), round(p.z)]
world.sendPlayer({type:"clientCmd",data:"fromPlayer",args:{x:round(p.x),y:round(p.y),z:round(p.z)}},p.id)
}
function fillToPlayer(id,p,world){
//fills at player feet
fillBlocks(p.prevPosCmd[0], p.prevPosCmd[1]-1, p.prevPosCmd[2], round(p.x), round(p.y-1), round(p.z), id, p.dimension,world)
world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}
function copyToPlayer(p,world){
copy(p.prevPosCmd[0], p.prevPosCmd[1]-1, p.prevPosCmd[2], round(p.x), round(p.y-1), round(p.z), p.dimension,world);
p.copiedBlocksCmd = copiedBlocks
world.sendPlayer({type:"clientCmd",data:"copySelect",args:{w:copiedBlocks.length,h:copiedBlocks[0].length,d:copiedBlocks[0][0].length}},p.id)
}
function pasteAtPlayer(p,world){
copiedBlocks = p.copiedBlocksCmd
paste(round(p.x), round(p.y-1), round(p.z), p.dimension,world)
world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}
function replaceAtPlayer(replace,into,p,world){
replaceBlocks(p.prevPosCmd[0], p.prevPosCmd[1]-1, p.prevPosCmd[2], round(p.x), round(p.y-1), round(p.z), replace, into, p.dimension, world)
world.sendPlayer({type:"clientCmd",data:"cancelFrom",args:{}},p.id)
}
let cancelShape = 0
async function hcyl(width, height, depth, id, X,Y,Z, dimension,world) {
let cid = cancelShape
let w2 = width * width
let d2 = depth * depth
let w3 = (width - 1.2) * (width - 1.2)
let d3 = (depth - 1.2) * (depth - 1.2)
for (let x = floor(-width); x <= ceil(width); x++) {
for (let y = floor(-height); y <= ceil(height); y++) {
for (let z = floor(-depth); z <= ceil(depth); z++) {
let n = x * x / w2 + z * z / d2
let n2 = x * x / w3 + z * z / d3
if (n < 1 && n2 >= 1) {
world.setBlock(round(X + x), round(Y + y), round(Z + z), id, false,false,false,false, dimension)
await sleep(10)
if(cancelShape > cid) return
}
}
}
}
}
async function cyl(width, height, depth, id, X,Y,Z, dimension,world) {
let cid = cancelShape
let w2 = width * width
let d2 = depth * depth
for (let x = floor(-width); x <= ceil(width); x++) {
for (let y = floor(-height); y <= ceil(height); y++) {
for (let z = floor(-depth); z <= ceil(depth); z++) {
let n = x * x / w2 + z * z / d2
if (n < 1) {
world.setBlock(round(X + x), round(Y + y), round(Z + z), id, false,false,false,false, dimension)
await sleep(10)
if(cancelShape > cid) return
}
}
}
}
}
async function sphereoid(w, h, d, id, X,Y,Z, dimension,world) {
let cid = cancelShape
let w2 = w * w
let h2 = h * h
let d2 = d * d
let w3 = (w - 1.5) * (w - 1.5)
let h3 = (h - 1.5) * (h - 1.5)
let d3 = (d - 1.5) * (d - 1.5)
for (let y = floor(-h); y <= ceil(h); y++) {
for (let x = floor(-w); x <= ceil(w); x++) {
for (let z = floor(-d); z <= ceil(d); z++) {
let n = x * x / w2 + y * y / h2 + z * z / d2
let n2 = x * x / w3 + y * y / h3 + z * z / d3
if (n < 1 && n2 >= 1) {
world.setBlock(round(X + x), round(Y + y), round(Z + z), id, false,false,false,false, dimension)
await sleep(10)
if(cancelShape > cid) return
}
}
}
}
}
async function ball(w, h, d, id, X,Y,Z, dimension,world) {
let cid = cancelShape
let w2 = w * w
let h2 = h * h
let d2 = d * d
for (let y = floor(-h); y <= ceil(h); y++) {
for (let x = floor(-w); x <= ceil(w); x++) {
for (let z = floor(-d); z <= ceil(d); z++) {
let n = x * x / w2 + y * y / h2 + z * z / d2
if (n < 1) {
world.setBlock(round(X + x), round(Y + y), round(Z + z), id, false,false,false,false, dimension)
await sleep(10)
if(cancelShape > cid) return
}
}
}
}
}
/*function parsePosition(x,px,int=false){//stuff inside by Trexler
let ret
if(x.startsWith('~+')){
ret = px+parseFloat(x.split("+")[1])
}else if(x.startsWith('~-')){
ret = px-parseFloat(x.split("-")[1])
}else{
ret = x.startsWith('~')?px:parseFloat(x)
}
if(int) ret = round(ret)
return ret
}*/
function parseTarget(str,pos,world){
if(str === "@s"){
return [pos]
}else if(str === "@a"){
let a = world.players.slice()
return a
}else if(str === "@e"){
return world.entities.slice()
}else if(str === "@p"){
let closest = Infinity, cp = undefined
for(let P of world.players){
let d = dist3(pos.x,pos.y,pos.z,P.x,P.y,P.z)
if(d < closest){
closest = d
cp = P
}
}
return [cp]
}else{
let p = getPlayerByUsername(str,world)
return p ? [p] : []
}
}
/*
types can be: root,literal,argument,redirect
if func exists, the node can be run with it at the end of stack
next is array of node ids
*/
/*let defaultServerCommandNodes = [
{
type:"root",
next:[
'fromPlayer', 'fillToPlayer', 'copyToPlayer', 'pasteAtPlayer', 'replaceToPlayer', 'cancelFrom', 'shape', 'cancelShape',
'give', 'kill', 'time', 'weather', 'teleportToPlayer', 'teleport', 'playSound', 'title', 'setBlock', 'getBlock', 'setTag', 'getTag',
'echo', 'var', 'solve', 'getPos', 'wait', 'getTime', 'blockInfo', 'seed', 'trigger', 'effect', 'clear', 'clearHistory',
'gameMode', 'spectatePlayer', 'reloadChunks', 'ban', 'unban', 'whitelist', 'online', 'sendEval', 'help'
]
},
,];const lateraaa=[//todo below
{
type:"literal",
id:"fromPlayer",
name: "fromPlayer",
info: "Sets starting position to player position",
func: (args,pos,scope,world) => fromPlayer(pos,world),
anonymousFunc: null
},
{
type:"literal",
id:"fillToPlayer",
name: "fillToPlayer",
next:["blockNameFillToPlayer"],
info: "Fills from starting position to player position",
anonymousFunc: null,
func: (args,pos,scope,world) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
fillToPlayer(id,pos,world)
},
},
{
type:"literal",
name: "copyToPlayer",
info: "Copys blocks from starting position to player position",
func: (args,pos,scope,world) => copyToPlayer(pos,world),
anonymousFunc: null
},
{
type:"literal",
name: "pasteAtPlayer",
info: "Pastes copied blocks at the player's position",
func: (args,pos,scope,world) => pasteAtPlayer(pos,world),
anonymousFunc: null
},
{
type:"literal",
name: "replaceToPlayer",
args: ["replace_what", "with_what"],
argValues:{replace_what:"type:block",with_what:"type:block"},
func: (args,pos,scope,world) => {
let replace = blockIds[args.replace_what]
if(!args.replace_what) replace = 0
let into = blockIds[args.with_what]
if(!args.with_what) into = 0
replaceAtPlayer(replace,into,pos,world)
},
anonymousFunc: null
},
{
type:"literal",
name:"cancelFrom",
info:"Delete starting position",
client:true
},
{
type:"literal",
name: "shape",
info: "Type can be: sphere, hollowSphere, cylinder, hollowCylinder",
args: ["type","width", "height", "depth", "block_name", "x", "y", "z"],
argValues: {block_name:"type:block",x:"type:x",y:"type:y",z:"type:z",type:["sphere","hollowSphere","cylinder","hollowCylinder"],width:"type:number",height:"type:number",depth:"type:number"},
func: (args,pos,scope,world) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
let x = args.x ? parseFloat(args.x) : pos.x,
y = args.y ? parseFloat(args.y) : pos.y,
z = args.z ? parseFloat(args.z) : pos.z,
width = parseFloat(args.width) || 0,
height = parseFloat(args.height) || 0,
depth = parseFloat(args.depth) || 0
if(args.type === "sphere") return ball(width, height, depth, id, x,y,z, pos.dimension, world)
else if(args.type === "hollowSphere") return sphereoid(width, height, depth, id, x,y,z, pos.dimension, world)
else if(args.type === "cylinder") return cyl(width, height, depth, id, x,y,z, pos.dimension, world)
else if(args.type === "hollowCylinder") return hcyl(width, height, depth, id, x,y,z, pos.dimension, world)
else return ["No such shape: "+args.type,"error"]
}
},
{
type:"literal",
name:"cancelShape",
info:"Stop generating shapes currently being generated.",
func: () => {
cancelShape++
}
},
{
type:"literal",
name: "give",
args: ["target", "block_name", "amount"],
argValues:{block_name:"type:block",target:["type:player","@s","@a","@p"],amount:"type:number"},
info: "Gives the target the the specified amount of specified blocks",
func: (args,pos,scope,world) => {
let id = blockIds[args.block_name]
let amount = parseInt(args.amount) || 1
let arr = parseTarget(args.target,pos,world)
if(arr){
for(let i of arr){
world.addItems(i.x,i.y,i.z,i.dimension,0,0,0,id,false,amount)
}
}else return ["No such target: "+args.target,"error"]
}
},
{
type:"literal",
name: "kill",
args: ["target","message"],
argValues:{target:["type:player","@s","@a","@e","@p"]},
info: "Target can be: @s, your username, someone's uername, @a, @e",
func: (args,pos,scope,world) => {
if(world.settings.killCmdOff) return ["Kill command is disabled on this world.","error"]
args.target = args.target || "@s"
let arr = parseTarget(args.target,pos,world)
if(arr){
for(let i of arr){
if(i.type === "Player"){
world.sendPlayer({type:"kill", data:args.message || pos.username+" killed "+(args.target === "@a" ? "everyone" : args.target)+" with the kill command."},i.id)
}else{
world.deleteEntity(i.id)
}
}
}else return ["No such target: "+args.target,"error"]
}
},
{
type:"literal",
name: "time",
args: ["mode","n"],
argValues:{mode:["set","add","subtract"],n:["day","night","type:number"]},
info: "mode can be: set, add, subtract. n is the time to set to. 1000 is a day. n an also be: day, night",
func: (args,pos,scope,world) => {
let time
if(args.n === "day") time = 500
else if(args.n === "night") time = 0
else time = parseInt(args.n) || 0
if(args.mode === "set"){
world.time = time
}else if(args.mode === "add"){
world.time += time
}else if(args.mode === "subtract"){
world.time -= time
}else{
return ["No such mode: "+args.mode,"error"]
}
}
},
{
type:"literal",
name: "weather",
args: ["w"],
argValues:{w:["clear","rain","snow"]},
info: "w is the weather to set to. It can be clear, rain, or snow",
func: (args,pos,scope,world) => {
if(args.w === "rain") world.weather = "rain"
else if(args.w === "snow") world.weather = "snow"
else world.weather = ""
}
},
{
type:"literal",
name:"teleportToPlayer",
names:["tpPlayer","tpp","tptp"],
args: ["to_who","who"],
argValues:{to_who:["@s","type:player"],who:["@s","type:player"]},
info: "Teleport player [who] to [to_who]. who is optional.",
func: (args,pos,scope,world) => {
let to = parseTarget(args.to_who,pos,world)
to = to && to[0]
let who = parseTarget(args.who,pos,world)
if(!to) return ["Player doesn't exsist: "+args.to_who,"error"]
if(!who || !who.length) who = [pos]
for(let e of who) world.sendPlayer({type:"tp",x:to.x,y:to.y,z:to.z,dimension:to.dimension},e.id)
}
},
//Trexler made this command but it has been modified
{
type:"literal",
name: "teleport",
names:["tp"],
args: ["target","x","y","z","dimension"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension",target:["@s","type:player"]},
info: "x, y, and z are the coordinates to teleport to. dimension is optional.",
func: (args,pos,scope,world) => {
let target = parseTarget(args.target,pos,world)
if(!target || !target[0]) return ["No such target: "+args.target,"error"]
if(!args.x || !args.y || !args.z) return ["You need to set the coordinates.","error"]
let px = pos.x, py = pos.y, pz = pos.z
let x = parsePosition(args.x,px)
let y = parsePosition(args.y,py)
let z = parsePosition(args.z,pz)
if(isNaN(x)) x = px
if(isNaN(y)) y = py
if(isNaN(z)) z = pz
let dimension = args.dimension || pos.dimension
for(let t of target) world.sendPlayer({type:"tp",x,y,z,dimension},t.id)
}
},
{
type:"literal",
name:"playSound",
args:["sound", "volume", "pitch"],
argValues:{sound:"type:sound",volume:"type:number",pitch:"type:number"},
info:"Plays a sound. Sound can be any sound, for example: click, block.grass.dig1, entity.generic.explode1. Volume is a number from 0 to 1.",
func: (args,pos,scope,world) => {
if(!args.sound) return ["The first argument (sound) is required.","error"]
let volume = parseFloat(args.volume) || 1
let pitch = parseFloat(args.pitch) || 1
world.playSound(null,null,null,args.sound, volume, pitch)
//return ["That sound doesn't exist.","error"]
}
},
{
type:"literal",
name:"title",
args:['text','subtext','color','fadeIn','fadeOut','stay'],
argValues:{fadeIn:"type:number",fadeOut:"type:number",stay:"type:number"},
info:"Shows text on screen. fadeIn and fadeOut and stay are miliseconds.",
func: (args,pos,scope,world) => {
args.text = args.text || "/title"
args.fadeIn = (args.fadeIn || args.fadeIn === 0) ? parseFloat(args.fadeIn) : 500
args.fadeOut = (args.fadeOut || args.fadeOut === 0) ? parseFloat(args.fadeOut) : 2000
args.stay = (args.stay || args.stay === 0) ? parseFloat(args.stay) : 1000
world.sendAll({type:"title",data:args.text,sub:args.subtext,color:args.color,fadeIn:args.fadeIn,fadeOut:args.fadeOut,stay:args.stay})
}
},
{
type:"literal",
name:"setBlock",
args:["x","y","z","dimension","block"],
argValues:{block:"type:block",x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension"},
info:"Sets a block at a specified position.",
func: (args,pos,scope,world) => {
let block = blockIds[args.block]
if(block === undefined) block = parseInt(args.block)
if(!blockData[block]) return ["No such block "+block,"error"]
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
world.setBlock(x,y,z,block,false,false,false,false,dimension)
}
},
{
type:"literal",
name:"getBlock",
args:["x","y","z","dimension"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension"},
info:"Gets a block at the specified position and sets a variable called block_name.",
func: (args,pos,scope,world) => {
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
scope.block_name = blockData[world.getBlock(x,y,z,dimension)].name
}
},
{
type:"literal",
name:"setTag",
args:["x","y","z","dimension","tag_name","tag_data"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension"},
info:"Sets a specified tag at a specified position. tag_name can be JSON or raw text.",
func: (args,pos,scope,world) => {
let data
try{
data = JSON.parse(args.tag_data)
}catch{
data = args.tag_data
}
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
try{
world.setTagByName(x,y,z,args.tag_name,data, false,dimension)
}catch(e){
return [e.message,"error"]
}
}
},
{
type:"literal",
name:"getTag",
args:["x","y","z","dimension","tag_name"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension"},
info:"Gets a specified tag at the specified position and sets a variable called tag_data. tag_data will be JSON string if not a string.",
func: (args,pos,scope,world) => {
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
scope.tag_data = world.getTagByName(x,y,z,args.tag_name,dimension)
if(typeof scope.tag_data !== "string") scope.tag_data = JSON.stringify(scope.tag_data)
}
},
/*{
name:"online",
noCheats: true,
info: "Lists people that are in this world.",
func: (args,pos,scope,world) => {
let arr = world.players.map(u => u.username)
let str = "<span style='color:lime;'>"+arr.length + " players online: " + arr.join(", ")
let bannedLength = 0
for(let b in world.banned) bannedLength ++
if(bannedLength){
str += "<br>"
str += bannedLength + " players banned: "
for(let b in world.banned) str += b + ", "
str = str.slice(0,str.length-2)
}
if(world.whitelist){
str += "<br>"
str += world.whitelist.length + " players whitelisted: "+world.whitelist.join(", ")
}
return [str,""]
}
},*-/
{
type:"literal",
name:"echo",
args:["data"],
info:"Outputs data.",
func: args => {
return [args.data+"",""]
}
},
{
type:"literal",
name:"var",
args:["name","value"],
info:"Set a variable to a value. Value can be empty.",
func: (args,pos,scope) => {
if(!args.name) return ["Error: name required.","error"]
scope[args.name] = args.value
}
},
{
type:"literal",
name:"solve",
args:["value1","operation","value2"],
argValues:{operation:["+","-","/","*","<",">","=","round","floor","ceil","sin","cos","tan","sqrt","%"]},
info:"Calculate operation on value1 and value2 and sets a variabled called value. Some operations don't use value2. Example: /solve 1 + 1",
func: (args,pos,scope) => {
let value1 = typeof args.value1 === "number" ? args.value1 : parseFloat(args.value1), value2 = typeof args.value2 === "number" ? args.value2 : parseFloat(args.value2)
if(isNaN(value1) || isNaN(args.value1)) value1 = args.value1
if(isNaN(value2) || isNaN(args.value2)) value2 = args.value2
switch(args.operation){
case "+":
scope.value = value1+value2
break
case "-":
scope.value = value1-value2
break
case "*":
scope.value = value1*value2
break
case "/":
scope.value = value1/value2
break
case "<":
scope.value = value1<value2
break
case ">":
scope.value = value1>value2
break
case "=":
scope.value = value1===value2
break
case "round":
scope.value = round(value1)
break
case "floor":
scope.value = floor(value1)
break
case "ceil":
scope.value = ceil(value1)
break
case "sin":
scope.value = sin(value1)
break
case "cos":
scope.value = cos(value1)
break
case "tan":
scope.value = tan(value1)
break
case "sqrt":
scope.value = sqrt(value1)
break
case "%":
scope.value = value1 % value2
break
default:
return ["No such operation called "+args.operation,"error"]
}
//scope.value += "" //convert to string
}
},
{
type:"literal",
name:"getPos",
names:["gp"],
args:["target"],
argValues:{target:["type:player","@s","@p"]},
info:"Gets position of specified target and sets target_x, target_y, target_z, target_dimension, target_name. Target can be @s, @p, or a username.",
func: (args,pos,scope,world) => {
args.target = args.target || "@s"
let arr = parseTarget(args.target,pos,world)
if(!arr || !arr[0]) return ["No such target: "+args.target,"error"]
let t = arr[0]
scope.target_x = t.x
scope.target_y = t.y
scope.target_z = t.z
scope.target_dimension = t.dimension
scope.target_name = t.username || t.name
}
},
{
type:"literal",
name:"wait",
args:["time"],
argValues:{time:["type:number"]},
info:"Wait for time miliseconds.",
func: args => {
return sleep(parseFloat(args.time))
}
},
{
type:"literal",
name:"getTime",
args:["timestart"],
argValues:{timestart:["type:number"]},
info:"Sets time to the current time in miliseconds. If timestart is specified, the time is subtracted from timestart.",
func: (args,pos,scope) => {
scope.time = Date.now()
if(args.timestart) scope.time -= parseInt(args.timestart)
}
},
{
type:"literal",
name:"blockInfo",
names:["bi"],
args:["block"],
argValues:{block:["type:block"]},
func: args => {
let block = blockData[blockIds[args.block]]
if(!block){
return ["No such block "+args.block,"error"]
}
let str = ''
for(let i in block){
if(i === "shape") continue
str += i+": "
if(typeof block[i] === "function") str += "function() { [code] }"
else if(typeof block[i] === "string") str += block[i]
else str += JSON.stringify(block[i])
str += "<br>"
}
return [str,""]
},
noCheats:true
},
{
type:"literal",
name:"seed",
noCheats:true,
func: (args,pos,scope,world) => [world.worldSeed+"",""]
},
{
type:"literal",
name:"trigger",
args:["condition","x","y","z","dimension"],
argValues:{x:"type:x",y:"type:y",z:"type:z",dimension:"type:dimension",condition:"type:boolean"},
info:"Trigger a command block at specified position if condition is a true value. condition may be a variable.",
func: (args,pos,scope,world) => {
if(!args.condition) return
let x = parsePosition(args.x,pos.x,true),
y = parsePosition(args.y,pos.y,true),
z = parsePosition(args.z,pos.z,true),
dimension = args.dimension || pos.dimension
let block = world.getBlock(x,y,z,dimension)
if(blockData[block].commandBlock){
blockData[block].trigger(x,y,z,dimension,world)
}
}
},
{
type:"literal",
name:"effect",
args:["target","name","time","level","hide_particles"],
argValues:{target:["type:player","@a","@e","@p"], name:["wither","blur"], time:["type:number"], level:"type:number", show_particles:"type:boolean"},
info:"Start a effect on target. time is in seconds. level should be more than zero.",
func: (args,pos,scope,world) => {
let arr = parseTarget(args.target,pos,world)
if(!arr || !arr[0]) return ["No such target: "+args.target,"error"]
let time = parseFloat(args.time)
let level = parseFloat(args.level)
let showParticles = args.hide_particles !== "true"
for(let ent of arr){
if(ent.applyEffect) ent.applyEffect(args.name, level,time,showParticles)
}
}
},
//client side commands
{
type:"literal",
name: "clear",
info: "Clears shown messages",
client:true,
noCheats: true
},
{
type:"literal",
name:"clearHistory",
info:"Clears chat history and input history.",
names:"ch",
client:true,
noCheats: true
},
{
type:"literal",
name:"gameMode",
names: ["gm"],
args: ["mode"],
argValues:{mode:["creative","c","survival","s","spectator","l"]},
info: "mode can be: creative, c, survival, s, spectator",
client:true,
},
{
type:"literal",
name:"spectatePlayer",
names:["sp"],
args:["username","remote_control"],
argValues:{username:"type:player",remote_control:"type:boolean"},
info:"Spectate a player. If remote_control is set to true and you are the host or certain people, remote control will be enabled.",
client:true,
},
{
type:"literal",
name:"reloadChunks",
info:"Reload chunks. May cause freezing.",
client:true,
},
{
type:"literal",
name: "ban",
args: ["username","reason"],
argValues:{username:"type:player"},
info: "Bans a player. They cannot rejoin the world. Reason is the reason why you banned them. Only bans them until multiplayer turns off",
client:true,
noCheats:true
},
{
type:"literal",
name: "unban",
args: ["username"],
argValues:{username:"type:banned"},
info: "Unbans a player.",
client:true,
noCheats:true
},
{
type:"literal",
name:"whitelist",
args: ["action","username"],
argValues:{action:["enable","disable","add","remove"],username:["type:player","type:whitelisted"]},
info: "Allow certain people to join. Uses:<br>/whitelist enable<br>/whitelist disable<br>/whitelist add username<br>/whitelist remove username",
client:true,
noCheats: true
},
{
type:"literal",
name:"online",
noCheats: true,
info: "Lists people that are in this world.",
client:true,
},
{
type:"literal",
name:"sendEval",
args:["target","data"],
argValues:{target:["type:player","@a","@A"]},
info:"Send javascript to players. Can only be used by certain people. Target can be: username, @a, @A. If target isn't specified, it sends it to all players except you. If target is @A, it send to everyone including you.",
client:true,
},
{
type:"literal",
name:"help",
names:["?"],
args:["command_name"],
client:true,
noCheats:true
}
]
win.defaultServerCommandNodes = defaultServerCommandNodes*/
let tempWorldForCommand
class CommandNode{
constructor(type, name, func, info, argType, redirect, anonymousFunc, noCheats){
this.type = type
this.name = name
this.func = func || undefined
this.next = []
this.world = tempWorldForCommand
this.info = info || undefined
this.redirect = redirect || undefined
this.argType = argType || undefined
this.anonymousFunc = anonymousFunc
this.id = tempWorldForCommand.commandNodes.length
this.noCheats = noCheats || false
tempWorldForCommand.commandNodes.push(this)
}
then(){
for(let n of arguments) this.next.push(n.id)
return this
}
static l(name,func,info,anonymousFunc,noCheats){
return new this("literal",name,func,info,null,null,anonymousFunc,noCheats)
}
static a(name,func,argType,anonymousFunc,noCheats){
return new this("argument",name,func,null,argType,null,anonymousFunc,noCheats)
}
static r(name,redirect){
return new this("redirect",name,null,null,null,redirect.id)
}
}
function initDefaultCommands(world){
tempWorldForCommand = world
let help, tp, gm, sp
new CommandNode("root").then(
help = CommandNode.l("help","client").then(CommandNode.a("help_with_name","client")),
CommandNode.r("?",help),
CommandNode.l("echo",null,"Outputs data.").then(CommandNode.a("data", (args,pos,scope) => [args.data+"",""], null,null,true)),
CommandNode.l("var",null, "Set a variable to a value. Value can be empty.").then(CommandNode.a("name").then(CommandNode.a("value",
(args,pos,scope) => {
if(!args.name) return ["Error: name required.","error"]
scope[args.name] = args.value
},null,null,true))),
CommandNode.l("fromPlayer", (args,pos,scope) => fromPlayer(pos,world), "Sets starting position to current position", false),
CommandNode.l("fillToPlayer",null,"Fills from starting position to current position").then(CommandNode.a("block_name",
(args,pos,scope) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
fillToPlayer(id,pos,world)
},"block",false)),
CommandNode.l("copyToPlayer",(args,pos,scope) => copyToPlayer(pos,world),"Copys blocks from starting position to current position",false),
CommandNode.l("pasteAtPlayer", (args,pos,scope) => pasteAtPlayer(pos,world), "Pastes copied blocks at the current position",false),
CommandNode.l("replaceToPlayer",null,"Replace certain blocks from starting position to current position with a certain block").then(CommandNode.a("replace_what",null,"block").then(CommandNode.a("with_what",
(args,pos,scope) => {
let replace = blockIds[args.replace_what]
if(!args.replace_what) replace = 0
let into = blockIds[args.with_what]
if(!args.with_what) into = 0
replaceAtPlayer(replace,into,pos,world)
},"block",false))),
CommandNode.l("cancelFrom","client","Delete starting position"),
CommandNode.l("shape",null,"Creates a shape of certain shape.").then(
CommandNode.l("sphere").then(CommandNode.a("width",null,"number").then(CommandNode.a("height",null,"number").then(CommandNode.a("depth",null,"number").then(CommandNode.a("block_name",
(args,pos) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
return ball(args.width || 0, args.height || 0, args.depth || 0, id, pos.x,pos.y,pos.z, pos.dimension, world)
},"block").then(CommandNode.a("x",null,"number").then(CommandNode.a("y",null,"number").then(CommandNode.a("z",
(args,pos) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
return ball(args.width || 0, args.height || 0, args.depth || 0, id, args.x,args.y,args.z, pos.dimension, world)
},"number")))))))),
CommandNode.l("hollowSphere").then(CommandNode.a("width",null,"number").then(CommandNode.a("height",null,"number").then(CommandNode.a("depth",null,"number").then(CommandNode.a("block_name",
(args,pos) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
return sphereoid(args.width || 0, args.height || 0, args.depth || 0, id, pos.x,pos.y,pos.z, pos.dimension, world)
},"block").then(CommandNode.a("x",null,"number").then(CommandNode.a("y",null,"number").then(CommandNode.a("z",
(args,pos) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
return sphereoid(args.width || 0, args.height || 0, args.depth || 0, id, args.x,args.y,args.z, pos.dimension, world)
},"number")))))))),
CommandNode.l("cylinder").then(CommandNode.a("width",null,"number").then(CommandNode.a("height",null,"number").then(CommandNode.a("depth",null,"number").then(CommandNode.a("block_name",
(args,pos) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
return cyl(args.width || 0, args.height || 0, args.depth || 0, id, pos.x,pos.y,pos.z, pos.dimension, world)
},"block").then(CommandNode.a("x",null,"number").then(CommandNode.a("y",null,"number").then(CommandNode.a("z",
(args,pos) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
return cyl(args.width || 0, args.height || 0, args.depth || 0, id, args.x,args.y,args.z, pos.dimension, world)
},"number")))))))),
CommandNode.l("hollowCylinder").then(CommandNode.a("width",null,"number").then(CommandNode.a("height",null,"number").then(CommandNode.a("depth",null,"number").then(CommandNode.a("block_name",
(args,pos) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
return hcyl(args.width || 0, args.height || 0, args.depth || 0, id, pos.x,pos.y,pos.z, pos.dimension, world)
},"block").then(CommandNode.a("x",null,"number").then(CommandNode.a("y",null,"number").then(CommandNode.a("z",
(args,pos) => {
let id = blockIds[args.block_name]
if(!args.block_name) id = 0
return hcyl(args.width || 0, args.height || 0, args.depth || 0, id, args.x,args.y,args.z, pos.dimension, world)
},"number"))))))))
),
CommandNode.l("cancelShape", () => {cancelShape++}, "Stop generating shapes currently being generated."),
CommandNode.l("give",null,"Gives the target the the specified amount of specified blocks").then(CommandNode.a("target",null,"target").then(CommandNode.a("block_name",
(args,pos,scope) => {
let id = blockIds[args.block_name]
let arr = parseTarget(args.target,pos,world)
if(arr.length){
for(let i of arr){
world.addItems(i.x,i.y,i.z,i.dimension,0,0,0,id,false,1)
}
}else return ["No such target: "+args.target,"error"]
},"block").then(CommandNode.a("amount",
(args,pos,scope) => {
let id = blockIds[args.block_name]
let amount = args.amount || 1
let arr = parseTarget(args.target,pos,world)
if(arr.length){
for(let i of arr){
world.addItems(i.x,i.y,i.z,i.dimension,0,0,0,id,false,amount)
}
}else return ["No such target: "+args.target,"error"]
},"number")))),
CommandNode.l("kill").then(CommandNode.a("target",
(args,pos,scope) => {
if(world.settings.killCmdOff) return ["Kill command is disabled on this world.","error"]
args.target = args.target || "@s"
let arr = parseTarget(args.target,pos,world)
if(arr.length){
for(let i of arr){
if(i.type === "Player"){
i.health = 0
i.damage(1,pos.username+" killed "+(args.target === "@a" ? "everyone" : args.target)+" with the kill command.")
}else{
world.deleteEntity(i.id)
}
}
}else return ["No such target: "+args.target,"error"]
},"target").then(CommandNode.a("message",
(args,pos,scope) => {
if(world.settings.killCmdOff) return ["Kill command is disabled on this world.","error"]
args.target = args.target || "@s"
let arr = parseTarget(args.target,pos,world)
if(arr.length){
for(let i of arr){
if(i.type === "Player"){
i.health = 0
i.damage(1,arg.message)
}else{
world.deleteEntity(i.id)
}
}
}else return ["No such target: "+args.target,"error"]
}))),
CommandNode.l("time",null,"mode can be: set, add. n is the time to set to. 1000 is a day. n an also be: day, night").then(
CommandNode.l("set").then(CommandNode.a("time", args => {world.time = args.time === "day" ? 500 : (args.time === "night" ? 0 : parseFloat(args.time))},"number")),
CommandNode.l("add").then(CommandNode.a("amount", args => {world.time += parseFloat(args.time)},"number"))
),
CommandNode.l("weather",null,"Set weather. May take a few moments to start.").then(
CommandNode.l("clear", () => {world.weather = "clear"}),
CommandNode.l("rain", () => {world.weather = "rain"}),
CommandNode.l("snow", () => {world.weather = "snow"})
),
tp = CommandNode.l("teleport",null,"Teleport certain player/self to location/entity/player").then(CommandNode.a("target",null,"target").then(
CommandNode.a("x",null,"x").then(CommandNode.a("y",null,"y").then(CommandNode.a("z",
(args,pos) => {
let arr = parseTarget(args.target,pos,world)
for(let e of arr) e.tp(args.x,args.y,args.z)
}, "z"))),
CommandNode.a("to_target",
(args,pos) => {
let arr = parseTarget(args.target,pos,world), to = parseTarget(args.to_target,pos,world)[0]
if(!to) return ["No such target: "+args.target,"error"]
for(let e of arr) e.tp(args.x,args.y,args.z)
},"target")
)),
CommandNode.r("tp",tp),
CommandNode.l("playSound",null,"Plays a sound. Volume should be a number from 0 to 1.").then(CommandNode.a("sound",
(args,pos,scope) => {
world.playSound(null,null,null,args.sound, 1, 1)
},"sound").then(CommandNode.a("volume",
(args,pos,scope) => {
world.playSound(null,null,null,args.sound, parseFloat(args.volume), 1)
},"number").then(CommandNode.a("pitch",
(args,pos,scope) => {
world.playSound(null,null,null,args.sound, parseFloat(args.volume), parseFloat(args.pitch))
},"number")))),
CommandNode.l("title",null,"Shows text on screen. fadeIn and fadeOut and stay are miliseconds.").then(CommandNode.a("text", args => {world.sendAll({type:"title",data:args.text,fadeIn:500,fadeOut:1000,stay:2000})}).then(CommandNode.a("subtext", args => {world.sendAll({type:"title",data:args.text,sub:args.subtext,fadeIn:500,fadeOut:1000,stay:2000})}).then(CommandNode.a("color", args => {world.sendAll({type:"title",data:args.text,sub:args.subtext,color:args.color,fadeIn:500,fadeOut:1000,stay:2000})}).then(
CommandNode.a("fadeIn",null,"number").then(CommandNode.a("fadeOut",null,"number").then(CommandNode.a("stay",args => {world.sendAll({type:"title",data:args.text,sub:args.subtext,color:args.color,fadeIn:args.fadeIn,fadeOut:args.fadeOut,stay:args.stay})},"number")))
)))),
CommandNode.l("setBlock",null,"Set a block at specified position").then(CommandNode.a("x",null,"x").then(CommandNode.a("y",null,"y").then(CommandNode.a("z",null,"number").then(CommandNode.a("block",
args => {
let block = blockIds[args.block]
if(block === undefined) block = parseInt(args.block)
if(!blockData[block]) return ["No such block "+block,"error"]
world.setBlock(args.x,args.y,args.z,block,false,false,false,false,pos.dimension)
},"block"))))),
CommandNode.l("getBlock",null,"Gets a block at the specified position and sets a variable called block_name.").then(CommandNode.a("x",null,"x").then(CommandNode.a("y",null,"y").then(CommandNode.a("z",
(args,pos,scope) => {
scope.block_name = blockData[world.getBlock(args.x,args.y,args.z,pos.dimension)].name
},"z")))),
CommandNode.l("getPos",null,"Gets position of specified target and sets target_x, target_y, target_z, target_dimension, target_name. Target can be @s, @p, or a username.").then(CommandNode.a("target",
(args,pos,scope) => {
args.target = args.target || "@s"
let arr = parseTarget(args.target,pos,world)
if(!arr.length) return ["No such target: "+args.target,"error"]
let t = arr[0]
scope.target_x = t.x
scope.target_y = t.y
scope.target_z = t.z
scope.target_dimension = t.dimension
scope.target_name = t.username || t.name
},"target")),
CommandNode.l("wait",null,"Wait for certain amount of milliseconds.").then(CommandNode.a("time", args => {sleep(args.time)},"number",null,true)),
CommandNode.l("seed", () => [world.worldSeed+"",""], null,null,true),
CommandNode.l("effect",null,"Start a effect on target. time is in seconds. level should be more than zero.").then(CommandNode.a("target",null,"target").then(CommandNode.a("name").then(CommandNode.a("time",null,"number").then(CommandNode.a("level",
(args,pos,scope) => {
let arr = parseTarget(args.target,pos,world)
if(!arr.length) return ["No such target: "+args.target,"error"]
let time = parseFloat(args.time)
let level = parseFloat(args.level)
for(let ent of arr){
if(ent.applyEffect) ent.applyEffect(args.name, level,time,true)
}
},"number").then(CommandNode.a("hide_particles",
(args,pos,scope) => {
let arr = parseTarget(args.target,pos,world)
if(!arr.length) return ["No such target: "+args.target,"error"]
let time = parseFloat(args.time)
let level = parseFloat(args.level)
let showParticles = args.hide_particles
for(let ent of arr){
if(ent.applyEffect) ent.applyEffect(args.name, level,time,showParticles)
}
},"boolean")))))),
gm = CommandNode.l("gameMode",null,"Set game mode.",null,true).then(CommandNode.a("mode",
(args,pos) => {
let m = args.mode
if(m === "creative" || m === "c") pos.gameMode = "creative"
else if(m === "survival" || m === "s") pos.gameMode = "survival"
else if(m === "spectator" || m === "l") pos.gameMode = "spectator", pos.riding = null
else return ["Game mode doesn't exsist: "+m,"error"]
world.sendPlayer({type:"gameMode",gameMode:pos.gameMode},pos.id)
},"gameMode",false)),
CommandNode.r("gm",gm),
CommandNode.l("clear","client","Clear messages",null,true),
CommandNode.l("clearHistory","client","Clears chat history and input history.",null,true),
sp = CommandNode.l("spectatePlayer",null,"Spectate a player. If remote_control is set to true and you are the host or certain people, remote control will be enabled.").then(CommandNode.a("username",
(args,pos) =>{
let player = getPlayerByUsername(arg.username,world)
if(player){
pos.gameMode = "spectator"
pos.riding = null
if(args.spectatePlayer_remoteControl === true) p.spectateRemoteControl = true
world.sendPlayer({type:"gameMode",gameMode:pos.gameMode, spectating:player.id,spectateRemoteControl:false},pos.id)
}else return ["Player doesn't exist: "+args.username,"error"]
}).then(CommandNode.a("remoteControl",
(args,pos) =>{
let player = getPlayerByUsername(arg.username,world)
if(player){
pos.gameMode = "spectator"
pos.riding = null
world.sendPlayer({type:"gameMode",gameMode:pos.gameMode, spectating:player.id,spectateRemoteControl:false,spectateRemoteControl:!!args.remoteControl},pos.id)
}else return ["Player doesn't exist: "+args.username,"error"]
},"boolean"))),
CommandNode.r("sp",sp),
CommandNode.l("reloadChunks","client","Reload chunks. May cause freezing.",true),
CommandNode.l("ban",null,"Bans a player. They cannot rejoin the world. Reason is the reason why you banned them.").then(CommandNode.a("ban_username","client",null,null,true).then(CommandNode.a("ban_reason","client",null,null,true))),
CommandNode.l("unban").then(CommandNode.a("unban_username","client",null,null,true)),
CommandNode.l("whitelist",null,"Allow certain people to join. Must be enabled to work.").then(CommandNode.a("whitelist_action","client",null,null,true).then(CommandNode.a("whitelist_username","client",null,null,true))),
CommandNode.l("online","client","Lists people that are in here.",null,true),
CommandNode.l("sendEval",null,"Send javascript to players. Can only be used by certain people. Target can be: username, @a, @A. If target isn't specified, it sends it to all players except you. If target is @A, it send to everyone including you.").then(CommandNode.a("target",null,"target").then(CommandNode.a("sendEval_data","client")))
)
/*args:["target","name","time","level","hide_particles"],
argValues:{target:["type:player","@a","@e","@p"], name:["wither","blur"], time:["type:number"], level:"type:number", show_particles:"type:boolean"},
info:"Start a effect on target. time is in seconds. level should be more than zero.",
func: (args,pos,scope,world) => {
let arr = parseTarget(args.target,pos,world)
if(!arr || !arr[0]) return ["No such target: "+args.target,"error"]
let time = parseFloat(args.time)
let level = parseFloat(args.level)
let showParticles = args.hide_particles !== "true"
for(let ent of arr){
if(ent.applyEffect) ent.applyEffect(args.name, level,time,showParticles)
}
} */
}
win.initDefaultCommands = initDefaultCommands
}
const {initDefaultCommands} = win
/*function getCmd(name,world){
for(let i of world.serverCommands){
if(i.name.toLowerCase() === name.toLowerCase()){
return i
}
if(i.names && i.names.includes(name)){
return i
}
}
}*/
const isString = /\p{L}|\p{N}|\?|_|@|\./u, isSpace = /[^\S\n]/
class CommandReader{
constructor(str, noRead){
this.str = str
this.idx = 0
this.tokenStart = 0
this.prevTokenEnd = 0
this.prevTokenStart = 0
if(!noRead) this.read()
}
read(){
if(arguments.length)expectCheck:{
for(let i of arguments){
if(this.nextTokenType === i) break expectCheck
}
throw "§cSyntax error: Unexpected "+this.nextTokenType+", Expected: "+Array.prototype.join.call(arguments," ")
}
let prevToken = this.nextTokenData
this.prevTokenEnd = this.idx
//get next token
const {str} = this
let c = str[this.idx]
while(isSpace.test(c) || c === "#"){
if(c === "#"){//comment
while(c !== "\n" && c){
this.idx++
c = str[this.idx]
}
}else{//space
this.idx++
c = str[this.idx]
}
}
this.nextTokenData = null
this.prevTokenStart = this.tokenStart
this.tokenStart = this.idx
if(this.idx >= str.length){
this.nextTokenType = "end"
return prevToken
}
if(c === "/" || c === "$" || c === "\n" || c === "+" || c === "-" || c === "*" || c === "(" || c === ")" || c === "~") this.nextTokenType = c, this.idx++
else if(c === "&" && str[this.idx+1] === "&") this.nextTokenType = "&&", this.idx+=2
else if(c === '"' || c === "'"){
const q = c
this.nextTokenType = "string"
this.nextTokenData = ""
this.idx++
c = str[this.idx]
while(c !== q && c){
this.nextTokenData += c
this.idx++
c = str[this.idx]
}
this.idx++
}else if(isString.test(c)){
this.nextTokenType = "string"
this.nextTokenData = ""
do{
this.nextTokenData += c
this.idx++
c = str[this.idx]
}while(isString.test(c) && c)
}else throw "§cSyntax error: Unknown character "+c
return prevToken
}
get stackEnd(){
return this.nextTokenType === "&&" || this.nextTokenType === "\n" || this.nextTokenType === "end"
}
get stackEndNoSpace(){
return (this.nextTokenType === "&&" || this.nextTokenType === "\n" || this.nextTokenType === "end") && this.prevTokenEnd === this.tokenStart
}
clone(){
let other = new this.constructor(this.str,true)
other.idx = this.idx
other.nextTokenType = this.nextTokenType
other.nextTokenData = this.nextTokenData
other.tokenStart = this.tokenStart
other.prevTokenEnd = this.prevTokenEnd
other.prevTokenStart = this.prevTokenStart
return other
}
goTo(other){//expects other.str to equal this.str
this.idx = other.idx
this.nextTokenType = other.nextTokenType
this.nextTokenData = other.nextTokenData
this.tokenStart = other.tokenStart
this.prevTokenEnd = other.prevTokenEnd
this.prevTokenStart = other.prevTokenStart
}
nextIs(type,data){
return this.nextTokenType === type && (!this.nextTokenData || this.nextTokenData === data)
}
}
win.CommandReader = CommandReader
//use something like this: https://wiki.vg/Command_Data
{
function parseLines(reader,world){
let cmds = ["all"]
while(reader.nextTokenType !== "end"){
if(reader.nextTokenType === "/") reader.read("/")
/*let currentNode = world.commandNodes[0]//root node
let args = {}
while(reader.nextTokenType !== "&&" && reader.nextTokenType !== "\n" && reader.nextTokenType !== "end"){
if(currentNode.next){
let found
for(let n of currentNode.next){//find next node that matches input
let node = world.commandNodes[world.commandIds[n]]
if(node.type === "literal"){
if(reader.nextTokenType === "string" && reader.nextTokenData === node.name){
currentNode = node
found = true
break
}
}else if(node.type === "argument"){
currentNode = node
found = true
break
}
}
if(!found) throw "§cUnknown command: No next node after "+currentNode.name+" for "+reader.nextTokenType+" "+reader.nextTokenData
}else throw "§cUnknown command: No next nodes for "+currentNode.name
if(node.type === "literal"){
reader.read("string")
}else if(currentNode.type === "argument"){
args[currentNode.name] = parseValue(reader)
}
}*/
/*let name = this.eat("string")
let args = {}
let cmd = getCmd(name,world)
let argIdx = 0
while(this.nextTokenType !== "&&" && this.nextTokenType !== "\n" && this.nextTokenType !== "end"){
args[cmd.args[argIdx++]] = this.parseValue()
}*/
let args = {}
cmds.push(["cmd",parseNodes(reader,world.commandNodes[0],args,world),args])
if(reader.nextTokenType === "&&" || reader.nextTokenType === "\n") reader.read("&&","\n")
}
return cmds
}
function parseNodes(reader,parentNode,args,world){
if(parentNode.type === "redirect"){
parentNode = world.commandNodes[parentNode.redirect]
}
if(!parentNode.next.length) throw "§cUnknown command: No more nodes after "+parentNode.name
let error
for(let n of parentNode.next){//find the best match in the next nodes
let node = world.commandNodes[n]
let newReader = reader.clone()
if(node.type === "literal" || node.type === "redirect"){
if(newReader.read("string").toLowerCase() !== node.name.toLowerCase()) continue
}else if(node.type === "argument"){
let thisOne
try{
thisOne = parseAdd(newReader,node.argType)
}catch(e){
error = e
}
if(thisOne !== undefined){
args[node.name] = thisOne
}else continue
}
let result
if(newReader.stackEnd){//last node in stack
if(node.type === "redirect"){
result = world.commandNodes[node.redirect]
}else result = node
if(!result.func){
error = "§cUnknown command: Incomplete command at "+node.name
continue
}
}else{
try{
result = parseNodes(newReader,node,args,world)
}catch(e){
error = e
}
}
if(result !== undefined){
reader.goTo(newReader)
return result
}
}
throw error || "§cUnknown command: Node does not go after "+parentNode.name
}
function parseAdd(reader,argType){
let ret = parseMult(reader,argType)
while(reader.nextTokenType === "+" || reader.nextTokenType === "-"){
let type = reader.nextTokenType
reader.read()
ret = [type, ret, parseMult(reader,argType)]
}
return ret
}
function parseMult(reader,argType){
let ret = parseValue(reader,argType)
while(reader.nextTokenType === "*" || reader.nextTokenType === "/"){
let type = reader.nextTokenType
reader.read()
ret = [type, ret, parseValue(reader,argType)]
}
return ret
}
function parseValue(reader,argType){
if(reader.nextTokenType === "$"){
reader.read("$")
return ["get",reader.read("string")]
}else if(reader.nextTokenType === "("){
reader.read()
let ret = parseAdd(reader)
reader.read(")")
return ret
}else if(reader.nextTokenType === "~"){
reader.read()
return ["~"+argType]
}else{
let v = reader.read("string")
if(!isNaN(v)) v = +v
else if(v === "true") v = true
else if(v === "false") v = false
return v
}
}
function parseCmd(str,world){
let reader = new CommandReader(str)
return parseLines(reader,world)
}
win.parseCmd = parseCmd
}
const {parseCmd} = win
/*function parseCmd(str,scope,world){
let hasSlash = str[0] === "/" ? "/" : ""
if(hasSlash) str = str.substring(1) //remove leading slash if there is one
let args = []
let val = "", inQuotes = false, quoteType = null, argIsVar = false
let remaining
let cmd
for(let i=0; i<str.length; i++){
let noRaw = !cmd || !cmd.args || !cmd.lastArgRaw || args.length !== cmd.args.length
if(str[i] === "/" && !(hasSlash && i === 0) && !inQuotes && noRaw){
remaining = str.substring(i)
break
}
if(noRaw && (str[i] === "'" || str[i] === '"') && (!inQuotes || quoteType === str[i])){
inQuotes = !inQuotes
quoteType = str[i]
}else if(str[i] === "$" && !inQuotes && !val){//starts with $
argIsVar = true
}else if(noRaw && (str[i] === " " || str[i] === "\n") && !inQuotes){
if(argIsVar) val = scope[val]
args.push(val)
if(args.length === 1) cmd = getCmd(val,world)
val = ""
argIsVar = false
}else val += str[i]
}
if(argIsVar) val = scope[val]
args.push(val)
if(args.length === 1) cmd = getCmd(val,world)
let name = args.shift()
args = cmd && cmd.args ? Object.fromEntries(args.filter((v,i) => i in cmd.args).map((v, i) => [cmd.args[i],v])) : {}
return [args,remaining,name,cmd]
}*/
async function runCmd(str, pos, world, anonymous = false, cb = emptyFunc, cheats = true){
let remaining = str
let output = [], newOutputs = []
let scope = {}
let cmds
try{
cmds = parseCmd(str,world)
await runParsedCommand(cmds,pos,scope,newOutputs,output,world,anonymous,cb,cheats)
}catch(e){
if(typeof e === "string"){
newOutputs.push(e,"error")
output.push(...newOutputs)
return cb(output,newOutputs)
}else throw e
}
/*while(remaining){
let [args,remain,name,cmd] = parseCmd(remaining,scope,world)
remaining = remain
await runParsedCommand(name,cmd,args,pos,scope,newOutputs,output,world,anonymous,cb,cheats)
}*/
output.push(...newOutputs)
return cb(output,newOutputs)
}
async function runParsedCommand(data,pos,scope,newOutputs,output,world,anonymous,cb,cheats){//Used if client runs server command
if(!Array.isArray(data)) return data
const action = data[0]
if(action === "cmd"){
let cmd = data[1], args = data[2]
/*if(!cmd){
throw "§cError: no such command called §f"+name
}*/
if(!cheats && !cmd.noCheats){
throw "§cError: Command requires cheats"
}
let func = anonymous ? cmd.anonymousFunc !== false && (cmd.anonymousFunc || cmd.func) : cmd.func
let actualArgs = {}
for(let i in args){
actualArgs[i] = await runParsedCommand(args[i],pos,scope,newOutputs,output,world,anonymous,cb,cheats)
}
if(cmd.func === "client"){
if(anonymous) throw "§cCannot run command "+cmd.name
else world.sendPlayer({type:"clientCmd",data:cmd.name,args:actualArgs},pos.id)
}else if(func){
let thisOutput = func(actualArgs,pos,scope)
if(thisOutput instanceof Promise){//Output previous data because new data won't be instant
output.push(...newOutputs)
cb(output,newOutputs)
newOutputs.length = 0
thisOutput = await thisOutput
}
if(thisOutput && thisOutput[1] === "error"){
throw thisOutput[0]
}
if(thisOutput) newOutputs.push(...thisOutput)
}else{
throw "§cError: Incomplete command at "+cmd.name
}
}else if(action === "all"){
for(let i=1; i<data.length; i++) await runParsedCommand(data[i],pos,scope,newOutputs,output,world,anonymous,cb,cheats)
}else if(action === "get") return scope[data[1]]
else if(action === "+") return await runParsedCommand(data[1],pos,scope,newOutputs,output,world,anonymous,cb,cheats)+await runParsedCommand(data[2],pos,scope,newOutputs,output,world,anonymous,cb,cheats)
else if(action === "-") return await runParsedCommand(data[1],pos,scope,newOutputs,output,world,anonymous,cb,cheats)-await runParsedCommand(data[2],pos,scope,newOutputs,output,world,anonymous,cb,cheats)
else if(action === "*") return await runParsedCommand(data[1],pos,scope,newOutputs,output,world,anonymous,cb,cheats)*await runParsedCommand(data[2],pos,scope,newOutputs,output,world,anonymous,cb,cheats)
else if(action === "/") return await runParsedCommand(data[1],pos,scope,newOutputs,output,world,anonymous,cb,cheats)/await runParsedCommand(data[2],pos,scope,newOutputs,output,world,anonymous,cb,cheats)
else if(action === "~x") return pos.x
else if(action === "~y") return pos.y
else if(action === "~z") return pos.z
else throw "Invalid action "+action
}
/*async function runCmdFromClient(name,args,pos,scope,world,id,cheats){
let cmd = getCmd(name,world)
let newOutputs = [], output = []
await runParsedCommand(name,cmd,args,pos,scope,newOutputs,output,world,false,undefined,cheats)
output.push(...newOutputs)
world.sendPlayer({type:"commandDone",data:output,scope,id},pos.id)
}*/
class Contacts {
constructor() {
this.array = []
this.size = 0
}
add(x, y, z, block, data) {
if (this.size === this.array.length) {
this.array.push([ x, y, z, block, data ])
} else {
this.array[this.size][0] = x
this.array[this.size][1] = y
this.array[this.size][2] = z
this.array[this.size][3] = block
this.array[this.size][4] = data
}
this.size++
}
clear() {
this.size = 0
}
}
let inBox = function(p, x, y, z, w, h, d) {
let iy = y - h/2 - p.height*0.5
let ih = h + p.height
let ix = x - w/2 - p.width*0.5
let iw = w + p.width
let iz = z - d/2 - p.depth*0.5
let id = d + p.depth
return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
}
let onBox = function(p, x, y, z, w, h, d) {
let iy = y - h/2 - p.height*0.5
let ih = h + p.height
let ix = x - w/2 - p.width*0.5
let iw = w + p.width
let iz = z - d/2 - p.depth*0.5
let id = d + p.depth
return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id
}
let touchingBox = function(p, x, y, z, w, h, d) {
let iy = y - h/2 - p.height*0.5 - 0.1
let ih = h + p.height + 0.2
let ix = x - w/2 - p.width*0.5 - 0.1
let iw = w + p.width + 0.2
let iz = z - d/2 - p.depth*0.5 - 0.1
let id = d + p.depth + 0.2
return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
}
let entities = [], entityIds = {}
class Entity {
constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns, vao, dimension) {
this.x = x
this.y = y
this.z = z
this.previousX = x
this.previousY = y
this.previousZ = z
this.canStepX = true
this.canStepY = true
this.pitch = pitch
this.yaw = yaw
this.roll = 0
this.pitch2 = 0
this.previousPitch = pitch
this.previousYaw = yaw
this.previousRoll = 0
this.previousPitch2 = 0
this.velx = velx
this.vely = vely
this.velz = velz
this.width = width
this.height = height
this.depth = depth
this.offsetY = 0
this.prevOffsetY = 0
this.extraSize = 0
this.hidden = false
this.harmEffect = 0
this.contacts = new Contacts()
this.lastUpdate = performance.now()
this.onGround = false
this.hasCollided = false
this.gravityStength = -0.11
this.standingOn = 0
this.insideBlock = 0
this.despawns = despawns
this.spawn = this.lastUpdate
this.canDespawn = false
this.dieEffect = 0
this.dieRotate = 0
this.burning = false
this.liquid = false
this.prevLiquid = false
this.wet = false
this.parts = {}
this.shader = 0
this.world = null //also set in addEntity
this.chunkX = x >> 4
this.chunkZ = z >> 4
this.chunkDimension = ""
this.glow = false
this.dimension = dimension
this.canRide = false
//this.hitboxWidth = this.hitboxWidth || max(this.width,this.depth)//unused
//this.hitboxHeight = this.hitboxHeight || this.height
this.rideOffsetX = 0
this.rideOffsetY = this.hitboxHeight/2
this.rideOffsetZ = 0
this.portalEffect = 0
this.portalFadeOutEffect = 0
this.doingPortal = 0
}
tp(x,y,z, dimension = this.dimension){
this.x = x
this.y = y
this.z = z
this.dimension = dimension
this.world.sendEntityPos(this)
this.updateChunk()
}
updateVelocity(now) {
this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
this.insideBlock = this.world.getBlock(round(this.x),round(this.y),round(this.z), this.dimension)
if(this.prevLiquid !== this.liquid){
this.prevLiquid = this.liquid
if(this.liquid && this.wet){
let pitch = (1/abs(this.y-this.previousY)*0.05+Math.random()*0.2)/((this.width+this.depth)*0.25/*0.25=average&correct width*/)
if(isFinite(pitch)) this.world.playSound(this.x,this.y-this.height/2,this.z,"liquid.splash",1,pitch)
this.world.sendAll({
type:"particles", particleType:"SplashParticle",
x:this.x, y:this.y-this.height/2, z:this.z, dimension:this.dimension, amount: 10
})
}
}
this.vely += this.gravityStength
let drag = this.liquid && !this.canFloat ? 0.7 : (this.onGround ? 0.8 : 0.9)
if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
this.velz += (this.velz * drag - this.velz)
this.velx += (this.velx * drag - this.velx)
this.vely += (this.vely * drag - this.vely)
}
collided(x, y, z, vx, vy, vz, block) {
let verts = blockData[block].shape.verts
let px = this.x - this.width / 2 - x
let py = this.y - this.height / 2 - y
let pz = this.z - this.depth / 2 - z
let pxx = this.x + this.width / 2 - x
let pyy = this.y + this.height / 2 - y
let pzz = this.z + this.depth / 2 - z
let minX, minY, minZ, maxX, maxY, maxZ, min, max
let stuckInBlock = this.mob && this.insideBlock && blockData[this.insideBlock].solid
//Top and bottom faces
let faces = verts[0]
if (vy <= 0) {
faces = verts[1]
}
if (vx === null && vz === null) {
let col = false
for (let face of faces) {
min = face.min
minX = min[0]
minZ = min[2]
max = face.max
maxX = max[0]
maxZ = max[2]
if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
col = true
if (vy <= 0) {
this.onGround = true
if(!stuckInBlock) this.y = face[1] + y + this.height / 2; else this.y = this.previousY
this.vely = 0
} else {
if(!stuckInBlock) this.y = face[1] + y - this.height / 2; else this.y = this.previousY
this.vely = 0
}
}
}
return col
}
//West and East faces
if (vx < 0) {
faces = verts[4]
} else if (vx > 0) {
faces = verts[5]
}
if (vx !== null) {
let col = false
for (let face of faces) {
min = face.min
minZ = min[2]
minY = min[1]
max = face.max
maxZ = max[2]
maxY = max[1]
if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
if (maxY - py > 0.5) {
this.canStepX = false
if(!stuckInBlock) this.x = x + face[0] + (vx < 0 ? this.width / 2 : -this.width / 2); else this.y = this.previousX
this.velx = 0
}
col = true
}
}
return col
}
//South and North faces
if (vz < 0) {
faces = verts[2]
} else if (vz > 0) {
faces = verts[3]
}
if (vz !== null) {
let col = false
for (let face of faces) {
min = face.min
minX = min[0]
minY = min[1]
max = face.max
maxX = max[0]
maxY = max[1]
if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
if (maxY - py > 0.5) {
this.canStepZ = false
if(!stuckInBlock) this.z = z + face[2] + (vz < 0 ? this.depth / 2 : -this.depth / 2); else this.y = this.previousY
this.velz = 0
}
col = true
}
}
return col
}
}
move(now) {
let steps = Math.ceil(max(abs(this.velx / (this.width/2)), abs(this.vely / (this.height/2)), abs(this.velz / (this.depth/2)), 1))
const VX = this.velx / steps
const VY = this.vely / steps
const VZ = this.velz / steps
let pminX = floor(this.x - this.width / 2)
let pmaxX = ceil(this.x + this.width / 2)
let pminY = floor(this.y - this.height / 2)
let pmaxY = ceil(this.y + this.height / 2)
let pminZ = floor(this.z - this.depth / 2)
let pmaxZ = ceil(this.z + this.depth / 2)
let block = null
let ontouch, closestTouch = Infinity
let touchX, touchY, touchZ
this.liquid = this.wet = false
for (let x = pminX; x <= pmaxX; x++) {
for (let y = pminY; y <= pmaxY; y++) {
for (let z = pminZ; z <= pmaxZ; z++) {
let block = this.world.getBlock(x, y, z, this.dimension)
if (block && blockData[block].solid) {
this.contacts.add(x, y, z, block)
}
if(blockData[block].activate){
blockData[block].activate(x,y,z,this.dimension,block,this,this.world)
}
if(!inBox(this,x,y,z,1,1,1)) continue
if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
this.liquid = true
if(this.canFloat && x === round(this.x) && z === round(this.z) && y === round(this.y)){
this.vely+=1/4
}
if(blockData[block].wet) this.wet = true
}
if(blockData[block].getCurrent){
var me = blockData[block]
var c = me.getCurrent(x,y,z,this.dimension,undefined,undefined,this.world)
this.velx += (c.x||0)/64
this.velz += (c.z||0)/64
var under = this.world.getBlock(x,y-1,z,this.dimension)
if(me.isThis(under) && under !== me.id) this.vely -= 1/128
}
if(blockData[block].ontouch){
let dist = max(abs(x-this.x),abs(z-this.z),abs(y-this.y))
if(dist<closestTouch){
closestTouch = dist
ontouch = blockData[block].ontouch
touchX = x, touchY = y, touchZ = z
}
}
if(this.ontouch) this.ontouch(x,y,z,block)
}
}
}
this.world.getEntitiesNear(this.x,this.y,this.z,this.dimension, max(this.width,this.height,this.depth)/2, nearEntityArray)
for(let e of nearEntityArray) {
if(e.canStandOn && e.block && e.x > pminX && e.x < pmaxX && e.y > pminY && e.y < pmaxY && e.z > pminZ && e.z < pmaxZ) {
this.contacts.add(e.x, e.y, e.z, e.block, e)
}
}
if(this.world.weather === "rain" && this.world.weatherAmount > 0.5){
let top = this.world.getSolidTop(round(this.x),round(this.z),this.dimension)
if(this.y > top) this.wet = true
}
this.previousX = this.x
this.previousY = this.y
this.previousZ = this.z
this.previousPitch = this.pitch
this.previousYaw = this.yaw
this.previousRoll = this.roll
this.previousPitch2 = this.pitch2
this.prevOffsetY = this.offsetY
this.hasCollided = false
for(let part in this.parts){
this.parts[part].prx = this.parts[part].rx
this.parts[part].pry = this.parts[part].ry
this.parts[part].prz = this.parts[part].rz
this.parts[part].pry2 = this.parts[part].ry2
}
let maxpushX = 0, minpushX = 0, maxpushY = 0, minpushY = 0, maxpushZ = 0, minpushZ = 0
for (let j = 1; j <= steps; j++) {
let px = this.x, pz = this.z, py = this.y
this.canStepX = false
this.canStepY = false
this.onGround = false
//Check collisions in the Y direction
this.y += VY
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
let x = block[0], y = block[1], z = block[2], vy = VY, thispush = 0
if(block[4]){
x = block[4].previousX
z = block[4].previousZ
vy -= (block[4].y-block[4].previousY)/steps
y = lerp(j/steps,block[4].previousY,y)
thispush = block[4].vely
}
if (this.collided(x, y, z, null, vy, null, block[3])) {
this.hasCollided = true
if(blockData[block[3]].bounciness){
thispush -= (VY*steps-thispush)*blockData[block[3]].bounciness
}
maxpushY = max(maxpushY,thispush)
minpushY = min(minpushY,thispush)
//break
}
}
if (this.onGround) {
this.canStepX = true
this.canStepZ = true
}
//Check collisions in the X direction
this.x += VX
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
let x = block[0], y = block[1], z = block[2], vx = VX, thispush = 0
if(block[4]){
z = block[4].previousZ
vx -= (block[4].x-block[4].previousX)/steps
x = lerp(j/steps,block[4].previousX,x)
thispush = block[4].velx
}
if (this.collided(x, y, z, vx, null, null, block[3])) {
if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
continue
}
this.hasCollided = true
if(blockData[block[3]].bounciness){
thispush -= (VX*steps-thispush)*blockData[block[3]].bounciness
}
maxpushX = max(maxpushX,thispush)
minpushX = min(minpushX,thispush)
//break
}
}
//Check collisions in the Z direction
this.z += VZ
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
let x = block[0], y = block[1], z = block[2], vz = VZ, thispush = 0
if(block[4]){
vz -= (block[4].z-block[4].previousZ)/steps
z = lerp(j/steps,block[4].previousZ,z)
thispush = block[4].velz
}
if (this.collided(x, y, z, null, null, vz, block[3])) {
if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
continue
}
this.hasCollided = true
if(blockData[block[3]].bounciness){
thispush -= (VZ*steps-thispush)*blockData[block[3]].bounciness
}
maxpushZ = max(maxpushZ,thispush)
minpushZ = min(minpushZ,thispush)
//break
}
}
}
this.contacts.clear()
if(this.onGround){
this.hasCollided = true
}
if(maxpushY || minpushY){
if("lastY" in this) this.lastY = this.y
this.vely += maxpushY+minpushY
this.onGround = false
}
if(maxpushX || minpushX){
this.velx += maxpushX+minpushX
}
if(maxpushZ || minpushZ){
this.velz += maxpushZ+minpushZ
}
this.updateChunk()
this.lastUpdate = now
this.contacts.clear()
if(ontouch){
ontouch(touchX, touchY, touchZ, this.dimension, this)
}
if(this.portalFadeOutEffect > 0){
this.portalFadeOutEffect -= 2
this.portalEffect = this.portalFadeOutEffect
}else if(this.portalEffect > 0){
this.portalEffect -= 1.25
}
if(this.doingPortal){
let chunk = this.world.getChunk(this.x,this.z,this.dimension)
if(chunk && chunk.allGenerated){
blockData[this.doingPortal].doneLoading(this,this.world)
this.doingPortal = 0
}
}
}
updateChunk(){
let chunkX = this.x >> 4, chunkZ = this.z >> 4
if(this.chunkX !== chunkX || this.chunkZ !== chunkZ || this.dimension !== this.chunkDimension){
let oldChunk = this.world.getChunk(this.chunkX<<4,this.chunkZ<<4,this.chunkDimension)
let chunk = this.world.getOrNewChunk(chunkX<<4,chunkZ<<4,this.dimension)
this.chunkX = chunkX
this.chunkZ = chunkZ
this.chunkDimension = this.dimension
if(oldChunk && oldChunk.entities[this.id]){
delete oldChunk.entities[this.id]
chunk.entities[this.id] = this
}
}
}
moveTowards(x,y,z, rw, rh, rd, slowDown = 1, gravity){
var dist = dist3(this.x/rw,this.y/rh,this.z/rd,x/rw,y/rh,z/rd)
if(!dist) return
var aDist = abs(dist)
if(aDist > 1) return
var iDist = 1 - aDist //inverted distance
var velx = x-this.x
var vely = y-this.y
var velz = z-this.z
var mag = sqrt(velx * velx + vely * vely + velz * velz)
this.velx += velx*iDist/mag/slowDown
if(!gravity) this.vely = vely*iDist/mag/slowDown
else if(this.onGround) this.vely += vely*iDist/mag/slowDown*20
this.velz += velz*iDist/mag/slowDown
/*var toX = lerp(iDist, this.x, x)
var toY = lerp(iDist, this.y, y)
var toZ = lerp(iDist, this.z, z)
this.velx = (toX - this.x) / slowDown * iDist
if(this.onGround) this.vely = (toY - this.y) / slowDown * iDist
this.velz = (toZ - this.z) / slowDown * iDist*/
/*var xd = this.x - p.x, zd = this.z - p.z;
var x = xd; this.velx = (x-(Math.sign(x)*7.25)) / 150
if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40}
var z = zd; this.velz = (z-(Math.sign(z)*7.25)) / 150*/
}
setPos(x,y,z,vx,vy,vz){
this.velx = vx
this.vely = vy
this.velz = vz
this.x = x
this.y = y
this.z = z
}
update() {
this.updateVelocity(now)
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
}
addPart(name,size,vao,x,y,z,w,h,d,rx,ry,rz = 0,attached = null,glow = false){
let part =  this.parts[name] = {
name,
size,vao,
x,y,z,w,h,d,rx,ry,rz,ry2:0, //x,y,z,rx,ry are relative to entity position
px:x,py:y,pz:z,prx:rx,pry:ry,prz:rz,
originalX:x, originalY:y, originalZ:z,
attached, glow
}
if(vao && vao.tHeVerticesBuffer){
part.verticesBuffer = vao.tHeVerticesBuffer
part.textureBuffer = vao.tHeTextureBuffer
part.normalBuffer = vao.tHeNormalBuffer
}
let attachChain = []
let part2 = part
while(part2.attached){
part2 = this.parts[part2.attached]
if(!part2) break
attachChain.push(part2.name)
}
attachChain.reverse()
part.attachChain = attachChain
return part
}
facePlayer(){
this.yaw = Math.PId - (atan2(p.z+p.offsetZ - this.z, p.x+p.offsetX - this.x) + Math.PI2 + Math.PI)
var adjacent = dist2(this.x,this.z,p.x+p.offsetX,p.z+p.offsetZ)
this.pitch = Math.PId - atan2(p.y+p.offsetY - this.y, adjacent)
}
pointAt(x,y,z){
this.yaw = Math.PId - (atan2(z - this.z, x - this.x) + Math.PI2 + Math.PI)
var adjacent = dist2(this.x,this.z,x,z)
this.pitch = Math.PId - atan2(y - this.y, adjacent)
}
/*pushByPlayer(ent){
let w = this.width/2, d = this.depth/2, h = this.height/2
let w2 = ent.w, d2 = ent.w
let w3 = (w+w2)**2, d3 = (d+d2)**2
if(this.x-w<ent.x+w2 && this.x+w>ent.x-w2 && this.z-d<ent.z+d2 && this.z+d>ent.z-d2 && this.y-h<ent.y+ent.topH && this.y+h>ent.y-ent.bottomH){
let velx = this.x-ent.x
let velz = this.z-ent.z
if(velx === 0 && velz === 0) return
let mag = sqrt(velx*velx+velz*velz)
let push = 1-sqrt(velx*velx/w3+velz*velz/d3)
velx = velx/mag*push*(w+w2)/2
velz = velz/mag*push*(d+d2)/2
this.velx += velx, this.velz += velz
}
}*/
pushByMob(ent){
let w = this.width/2, d = this.depth/2, h = this.height/2
let w2 = ent.width/2, d2 = ent.depth/2, h2 = ent.height/2
let w3 = (w+w2)**2, d3 = (d+d2)**2
if(this.x-w<ent.x+w2 && this.x+w>ent.x-w2 && this.z-d<ent.z+d2 && this.z+d>ent.z-d2 && this.y-h<ent.y+h2 && this.y+h>ent.y-h2){
let velx = this.x-ent.x
let velz = this.z-ent.z
if(velx === 0 && velz === 0) return
let mag = sqrt(velx*velx+velz*velz)
let push = 1-sqrt(velx*velx/w3+velz*velz/d3)
velx = velx/mag*push*(w+w2)/2
velz = velz/mag*push*(d+d2)/2
this.velx += velx, this.velz += velz
}
}
}
const
pW = 0.3,
pTopH = 0.18,
pDefaultBottomH = 1.62,
pSitBottomH = 0.995,
pSneakBottomH = 1.32,
pSwimBottomH = 0.625,
pGravity = -0.11
//if you add something to above, change player entity too and server side
class Player extends Entity{
type = "Player"
constructor(){
super(0, 0, 0, 0, 0, 0, 0, 0, pW*2, pDefaultBottomH+pTopH, pW*2, null, null, 0, Infinity, "this isn't really a VAO... but it will be overwritten")
let pix = 1/16
this.targetX = 0
this.targetY = 0
this.targetZ = 0
this.rx = 0
this.ry = 0
this.dimension = ""
this.bodyRot = 0
this.die = false
this.cheats = false
this.resendHealth = false
this.resendEffects = false
this.spawnPoint = null
this.didEndPoem = false
this.sneaking = false
this.walking = false
this.sprinting = false
this.eating = false
this.sleeping = false
this.sitting = false
this.swimming = false
this.usingItem = false
this.prevEating = false
this.eatStart = 0
this.addPart("body",null,null,0,0,0,1,1,1,0,0)
this.addPart("head",null,null,0,pix*6,0,1,1,1,0,0)
this.addPart("leftArm",null,null,pix*4,pix*6,0,1,1,1,0,0)
this.addPart("rightArm",null,null,pix*-4,pix*6,0,1,1,1,0,0)
this.addPart("leftLeg",null,null,pix*2,pix*-6,0,1,1,1,0,0)
this.addPart("rightLeg",null,null,pix*-2,pix*-6,0,1,1,1,0,0)
this.addPart("cape",null,null,0,pix*6,pix*-3,1,1,1,0,0)
this.holding = 0 //shown in the hand, it is set to the blockid for the block the player is holding
this.addPart("holding",null,null,0, 0, 0, 1,1,1, 0, 0)
this.punchEffect = 0
this.inventory = {
hotbar:new Array(9).fill(null), main:new Array(27).fill(null),
crafting2:new Array(4), crafting3:new Array(9),
craftingResult:null,craftingName:null,holding:null,
anvilInput:null,anvilMaterial:null,anvilOutput:null, anvilRename:"", anvilCost:0,
hotbarSlot:0,
slotIds:{
hotbar:[],
main:[],
crafting3:[],
crafting2:[],
craftingResult:null,
furnaceInput:null,
furnaceOutput:null,
furnaceFuel:null,
chest:[],
anvilInput:null,
anvilMaterial:null,
anvilOutput:null,
dispenser:[],
hopper:[]
},
containerData:{}
}
this.achievments = []
this.username = null
this.afk = false
this.scale = 1
this.prevScale = null
this.direction = new PVector()
this.crackPos = [0,0,0]
this.breakStart = 0
}
get survival(){return this.gameMode==="survival"||this.gameMode==="hardcore"}
get spectator(){return this.gameMode==="spectator"}
respawn(){
let spawn = this.spawnPoint
if(!spawn){
spawn = this.spawnPoint = {x:this.world.spawnPoint.x,y:this.world.spawnPoint.y,z:this.world.spawnPoint.z}
}
this.tp(spawn.x,spawn.y+0.5+this.height*0.5,spawn.z)
this.velx = this.vely = this.velz = 0
this.lastY = this.y
this.health = 20
this.oxygen = 20
this.food = 20
this.foodSaturation = 5
this.foodTimer = 0
this.foodExhaustion = 0
this.lastXP = 0
this.XP = 0
this.level = 0
this.totalXP = 0
this.nextLevel = 0
this.lastXP = 0
this.setLevel()
this.effects = {}
this.freezeEffect = 0
this.burnTimer = 0
this.dieMessage = "Invalid death"
this.dimension = ""
this.riding = null
this.hidden = false
this.die = false
this.harmEffect = 0
this.lastDamage = 0
this.lastHeal = 0
this.lastBlockHarm = 0
this.touchingBurnBlock = false
this.lastLoseOxygen = 0
this.lastGetOxygen = 0
this.burnStart = 0
this.attackedBy = null
this.attackedById = null
this.attackedByTime = 0
this.lastFreezeHealth = 0
this.flying = false
}
tp(x,y,z,dimension=this.dimension){
this.targetX = this.x = x
this.targetY = this.y = y
this.targetZ = this.z = z
this.dimension = dimension
this.connection.send({type:"tp",x,y,z,dimension})
}
addXP(amount){
this.lastXP = now
this.XP += amount
if(this.XP >= this.nextLevel){
this.level += Math.floor(this.XP / this.nextLevel)
this.XP = this.XP % this.nextLevel
this.world.playSound(this.x,this.y,this.z,"random.levelup")
this.setLevel()
}else{
this.world.playSound(this.x,this.y,this.z,"random.orb")
}
this.resendHealth = true
}
setLevel(){
if(this.level <= 15){
this.nextLevel = 2*this.level+7
}else if(p.level <= 30){
this.nextLevel = 5*this.level-38
}else{
this.nextLevel = 9*this.level-158
}
}
calculateTotalXP(){
if(this.level <= 16){
this.totalXP = (this.level * this.level) + 6 * this.level
}else if(this.level <= 31){
this.totalXP = 2.5 * (this.level * this.level) - 40.5 * this.level + 360
}else if(p.level > 31){
this.totalXP = 4.5 * (this.level * this.level) - 162.5 * this.level + 2220
}else this.totalXP = -1 //it didn't match any (that's probably impossible)
if(this.totalXP !== -1){
this.totalXP += this.XP
}
}
sendHealth(){
this.connection.send({type:"health",health:this.health,food:this.food,foodSaturation:this.foodSaturation,oxygen:this.oxygen,burning:this.burning,freezeEffect:this.freezeEffect,XP:this.XP,level:this.level,nextLevel:this.nextLevel})
}
sendEffects(){
this.connection.send({type:"effects",data:this.effects})
}
saveInv(){
let inv = this.world.playersInv[this.host ? ":host" : this.username]
if(!inv) inv = this.world.playersInv[this.host ? ":host" : this.username] = {}
inv.survivStr = this.world.getSurvivStr(this).array
inv.inv = this.world.getInv(this).array
}
addAchievment(name){
let id = achievmentIds[name]
let a = achievementTypes[id]
if(!a) throw new Error("No such achievment: "+name)
if(this.achievments.includes(id)) return
if(this.cheats) return
this.achievments.push(id)
//sideMessage("Achievment Made: "+a.name, a.description)
//showTitle("§bAchievment Made",a.name)
this.connection.send({type:"achievment",data:id})
this.world.sendAll({type:"message",fromServer:true,data:this.username+" achieved: "+a.name})
}
addDiscovery(block){
if(this.cheats || blockData[block].tool) return
let id = (((block & isCube) << 1) | 1) << 8
if(this.achievments.includes(id)) return
this.achievments.push(id)
//let info
//if(blockInfo[blockInfoIds[id>>9]]) info = blockInfo[blockInfoIds[id>>9]].data
//sideMessage("Discovery Made: "+blockData[id>>9].Name, info)
/*if(!titleShowing || title === "§bAchievment Made"){
discoverTime = 200
discoverBlock = id>>9
}*/
this.connection.send({type:"achievment",data:id})
this.world.sendAll({type:"message",fromServer:true,data:this.username+" discovered: "+blockData[block].Name})
}
move(now){
let pminX = floor(this.x - this.width / 2)
let pmaxX = ceil(this.x + this.width / 2)
let pminY = floor(this.y - this.height / 2)
let pmaxY = ceil(this.y + this.height / 2)
let pminZ = floor(this.z - this.depth / 2)
let pmaxZ = ceil(this.z + this.depth / 2)
let block = null
this.liquid = this.wet = false
let ontouch, closestTouch = Infinity
let touchX, touchY, touchZ
let damageX = 0, damageY = 0, damageZ = 0
let damageBlockAmount = 0
let damageBlock
let takeDamage = 0
this.powder = false
this.spikyBush = false
this.quicksand = false
this.damageResistance = 0
for (let x = pminX; x <= pmaxX; x++) {
for (let y = pminY; y <= pmaxY; y++) {
for (let z = pminZ; z <= pmaxZ; z++) {
let block = this.world.getBlock(x, y, z, this.dimension)
if (block && blockData[block].solid) {
this.contacts.add(x, y, z, block)
}
if(touchingBox(this,x,y,z,1,1,1)){
let d = blockData[block].damage
if(typeof d === "function") d = d(x,y,z,this.dimension,this.world)
if(d && d>takeDamage) {
takeDamage = d
damageBlock = blockData[block]
}
if(d){
damageX += x*d
damageY += y*d
damageZ += z*d
damageBlockAmount+=d
}
}
if(onBox(this,x,y,z,1,1,1)){
let d = blockData[block].damageUp
if(d && d>takeDamage) {
takeDamage = d
damageBlock = blockData[block]
}
if(d){
damageX += x*d
damageY += y*d
damageZ += z*d
damageBlockAmount+=d
}
if(blockData[block].damageResistance && blockData[block].damageResistance > this.damageResistance){
this.damageResistance = blockData[block].damageResistance
}
}
if(blockData[block].activate){
blockData[block].activate(x,y,z,this.dimension,block,this)
}
if(!inBox(this,x,y,z,1,1,1)) continue
if(!this.spectator && blockData[block].ontouch){
let dist = max(abs(x-this.x),abs(z-this.z),abs(y-this.y))
if(dist<closestTouch){
closestTouch = dist
ontouch = blockData[block].ontouch
touchX = x, touchY = y, touchZ = z
}
}
if(blockData[block].liquid) {
this.liquid = true
}
if(blockData[block].wet){
this.wet = true
}
if(blockData[block].getCurrent && !this.spectator){
var me = blockData[block]
var c = me.getCurrent(x,y,z,this.dimension,undefined,undefined,world)
this.velx += (c.x||0)/64
this.velz += (c.z||0)/64
var under = this.world.getBlock(x,y-1,z,this.dimension)
if(me.isThis(under) && under !== me.id) this.vely -= 1/128
}
if(!blockData[block].solid && blockData[block].powder){
this.powder = true
}
if(blockData[block].spikyBush){
this.spikyBush = true
}
if(blockData[block].quicksand){
this.quicksand = true
}
}
}
}
this.lastUpdate = now
this.previousX = this.x
this.previousY = this.y
this.previousZ = this.z
this.x = this.targetX
this.y = this.targetY
this.z = this.targetZ
this.previousPitch = this.pitch
this.previousYaw = this.yaw
this.yaw = this.bodyRot
if(takeDamage > 0 && now - this.lastBlockHarm > 500 && this.survival){
damageX /= damageBlockAmount
damageY /= damageBlockAmount
damageZ /= damageBlockAmount
this.lastBlockHarm = now
let msg = damageBlock.dieMessage ? damageBlock.dieMessage() : damageBlock.burnEnt ? (this.username+" burned up while touching "+damageBlock.Name) : (this.username+" died because of "+damageBlock.name+". You should avoid it next time.")
let type = damageBlock.burnEnt ? "fire" : ""
this.damage(takeDamage, msg, false, type, damageX, damageY, damageZ)
}
this.touchingBurnBlock = damageBlock && damageBlock.burnEnt && true
let blockAtFeet = world.getBlock(round(this.x), ceil(this.y-this.height*0.5), round(this.z), this.dimension)
let blockAtTop = world.getBlock(round(this.x), floor(this.y+this.height*0.5), round(this.z), this.dimension)
if(blockAtTop && blockData[blockAtTop].ladder || blockAtFeet && blockData[blockAtFeet].ladder){
this.lastY = this.y
}
if(this.y > this.lastY) this.lastY = this.y
if(ontouch){
ontouch(touchX, touchY, touchZ, this.dimension, this)
}
if(this.portalFadeOutEffect > 0){
this.portalFadeOutEffect -= 2
this.portalEffect = this.portalFadeOutEffect
}else if(this.portalEffect > 0){
this.portalEffect -= 1.25
}
if(this.doingPortal){
let chunk = this.world.getChunk(this.x,this.z,this.dimension)
if(chunk && chunk.allGenerated){
blockData[this.doingPortal].doneLoading(this,this.world)
this.doingPortal = 0
}
}
}
update(){
if(this.harmEffect > 0){
this.harmEffect -= 3
}
if(this.health <= 0 && !this.die){
this.die = true
if(this.survival){
for(let i of this.inventory.hotbar){
if(i){
this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,i.id,true,i.amount,i.durability,i.customName,this.id)
}
}
for(let i of this.inventory.main){
if(i){
this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,i.id,true,i.amount,i.durability,i.customName,this.id)
}
}
this.inventory.hotbar.fill(null)
this.inventory.main.fill(null)
this.calculateTotalXP()
if(this.totalXP > 0) this.world.addEntity(new entities[entityIds.ExperienceOrb](this.x,this.y,this.z,this.totalXP),false,this.dimension)
}
this.world.sendAll({type:"die",id:this.id,message:this.dieMessage})
this.world.poof(this.x,this.y,this.z, undefined,this.dimension, this.width,this.height,this.depth,true)
this.world.sendAll({type:"message",data:"§6"+this.dieMessage,fromServer:true})
}
if(this.die){
this.dieEffect += 0.05
if(this.dieEffect > 1){
this.dieEffect = 1
}
this.dieRotate = (this.dieEffect**4)*Math.PI2
}else{
this.dieEffect = 0
this.dieRotate = 0
}
this.hidden = this.die || this.spectator
this.move(now)
if(!this.die && this.survival){
if(this.y < minHeight){
if(this.y <= minEntityY){
this.dieMessage = this.username+" fell out of the world"+(this.attackedBy ? " while being attacked by "+this.attackedBy+"." : ".")
this.health = -1
this.resendHealth = true
}else if(now-this.lastBlockHarm > 500){
this.lastBlockHarm = now
this.damage(4, this.username+" fell out of the world"+(this.attackedBy ? " while being attacked by "+this.attackedBy+"." : "."))
}
}
if(this.walking && this.sprinting){
this.foodExhaustion += 0.016
}
if(this.foodSaturation > this.food) this.foodSaturation = this.food
/*if(p.food > 17 || p.food === 0){
var timer = now - p.foodTimer
if(timer >= 4000){
p.foodTimer = now
if(p.food === 0){
p.health --
harmEffect = 40
hitSound()
updateHUD = true
}else if(p.foodSaturation > 0 && p.health < 20){
p.health ++
healEffect = 40
updateHUD = true
}
}*/
/*if((timer === 500 || timer === 0) && p.food >= 20 && p.health < 20 && p.foodExhaustion > 0){
var heal = min(p.foodSaturation/6, 1)
p.health += heal
if(p.food > 18){
p.foodExhaustion += heal*6
}
healEffect = 40
updateHUD = true
}
}*/
let healTimer = now-this.lastHeal
if(this.health < 20){
let heal
if(this.foodSaturation > 6 && this.food === 20 && healTimer >= 500){
heal = min(this.foodSaturation/6,1)
}else if(this.food >= 18 && healTimer >= 4000){
heal = 1
}
if(heal){
this.lastHeal = now
this.health += heal
this.foodExhaustion += heal
this.resendHealth = true
}
//if(this.food < 18 && this.food > 0) this.lastHeal = now
}
if(this.health > 0 && this.food <= 0 && healTimer >= 4000){
this.lastHeal = now
this.damage(1, this.username+" starved to death.")
}
if(this.foodExhaustion >= 4){
this.foodExhaustion -= 4
this.foodSaturation --
if(this.foodSaturation <= 0){
this.food --
this.resendHealth = true
}
}
if(this.effects.wither && this.survival && now-this.lastBlockHarm > 1000){
this.lastBlockHarm = now
this.damage(this.effects.wither.level*0.5, this.username+" got withered. Ew.")
}
if(this.powder){
if(this.freezeEffect<140){
this.freezeEffect ++
this.resendHealth = true
if(this.freezeEffect > 140){
this.freezeEffect = 140
}
}
if(this.freezeEffect === 140){
if(now - this.lastFreezeHealth > 2000){
this.lastFreezeHealth = now
this.damage(1,this.username+" froze to death.", false, "freeze")
}
}else{
this.lastFreezeHealth = now
}
}else if(this.freezeEffect > 0){
this.freezeEffect --
this.resendHealth = true
}
if(this.spikyBush && this.walking && now - this.lastBlockHarm > 500){
this.lastBlockHarm = now
this.damage(1, this.username+" died because of spikes.", false, "berrybush")
}
if(this.touchingBurnBlock){
this.burnTimer += 0.2
}
if(this.burnTimer > 16) this.burnTimer = 16
let burning = this.burnTimer > 0
if(this.burning !== burning) this.burning = burning, this.resendHealth = true
if(this.survival && this.burning){
if(now - this.burnStart > 1000){
this.burnStart = now
this.burnTimer -= 2
if(this.burnTimer < 0) this.burnTimer = 0
this.damage(1, this.username+" burned up.", false, "fire")
}
}
if((this.wet || this.freezeEffect > 0) && this.burnTimer > 0) {
this.burnTimer = 0
this.world.poof(this.x,this.y-this.height*0.5+0.25,this.z, 8, this.dimension, this.width*0.5*2,0,this.depth*0.5*2, true)
}
if(this.liquid && this.inLiquid){
if(this.oxygen > 0){
var time = floor(this.oxygen / 2) * 2 === this.oxygen ? 1000 : 125
if(now - this.lastLoseOxygen > time){
this.oxygen --
this.lastLoseOxygen = now
}
}else{
if(now-this.lastBlockHarm > 500){
this.lastBlockHarm = now
this.damage(1, this.username+" drowned in "+blockData[this.blockHere].Name+".",false, "drown")
}
}
}/*suffoacting*/else if(this.blockHere && (blockData[this.blockHere].solid && !blockData[this.blockHere].transparent || blockData[this.blockHere].quicksand)){
if(this.oxygen > 0){
var time = floor(this.oxygen / 2) * 2 === this.oxygen ? 250 : 125
if(now - this.lastLoseOxygen > time){
this.oxygen --
this.lastLoseOxygen = now
}
}else{
if(now-this.lastBlockHarm > 500){
this.lastBlockHarm = now
var msg = this.username+" was suffocated by "
var name = blockData[this.blockHere].Name
if("aeiouAEIOU".includes(name[0])) msg += "an " //check for vowels
else msg += "a "
msg += name+"."
this.damage(1, msg)
}
}
}else if(this.oxygen < 20 && now - this.lastGetOxygen > 300){
this.lastGetOxygen = now
this.oxygen = (floor(this.oxygen/2)*2) + 2
}
}else{
this.burnTimer = 0
if(this.burning){
this.burning = false
this.resendHealth = true
}
this.oxygen = 20
}
if(this.onGround){
let fall = (this.lastY - this.y) / this.scale
this.lastY = this.y
this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
let block = this.standingOn
if(fall > 3 && this.survival && !this.liquid) {
let fallType = fall > 6 ? "bigfall" : "smallfall"
let d = fall-3
let reason = this.username+" fell "+Math.round(fall)+" blocks"+(this.attackedBy ? " while being attacked by "+this.attackedBy+"." : ".")
if(block && blockData[block].name === "pointedDripstone"){
d = fall*2-2
reason = this.username+" fell onto a pointed dripstone and got poked to death"+(this.attackedBy ? " while being attacked by "+this.attackedBy+"." : ".")
}
this.damage(Math.floor(d*(1-this.damageResistance)), reason, false, fallType)//Math.floor( (p.velocity.y * p.velocity.y * 8));
}
}
if(this.attackedBy && Date.now()-this.attackedTime > 10000) this.attackedBy = null, this.attackedById = null
this.holding = this.inventory.hotbar[this.inventory.hotbarSlot] ? this.inventory.hotbar[this.inventory.hotbarSlot].id : 0
let holdBlockData = blockData[this.holding]
if(this.eating){
if(!this.prevEating){
this.prevEating = true
this.eatStart = now
}
let time = now - this.eatStart
if(time > 1610){
this.eatStart = now
this.food += holdBlockData.food
this.foodSaturation += holdBlockData.saturation
this.resendHealth = true
let holdObj = this.inventory.hotbar[this.inventory.hotbarSlot]
if(this.survival && holdObj){
holdObj.amount --
if(!holdObj.amount) this.inventory.hotbar[this.inventory.hotbarSlot] = null
if(holdBlockData.eatResult && !newInvItem(this,blockIds[holdBlockData.eatResult])) {
this.world.addItems(holdBlockData.x,holdBlockData.y,holdBlockData.z,holdBlockData.dimension,0,0,0,blockIds[holdBlockData.eatResult])
}
}
if(this.food >= 20){
this.world.playSound(this.x,this.y,this.z,"random.burp")
}
}
}else this.prevEating = false
if(this.usingItem){
let holdObj = this.inventory.hotbar[this.inventory.hotbarSlot]
if(holdBlockData.name === "bow" && hasItem(this,blockIds.arrow)){
let pull = holdObj.pulling || 0
let start = holdObj.pullStart || 0
if(pull < 3 && now - start > 500){
holdObj.pullStart = now
pull++
holdObj.pulling = pull
let id = holdBlockData.id
switch(pull){
case 0:
holdObj.id = id; break
case 1:
holdObj.id = id | SLAB; break
case 2:
holdObj.id = id | STAIR; break
case 3:
holdObj.id = id | CROSS; break
}
}
}
}else{
let holdObj = this.inventory.hotbar[this.inventory.hotbarSlot]
if(holdBlockData.name === "bow" && holdObj.pulling && hasItem(this,blockIds.arrow)){
if(!holdObj.pulling) return true
if(minusOneItem(this,blockIds.arrow)){
let pd = this.direction
let i = holdObj.pulling / 3
this.world.addEntity(new entities[entityIds.Arrow](this.x+pd.x,this.y+pd.y,this.z+pd.z,pd.x*i,pd.y*i,pd.z*i,this.id),false,this.dimension)
}
delete holdObj.pulling
delete holdObj.pullStart
holdObj.id = holdBlockData.id
}
}
for(let i in this.effects){
let e = this.effects[i]
e.time--
if(e.time <= 0){
delete this.effects[i]
this.resendEffects = true
}
}
if(this.food > 20) this.food = 20
if(this.food < 0) this.food = 0
if(this.foodSaturation < 0) this.foodSaturation = 0
if(this.health > 20) this.health = 20
if(this.oxygen > 20) this.oxygen = 20
if(this.scale !== this.prevScale){
this.prevScale = this.scale
let s = this.scale
this.width = this.depth = pW*2*s
this.defaultHeight = this.height = (pDefaultBottomH+pTopH)*s
this.sitHeight = (pSitBottomH+pTopH)*s
this.sneakHeight = (pSneakBottomH+pTopH)*s
this.swimHeight = (pSwimBottomH+pTopH)*s
}
if(this.sneaking){
this.height = this.sneakHeight
}else if(this.eating || this.usingItem && blockData[this.holding].spyglass){
}else if(this.sitting){
this.height = this.sitHeight
}else if(this.swimming){
this.height = this.swimHeight
}else if(!this.sprinting){
this.height = this.defaultHeight
}
for(var p in this.parts){
var part = this.parts[p]
part.prx = part.rx
part.pry = part.ry
part.prz = part.rz
part.pry2 = part.ry2
part.lastUpdate = now
}
this.direction.x = -sin(this.ry) * cos(this.rx)
this.direction.y = sin(this.rx)
this.direction.z = cos(this.ry) * cos(this.rx)
}
setPos(x,y,z,vx,vy,vz){
this.targetX = x
this.targetY = y
this.targetZ = z
this.velx = vx
this.vely = vy
this.velz = vz
}
setRot(rx,ry, bodyRot, unremote){
this.rx = rx
this.ry = ry
this.bodyRot = (bodyRot || bodyRot === 0) ? bodyRot : ry
if(unremote) this.connection.send({type:"rot",rx,ry,bodyRot:this.bodyRot})
}
applyEffect(name,level,time, showParticles = true){
time *= 20
if(this.effects[name]){
let e = this.effects[name]
if(level>e.level){
e.level = level
e.time = time
e.showParticles = e.showParticles || showParticles
}
}
this.effects[name] = {level, time, showParticles}
this.resendEffects = true //this.world.sendPlayer({type:"effect", name,level,time,showParticles},this.id)
}
damage(amount, why, nosound,type, x,y,z, attackedBy, velx=0,vely=0,velz=0){
if(!this.survival) return
/*let h = inventory.hotbar[inventory.hotbarSlot]
if(h && h.id && p.usingItem && blockData[h.id].sword){
amount /= blockData[h.id].durability/30
h.durability -= amount/5
}*/
let prev = amount
if(this.harmEffect > 0){
//when your red, you are immune to most damage
if(amount > this.lastDamage){
amount -= this.lastDamage
}else return
}
let prevHealth = this.health
this.health -= amount
this.harmEffect = 30
this.lastDamage = prev
if(typeof x === "number" && !velx && !vely && !velz){
velx = this.x-x, velz = this.z-z
let mag = sqrt(velx*velx+velz*velz)*4
velx /= mag, velz /= mag
vely = 0.5
if(!velx && !velz) velx = velz = 0//possible NaN
}
if(attackedBy){
this.attackedBy = attackedBy.username || attackedBy.name
this.attackedById = attackedBy.id
this.attackedTime = Date.now()
}
if(!nosound){
switch(type){
case "drown":
drownHurtSound(this)
break
case "freeze":
freezeHurtSound(this)
break
case "fire":
fireHurtSound(this)
break
case "berrybush":
berrybushHurtSound(this)
break
case "smallfall":
this.world.playSound(this.x,this.y,this.z,"damage.smallfall")
break
case "bigfall":
this.world.playSound(this.x,this.y,this.z,"damage.bigfall")
break
case "hit":
oofSound(this) //also does below
default:
hitSound(this)
break
}
}
this.dieMessage = why
this.world.sendAll({type:"harmEffect",id:this.id})
this.sendHealth()
this.connection.send({type:"damage",x,y,z,lastHealth:prevHealth,velx,vely,velz})
}
}
entities[entities.length] = class Item extends Entity {
static name2 = "Item"
constructor(x, y, z, velx, vely, velz, blockID, autoSetVel, amount, durability = null, name = null, from) {
super(x, y, z, 0, 0, velx, vely, velz, 0.25, 0.25, 0.25, null, null, 0, 300000/*1500000*/)
this.block = blockID
this.from = from || undefined
this.durability = durability
this.name = name
this.amount = amount || 1
this.gravityStength = -0.07
this.noHitbox = true
this.canFloat = true
this.cullFace = true
if(autoSetVel){
this.velx = (Math.random()-0.5) * 0.2
this.vely = Math.random() * 0.2
this.velz = (Math.random()-0.5) * 0.2
}
}
goCloserToPlayer(e){
let xDist = this.x - e.x
let yDist = this.y - (e.y - e.height/2)
let zDist = this.z - e.z
var hRange = 1.425
let comeCloser = xDist > -hRange && xDist < hRange && yDist > -0.75 && yDist < 2.3 && zDist > -hRange && zDist < hRange
if(comeCloser){
this.moveTowards(e.x, Math.min(Math.max(this.y, e.y - e.height*0.5),e.y+e.height*0.5), e.z, hRange,2.3,hRange, 3)
}
/*if(pickup){
var dist = dist3(this.x, this.y, this.z, p.x, p.y, p.z)
var dist2 = dist3(this.x, this.y, this.z, p.x, p.y-1, p.z)
pickup = ((1 >= dist) && (dist >= -1)) || ((1 >= dist2) && (dist2 >= -1))
}*/
let w = e.width*0.5
return xDist > -w && xDist < w && yDist > 0 && yDist < e.height && zDist > -w && zDist < w
}
update() {
this.updateVelocity(now)
this.move(now)
if(this.amount <= 0){
return this.canDespawn = true
}
this.yaw += 0.05;
if(this.yaw > Math.PId){
this.yaw -= Math.PId
this.previousYaw -= Math.PId
}
let pickup
if(now - this.spawn > 1000){
for(var P of this.world.players){
if(!P.hidden && !P.die && P.dimension === this.dimension){
if(this.goCloserToPlayer(P)) pickup = P
}
}
}
let d = 3/4
var stackSize = blockData[this.block].stackSize
var c = false
this.world.getEntitiesNear(this.x,this.y,this.z,this.dimension, 1, nearEntityArray)
for(var e of nearEntityArray){
if(e.type === "Item" && e !== this && e.block === this.block && (!e.name && !this.name || e.name === this.name) && e.amount + this.amount <= stackSize){
var xDist = this.x - e.x
var yDist = this.y - e.y
var zDist = this.z - e.z
let stack = xDist > -d && xDist < d && yDist > -d && yDist < d && zDist > -d && zDist < d
if(stack){
this.amount += e.amount
e.amount = 0
this.velx = (this.velx+e.velx)/2
this.vely = (this.vely+e.vely)/2
this.velz = (this.velz+e.velz)/2
this.x = (this.x+e.x)/2
this.y = (this.y+e.y)/2
this.z = (this.z+e.z)/2
c = true
}
}
}
//if(c) this.world.sendAll({type:"entEvent",event:"itemAmount",data:this.amount,id:this.id})
if(c) this.world.sendEntityPos(this)
if(pickup){
let pickuped = false
while(this.amount > 0 && newInvItem(pickup, this.block, this.durability, this.name)){
this.amount--
pickuped = true
}
if(pickuped){
if(blockData[this.block].log){
pickup.addAchievment("Getting Wood")
}else if(this.block === blockIds.diamond){
pickup.addAchievment("DIAMONDS!")
}else if(this.block === blockIds.ancientDebris){
pickup.addAchievment("Hidden In The Depths")
}else if(this.block === blockIds.diamond && this.from !== p.id){
//that achivement
let from = getPlayerById(this.from)
if(from) from.addAchievment("Diamonds to you!")
}else if(this.block === blockIds.tomatoSeeds){
pickup.addAchievment("Time to plant tomatoes!")
}
pickup.addDiscovery(this.block)
let pitch = rand(0.6, 1.5)
this.world.playSound(this.x,this.y,this.z,"random.plop",1,pitch)
this.world.sendEntityPos(this)//send({type:"entEvent",event:"itemAmount",data:this.amount,id:this.id})
}
}
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
if(!this.amount){
this.canDespawn = true
}
if(this.insideBlock && blockData[this.insideBlock].itemOnTop || this.standingOn && blockData[this.standingOn].itemOnTop){
var inside = this.insideBlock && blockData[this.insideBlock].itemOnTop
var block = inside ? this.insideBlock : this.standingOn
var y = inside ? round(this.y) : ceil(this.y-this.height/2)-1
var amount = blockData[block].itemOnTop(round(this.x),y,round(this.z),this.dimension,this)
if(amount){
this.amount = amount
this.willUpdateShape = true
//this.world.sendAll({type:"entEvent",event:"itemAmount",data:this.amount,id:this.id})
this.world.sendEntityPos(this)
}else if(amount === 0) this.canDespawn = true
}
}
}
let BlockEntity = entities[entities.length] = class BlockEntity extends Entity{
static name2 = "BlockEntity"
constructor(blockID, x,y,z, solidOnGround){
super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null, null, null, 1500000)
this.block = blockID
this.solidOnGround = solidOnGround
this.lastY = y
this.noHitbox = true
this.cullFace = true
}
changeBlock(blockID){
if(this.block === blockID) return
this.block = blockID
}
update() {
this.updateVelocity(now)
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
if(this.onGround && this.solidOnGround){
var x = round(this.x), y = round(this.y), z = round(this.z)
var b = this.world.getBlock(x, y, z, this.dimension)
if(b && !blockData[b].liquid){
// non cube block breaks falling blocks
this.world.addItems(x,y,z,this.dimension, 0,0,0, this.block)
}else{
this.world.setBlock(x,y,z, this.block,false,false,false,false,this.dimension)
this.world.blockSound(this.block, "land", x,y,z)
}
this.canDespawn = true
}
if(blockData[this.block].name === "anvil" || blockData[this.block].name === "pointedDripstone"){
var ent = entCollided(this)
var d
if(blockData[this.block].name === "pointedDripstone") d = min(max((this.lastY - this.y - 2) * 2, 0), 40)
else if(blockData[this.block].name === "anvil") d = min(max((this.lastY - this.y - 1) * 2, 0), 40)
if(entPlayerCollided){
var reason
if(blockData[this.block].name === "pointedDripstone") reason = ent.username+" got poked to death by a falling pointed dripstone"
else if(blockData[this.block].name === "anvil") reason = ent.username+" got hit by an anvil and stuff"
ent.damage(d,reason,false,null,this.previousX,this.previousY,this.previousZ)
}else if(ent && ent.damage){
ent.damage(d)
}
if(blockData[this.block].name === "pointedDripstone" && this.onGround){
var b = blockIds.pointedDripstone
this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,b,true)
this.world.blockParticles(b,this.x,this.y,this.z,30, "break",this.dimension)
this.canDespawn = true
}
}
}
}
let PrimedTNT = entities[entities.length] = class PrimedTNT extends BlockEntity{
static name2 = "PrimedTNT"
constructor(x,y,z, timerStart, tntBlockId = blockIds.tnt){
super(tntBlockId, x,y,z)
this.velx = (Math.random() * 0.1) - 0.05
this.vely = Math.random() * 0.1
this.velz = (Math.random() * 0.1) - 0.05
this.timerStart = timerStart || this.spawn
this.lastCollidedY = this.timerStart
this.timeLimit = 80
this.tntBlockId = tntBlockId
}
explode(){
var x = round(this.x), y = round(this.y), z = round(this.z)
this.world.explode(x,y,z,4, this.liquid || !this.world.settings.tntExplode, this.dimension)
}
update() {
this.updateVelocity(now)
this.move(now)
if(this.onGround){
this.lastCollidedY = this.y
}
var h = this.y - this.lastCollidedY
if(h > 19.75){
this.lastCollidedY = this.y
this.timerStart -= 1000
}
if((now - this.spawn) / tickTime >= this.timeLimit){
this.canDespawn = true
this.explode()
}
}
}
entities[entities.length] = class PrimedSuperTNT extends PrimedTNT{
static name2 = "PrimedSuperTNT"
constructor(x,y,z, timerStart){
super(x,y,z, timerStart, blockIds.tnt | SLAB)
}
explode(){
var x = round(this.x), y = round(this.y), z = round(this.z)
this.world.explode(x,y,z,8, blockData[this.world.getBlock(x,y,z)].liquid || !this.world.settings.tntExplode, this.dimension)
}
}
entities[entities.length] = class PrimedUltraTNT extends PrimedTNT{
static name2 = "PrimedUltraTNT"
constructor(x,y,z, timerStart){
super(x,y,z, timerStart, blockIds.tnt | STAIR)
}
explode(){
var x = round(this.x), y = round(this.y), z = round(this.z)
this.world.explode(x,y,z,24, blockData[this.world.getBlock(x,y,z)].liquid || !this.world.settings.tntExplode, this.dimension)
}
}
entities[entities.length] = class PrimedUnTNT extends PrimedTNT{
static name2 = "PrimedUnTNT"
constructor(x,y,z, timerStart){
super(x,y,z, timerStart, blockIds.untnt)
}
explode(){
var x = round(this.x), y = round(this.y), z = round(this.z)
this.world.explode(x,y,z,5, blockData[this.world.getBlock(x,y,z)].liquid || !this.world.settings.tntExplode || "original", this.dimension)
}
}
entities[entities.length] = class MovingBlock extends BlockEntity{
static name2 = "MovingBlock"
noRemoteDelete = true
constructor(block,x,y,z,mx,my,mz,despawns, solidWhenDone = false, tags = null){
super(block, x,y,z)
this.sx = x //s stands for start
this.sy = y
this.sz = z
this.mx = mx //m stands for end
this.my = my
this.mz = mz
this.despawns = despawns //also tells how much time for it to move
this.solidWhenDone = solidWhenDone
this.tags = tags
this.canStandOn = true
this.endAs = null
}
update() {
if (this.lastUpdate - this.spawn >= this.despawns) {
this.canDespawn = true
if(this.solidWhenDone){
this.x = this.mx
this.y = this.my
this.z = this.mz
this.world.setBlock(round(this.x),round(this.y),round(this.z),this.endAs || this.block, false,false,false,false, this.dimension)
if(this.tags) this.world.setTags(round(this.x),round(this.y),round(this.z), this.tags, false, this.dimension)
}
}
this.previousX = this.x
this.previousY = this.y
this.previousZ = this.z
this.lastUpdate = now
var prog = min((now - this.spawn) / this.despawns, 1)
this.x = lerp(prog, this.sx, this.mx)
this.y = lerp(prog, this.sy, this.my)
this.z = lerp(prog, this.sz, this.mz)
this.velx = this.x - this.previousX
this.vely = this.y - this.previousY
this.velz = this.z - this.previousZ
}
}
entities[entities.length] = class BlockDisplay extends BlockEntity{
static name2 = "BlockDisplay"
constructor(block,x,y,z,w,h,d){
super(block, x,y,z, w,h,d)
this.width = w
this.height = h
this.depth = d
}
update() {}
}
entities[entities.length] = class EnderPearl extends BlockEntity{
static name2 = "EnderPearl"
constructor(x,y,z,velx,vely,velz){
super(blockIds.enderPearl, x,y,z,from)
this.velx = velx
this.vely = vely
this.velz = velz
this.from = from
this.facesPlayer = true
this.gravityStength = -0.04
}
update() {
this.updateVelocity(now)
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
if(this.hasCollided){
if(this.from){
let p = getPlayerById(this.from,this.world)
if(p){
p.tp(this.x,this.y+1,this.z,this.dimension)
this.canDespawn = true
}
}else this.canDespawn = true
}
this.canFacePlayer = true
}
}
entities[entities.length] = class Snowball extends BlockEntity{
static name2 = "Snowball"
constructor(x,y,z,velx,vely,velz,from){
super(blockIds.snowball, x,y,z)
this.velx = velx
this.vely = vely
this.velz = velz
this.from = from
this.facesPlayer = true
this.gravityStength = -0.04
}
update() {
this.updateVelocity(now)
this.move(now)
if(now - this.spawn > 250){
var collided = entCollided(this)
let from = getEntityOrPlayer(this.from,this.world)
from = from && (from.username || from.name)
if(collided && collided !== this){
if(entPlayerCollided){
collided.damage(1,from+" killed "+collided.username+" with snowballs.",false,null,this.previousX,this.previousY,this.previousZ)
}else{
if(collided.damage) collided.onhit(1,false, 0,0, this.from)
}
this.canDespawn = true
}
}
if (now - this.spawn > this.despawns || this.hasCollided) {
this.canDespawn = true
}
if(this.canDespawn) this.world.blockParticles(this.block,this.x,this.y,this.z,30, "break",this.dimension)
this.canFacePlayer = true
}
}
entities[entities.length] = class SmallFireball extends BlockEntity{
static name2 = "SmallFireball"
constructor(x,y,z,velx,vely,velz,from){
super(blockIds.fireCharge, x,y,z)
this.width = this.height = this.depth = 0.3125
this.velx = velx
this.vely = vely
this.velz = velz
this.from = from
this.facesPlayer = true
this.gravityStength = -0.07
}
update() {
this.updateVelocity(now)
this.move(now)
if(now - this.spawn > 250){
var collided = entCollided(this)
let from = getEntityOrPlayer(this.from,this.world)
from = from && (from.username || from.name)
if(collided && collided !== this){
if(entPlayerCollided){
collided.burnTimer += 8
collided.damage(5,collided.username+" was shot by fireballs from "+from+".",false,null,this.previousX,this.previousY,this.previousZ)
}else{
if(collided.damage) collided.onhit(5,false, 0,0, this.from), collided.burnTimer += 8
}
this.canDespawn = true
}
}
if (now - this.spawn > this.despawns || this.hasCollided) {
this.canDespawn = true
if(this.hasCollided) this.world.setBlock(round(this.x),round(this.y),round(this.z),blockIds.fire,false,false,false,false,this.dimension)
}
if(this.canDespawn) this.world.blockParticles(this.block,this.x,this.y,this.z,30, "break",this.dimension)
this.canFacePlayer = true
}
}
entities[entities.length] = class Egg extends BlockEntity{
static name2 = "Egg"
constructor(x,y,z,velx,vely,velz,from){
super(blockIds.egg, x,y,z)
this.velx = velx
this.vely = vely
this.velz = velz
this.from = from
this.facesPlayer = true
this.gravityStength = -0.07
}
update() {
this.updateVelocity(now)
this.move(now)
var collided = entCollided(this)
let from = getEntityOrPlayer(this.from,this.world)
from = from && (from.username || from.name)
if(collided && collided !== this){
if(entPlayerCollided) collided.damage(1,from+" killed "+collided.username+" with eggs.",false,null,this.previousX,this.previousY,this.previousZ)
else if(collided.damage) collided.onhit(1,false, 0,0, this.from)
this.canDespawn = true
}
if (now - this.spawn > this.despawns || this.hasCollided) {
this.canDespawn = true
}
if(this.canDespawn){
this.world.blockParticles(this.block,this.x,this.y,this.z,30, "break",this.dimension)
if(rand() > 0.9) this.world.addEntity(new entities[entityIds.Chicken](this.x,this.y,this.z),false,this.dimension)
}
this.canFacePlayer = true
}
}
entities[entities.length] = class SlingshotShot extends BlockEntity{
static name2 = "SlingshotShot"
constructor(x,y,z,velx,vely,velz){
super(blockIds.ironNugget, x,y,z)
this.velx = velx
this.vely = vely
this.velz = velz
this.despawns = 10000
this.facesPlayer = true
this.gravityStength = -0.02
}
update() {
this.updateVelocity(now)
this.move(now)
if (now - this.spawn > this.despawns && this.onGround) {
this.canDespawn = true
//world.addEntity(new Item(this.x,this.y,this.z,0,0,0,blockIds.ironNugget))
}
var collided = entCollided(this)
if(collided){
if(entPlayerCollided) collided.damage(5,collided.username+" got killed by a slingshot.",false,null,this.previousX,this.previousY,this.previousZ)
else if(collided.damage) collided.damage(5)
this.canDespawn = true
}
this.canFacePlayer = true
}
move(now) {
let pminX = floor(this.x - this.width / 2)
let pmaxX = ceil(this.x + this.width / 2)
let pminY = floor(this.y - this.height / 2)
let pmaxY = ceil(this.y + this.height / 2)
let pminZ = floor(this.z - this.depth / 2)
let pmaxZ = ceil(this.z + this.depth / 2)
let block = null
this.liquid = false
for (let x = pminX; x <= pmaxX; x++) {
for (let y = pminY; y <= pmaxY; y++) {
for (let z = pminZ; z <= pmaxZ; z++) {
let block = this.world.getBlock(x, y, z, this.dimension)
if (block && blockData[block].solid) {
this.contacts.add(x, y, z, block)
}
if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
this.liquid = true
}
}
}
}
this.previousX = this.x
this.previousY = this.y
this.previousZ = this.z
var xBounce, yBounce, zBounce, pvelx = this.velx, pvely = this.vely, pvelz = this.velz
this.canStepX = false
this.canStepY = false
this.onGround = false
this.hasCollided = false
//Check collisions in the Y direction
this.y += this.vely
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
if (this.collided(block[0], block[1], block[2], null, this.vely, null, block[3])) {
this.y = this.previousY
this.vely = 0
this.hasCollided = true
yBounce = true
break
}
}
if (this.y === this.previousY) {
this.canStepX = true
this.canStepZ = true
}
//Check collisions in the X direction
this.x += this.velx
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
if (this.collided(block[0], block[1], block[2], this.velx, null, null, block[3])) {
if (this.canStepX && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2], this.dimension)) {
continue
}
this.x = this.previousX
this.velx = 0
this.hasCollided = true
xBounce = true
break
}
}
//Check collisions in the Z direction
this.z += this.velz
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
if (this.collided(block[0], block[1], block[2], null, null, this.velz, block[3])) {
if (this.canStepZ && !this.world.getBlock(block[0], block[1] + 1, block[2], this.dimension) && !this.world.getBlock(block[0], block[1] + 2, block[2]), this.dimension) {
continue
}
this.z = this.previousZ
this.velz = 0
this.hasCollided = true
zBounce = true
break
}
}
if(this.onGround){
this.hasCollided = true
}
if(xBounce) this.velx = -pvelx
if(yBounce) this.vely = -pvely
if(zBounce) this.velz = -pvelz
this.updateChunk()
this.lastUpdate = now
this.contacts.clear()
}
}
entities[entities.length] = class Arrow extends Entity{
static name2 = "Arrow"
constructor(x,y,z,dx,dy,dz, from){
super(x, y, z, 0, 0, dx, dy, dz, 0.25, 0.25, 0.25, null, null, null, 60000)
this.direction = new PVector(dx,dy,dz)
this.stopStart = this.spawn
this.hasStopped = false
this.noHitbox = true
this.from = from
}
updateVelocity(now) {
this.vely += -0.005
let drag = this.liquid ? 0.7 : 0.99
if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
this.velz += (this.velz * drag - this.velz)
this.velx += (this.velx * drag - this.velx)
this.vely += (this.vely * drag - this.vely)
}
update(){
let pvelx = this.velx
let pvely = this.vely
let pvelz = this.velz
this.updateVelocity(now)
this.move(now)
if(this.hasCollided){
this.x = this.previousX
this.y = this.previousY
this.z = this.previousZ
this.velx = pvelx
this.vely = pvely
this.velz = pvelz
}
if(this.hasCollided && !this.hasStopped){
this.hasStopped = true
this.stopStart = now
this.direction.x = this.velx
this.direction.y = this.vely
this.direction.z = this.velz
this.direction.normalize()
var x = round(this.x+this.direction.x)
var y = round(this.y+this.direction.y)
var z = round(this.z+this.direction.z)
var block = this.world.getBlock(x,y,z,this.dimension)
if(block && blockData[block].projectileHit){
blockData[block].projectileHit(x,y,z,this.dimension,this)
}
}
if (now - this.stopStart > this.despawns) {
this.canDespawn = true
}
if(!this.hasCollided){
let collided = entCollided(this)
let from = getEntityOrPlayer(this.from,this.world)
from = from && (from.username || from.name)
let d = dist3(this.velx,this.vely,this.velz,0,0,0)*4
if(collided && collided !== this){
this.canDespawn = true
if(entPlayerCollided) collided.damage(d,collided.username+" got killed by an arrow"+(from ? " from "+from+"." : "."),false,null,this.previousX,this.previousY,this.previousZ,null, this.velx/2, undefined,this.velz/2)
else if(collided.onhit) collided.onhit(d,false, this.velx/2,this.velz/2, this.from)
else this.canDespawn = false
}
}else{
let collided = entCollided(this)
if(entPlayerCollided && !collided.spectator && newInvItem(collided,blockIds.arrow)) this.canDespawn = true
}
this.yaw = Math.PId - (atan2(this.velz, this.velx) + Math.PI2 + Math.PI)
var adjacent = sqrt(this.velx*this.velx+this.velz*this.velz)
this.pitch = Math.PId - atan2(this.vely, adjacent)
}
}
entities[entities.length] = class ExperienceOrb extends Entity{
static name2 = "ExperienceOrb"
constructor(x,y,z,value){
super(x, y, z, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, null, null, null, 300000)
this.amount = value
this.noHitbox = true
this.facesPlayer = true
}
goToPlayer(e){
var dist = dist3(this.x,this.y,this.z,e.x,e.y-e.height*0.5,e.z)
if(dist < 7.25){
////var speed = (7.25 - dist) / 10
//var aDist = abs(dist)
//var xd = this.x - p.x, zd = this.z - p.z;
//var x = xd/*/abs(zd)*/; this.velx = (x-(Math.sign(x)*7.25)) / 150//; this.velx = -this.velx
//if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40/*; this.vely = -this.vely*/}
//var z = zd/*/abs(xd)*/; this.velz = (z-(Math.sign(z)*7.25)) / 150//; this.velx = -this.velx
this.moveTowards(e.x, e.y-e.height*0.5, e.z, 7.25,7.25,7.25, 5, true)
}
return dist < 0.5
}
update(){
let pickup
for(let p of this.world.players){
if(!p.hidden && !p.die && p.dimension === this.dimension){
if(this.goToPlayer(p)) pickup = p
}
}
this.updateVelocity(now)
this.move(now)
if(pickup){
if(now - pickup.lastXP >= 100){
pickup.addXP(this.amount)
this.canDespawn = true
}
}
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
}
}
entities[entities.length] = class Minecart extends Entity{
static name2 = "Minecart"
pushes = true
constructor(x,y,z){
super(x, y, z, 0, 0, 0, 0, 0, 0.98, 1, 0.98, null, null, 0, Infinity)
this.heightOnDiagonal = 1-this.width
this.defaultHeight = this.height
this.health = 6
this.prevOnTrack = false
this.rideOffsetY = -6/16
this.canRide = true
}
onclick(holding,p){
p.riding = this.id
p.connection.send({type:"sit",riding:p.riding})
return true
}
updateVelocity(now) {
this.standingOn = this.world.getBlock(round(this.x), floor(this.y-this.height/2), round(this.z), this.dimension)
if(this.prevLiquid !== this.liquid){
this.prevLiquid = this.liquid
if(this.liquid && this.wet){
let pitch = (1/abs(this.y-this.previousY)*0.05+Math.random()*0.2)/((this.width+this.depth)*0.25/*0.25=average&correct width*/)
if(isFinite(pitch)) this.world.playSound(this.x,this.y-this.height/2,this.z,"liquid.splash",1,pitch)
this.world.sendAll({
type:"particles", particleType:"SplashParticle",
x:this.x, y:this.y-this.height/2, z:this.z, dimension:this.dimension, amount: 10
})
}
}
this.vely += this.gravityStength
let drag = this.liquid ? 0.7 : 0.95
let yDrag = this.liquid ? 0.7 : 0.95
if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
this.velz += (this.velz * drag - this.velz)
this.velx += (this.velx * drag - this.velx)
this.vely += (this.vely * yDrag - this.vely)
}
update() {
let railX = round(this.x), railY = round(this.y), railZ = round(this.z)
let onBlock = this.world.getBlock(railX,railY,railZ,this.dimension)
if(!blockData[onBlock].rail){
let under = this.world.getBlock(railX,railY-1,railZ,this.dimension)//to allow diagonals
if(blockData[under].rail) onBlock = under, railY--
}
this.updateVelocity(now)
for(let P of this.world.players){
if(!P.hidden && !P.die && P.dimension === this.dimension && P.riding !== this.id) this.pushByMob(P)
}
this.world.getEntitiesNear(this.x,this.y,this.z,this.dimension, 16, nearEntityArray)
for(let ent of nearEntityArray){
if(ent.pushes && ent !== this && ent.dimension === this.dimension && ent.riding !== this.id) this.pushByMob(ent)
}
let {velx, vely, velz} = this
let speed = sqrt(velx*velx+velz*velz+vely*vely)*2
if(speed>1){
this.velx /= speed, this.vely /= speed, this.velz /= speed
}
this.move(now)
this.height = this.defaultHeight
this.pitch = 0
this.offsetY = 0
if(onBlock && blockData[onBlock].rail){
let rot = onBlock&ROTATION
let {prevOnTrack} = this
if((onBlock & isState) === CUBE){
let velMag = sqrt(velx*velx+velz*velz)
if(rot === NORTH || rot === SOUTH) this.velz = prevOnTrack ? velMag*Math.sign(velz) : velz, this.velx = 0, this.x = railX, this.yaw = round(this.yaw/Math.PI)*Math.PI
else if(rot === EAST || rot === WEST) this.velx = prevOnTrack ? velMag*Math.sign(velx) : velx, this.velz = 0, this.z = railZ, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
this.vely = 0, this.y = railY
this.prevOnTrack = true
}else if((onBlock & isState) === STAIR){//corner rail
let originX, originZ
if(rot === NORTH) originX = railX-0.5, originZ = railZ-0.5
else if(rot === WEST) originX = railX+0.5, originZ = railZ-0.5
else if(rot === SOUTH) originX = railX+0.5, originZ = railZ+0.5
else if(rot === EAST) originX = railX-0.5, originZ = railZ+0.5
let dx = this.x-originX, dz = this.z-originZ
let mag = sqrt(dx*dx+dz*dz)*2
dx /= mag, dz /= mag
this.x = originX+dx
this.z = originZ+dz
let targetYaw = atan2(dx,dz)+Math.PI2
this.yaw = round((this.yaw-targetYaw)/Math.PI)*Math.PI+targetYaw
//below: calculate new velocity
let velMag = sqrt(velx*velx+velz*velz)
let prevDir = velx*dz + velz*-dx//more accurate if use previous dx and dz
let s = dz*2, c = -dx*2
if(prevOnTrack){
prevDir = Math.sign(prevDir)
this.velx = velMag*s*prevDir
this.velz = velMag*c*prevDir
}else{
this.velx = prevDir*s
this.velz = prevDir*c
}
this.vely = 0, this.y = railY
//this.world.blockParticles(4,this.x+Math.sign(velMag)*sin(this.yaw),7,this.z+Math.sign(velMag)*cos(this.yaw),1,'','')
/*//stop velocity in certain direction
let dot = this.velx*dx + this.velz*dz
this.velx = this.velx - dx * dot
this.velz = this.velz - dz * dot*/
this.prevOnTrack = true
}else if((onBlock & isState) === SLAB){//raised
let diagonal = sqrt(0.5)
let originX = railX, originY = railY, originZ = railZ, dx = 0, dy = diagonal, dz = 0
if(rot === NORTH) originZ -= 0.5, dz = diagonal, this.yaw = round(this.yaw/Math.PI)*Math.PI
else if(rot === SOUTH) originZ += 0.5, dz = -diagonal, this.yaw = round(this.yaw/Math.PI)*Math.PI
else if(rot === EAST) originX -= 0.5, dx = diagonal, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
else if(rot === WEST) originX += 0.5, dx = -diagonal, this.yaw = round((this.yaw-Math.PI2)/Math.PI)*Math.PI+Math.PI2
let dot = (this.x-originX)*dx + (this.z-originZ)*dz + (this.y-originY)*dy
this.x = originX+dx*dot
this.y = originY+dy*dot
this.z = originZ+dz*dot
let velMag = sqrt(velx*velx+velz*velz+vely*vely)
let prevDir = velx*dx + velz*dz + vely*dy//more accurate if use previous dx and dz
if(prevOnTrack){
prevDir = Math.sign(prevDir)
this.velx = velMag*dx*prevDir
this.velz = velMag*dz*prevDir
this.vely = velMag*dy*prevDir
}else{
this.velx = prevDir*dx
this.velz = prevDir*dz
this.vely = prevDir*dy
}
this.prevOnTrack = true
this.height = this.heightOnDiagonal//to allow fitting
this.pitch = -Math.PI4*Math.sign(sin(this.yaw)*dx+cos(this.yaw)*dz)
this.offsetY = 0.25
}else this.prevOnTrack = false
if(this.yaw > Math.PId) this.yaw -= Math.PId, this.previousYaw -= Math.PId
if(this.yaw < 0) this.yaw += Math.PId, this.previousYaw += Math.PId
if(blockData[onBlock].name === "poweredRail"){
let velMag = sqrt(velx*velx+velz*velz+vely*vely)
if(onBlock&FLIP){
if(velMag > 0.01 && velMag<8){
let extraSpeed = (8-velMag)*0.06
this.velx += this.velx/velMag*extraSpeed
this.velz += this.velz/velMag*extraSpeed
this.vely += this.vely/velMag*extraSpeed
if((onBlock&isState) === CUBE){
if(rot === NORTH || rot === SOUTH){
if(blockData[this.world.getBlock(railX,railY,railZ+1)].solid) this.velz = min(this.velz,-0.1)
else if(blockData[this.world.getBlock(railX,railY,railZ-1)].solid) this.velz = max(this.velz,0.1)
}else if(rot === EAST || rot === WEST){
if(blockData[this.world.getBlock(railX+1,railY,railZ)].solid) this.velx = min(this.velx,-0.1)
else if(blockData[this.world.getBlock(railX-1,railY,railZ)].solid) this.velx = max(this.velx,0.1)
}
}
}
}else{
this.velx *= 0.65
this.velz *= 0.65
this.vely *= 0.65
}
}
}else this.prevOnTrack = false
if(this.harmEffect > 0){
this.harmEffect--
}
if(this.health <= 0){
this.canDespawn = true
this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,blockIds.minecart,true,1,null,null,this.id)
}
}
onhit(damage,remote, vx,vz, from){
this.health -= damage
if(this.harmEffect>0) this.harmEffect += 7-floor(this.health)
else this.harmEffect = 7-floor(this.health)
if(!remote) this.world.sendEntityPos(this)
}
}
class Mob extends Entity{
static mob = true
mob = true
pushes = true
constructor(){
super(...arguments)
/*this.moveTime = 0
this.spinTime = 0
this.spin = 0
this.dirx = 0
this.dirz = 0*/
this.health = 0
this.lastDamage = 0
this.lastY = this.y
this.path = null
this.walking = false
this.panick = 0
this.drop = null
this.dropAmount = 0
this.maxDamageBlock = 0 //for blocks with damage
this.maxBurnBlock = 0
this.burnTimer = 0
this.burning = false
this.lastBlockDamage = 0
this.oxygen = 20
this.lastOxygenChange = 0
this.spinTarget = 0
this.spinTargetPitch = 0
this.die = false
this.lastStepSound = 0
this.hostile = false
this.minFollowDist = 0
this.maxFollowDist = 0
this.detectionDist = 0
this.target = null, this.targetEnt = null
this.attackStrength = 0
this.attackCooldown = 0, this.maxAttackCooldown = 0
this.holding = this.prevHolding = 0
this.canClimb = false
this.canFly = false
this.attacks = null
this.attracts = null
this.attractEnt = null
this.attractedBy = null
this.sitting = false
this.owner = null
this.name = null
this.despawnStart = performance.now()
this.hasAI = true
this.effects = {}
this.lastPathFind = 0
this.blockAtFeet = 0
}
findPath(fx,fy,fz,x,y,z){
let spreaded = [], spreadAt = [fx,fy,fz,null] //x y z parent
let spreadAtIndexes = [null]//points at parent node
let maxDist = 40, dist, dx, dy, dz, dd
let sx = fx, sy = fy, sz = fz, xDir, yDir, zDir, cy
let f = this.canFly
let closestIdx, closestIdxDist = Infinity
while(spreadAt.length && max(abs(sx-x),abs(sy-y),abs(sz-z)) > 0){
sx = spreadAt[spreadAt.length-4]
sy = spreadAt[spreadAt.length-3]
sz = spreadAt[spreadAt.length-2]
let closestDist = Infinity
xDir = yDir = zDir = 0
if(max(abs(sx-fx),abs(sy-fy),abs(sz-fz)) > maxDist && spreaded.length > 1000) return
{
dx = 1, dz = 0
let ci = this.world.getBlock(sx+dx,sy-1,sz+dz)
let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[ci].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
dy = 1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((b||f) && !a && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
dy = 0, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((c || blockData[ci].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
dy = -1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((d||f) && !c && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
}
{
dx = -1, dz = 0
let ci = this.world.getBlock(sx+dx,sy-1,sz+dz)
let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[ci].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
dy = 1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((b||f) && !a && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
dy = 0, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((c || blockData[ci].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
dy = -1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((d||f) && !c && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
}
{
dx = 0, dz = 1
let ci = this.world.getBlock(sx+dx,sy-1,sz+dz)
let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[ci].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
dy = 1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((b||f) && !a && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
dy = 0, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((c || blockData[ci].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
dy = -1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((d||f) && !c && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
}
{
dx = 0, dz = -1
let ci = this.world.getBlock(sx+dx,sy-1,sz+dz)
let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[ci].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
dy = 1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((b||f) && !a && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
dy = 0, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((c || blockData[ci].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
dy = -1, dist = abs(sx+dx-x)+abs(sz+dz-z)+abs(sy+dy-y)
if((d||f) && !c && dist<closestDist && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz
}
let above = blockData[this.world.getBlock(sx,sy+1,sz)], below = blockData[this.world.getBlock(sx,sy-1,sz)]
dist = abs(sx-x)+abs(sz-z)+abs(sy+1-y)
if(above.ladder && dist < closestDist && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) closestDist = dist, xDir = 0, yDir = 1, zDir = 0
dist = abs(sx-x)+abs(sz-z)+abs(sy-1-y)
if(below.ladder && dist < closestDist && !xyArrayHas(spreaded,spreadAt,sx,sy-1,sz)) closestDist = dist, xDir = 0, yDir = -1, zDir = 0
if(this.canClimb){
let b = blockData[this.world.getBlock(sx+1,sy,sz)].solid || blockData[this.world.getBlock(sx-1,sy,sz)].solid || blockData[this.world.getBlock(sx,sy,sz+1)].solid || blockData[this.world.getBlock(sx,sy,sz-1)].solid,
a2 = blockData[this.world.getBlock(sx,sy+1,sz)].solid,
b2 = blockData[this.world.getBlock(sx,sy,sz)].solid
dist = abs(sx-x)+abs(sz-z)+abs(sy+1-y)
if(!a2 && !b2 && b && dist < closestDist && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) closestDist = dist, xDir = 0, yDir = 1, zDir = 0
}
if(this.canFly){
let a2 = blockData[this.world.getBlock(sx,sy+1,sz)].solid,
b2 = blockData[this.world.getBlock(sx,sy,sz)].solid
dist = abs(sx-x)+abs(sz-z)+abs(sy+1-y)
if(!a2 && !b2 && dist < closestDist && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) closestDist = dist, xDir = 0, yDir = 1, zDir = 0
}
/*dist = abs(sx+1-x)+abs(sz-z)
if(dist < closestDist){
dx = 1, dy = 0, dz = 0, dd = false, cy = Infinity
let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
if((b||f) && !a && abs(sy+1-fy) < cy) dy = 1, dd = true, cy = abs(sy-1-fy)
if((c || blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && abs(sy-fy) < cy) dy = 0, dd = true, cy = abs(sy-1-fy)
if((d||f) && !c && abs(sy-1-fy) < cy) dy = -1, dd = true, cy = abs(sy-1-fy)
if(dd && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz, closestY = cy
}
dist = abs(sx-1-x)+abs(sz-z)
if(dist < closestDist){
dx = -1, dy = 0, dz = 0, dd = false, cy = Infinity
let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
if((b||f) && !a && abs(sy+1-fy) < cy) dy = 1, dd = true, cy = abs(sy-1-fy)
if((c || blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && abs(sy-fy) < cy) dy = 0, dd = true, cy = abs(sy-1-fy)
if((d||f) && !c && abs(sy-1-fy) < cy) dy = -1, dd = true, cy = abs(sy-1-fy)
if(dd && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz, closestY = cy
}
dist = abs(sx-x)+abs(sz+1-z)
if(dist < closestDist){
dx = 0, dy = 0, dz = 1, dd = false, cy = Infinity
let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
if((b||f) && !a && abs(sy+1-fy) < cy) dy = 1, dd = true, cy = abs(sy-1-fy)
if((c || blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && abs(sy-fy) < cy) dy = 0, dd = true, cy = abs(sy-1-fy)
if((d||f) && !c && abs(sy-1-fy) < cy) dy = -1, dd = true, cy = abs(sy-1-fy)
if(dd && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz, closestY = cy
}
dist = abs(sx-x)+abs(sz-1-z)
if(dist < closestDist){
dx = 0, dy = 0, dz = -1, dd = false, cy = Infinity
let a = blockData[this.world.getBlock(sx+dx,sy+1,sz+dz)].solid, b = blockData[this.world.getBlock(sx+dx,sy,sz+dz)].solid, c = blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].solid, d = blockData[this.world.getBlock(sx+dx,sy-2,sz+dz)].solid
if((b||f) && !a && abs(sy+1-fy) < cy) dy = 1, dd = true, cy = abs(sy-1-fy)
if((c || blockData[this.world.getBlock(sx+dx,sy-1,sz+dz)].liquid || f) && !(b || blockData[this.world.getBlock(sx+dx,sy,sz+dz)].liquid) && abs(sy-fy) < cy) dy = 0, dd = true, cy = abs(sy-1-fy)
if((d||f) && !c && abs(sy-1-fy) < cy) dy = -1, dd = true, cy = abs(sy-1-fy)
if(dd && !xyArrayHas(spreaded,spreadAt,sx+dx,sy+dy,sz+dz)) closestDist = dist, xDir = dx, yDir = dy, zDir = dz, closestY = cy
}
if(!isFinite(closestDist) && this.canClimb){
let b = blockData[this.world.getBlock(sx+1,sy,sz)].solid || blockData[this.world.getBlock(sx-1,sy,sz)].solid || blockData[this.world.getBlock(sx,sy,sz+1)].solid || blockData[this.world.getBlock(sx,sy,sz-1)].solid,
a2 = blockData[this.world.getBlock(sx,sy+1,sz)].solid,
b2 = blockData[this.world.getBlock(sx,sy,sz)].solid
if(!a2 && !b2 && b && abs(sy+1-fy) < closestY && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) yDir = 1, closestY = abs(sy+1-fy), closestDist = abs(sx-x)+abs(sz-z)
}else if(!isFinite(closestDist) && this.canFly){
let a2 = blockData[this.world.getBlock(sx,sy+1,sz)].solid,
b2 = blockData[this.world.getBlock(sx,sy,sz)].solid
if(!a2 && !b2 && abs(sy+1-fy) < closestY && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) yDir = 1, closestY = abs(sy+1-fy), closestDist = abs(sx-x)+abs(sz-z)
}else if(!isFinite(closestDist)){
let above = blockData[this.world.getBlock(sx,sy+1,sz)], below = blockData[this.world.getBlock(sx,sy-1,sz)]
if(above.ladder && abs(sy+1-fy) < closestY && !xyArrayHas(spreaded,spreadAt,sx,sy+1,sz)) yDir = 1, closestY = abs(sy+1-fy), closestDist = abs(sx-x)+abs(sz-z)
if(below.ladder && abs(sy-1-fy) < closestY && !xyArrayHas(spreaded,spreadAt,sx,sy-1,sz)) yDir = -1, closestY = abs(sy-1-fy), closestDist = abs(sx-x)+abs(sz-z)
}*/
if(spreadAtIndexes[spreadAtIndexes.length-1] === null){//if not already in spreaded
spreadAtIndexes[spreadAtIndexes.length-1] = spreaded.length
spreaded.push(sx,sy,sz, spreadAtIndexes.length>1 ? spreadAtIndexes[spreadAtIndexes.length-2] : null)
let fromDist = max(abs(sx-x),abs(sy-y),abs(sz-z))
if(fromDist<closestIdxDist){
closestIdxDist = fromDist
closestIdx = spreadAtIndexes[spreadAtIndexes.length-1]
}
}
if(isFinite(closestDist)) spreadAt.push(sx+xDir,sy+yDir,sz+zDir, null), spreadAtIndexes.push(null)
else spreadAt.pop(), spreadAt.pop(), spreadAt.pop(), spreadAt.pop(), spreadAtIndexes.pop()
}
if(sx === fx && sy === fy && sz === fz) return null
let i = closestIdx, path = []//[sz+zDir,sy+yDir,sx+xDir,sz,sy,sx]
while(path.length < 85){
i = spreaded[i+3]
if(i) path.push(spreaded[i+2],spreaded[i+1],spreaded[i])
else break
}
path.reverse()
return path
}
randomPath(){
let x = round(this.x+rand(-10,10))
let z = round(this.z+rand(-10,10))
let y, y2
for(y = y2 = round(this.y); y<round(this.y)+10; y++, y2--){
let data = blockData[this.world.getBlock(x,y,z,this.dimension)]
if(!data.solid && !data.liquid) break
data = blockData[this.world.getBlock(x,y2,z,this.dimension)]
if(!data.solid && !data.liquid) break
}
this.path = this.findPath(round(this.x),round(this.y-this.height/2),round(this.z),x,y,z) || null
}
AI(now){
if(!this.hasAI) return
let target = this.target && getEntityOrPlayer(this.target,this.world)
let follow = target || this.attractEnt
let d = follow && max(abs(follow.x-this.x),abs(follow.y-this.y),abs(follow.z-this.z))
if(this.path && this.path.length && (!follow || follow === target && d > this.minFollowDist || follow === this.attractEnt && d > 2)){
//let x,y,z, c = Infinity, i
/*for(let i2=0; i2<this.path.length; i2+=3){
let d = max(abs(this.path[i2]-this.x),abs(this.path[i2+1]-this.y),abs(this.path[i2+2]-this.z))
if(d < c) c = d, x = this.path[i2], y = this.path[i2+1], z = this.path[i2+2], i = i2
}
if(i > 0) this.path.splice(0,i) //get rid of the part that it wont go to
*/
let [x,y,z] = this.path
let yaw = angleOf(x,z,this.x,this.z)
this.spinTarget = yaw
if(this.yaw - yaw > Math.PI) yaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
if(this.yaw - yaw < -Math.PI) yaw -= Math.PId
let d = max(min(yaw - this.yaw, 0.3),-0.3)
this.yaw += d
let distToPath = max(abs(this.x-x),abs(this.z-z),abs(this.y-this.height/2-y)), goingVertical = x === this.path[3] && z === this.path[5]
let speed = this.panick > 0 ? 0.08 : (this.target ? 0.03 : 0.02)
if(!goingVertical || distToPath > 1){//if going up, don't move unless too far
this.velx += sin(this.yaw) * speed
this.velz += cos(this.yaw) * speed
}
if(y > round(this.y-this.height/2)){
if(this.canClimb) this.vely = 0.2
else if(this.canFly) this.vely += 0.2
else if(this.onGround) this.vely = 0.6
if(this.blockAtFeet && blockData[this.blockAtFeet].ladder){
this.vely = 0.2
}
}
if(distToPath < 1){
this.path.splice(0,3)
}
if(!this.path.length) this.path = null
this.walking = true
}else{
this.walking = false
if(this.spinTarget !== this.yaw){
let yaw = this.spinTarget
if(this.yaw - yaw > Math.PI) yaw += Math.PId //prevent weird thing happening when rotation was 0 but is now 360
if(this.yaw - yaw < -Math.PI) yaw -= Math.PId
let d = max(min(yaw - this.yaw, 0.1),-0.1)
this.yaw += d
}
}
if(this.liquid) this.vely += 0.3
if(this.path && this.sitting) this.path = null
if(this.sitting && this.targetEnt) this.targetEnt = target = null
if(target){
let d = max(abs(this.x-target.x),abs(this.y-target.y),abs(this.z-target.z))
if(d > this.maxFollowDist ||
this.dimension !== target.dimension || target.hidden || target.die || target.survival !== undefined && !target.survival
) this.target = target = null
}
if(this.hostile && !target && !this.sitting){
let c = Infinity
if(!this.attacks || this.attacks.includes("Player")) for(let ent of this.world.players){
if(this.dimension === ent.dimension && !ent.hidden && !ent.die && ent.survival){
let d = max(abs(this.x-ent.x),abs(this.y-ent.y),abs(this.z-ent.z))
if(d<this.detectionDist && d<c){
c = d
this.target = ent.id, target = ent
}
}
}
if(this.attacks){
this.world.getEntitiesNear(this.x,this.y,this.z,this.dimension, this.detectionDist, nearEntityArray)
for(let ent of nearEntityArray){
if(this.dimension === ent.dimension && !ent.hidden && !ent.die && this.attacks.includes(ent.type)){
let d = max(abs(this.x-ent.x),abs(this.y-ent.y),abs(this.z-ent.z))
if(d<this.detectionDist && d<c){
c = d
this.target = ent.id, target = ent
}
}
}
}
}
this.attractEnt = null
if(!target && this.attracts){
let cd = Infinity
for(let p of this.world.players){
let dist = max(abs(this.x-p.x),abs(this.y-p.y),abs(this.z-p.z))
if(p.dimension === this.dimension && !p.hidden && !p.die && dist < 5 && dist < cd && this.attracts.includes(p.holding)) cd = dist, this.attractEnt = p
}
}
this.attractedBy = this.attractEnt ? (this.attractEnt.id) : null
if(this.attackCooldown > 0) this.attackCooldown--
if(follow && !this.sitting){
let y = round(follow.y)
if(!this.canFly){
while(!blockData[this.world.getBlock(round(follow.x),y,round(follow.z),this.dimension)].solid && y>round(this.y)-this.detectionDist) y--
y++
}
if(now-this.lastPathFind>1000){
this.lastPathFind = now
let path = this.findPath(round(this.x),round(this.y-this.height/2),round(this.z),round(follow.x),y,round(follow.z))
if(path){
path.splice(0,3)
this.path = path
}
}
if(target && this.attackStrength && this.attackCooldown <= 0 && (d || d === 0) && d <= this.minFollowDist+0.5){
let velx = sin(this.yaw)/2, velz = cos(this.yaw)/2
if(target.type === "Player"){
let msg = this.name ? target.username+"was killed by "+this.name+"." : this.killMessage(target.username)
target.damage(this.attackStrength,msg,false,null,this.x,this.y,this.z,this)
}else if(target.onhit) target.onhit(this.attackStrength,false, velx,velz, this.id)
this.attackCooldown = this.maxAttackCooldown
//this.world.sendAllInChunk({type:"entEvent",event:"mobAttack",id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
this.world.sendEntityPos(this)
}
}else{
if(!this.sitting && rand() > 0.995 && !this.path){
this.randomPath()
}else if(rand() > 0.99){
this.spinTarget = rand(Math.PId)
this.spinTargetPitch = 0
}
}
if(this.saySound && rand() > 0.999){
let sound = this.saySound
if(Array.isArray(sound)) sound = sound[Math.floor(Math.random()*sound.length)]
this.world.playSound(this.x,this.y,this.z, sound)
}
this.targetEnt = target
if(this.additionalAI) this.additionalAI()
if(this.yaw<0) this.yaw += Math.PId
if(this.yaw>Math.PId) this.yaw -= Math.PId
/*let dt = (now - this.lastUpdate) / 33
dt = dt > 2 ? 2 : dt
if(this.moveTime > 0){
this.moveTime --
this.velx += this.dirx / 100
this.velz += this.dirz / 100
}else if(this.spinTime > 0){
this.spinTime --
this.yaw += this.spin
if(this.yaw > Math.PI*2){
this.yaw -= Math.PI*2
}
if(this.yaw < 0){
this.yaw += Math.PI*2
}
}else if(Math.random()>0.8){
if(Math.random() > 0.5){
this.spinTime = Math.random()*60
this.spin = (Math.random()>0.5 ? 0.05 : -0.05)
}else{
this.moveTime = Math.random()*60
this.dirx = Math.cos(this.yaw)
this.dirz = -Math.sin(this.yaw)
}
}
if(this.moveTime > 0 && Math.random() > 0.5){
var b = world.getBlock(round(this.x+this.dirx), this.y, round(this.z+this.dirz), this.dimension)
if(this.onGround && blockData[b].solid && !blockData[b].liquid){
this.vely = 0.3
}
if(blockData[b].liquid){
this.vely += 0.05
}
}*/
}
ontouch(x,y,z,block){
let data = blockData[block]
if(inBox(this,x,y,z,1,1,1)){
if(data.damage){
let d = data.damage
if(typeof d === "function") d = d(round(this.x),round(this.y),round(this.z),this.dimension,this.world)
if(d > this.maxDamageBlock) this.maxDamageBlock = d
}
if(data.burnEnt) this.maxBurnBlock = 0.2
}else if(data.damageUp && onBox(this,x,y,z,1,1,1)){
if(data.damageUp > this.maxDamageBlock) this.maxDamageBlock = data.damageUp
}
}
mobUpdate(now) {
this.maxBurnBlock = this.maxDamageBlock = 0
this.updateVelocity(now)
this.move(now)
for(let P of this.world.players){
if(!P.hidden && !P.die && P.dimension === this.dimension && P.riding !== this.id) this.pushByMob(P)
}
this.world.getEntitiesNear(this.x,this.y,this.z,this.dimension, 16, nearEntityArray)
for(let ent of nearEntityArray){
if(ent.pushes && ent !== this && ent.dimension === this.dimension && ent.riding !== this.id) this.pushByMob(ent)
}
let blockAtFeet = this.world.getBlock(round(this.x),ceil(this.y-this.height/2),round(this.z), this.dimension)
this.blockAtFeet = blockAtFeet
this.AI(now)
if(blockAtFeet && blockData[blockAtFeet].ladder){
this.lastY = this.y
if(this.vely < 0) this.vely *= 0.2
}
//health and death & stuff
if(this.y > this.lastY) this.lastY = this.y
if(this.onGround && !this.canFly){
let fall = this.lastY - this.y
this.lastY = this.y
if(!this.liquid && fall > 3){
this.damage(fall-3)
}
}
if(this.maxDamageBlock > 0 && now - this.lastBlockDamage > 500){
this.lastBlockDamage = now
this.damage(this.maxDamageBlock)
if(!this.path) this.randomPath()
this.sitting = false
//this.world.sendAllInChunk({type:"entEvent",event:"sit",id:this.id, data:this.sitting},this.chunkX,this.chunkZ,this.chunkDimension)
this.world.sendEntityPos(this)
this.panick = 20
}
this.burnTimer += this.maxBurnBlock
if(this.burnTimer > 16) this.burnTimer = 16
this.burning = this.burnTimer > 0
if(this.burning){
if(now - this.lastBlockDamage > 1000){
this.lastBlockDamage = now
this.burnTimer -= 2
if(this.burnTimer < 0) this.burnTimer = 0
this.damage(1)
if(!this.path) this.randomPath()
this.sitting = false
//this.world.sendAllInChunk({type:"entEvent",event:"sit",id:this.id, data:this.sitting},this.chunkX,this.chunkZ,this.chunkDimension)
this.world.sendEntityPos(this)
this.panick = 20
}
}
if(this.insideBlock && (blockData[this.insideBlock].solid && !blockData[this.insideBlock].transparent || blockData[this.insideBlock].liquid)){
if(this.oxygen > 0){
if(now - this.lastOxygenChange > (blockData[this.insideBlock].liquid ? 1000 : 500)){
this.lastOxygenChange = now
this.oxygen-=2
}
}else{
if(now - this.lastOxygenChange > 500){
this.lastOxygenChange = now
this.damage(1)
this.sitting = false
if(!this.path) this.randomPath()
this.panick = 20
//this.world.sendAllInChunk({type:"entEvent",event:"sit",id:this.id, data:this.sitting},this.chunkX,this.chunkZ,this.chunkDimension)
this.world.sendEntityPos(this)
}
}
}else if(this.oxygen < 20){
if(now - this.lastOxygenChange > 250){
this.lastOxygenChange = now
this.oxygen+=2
}
}
if(this.oxygen < 0) this.oxygen = 0
if(this.oxygen > 20) this.oxygen = 20
for(let i in this.effects){
let e = this.effects[i]
e.time--
if(e.time <= 0) delete this.effects[i]
}
if(this.effects.wither && now-this.lastBlockDamage > 1000){
this.lastBlockDamage = now
this.damage(this.effects.wither.level*0.5)
if(!this.path) this.randomPath()
this.panick = 20
}
if(this.harmEffect > 0){
this.harmEffect -= 3
}
if(this.health <= 0 && !this.die){
this.die = true
this.hasAI = false
if(this.deathSound){
let sound = this.deathSound
if(Array.isArray(sound)) sound = sound[Math.floor(Math.random()*sound.length)]
this.world.playSound(this.x,this.y,this.z, sound)
}
if(this.drop){
for(let i of this.drop){
let amount = this.dropAmount || 1
if(Array.isArray(amount)) amount = round(rand(amount[0],amount[1]))
this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,i,true,amount,null,null,this.id)
}
if(this.holding) this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,this.holding,true,null,null,null,this.id)
if(this.experience) this.world.addEntity(new entities[entityIds.ExperienceOrb](this.x, this.y, this.z, this.experience),false,this.dimension)
if(this.ondie) this.ondie()
}
}
if(this.die){
this.dieEffect += 0.04//0.05 //slower than client side to allow animation
this.dieRotate = (this.dieEffect**4)*Math.PI2
if(this.dieEffect > 1){
this.canDespawn = true
this.dieEffect = 0
this.dieRotate = 0
this.hidden = true
this.world.poof(this.x,this.y,this.z, undefined,this.dimension, this.width,this.height,this.depth,true)
}
}
if(this.walking && now - this.lastStepSound > (this.panick ? 500 : 1000)){
this.lastStepSound = now
if(this.stepSound){
let sound = this.stepSound
if(Array.isArray(sound)) sound = sound[Math.floor(Math.random()*sound.length)]
this.world.playSound(this.x,this.y-this.height/2,this.z, sound)
}else this.world.blockSound(this.standingOn,"step",this.x,this.y-this.height/2,this.z)
}
if(this.panick > 0) this.panick--
}
updateAlways(){
let canDespawn = true
for(let p of this.world.players){
if(max(abs(this.x-p.x),abs(this.y-p.y),abs(this.z-p.z)) <= 48) canDespawn = false
}
if(this.name) canDespawn = false
if(!canDespawn) this.despawnStart = now
else if (now - this.despawnStart > this.despawns) {
this.canDespawn = true
}
}
damage(amount,vx,vy,vz){
if(vx) this.velx += vx
if(vy) this.vely += vy
if(vz) this.velz += vz
var prev = amount
if(this.harmEffect > 0){
if(amount > this.lastDamage){
amount -= this.lastDamage
}else return
}
this.health -= amount
this.harmEffect = 30
this.lastDamage = prev
if(this.hurtSound){
let sound = this.hurtSound
if(Array.isArray(sound)) sound = sound[Math.floor(Math.random()*sound.length)]
this.world.playSound(this.x,this.y,this.z, sound)
}
}
onhit(damage,remote, vx,vz, from){
this.panick = 60
if(!this.path) this.randomPath()
//this.world.sendAllInChunk({type:"entEvent",event:"sit",id:this.id, data:this.sitting},this.chunkX,this.chunkZ,this.chunkDimension)
this.sitting = false
this.damage(damage,vx,min(max(0.5-this.vely,0),0.5),vz)
setTarget:if(this.hostile){
if(this.owner){
let owner = getPlayerByUsername(this.owner,this.world)
if(from === owner.username) break setTarget
}
this.target = from || null
}
if(!remote) this.world.sendEntityPos(this)
}
applyEffect(name,level,time, showParticles = true){
time *= 20
if(this.effects[name]){
let e = this.effects[name]
if(level>e.level){
e.level = level
e.time = time
e.showParticles = e.showParticles || showParticles
}
}
this.effects[name] = {level, time, showParticles}
}
}
entities[entities.length] = class Cow extends Mob{
static name2 = "Cow"
drop = [blockIds.rawBeef]
dropAmount = [1,3]
saySound = ["cow.say1","cow.say2","cow.say3","cow.say4"]
stepSound = ["cow.step1","cow.step2","cow.step3","cow.step4"]
hurtSound = ["cow.hurt1","cow.hurt2","cow.hurt3"]
defaultName = "Cow"
constructor(x,y,z){
super(x, y, z, 0, 0, 0, 0, 0, 1, 21/16, 1, null,null, null, 300000)
var pix = 1/16
this.offsetY = pix*9.5
this.addPart("frontRightLeg",null,null,pix*-4,pix*-8,pix*7,1,1,1,0,0)
this.addPart("frontLeftLeg",null,null,pix*4,pix*-8,pix*7,1,1,1,0,0)
this.addPart("backRightLeg",null,null,pix*-4,pix*-8,pix*-6,1,1,1,0,0)
this.addPart("backLeftLeg",null,null,pix*4,pix*-8,pix*-6,1,1,1,0,0)
this.addPart("head",null,null,0,0,pix*9,1,1,1,0,0)
this.health = 10
this.attracts = [blockIds.wheat]
}
update(){
this.mobUpdate(now)
}
onclick(holding){
if(holding && holding.id === blockIds.bucket) holding.id = blockIds.milkBucket
}
}
entities[entities.length] = class Pig extends Mob{
static name2 = "Pig"
drop = [blockIds.rawPorkchop]
dropAmount = [1,3]
saySound = ["pig.say1","pig.say2","pig.say3"]
stepSound = ["pig.step1","pig.step2","pig.step3","pig.step4","pig.step5"]
deathSound = "pig.death"
defaultName = "Pig"
constructor(x,y,z){
super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, null, 300000)
var pix = 1/16
this.offsetY = pix*6
this.addPart("frontRightLeg",null,null,pix*-3,pix*-8,pix*5,1,1,1,0,0)
this.addPart("frontLeftLeg",null,null,pix*3,pix*-8,pix*5,1,1,1,0,0)
this.addPart("backRightLeg",null,null,pix*-3,pix*-8,pix*-7,1,1,1,0,0)
this.addPart("backLeftLeg",null,null,pix*3,pix*-8,pix*-7,1,1,1,0,0)
this.addPart("head",null,null,0,pix*-2,pix*10,1,1,1,0,0)
this.health = 10
this.attracts = [blockIds.carrot, blockIds.potato]
}
update(){
this.mobUpdate(now)
}
}
entities[entities.length] = class Creeper extends Mob{
static name2 = "Creeper"
drop = [blockIds.gunpowder]
dropAmount = [0,2]
experience = 5
hurtSound = ["creeper.say1","creeper.say2","creeper.say3","creeper.say4"]
deathSound = "creeper.death"
defaultName = "Creeper"
constructor(x,y,z){
super(x, y, z, 0, 0, 0, 0, 0, 0.5, 26/16, 0.5, null,null, null, 300000)
var pix = 1/16
this.offsetY = pix*-1
this.addPart("frontRightLeg",null,null,pix*-2,pix*-6,pix*4,1,1,1,0,0)
this.addPart("frontLeftLeg",null,null,pix*2,pix*-6,pix*4,1,1,1,0,0)
this.addPart("backRightLeg",null,null,pix*-2,pix*-6,pix*-4,1,1,1,0,0)
this.addPart("backLeftLeg",null,null,pix*2,pix*-6,pix*-4,1,1,1,0,0)
this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
this.health = 10
this.hostile = true
this.minFollowDist = 3
this.maxFollowDist = this.detectionDist = 16
this.timerStart = 0
this.explodeAmount = 0
this.timeLimit = 30
}
explode(){
var x = round(this.x), y = round(this.y), z = round(this.z)
this.world.explode(x,y,z,3, this.liquid || !this.world.settings.tntExplode, this.dimension)
}
update(){
this.mobUpdate(now)
let d = this.targetEnt && max(abs(this.targetEnt.x-this.x),abs(this.targetEnt.y-this.y),abs(this.targetEnt.z-this.z))
if(this.targetEnt && d<=this.minFollowDist){
if(!this.explodeAmount){
this.timerStart = now
this.world.playSound(this.x,this.y,this.z, "random.fuse")
}
this.explodeAmount++
if(this.explodeAmount > 20) this.explodeAmount = 20
}else if(this.explodeAmount) this.explodeAmount--
this.shader = 0, this.extraSize = 0
if(this.explodeAmount>0){
var i = Math.floor((now - this.timerStart) / 125)
if(!(i%2)){
this.shader = 1
}
if((now - this.timerStart) / tickTime >= this.timeLimit - 10){
//get bigger
this.extraSize = min(-((this.timeLimit - 10) - ((now - this.timerStart) / tickTime)) / 40,0.25)
this.shader = 1
}
if((now - this.timerStart) / tickTime >= this.timeLimit){
this.canDespawn = true
this.explode()
}
}
}
onclick(block){
if(!block || block.id !== blockIds.flintAndSteel) return
this.explodeAmount = 100
this.timerStart = now
this.world.sendEntityPos(this)
//this.world.sendAllInChunk({type:"entEvent",event:"creeperForceExplode",id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
}
}
entities[entities.length] = class Sheep extends Mob{
static name2 = "Sheep"
drop = [blockIds.rawMutton]
dropAmount = [1,2]
saySound = ["sheep.say1","sheep.say2","sheep.say3"]
hurtSound = ["sheep.say1","sheep.say2","sheep.say3"]
stepSound = ["sheep.step1","sheep.step2","sheep.step3","sheep.step4","sheep.step5"]
defaultName = "Sheep"
constructor(x,y,z, color, wool){
super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, null,null, 0, 300000, "vao")
var pix = 1/16
this.offsetY = pix*7
this.addPart("frontRightLeg",null,null,pix*-3,pix*-3,pix*5,1,1,1,0,0)
this.addPart("frontLeftLeg",null,null,pix*3,pix*-3,pix*5,1,1,1,0,0)
this.addPart("backRightLeg",null,null,pix*-3,pix*-3,pix*-7,1,1,1,0,0)
this.addPart("backLeftLeg",null,null,pix*3,pix*-3,pix*-7,1,1,1,0,0)
this.addPart("head",null,null,0,pix*4,pix*10,1,1,1,0,0)
this.health = 10
this.fur = true
this.eating = 0
this.color = color
this.wool = wool
if(!color){
let r = rand(100), dye
if(r > 50) dye = "white"
else if(r > 35) dye = "lightGray"
else if(r > 20) dye = "gray"
else if(r > 5) dye = "black"
else if(r > 1) dye = "brown"
else dye = "pink"
this.color = colors.dye[dye].slice()
this.wool = dye+"Wool"
}
this.attracts = [blockIds.wheat]
}
ondie(){
this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,blockIds[this.wool],true,round(rand(1,2)))
}
onclick(holding){
let data = blockData[holding ? holding.id : 0]
if(data.dye){
this.color = colors.dye[data.dye].slice()
this.wool = data.dye+"Wool"
//if(multiplayer) send({type:"entEvent",event:"sheepColor",data:{color:this.color,wool:this.wool},id:this.id})
this.world.sendEntityPos(this)
}else if(data.shears){
if(!this.fur) return
this.fur = false
this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,blockIds[this.wool],true,round(rand(1,3)))
//this.world.sendAllInChunk({type:"entEvent",event:"sheepFur",data:false,id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
this.world.sendEntityPos(this)
this.world.playSound(this.x,this.y,this.z, "sheep.shear")
}
}
additionalAI(now){
if(!this.eating && this.standingOn === blockIds.grass && rand() > 0.999){
this.eating = 1
//this.world.sendAllInChunk({type:"entEvent",event:"sheepEat",id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
this.world.sendEntityPos(this)
}
if(this.eating && this.standingOn !== blockIds.grass) this.eating = 0
if(this.eating && ++this.eating > 40){
this.eating = 0
this.world.setBlock(round(this.x),floor(this.y-this.height/2),round(this.z),blockIds.dirt,false,false,false,false,this.dimension)
this.fur = true
//this.world.sendAllInChunk({type:"entEvent",event:"sheepFur",data:true,id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
this.world.sendEntityPos(this)
this.world.blockParticles(this.standingOn,round(this.x),floor(this.y-this.height/2)+0.5,round(this.z),30, "break",this.dimension)
}
}
update(){
this.mobUpdate(now)
}
}
entities[entities.length] = class Chicken extends Mob{
static name2 = "Chicken"
drop = [blockIds.rawChicken,blockIds.feather]
saySound = ["chicken.say1","chicken.say2","chicken.say3"]
stepSound = ["chicken.step1","chicken.step2"]
hurtSound = ["chicken.hurt1","chicken.hurt2"]
defaultName = "Chicken"
constructor(x,y,z){
var pix = 1/16
super(x, y, z, 0, 0, 0, 0, 0, 0.5, pix*11, 0.5, null,null, null, 300000)
this.offsetY = pix*2.5
this.addPart("leftWing",null,null,pix*3.5,pix*3,0,1,1,1,0,0)
this.addPart("rightWing",null,null,pix*-3.5,pix*3,0,1,1,1,0,0)
this.addPart("rightLeg",null,null,pix*-1.5,pix*-3,0,1,1,1,0,0)
this.addPart("leftLeg",null,null,pix*1.5,pix*-3,0,1,1,1,0,0)
this.addPart("head",null,null,0,pix*4,pix*4.5,1,1,1,0,0)
this.health = 4
this.attracts = [blockIds.beetrootSeeds, blockIds.tomatoSeeds, blockIds.pumpkinSeeds, blockIds.melonSeeds, blockIds.wheatSeeds]
}
additionalAI(){
if(rand() > 0.9998){
this.world.addItems(this.x,this.y,this.z,this.dimension,0,0,0,blockIds.egg,true)
this.world.playSound(this.x,this.y,this.z, "chicken.plop")
}
}
update(){
this.mobUpdate(now)
if(this.vely < 0){
this.vely *= 0.5
this.lastY = this.y
}
}
}
entities[entities.length] = class Zombie extends Mob{
static name2 = "Zombie"
drop = [blockIds.rottenFlesh]
dropAmount = [0,3]
experience = 5
saySound = ["zombie.say1","zombie.say2","zombie.say3"]
stepSound = ["zombie.step1","zombie.step2","zombie.step3","zombie.step4","zombie.step5"]
hurtSound = ["zombie.hurt1","zombie.hurt2"]
deathSound = "zombie.death"
defaultName = "Zombie"
constructor(x,y,z){
super(x, y, z, 0, 0, 0, 0, 0, 1, 2, 1, null,null, null, 300000)
var pix = 1/16
this.offsetY = pix*2
this.addPart("rightLeg",null,null,pix*-2,pix*-6,0,1,1,1,0,0)
this.addPart("leftLeg",null,null,pix*2,pix*-6,0,1,1,1,0,0)
this.addPart("rightArm",null,null,pix*-6,pix*6,pix*0,1,1,1,0,0)
this.addPart("leftArm",null,null,pix*6,pix*6,pix*0,1,1,1,0,0)
this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
this.health = 20
this.hostile = true
this.minFollowDist = 1
this.maxFollowDist = 35
this.detectionDist = 17.5
this.attackStrength = 3
this.maxAttackCooldown = 20
}
killMessage(username){return username+" died from some small punches from a Zombie."}
update(){
this.mobUpdate(now)
if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0, this.dimension)*this.world.skyLight > 11){
this.burnTimer += 0.2
}
}
}
entities[entities.length] = class Skeleton extends Mob{
static name2 = "Skeleton"
drop = [blockIds.bone,blockIds.arrow]
dropAmount = [1,2]
experience = 5
saySound = ["skeleton.say1","skeleton.say2","skeleton.say3"]
stepSound = ["skeleton.step1","skeleton.step2","skeleton.step3","skeleton.step4"]
hurtSound = ["skeleton.hurt1","skeleton.hurt2","skeleton.hurt3","skeleton.hurt4"]
deathSound = "skeleton.death"
defaultName = "Skeleton"
constructor(x,y,z){
super(x, y, z, 0, 0, 0, 0, 0, 0.75, 2, 0.75, null,null, null, 300000)
var pix = 1/16
this.offsetY = pix*2
this.addPart("rightLeg",null,null,pix*-2,pix*-6,0,1,1,1,0,0)
this.addPart("leftLeg",null,null,pix*2,pix*-6,0,1,1,1,0,0)
this.addPart("rightArm",null,null,pix*-5,pix*6,pix*0,1,1,1,0,0)
this.addPart("leftArm",null,null,pix*5,pix*6,pix*0,1,1,1,0,0)
this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
this.addPart("holding",null,null,0,0,0,1,1,1,0,0,undefined,"rightArm") //changed later
this.health = 20
this.hostile = true
this.minFollowDist = 8
this.maxFollowDist = this.detectionDist = 16
this.holding = blockIds.bow, this.maxAttackCooldown = 20
}
additionalAI(){
if(blockData[this.holding].name === "bow" && this.targetEnt && this.attackCooldown <= 0){
let vx = this.targetEnt.x - this.x, vy = this.targetEnt.y - this.y, vz = this.targetEnt.z - this.z
let mag = sqrt(vx*vx+vy*vy+vz*vz)
vx /= mag, vy /= mag, vz /= mag
this.world.addEntity(new entities[entityIds.Arrow](this.x+vx,this.y+vy,this.z+vz,vx,vy,vz,this.id),false,this.dimension)
this.attackCooldown = this.maxAttackCooldown
this.world.sendEntityPos(this)
//this.world.sendAllInChunk({type:"entEvent",event:"mobAttack",id:this.id},this.chunkX,this.chunkZ,this.chunkDimension)
}
}
update(){
this.mobUpdate(now)
if(!this.liquid && this.world.getLight(round(this.x), round(this.y), round(this.z), 0, this.dimension)*this.world.skyLight > 11){
this.burnTimer += 0.2
}
}
}
entities[entities.length] = class Spider extends Mob{
static name2 = "Spider"
saySound = ["spider.say1","spider.say2","spider.say3","spider.say4"]
stepSound = ["spider.step1","spider.step2","spider.step3","spider.step4"]
deathSound = "spider.death"
drop = [blockIds.string,blockIds.spiderEye]
dropAmount = [0,2]
experience = 5
constructor(x,y,z,cave){
let s = cave ? 0.7 : 1
super(x, y, z, 0, 0, 0, 0, 0, s, s, s, null,null, null, 300000)
var pix = 1/16
this.offsetY = pix*2
let legRot = Math.PI/8
this.addPart("rightLeg0",null,null,pix*-3,0,0,1,1,1,0,0,legRot)
this.addPart("rightLeg1",null,null,pix*-3,0,0,1,1,1,0,0,legRot)
this.addPart("rightLeg2",null,null,pix*-3,0,0,1,1,1,0,0,legRot)
this.addPart("rightLeg3",null,null,pix*-3,0,0,1,1,1,0,0,legRot)
this.addPart("leftLeg0",null,null,pix*3,0,0,1,1,1,0,0,-legRot)
this.addPart("leftLeg1",null,null,pix*3,0,0,1,1,1,0,0,-legRot)
this.addPart("leftLeg2",null,null,pix*3,0,0,1,1,1,0,0,-legRot)
this.addPart("leftLeg3",null,null,pix*3,0,0,1,1,1,0,0,-legRot)
this.addPart("head",null,null,0,0,pix*7,1,1,1,0,0)
this.fur = !!cave
this.defaultName = cave ? "Cave Spider" : "Spider"
this.health = 16
this.canClimb = true
this.hostile = true
this.minFollowDist = 1.5
this.maxFollowDist = 16
this.detectionDist = -1
this.attackStrength = 2
this.maxAttackCooldown = 20
}
killMessage(username){return username+" died from a tiny little spider."}
update(){
this.mobUpdate(now)
if(this.prevWalking !== this.walking){
this.prevWalking = this.walking
this.walkStart = now
}
}
}
entities[entities.length] = class Wolf extends Mob{
static name2 = "Wolf"
defaultName = "Wolf"
constructor(x,y,z){
super(x, y, z, 0, 0, 0, 0, 0, 0.6, 0.8, 0.6, null,null, null, Infinity, "vao")
var pix = 1/16
this.addPart("head",null,null,0,0,pix*10,1,1,1,0,0)
this.addPart("frontRightLeg",null,null,pix*-1.5,pix*-3,pix*5,1,1,1,0,0)
this.addPart("frontLeftLeg",null,null,pix*1.5,pix*-3,pix*5,1,1,1,0,0)
this.addPart("backRightLeg",null,null,pix*-1.5,pix*-3,pix*-6,1,1,1,0,0)
this.addPart("backLeftLeg",null,null,pix*1.5,pix*-3,pix*-6,1,1,1,0,0)
this.addPart("tail",null,null,0,0,pix*-8,1,1,1,Math.PI2,0)
this.addPart("collar",null,null,0,0,pix*6.1,1,1,1,0,0)
this.health = 8
this.hostile = true
this.minFollowDist = 1.5
this.maxFollowDist = 16
this.detectionDist = 16
this.attackStrength = 4
this.maxAttackCooldown = 20
this.attacks = ["Sheep","Rabbit","Fox","Skeleton"]
this.attracts = [blockIds.bone]
this.wetStuff = 0
this.tame = false
this.color = colors.dye.red.slice()
}
feed(id,from){
if(id === blockIds.bone){
if(this.tame){
let prev = this.health
this.health++
if(this.health > 20) this.health = 20
this.world.sendEntityPos(this)
}else{
if(rand(3) > 1){
this.world.sendAllInChunk({
type:"particles",particleType:"smokeCube",
x:this.x,y:this.y,z:this.z,dimension:this.dimension,amount:10
},this.chunkX,this.chunkZ,this.chunkDimension)
}else{
this.world.sendAllInChunk({
type:"particles",particleType:"hearts",
x:this.x,y:this.y,z:this.z,dimension:this.dimension,amount:10
},this.chunkX,this.chunkZ,this.chunkDimension)
this.world.addEntity(new entities[entityIds.ExperienceOrb](this.x,this.y,this.z, rand(1,7)),false,this.dimension)
this.tame = true
this.health *= 20/8
let owner = getPlayerById(from,this.world)
this.owner = owner.username
this.world.sendEntityPos(this)
}
}
}
}
onclick(holding,p){
let data = blockData[holding ? holding.id : 0]
if(data.dye){
this.color = colors.dye[data.dye].slice()
//if(multiplayer) send({type:"entEvent",event:"wolfCollarColor",data:this.color,id:this.id})
//this.updateShape()
this.world.sendEntityPos(this)
}else if(holding.id === blockIds.bone){
holding.amount--
this.feed(holding.id,p.id)
}else if(this.tame){
this.sitting = !this.sitting
this.world.sendEntityPos(this)
//if(multiplayer) send({type:"entEvent",event:"sit",id:this.id, data:this.sitting})
}
}
killMessage(username){return username+" got bited by a wolf."}
additionalAI(){
let owner = this.owner && getPlayerByUsername(this.owner,this.world)
if(!owner || owner.die || owner.hidden) return
let d = max(abs(this.x-owner.x),abs(this.y-owner.y),abs(this.z-owner.z))
if(d > 16 && !this.sitting){
this.target = null
let x = round(this.x), y = round(this.y), z = round(this.z)
let closest = Infinity, cx, cy, cz
for(let x2=-5;x2<5;x2++) for(let z2=-5;z2<5;z2++) for(let y2=-5;y2<5;y2++){
if(!blockData[this.world.getBlock(owner.x+x2,owner.y+y2,owner.z+z2)].solid){
let dist = max(abs(x2),abs(y2),abs(z2))
if(dist < closest && blockData[world.getBlock(owner.x+x2,owner.y+y2-1,owner.z+z2)].solid) closest = dist, cx = x2, cy = y2, cz = z2
}
}
if(isFinite(closest)){
this.x = owner.x+cx
this.y = owner.y+cy
this.z = owner.z+cz
this.path = null
this.lastY = this.y
//this.world.sendAll({type:"entEvent",event:"tp",id:this.id, data:{x:this.x,y:this.y,z:this.z}})
this.world.sendEntityPos(this)
}
}else if(d > 8 && !this.sitting){
if(now-this.lastPathFind>1000){
this.lastPathFind = now
let path = this.findPath(round(this.x),round(this.y-this.height/2),round(this.z),round(owner.x),round(owner.y),round(owner.z))
if(path){
path.splice(0,3)
this.path = path
}
}
}
if(owner && !owner.die && !owner.hidden){
if(owner.attackedById && this.target !== owner.attackedById){
this.target = owner.attackedById
this.world.sendEntityPos(this)
//send({type:"entEvent",event:"wolfTarget",id:this.id, data:this.target})
}
}
}
update(){
this.mobUpdate(now)
let pix = 1 / 16
if(!this.target && !this.tame){
this.world.getEntitiesNear(this.x,this.y,this.z,this.dimension, 16, nearEntityArray)
let cd = Infinity, ctarget
for(let i of nearEntityArray){
if(i.dimension === this.dimension && i.type === this.type && i.target){
let d = max(abs(i.x-this.x),abs(i.y-this.y),abs(i.z-this.z))
if(d < 16 && d < cd) cd = d, ctarget = i.target
}
}
if(ctarget) this.target = ctarget
}
}
}
entities[entities.length] = class Blaze extends Mob{
static name2 = "Blaze"
drop = [blockIds.blazeRod]
dropAmount = [0,1]
experience = 10
saySound = ["blaze.breathe1","blaze.breathe2","blaze.breathe3","blaze.breathe4"]
hurtSound = ["blaze.hit1","blaze.hit2","blaze.hit3","blaze.hit4"]
deathSound = "blaze.death"
defaultName = "Blaze"
constructor(x,y,z){
var pix = 1/16
super(x, y, z, 0, 0, 0, 0, 0, 1, pix*22, 1, null,null, null, 300000)
this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
this.health = 20
this.hostile = true
this.minFollowDist = 1
this.maxFollowDist = 48
this.detectionDist = 48
this.attackStrength = 6
this.maxAttackCooldown = 200
this.canFly = true
}
killMessage(username){return username+" got killed by blaze."}
additionalAI(){
if(this.targetEnt){
if(this.attackCooldown <= 0){
this.attackCooldown = this.maxAttackCooldown
//this.world.sendAll({type:"entEvent",event:"mobAttack",id:this.id})
this.world.sendEntityPos(this)
}
if(this.attackCooldown === 20 || this.attackCooldown === 11 || this.attackCooldown === 2){
let vx = this.targetEnt.x - this.x, vy = this.targetEnt.y - this.y, vz = this.targetEnt.z - this.z
let mag = sqrt(vx*vx+vy*vy+vz*vz)
vx /= mag, vy /= mag, vz /= mag
this.world.addEntity(new entities[entityIds.SmallFireball](this.x+vx,this.y+vy,this.z+vz,vx,vy,vz,this.id),false,this.dimension)
}
}
}
update(){
this.mobUpdate(now)
if(this.burnTimer) this.burnTimer = 0
if(this.targetEnt && this.attackCooldown > 0 && this.attackCooldown < 100) this.burning = true
}
}
entities[entities.length] = class Enderman extends Mob{
static name2 = "Enderman"
defaultName = "Enderman"
constructor(x,y,z){
super(x, y, z, 0, 0, 0, 0, 0, 0.75, 3, 0.75, null,null, null, 300000)
let pix = 1/16
this.offsetY = pix*13
this.addPart("rightLeg",null,null,pix*-2,pix*-6,0,1,1,1,0,0)
this.addPart("leftLeg",null,null,pix*2,pix*-6,0,1,1,1,0,0)
this.addPart("rightArm",null,null,pix*-4,pix*6,pix*0,1,1,1,0,0)
this.addPart("leftArm",null,null,pix*4,pix*6,pix*0,1,1,1,0,0)
this.addPart("head",null,null,0,pix*10,0,1,1,1,0,0)
this.health = 40
this.hostile = true
this.minFollowDist = 1
this.maxFollowDist = 16
this.detectionDist = 16
this.attackStrength = 7
this.maxAttackCooldown = 20
}
killMessage(username){return username+" died from Enderman."}
update(){
this.mobUpdate(now)
if(this.wet){
if(now - this.lastBlockDamage > 1000){
this.lastBlockDamage = now
this.damage(1)
}
}
}
}
let entityOrder = ['Item','BlockEntity', 'PrimedTNT', 'PrimedSuperTNT', 'PrimedUltraTNT', 'PrimedUnTNT', 'MovingBlock', 'EnderPearl', 'Snowball', 'Egg', 'SlingshotShot', 'Arrow', 'Sign', 'ItemFrame', 'ExperienceOrb', 'Cow', 'Pig', 'Creeper', 'Sheep', 'Chicken', 'Zombie', 'Skeleton', 'Spider', 'EnderDragon', 'BlockParticle', 'PoofParticle', 'FallingDustParticle', 'RedstoneParticle', 'ShockwaveParticle', 'SmokeParticle', 'NoteParticle', 'GlintParticle', 'FlameParticle', 'LavaParticle', 'DripParticle', 'SplashParticle', 'Spark', 'TextDisplay','Wolf','HeartParticle',"Blaze","SmallFireball","BlockDisplay","BeaconBeam","Enderman","Minecart"]
let unorderedEntities = entities.slice()
for(let i=0; i<entities.length; i++){
entityIds[entities[i].name2] = i
}
for(let i=0; i<entityOrder.length; i++){
if(entityIds[entityOrder[i]] === undefined){
delete entities[i]
delete entityIds[entityOrder[i]]
continue
}
entities[i] = unorderedEntities[entityIds[entityOrder[i]]]
entities[i].prototype.entId = i
entities[i].prototype.type = entities[i].name2
entityIds[entities[i].name2] = i
}
win.serverEntities = entities, win.serverEntityIds = entityIds
console.log(entities.length,'entities and particles on server side')
//islandgenerator from https://www.khanacademy.org/computer-programming/minekhan-island-world-type/5771215095939072
class IslandGenerator {
constructor(world) {
this.world = world
this.seedSet = false;
this.seed = 0;
this.reset()
}
reset(){
this.size = 600;
this.diagonalNeighbors = true; //true if the corners are also adjacent
this.grid = [];
this.vertex = [];
this.river = [];
this.precip = [];
this.biome = [];
this.biomeBlend = [];
this.highestPoint = [0,0];
this.updates = [];
this.stage = 0;
this.changes = 0;
this.rivers = 0;
this.h = 0;
this.X = 0;
}
GetVertex(x, y) {
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 0;}
return this.vertex[x+y*this.size];
}
GetHeight(x, y) {
x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 5;}
return Math.round(
(this.GetVertex(Math.floor(x), Math.floor(y))+
this.GetVertex(Math.floor(x+0.5), Math.floor(y))+
this.GetVertex(Math.floor(x), Math.floor(y+0.5))+
this.GetVertex(Math.floor(x+0.5), Math.floor(y+0.5)))*0.5+5);
};
GetWater(x, y) {
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
if (this.GetBiome(x,y) === -15099421 || this.GetBiome(x,y) === -16479791) {return 1}
return Math.sqrt(this.river[x+y*this.size]);
}
GetWaterDepth(x, y) {
x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
var w = 0;
for (let x2 = 0; x2 < 1; x2+=0.5) {
for (let y2 = 0; y2 < 1; y2+=0.5) {
w += this.GetWater(Math.floor(x+x2),Math.floor(y+y2));
}
}
w = w/4.0;
if (w > 0.25) {
return 1;
}   else {
return 0;
}
}
GetBiome(x, y) {
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return -16479791;}
return this.biome[x+y*this.size];
}
GetBiomeType(x, y) {
x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
return this.GetBiome(Math.floor(x),Math.floor(y));
}
GetNeighbors(x, y) {
var n = [];
if (x > 0) {
n.push({x:x-1, y:y});
if (this.diagonalNeighbors) {
if (y > 0) {
n.push({x:x-1, y:y-1});
}
if (y < this.size-1) {
n.push({x:x-1, y:y+1});
}}
}
if (x < this.size-1) {
n.push({x:x+1, y:y});
if (this.diagonalNeighbors) {
if (y > 0) {
n.push({x:x+1, y:y-1});
}
if (y < this.size-1) {
n.push({x:x+1, y:y+1});
}
}
}
if (y > 0) {
n.push({x:x, y:y-1});
}
if (y < this.size-1) {
n.push({x:x, y:y+1});
}
return n;
}
GetDown(x, y) {
var n = this.GetNeighbors(x, y);
var l = this.size;
var ld = [];
for (var i in n) {
if (this.vertex[n[i].x + n[i].y*this.size] <= l) {
if (this.vertex[n[i].x + n[i].y*this.size] === l) {
ld.push(n[i]);
}
l = this.vertex[n[i].x + n[i].y*this.size];
ld = [n[i]];
}
}
if (l <= this.vertex[x + y*this.size]) {
return ld[Math.floor(this.random(ld.length))];
}
return undefined;
}
SetSeed(seed) {
if(this.seed !== seed) this.reset()
this.seed = seed;
this.seedSet = true;
this.randomGenerator = new Marsaglia(hash(seed, 2123155232) * 210000000)
this.random = (max = 1) => this.randomGenerator.nextDouble()*max
}
Generate(start) {
var end = start+16;
var nS = 0.021;
function sq(n) {return n*n}
function color(r, g, b, a) {
a = (a === undefined ? 255 : a);
g = (g === undefined ? r : g);
b = (b === undefined ? g : b);
if (a > 127) {a = -256+a;}
return b+g*256+r*65536+a*16777216;
}
if (this.stage === 0) { //landmass
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
this.grid[x +y*this.size] = 0;
this.vertex[x + y*this.size] = -1;
this.precip[x + y*this.size] = -1;
this.river[x + y*this.size] = 0;
var d = this.size/2-Math.sqrt(sq(x-this.size/2)+sq(y-this.size/2));
var islandMask = Math.sqrt(sq(this.size/2)-sq(d-this.size/2))*2/this.size;
var v = this.world.noiseProfile.noise(x*nS, y*nS, this.seed);
if (v*islandMask > 0.3) {
this.grid[x+y*this.size] = 1;
}
}
this.X++;
}
if (this.X === this.size) {
this.updates.push({type:"ocean", x:0, y:0});
}
}   else if (this.stage === 1) {    //Oceans
while (this.updates.length > 0 && win.performance.now() < end) {
var u = this.updates.shift();
if (this.grid[u.x+u.y*this.size] === 0) {
this.grid[u.x+u.y*this.size] = 2;
var n = this.GetNeighbors(u.x, u.y);
for (var i = 0; i < n.length; i++) {
if (this.grid[n[i].x+n[i].y*this.size] === 0) {
this.updates.push({type:"ocean",x:n[i].x,y:n[i].y});
}
}
}
}
if (this.updates.length === 0) {
this.X = this.size;
}
}   else if (this.stage === 2) {    //altitude
if (this.h === -1) {this.h = 0;}
var doingLake = false;
var I = 0;
while (win.performance.now() < end && this.updates.length > 0 && I < this.updates.length) {
if (this.updates[I].type === "lake") {
var u = this.updates.splice(I, 1)[0];
if (this.grid[u.x + u.y*this.size] === 0 && this.vertex[u.x+u.y*this.size] === -1) {
this.vertex[u.x + u.y*this.size] = u.a;
var n = this.GetNeighbors(u.x, u.y);
for (var i in n) {
if (this.grid[n[i].x+n[i].y*this.size] === 0 && this.vertex[n[i].x + n[i].y*this.size] === -1) {
this.updates.push({type:"lake",x:n[i].x,y:n[i].y,a:u.a});
}
}
}
I--;
}
I++;
}
while (this.X < this.size && win.performance.now() < end && !doingLake) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
if (this.vertex[x+y*this.size] === -1) {
if (this.grid[x+y*this.size] === 2) {
this.vertex[x+y*this.size] = this.h;
this.changes++;
}   else if (this.h > 0) {
var n = this.GetNeighbors(x, y);
var l = this.size;
var ld;
for (var i in n) {
var v = this.vertex[n[i].x + n[i].y*this.size];
if (v < l && v !== -1) {
l = v;
ld = n[i];
}
}
if (l !== this.size && l <= this.h) {
if (this.grid[x+y*this.size] === 0) {
this.updates.push({type:"river",x:ld.x,y:ld.y});
this.updates.push({type:"lake",x:x,y:y,a:l});
}   else {
this.vertex[x+y*this.size] = l+1+(this.random() > 0.5 ? 1 : 0);
}
this.changes++;
}
}
}
}
this.X++;
}
if (this.X === this.size && this.h < this.size/3) {
if (this.changes === 0) {
this.h++;
}
this.X = 0;
this.changes = 0;
}
}   else if (this.stage === 3) {    //altitude readjustment
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
this.vertex[x+y*this.size] = (Math.pow(20, this.vertex[x+y*this.size]/this.size*3)-1)/(20-1)*this.size/3;
if (this.vertex[x+y*this.size] > this.vertex[this.highestPoint[0]+this.highestPoint[1]*this.size]) {
this.highestPoint[0] = x;
this.highestPoint[1] = y;
}
}
this.X++;
}
}   else if (this.stage === 4) {    //rivers
if (this.rivers === 0) {
var x, y;
for (var i = 0; i < 200 && this.rivers < 100; i++) {
x = Math.floor(this.random(this.size));
y = Math.floor(this.random(this.size));
if (this.grid[x+y*this.size] === 1) {
this.updates.push({type:"river",x:x,y:y});
this.rivers++;
}
}
}   else {
if (this.updates.length === 0) {
this.X = this.size;
}
}
while(this.updates.length > 0 && win.performance.now() < end) {
var u = this.updates[0];
if (this.grid[u.x+u.y*this.size] === 1) {
this.river[u.x+u.y*this.size]++;
var d = this.GetDown(u.x, u.y);
if (d === undefined) {
this.updates.shift();
}   else {
this.updates[0].x = d.x; this.updates[0].y = d.y;
}
}   else {
this.updates.shift();
}
}
}   else if (this.stage === 5) {    //precipitation
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
if (this.precip[x + y*this.size] === -1) {
if (this.h === -1) {
if (this.grid[x + y*this.size] === 2) {
this.precip[x + y*this.size] = 5;
this.changes++;
}
}   else {
if (this.h <= 8) {
if (this.grid[x + y*this.size] === 0 || this.river[x+y*this.size] > 0) {
this.precip[x + y*this.size] = 8;
this.changes++;
}
}
var n = this.GetNeighbors(x, y);
var h = -1;
for (var i in n) {
if (this.precip[n[i].x + n[i].y*this.size] > h) {
h = this.precip[n[i].x + n[i].y*this.size];
}
}
if (h > -1 && h >= this.h) {
this.precip[x+y*this.size] = Math.max(h - (this.random() < 0.5 ? 0.66 : 0.33), 0);
this.changes++;
}
}
}
}
this.X++;
}
if (this.X === this.size) {
this.X = 0;
if (this.h === -1) {
this.h = 10;
}   else {
if (this.changes === 0) {
this.h--;
}
this.changes = 0;
if (this.h < 0) {
this.X = this.size;
}
}
}
}   else if (this.stage === 6) {    //readjust precipitation
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
this.precip[x+y*this.size] = Math.floor(this.precip[x+y*this.size]/10*6);
}
this.X++;
}
}   else if (this.stage === 7) {    //temperature
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
}
this.X++;
}
}   else if (this.stage === 8) {    //biomes
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
var c;
var h = Math.floor(this.vertex[x+y*this.size]/this.size*6*5);
switch (this.grid[x+y*this.size]) {
case 0: if (h > 2) {
c = color(157, 194, 201);
}   else {
c = color(25, 153, 227);
}   break;
case 1: if (this.river[x+y*this.size] > 0) {
if (h > 2) {
c = color(157, 194, 201);
}   else {
c = color(25, 153, 227);
}
}   else {
switch (h) {
case 0: switch (this.precip[x+y*this.size]) {
case 5: case 4: c = color(10, 133, 72); break;
case 3: case 2: c = color(10, 133, 23); break;
case 1: c = color(179, 232, 35); break;
case 0: c = color(209, 166, 58); break;
} break;
case 1: switch (this.precip[x+y*this.size]) {
case 5: c = color(14, 156, 85); break;
case 4: case 3: c = color(72, 133, 10); break;
case 2: case 1: c = color(179, 232, 35); break;
case 0: c = color(207, 195, 58); break;
} break;
case 2: switch (this.precip[x+y*this.size]) {
case 5: case 4: c = color(121, 191, 95); break;
case 3: case 2: c = color(155, 161, 135); break;
case 1: case 0: c = color(207, 195, 58); break;
} break;
case 3: case 4: switch (this.precip[x+y*this.size]) {
case 5: case 4: case 3: c = color(255); break;
case 2: c = color(149, 189, 94); break;
case 1: c = color(180); break;
case 0: c = color(128);
} break;
}
}
break;
case 2: c = color(4, 137, 209); break;
}
this.biome[x+y*this.size] = c;
}
this.X++;
}
}   else if (this.stage === 9) {    //add lava
let ph = this.vertex[this.highestPoint[0] + this.highestPoint[1]*this.size]-5;
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
if (this.vertex[x + y*this.size] > ph) {
this.vertex[x + y*this.size] = ph-2;
this.biome[x + y*this.size] = -65536;
}
}
this.X++;
}
}
if (this.X === this.size) {
this.X = 0;
this.h = -1;
this.stage++;
console.log(this.stage)
}
}
}
class Section {
constructor(x, y, z, chunk, blocks = undefined) {
this.x = x
this.y = y
this.z = z
this.blocks = blocks || new Int32Array(4096)
this.blockLight = new Uint8Array(4096)
this.skyLight = new Uint8Array(4096)
this.tags = new Array(4096)
this.chunk = chunk
this.world = chunk && chunk.world
this.type = chunk && chunk.type
this.edited = false
this.caves = this.type !== "" || !this.world.caves
}
getBlock(x, y, z) {
return this.blocks[x * 256 + y * 16 + z]
}
setBlock(x, y, z, blockId) {
this.blocks[x * 256 + y * 16 + z] = blockId
}
deleteBlock(x, y, z) {
this.blocks[x * 256 + y * 16 + z] = 0
}
updateBlock(x, y, z, world, noOnupdate, sx,sy,sz) {
let i = x
let j = y
let k = z
x += this.x
y += this.y
z += this.z
let block = this.blocks[i * 256 + j * 16 + k]
if(!noOnupdate) this.world.updateQueue.push(x,y,z,this.type,sx,sy,sz)
/*else if(!noOnupdate){
if((block & isState) === STAIR || (block & isState) === CORNERSTAIRIN || (block & isState) === CORNERSTAIROUT){
let front, back //front is lower side
let rot = block & ROTATION
switch(rot){
case NORTH:
front = this.world.getBlock(x,y,z-1,this.type)
back = this.world.getBlock(x,y,z+1,this.type)
break
case SOUTH:
front = this.world.getBlock(x,y,z+1,this.type)
back = this.world.getBlock(x,y,z-1,this.type)
break
case EAST:
front = this.world.getBlock(x-1,y,z,this.type)
back = this.world.getBlock(x+1,y,z,this.type)
break
case WEST:
front = this.world.getBlock(x+1,y,z,this.type)
back = this.world.getBlock(x-1,y,z,this.type)
break
}
front = front
back = back
let frontType = (front & isState) === STAIR && 1 || (front & isState) === CORNERSTAIRIN && 2 || (front & isState) === CORNERSTAIROUT && 3 || 0
let backType = (back & isState) === STAIR && 1 || (back & isState) === CORNERSTAIRIN && 2 || (back & isState) === CORNERSTAIROUT && 3 || 0
let target = blockData[block].id, rotate = 0, type = STAIR
if(frontType === 1){
switch(front & ROTATION){
case NORTH:
if(rot === EAST) type = CORNERSTAIRIN
else if(rot === WEST){ rotate = 1; type = CORNERSTAIRIN }
break
}
}
target |= type
if(rotate){
switch(rot){
case NORTH:
target |= EAST
break
case EAST:
target |= SOUTH
break
case SOUTH:
target |= WEST
break
case WEST:
target |= NORTH
break
}
}else target |= rot
if(block !== target) this.world.setBlock(x,y,z,target,false,false,false,false,this.type)
}
}*/
}
carveCaves() {
let {world} = this
let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16
for (let x = this.x, xx = 0; x < wx; x++, xx++) {
for (let z = this.z, zz = 0; z < wz; z++, zz++) {
wy = this.chunk.tops[zz * 16 + xx]
for (let y = this.y; y < wy; y++) {
if (isCave(x, y, z, world)) {
if (y > 3) {
for (let i = 0; i < sphere.length; i += 3) {
if(y+sphere[i + 1]<10) world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.Lava, true,true,false,false, this.type)
else world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.air, true,true,false,false, this.type)
}
}
}
}
}
}
this.caves = true
}
oldSpawnMobs(){
let {world} = this
let fieldMobs = ["Cow","Pig","Sheep","Chicken"]
let snowMobs = ["Wolf"]
let hostileMobs = ["Creeper","Zombie","Skeleton","Spider","Enderman"]
let netherWasteMobs = ["Blaze"]
let endMobs = ["Enderman"]
let x = Math.random() * 16 | 0
let y = Math.random() * 16 | 0
let z = Math.random() * 16 | 0
let minChunkX = this.x + x - 32 >> 4
let maxChunkX = this.x + x + 32 >> 4
let minChunkZ = this.z + z - 32 >> 4
let maxChunkZ = this.z + z + 32 >> 4
let chunks = this.type === "nether" ? this.world.netherChunks : (this.type === "end" ? this.world.endChunks : this.world.chunks)
let block = this.getBlock(x,y,z), light = max(this.getLight(x,y,z,0)*this.world.skyLight,this.getLight(x,y,z,1))
let under = this.chunk.getBlock(x,y+this.y-1,z,0,true)
if(this.type === "" && !block && light > 10 && under === blockIds.grass){
for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
if(chunks[x2] && chunks[x2][z2]) for(let i in chunks[x2][z2].entities){
let ent = chunks[x2][z2].entities[i]
if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
}
}
let amount = rand(1,6)
let mob = fieldMobs[floor(rand(fieldMobs.length))]
for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),this.type,world)
}else if(this.type === "" && !block && light > 10 && this.world.getBiome(this.x+x,this.y+y,this.z+z,this.type) === "snowyPlains" && (under === blockIds.grass || blockData[under].name === "snow")){
for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
if(chunks[x2] && chunks[x2][z2]) for(let i in chunks[x2][z2].entities){
let ent = chunks[x2][z2].entities[i]
if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
}
}
let amount = rand(1,6)
let mob = snowMobs[floor(rand(snowMobs.length))]
for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),this.type,world)
}else if(this.type === "" && !block && light <= 11 && under && 
!this.getBlock(x,y+1,z) && !this.getBlock(x+1,y,z) && !this.getBlock(x,y,z+1)
&& !this.getBlock(x+1,y+1,z) && !this.getBlock(x,y+1,z+1)){
let within = false
for(let p of this.world.players){
let dist = max(abs(this.x+x-p.x),abs(this.y+y-p.y),abs(this.z+z-p.z))
if(dist < 16 || p.dimension !== this.type) return
within = within || dist<32
}
if(!within) return
for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
if(chunks[x2] && chunks[x2][z2]) for(let i in chunks[x2][z2].entities){
let ent = chunks[x2][z2].entities[i]
if(ent.mob && ent.hostile && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
}
}
let mob = hostileMobs[floor(rand(hostileMobs.length))]
blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),this.type,world)
}else if(this.type === "nether" && !block && this.world.getBiome(this.x+x,this.y+y,this.z+z,this.type) === "netherWastes" && under === blockIds.netherrack){
for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
if(chunks[x2] && chunks[x2][z2]) for(let i in chunks[x2][z2].entities){
let ent = chunks[x2][z2].entities[i]
if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
}
}
let amount = rand(1,6)
let mob = netherWasteMobs[floor(rand(netherWasteMobs.length))]
for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),this.type,world)
}else if(this.type === "end" && !block && blockData[under].solid){
for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
if(chunks[x2] && chunks[x2][z2]) for(let i in chunks[x2][z2].entities){
let ent = chunks[x2][z2].entities[i]
if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
}
}
let amount = rand(1,6)
let mob = endMobs[floor(rand(endMobs.length))]
for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),this.type,world)
}
}
spawnMobs(){
if(!this.chunk.lit) return
if(this.world.usePreBeta) return this.oldSpawnMobs()
let {world} = this
let x = Math.random() * 16 | 0
let y = Math.random() * 16 | 0
let z = Math.random() * 16 | 0
let block = this.getBlock(x,y,z)
if(block ||
this.getBlock(x,y+1,z) || this.getBlock(x+1,y,z) || this.getBlock(x,y,z+1)
|| this.getBlock(x+1,y+1,z) || this.getBlock(x,y+1,z+1)) return//no space
let minChunkX = this.x + x - 32 >> 4
let maxChunkX = this.x + x + 32 >> 4
let minChunkZ = this.z + z - 32 >> 4
let maxChunkZ = this.z + z + 32 >> 4
let chunks = this.type === "nether" ? this.world.netherChunks : (this.type === "end" ? this.world.endChunks : this.world.chunks)
let light = max(this.getLight(x,y,z,0)*this.world.skyLight,this.getLight(x,y,z,1))
let under = this.chunk.getBlock(x,y+this.y-1,z,0,true)
let biome = world.getBiome(x+this.x,y+this.y,z+this.z)
let passiveMobs = biomeData[biome][2]
let hostileMobs = biomeData[biome][3]
if(passiveMobs && light > 10 && under){
for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
if(chunks[x2] && chunks[x2][z2]) for(let i in chunks[x2][z2].entities){
let ent = chunks[x2][z2].entities[i]
if(ent.mob && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
}
}
let mob = passiveMobs[floor(rand(passiveMobs.length))]
let amount = rand(mob[1],mob[2])
if(blockIds["spawn"+mob[0]]){
for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob[0]]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),this.type,world)
}
}
if(!light && under){
let within = false
for(let p of this.world.players){
let dist = max(abs(this.x+x-p.x),abs(this.y+y-p.y),abs(this.z+z-p.z))
if(dist < 16 || p.dimension !== this.type) return
within = within || dist<32
}
if(!within) return
for(let x2=minChunkX; x2<=maxChunkX; x2++) for(let z2=minChunkZ; z2<=maxChunkZ; z2++){
if(chunks[x2] && chunks[x2][z2]) for(let i in chunks[x2][z2].entities){
let ent = chunks[x2][z2].entities[i]
if(ent.mob && ent.hostile && max(abs(this.x+x-ent.x),abs(this.y+y-ent.y),abs(this.z+z-ent.z)) < 32) return
}
}
let idx = floor(rand((hostileMobs ? hostileMobs.length : 0)+defaultHostileMobs.length))
let mob = hostileMobs && idx<hostileMobs.length ? hostileMobs[idx] : defaultHostileMobs[idx-(hostileMobs ? hostileMobs.length : 0)]
let amount = rand(mob[1],mob[2])
if(blockIds["spawn"+mob[0]]){
for(let i=0; i<amount; i++) blockData[blockIds["spawn"+mob[0]]].spawnMob(x+this.x+rand(),y+this.y,z+this.z+rand(),this.type,world)
}
}
}
tick() {
var world = this.world
for (let i = 0; i < 40; i++) {
let rnd = Math.random() * this.blocks.length | 0
let blockID = this.blocks[rnd], block = blockData[blockID]
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
if(i<18){
if ((blockID & isCube) === blockIds.grass || (blockID & isCube) === blockIds.mycelium) {
// Spread grass
if (!blockData[world.getBlock(x, y + 1, z, this.type)].transparent) {
world.setBlock(x, y, z, blockIds.dirt, false,false,false,false, this.type)
return
}
let rnd2 = Math.random() * 27 | 0
let x2 = rnd2 % 3 - 1
rnd2 = (rnd2 - x2 - 1) / 3
let y2 = rnd2 % 3 - 1
rnd2 = (rnd2 - y2 - 1) / 3
z += rnd2 - 1
x += x2
y += y2
let spreadTo = this.world.getBlock(x, y, z, this.type)
if ((spreadTo & isCube) === blockIds.dirt && this.world.getBlock(x, y + 1, z, this.type) === blockIds.air) {
this.world.setBlock(x, y, z, (blockID & isCube) | (spreadTo & (~isCube)), false,false,false,false, this.type)
}
} else if((blockID & isCube) === blockIds.crimsonNylium || (blockID & isCube) === blockIds.warpedNylium){
// Spread nylium
if (!blockData[world.getBlock(x, y + 1, z, this.type)].transparent) {
world.setBlock(x, y, z, blockIds.netherrack, false,false,false,false, this.type)
return
}
let rnd2 = Math.random() * 27 | 0
let x2 = rnd2 % 3 - 1
rnd2 = (rnd2 - x2 - 1) / 3
let y2 = rnd2 % 3 - 1
rnd2 = (rnd2 - y2 - 1) / 3
z += rnd2 - 1
x += x2
y += y2
let spreadTo = this.world.getBlock(x, y, z, this.type)
if ((spreadTo & isCube) === blockIds.netherrack && this.world.getBlock(x, y + 1, z, this.type) === blockIds.air) {
this.world.setBlock(x, y, z, (blockID & isCube) | (spreadTo & (~isCube)), false,false,false,false, this.type)
}
} else if (block.grow){
block.grow(x,y,z,this.type,this.world)
}else if(block.name === "vine" || block.name === "weepingVines"){
if(!this.world.getBlock(x,y-1,z)){
this.world.setBlock(x,y-1,z,blockID, false,false,false,false,this.type)
}
}else if(block.name === "twistingVines"){
let i = (rnd >> 8) + this.x
let j = (rnd >> 4 & 15) + this.y
let k = (rnd & 15) + this.z
if(!this.world.getBlock(x,y+1,z)){
this.world.setBlock(x,y+1,z,blockID, false,false,false,false,this.type)
}
}
}
if(i<8){
if(blockID === blockIds.tomatoPlant){
world.setBlock(x, y, z, blockIds.tomatoPlant|SLAB, false,false,false,false, this.type)
}else if(blockID === (blockIds.tomatoPlant|SLAB)){
world.setBlock(x, y, z, blockIds.tomatoPlant|STAIR, false,false,false,false, this.type)
}else if(blockID === (blockIds.tomatoPlant|STAIR)){
world.setBlock(x, y, z, blockIds.tomatoPlant|CROSS, false,false,false,false, this.type)
}else if(blockID === (blockIds.tomatoPlant|CROSS)){
world.setBlock(x, y, z, blockIds.tomatoPlant|TALLCROSS, false,false,false,false, this.type)
}/*wheat*/else if(blockID === (blockIds.wheat)){
world.setBlock(x, y, z, blockIds.wheat|SLAB, false,false,false,false, this.type)
}else if(blockID === (blockIds.wheat|SLAB)){
world.setBlock(x, y, z, blockIds.wheat|STAIR, false,false,false,false, this.type)
}else if(blockID === (blockIds.wheat|STAIR)){
world.setBlock(x, y, z, blockIds.wheat|CROSS, false,false,false,false, this.type)
}else if(blockID === (blockIds.wheat|CROSS)){
world.setBlock(x, y, z, blockIds.wheat|TALLCROSS, false,false,false,false, this.type)
}else if(blockID === (blockIds.wheat|TALLCROSS)){
world.setBlock(x, y, z, blockIds.wheat|DOOR, false,false,false,false, this.type)
}else if(blockID === (blockIds.wheat|DOOR)){
world.setBlock(x, y, z, blockIds.wheat|TORCH, false,false,false,false, this.type)
}else if(blockID === (blockIds.wheat|TORCH)){
world.setBlock(x, y, z, blockIds.wheat|LANTERN, false,false,false,false, this.type)
}/*cactus fruit*/else if(blockID === (blockIds.newCactusFruit|CROSS)){
world.setBlock(x, y, z, blockIds.greenCactusFruit|CROSS, false,false,false,false, this.type)
}else if(blockID === (blockIds.greenCactusFruit|CROSS)){
world.setBlock(x, y, z, blockIds.redCactusFruit|CROSS, false,false,false,false, this.type)
}else if(blockID === (blockIds.redCactusFruit|CROSS)){
world.setBlock(x, y, z, blockIds.purpleCactusFruit|CROSS, false,false,false,false, this.type)
}/*cactus*/else if(blockID === (blockIds.cactus|CACTUS)){
var tall = 0
var maxTall = 3
for(var t=0; t<maxTall; t++){
if(world.getBlock(x,y-t,z,this.type) === (blockIds.cactus|CACTUS)) tall++
else break
}
if(tall >= maxTall) return
var above = world.getBlock(x,y+1,z,this.type)
if(blockData[above].cactusFruit){
if(world.getBlock(x,y+2,z,this.type)) return //the cactus fruit can't replace blocks
world.setBlock(x,y+2,z, above, false,false,false,false, this.type) //move the cactus fruit up
}else if(above) return //there is a block so it can't grow
world.setBlock(x,y+1,z, blockIds.cactus|CACTUS, false,false,false,false, this.type)
}else if(blockID === blockIds.sweetBerryBush){
world.setBlock(x, y, z, blockIds.sweetBerryBush|SLAB, false,false,false,false, this.type)
}else if(blockID === (blockIds.sweetBerryBush | SLAB)){
world.setBlock(x, y, z, blockIds.sweetBerryBush|STAIR, false,false,false,false, this.type)
}else if(blockID === (blockIds.sweetBerryBush | STAIR)){
world.setBlock(x, y, z, blockIds.sweetBerryBush|CROSS, false,false,false,false, this.type)
}else if(blockID === (blockIds.cocoa | (blockID & ROTATION))){
world.setBlock(x, y, z, blockIds.cocoa|SLAB|(blockID&ROTATION), false,false,false,false, this.type)
}else if(blockID === (blockIds.cocoa | SLAB | (blockID & ROTATION))){
world.setBlock(x, y, z, blockIds.cocoa|STAIR|(blockID&ROTATION), false,false,false,false, this.type)
}else if(blockID === blockIds.beetroots){//beetroot
world.setBlock(x, y, z, (blockIds.beetroots|SLAB), false,false,false,false, this.type)
}else if(blockID === (blockIds.beetroots | SLAB)){
world.setBlock(x, y, z, (blockIds.beetroots|STAIR), false,false,false,false, this.type)
}else if(blockID === (blockIds.beetroots | STAIR)){
world.setBlock(x, y, z, (blockIds.beetroots|CROSS), false,false,false,false, this.type)
}else if(blockID === blockIds.potatoes){//potato
world.setBlock(x, y, z, (blockIds.potatoes|SLAB), false,false,false,false, this.type)
}else if(blockID === (blockIds.potatoes | SLAB)){
world.setBlock(x, y, z, (blockIds.potatoes|STAIR), false,false,false,false, this.type)
}else if(blockID === (blockIds.potatoes | STAIR)){
world.setBlock(x, y, z, (blockIds.potatoes|CROSS), false,false,false,false, this.type)
}else if(blockID === blockIds.carrots){//carrot
world.setBlock(x, y, z, (blockIds.carrots|SLAB), false,false,false,false, this.type)
}else if(blockID === (blockIds.carrots | SLAB)){
world.setBlock(x, y, z, (blockIds.carrots|STAIR), false,false,false,false, this.type)
}else if(blockID === (blockIds.carrots | STAIR)){
world.setBlock(x, y, z, (blockIds.carrots|CROSS), false,false,false,false, this.type)
}else if(blockID === (blockIds.bambooStalk | STAIR) || blockID === (blockIds.bambooStalk | SLAB) || blockID === blockIds.bambooStalk || blockID === (blockIds.bambooStalk | CROSS) || blockID === (blockIds.bambooStalk | TALLCROSS)){
var tall = 0
var maxTall = 16
let blocks = []
for(let t=0; t<maxTall; t++){
let block = world.getBlock(x,y-t,z,this.type)
if(blockData[block].name === "bambooStalk"){
tall++
blocks.push(block)
}else break
}
if(tall >= maxTall) return
var above = world.getBlock(x,y+1,z,this.type)
if(above) return //there is a block so it can't grow
world.setBlock(x,y+1,z, blockIds.bambooStalk | (tall > 3 ? STAIR : TALLCROSS), false,false,false,false, this.type)
if(tall > 3){
for(let t=0; t<tall; t++){
let block = blocks[t]
if(t === 0 && block !== (blockIds.bambooStalk | SLAB)) world.setBlock(x,y-t,z,blockIds.bambooStalk | SLAB,false,false,false,false,this.type)
else if(block !== blockIds.bambooStalk) world.setBlock(x,y-t,z,blockIds.bambooStalk,false,false,false,false,this.type)
}
}else{
for(let t=0; t<tall; t++){
let block = blocks[t]
if(t === 0 && block !== (blockIds.bambooStalk | CROSS)) world.setBlock(x,y-t,z,blockIds.bambooStalk | CROSS,false,false,false,false,this.type)
}
}
}else if(blockID === (blockIds.bambooShoot | CROSS)){
if(world.getBlock(x,y+1,z,this.type)) return
world.setBlock(x, y, z, blockIds.bambooStalk|CROSS, false,false,false,false, this.type)
world.setBlock(x, y+1, z, blockIds.bambooStalk|TALLCROSS, false,false,false,false, this.type)
}else if(block.name === "sugarCane"){
let b = blockID
var tall = 0
var maxTall = 3
for(var t=0; t<maxTall; t++){
if(world.getBlock(x,y-t,z,this.type) === b) tall++
else break
}
if(tall >= maxTall) return
var above = world.getBlock(x,y+1,z,this.type)
if(above) return //there is a block so it can't grow
world.setBlock(x,y+1,z, b, false,false,false,false, this.type)
}else if(blockID === blockIds.pitcherCrop){
world.setBlock(x, y, z, (blockIds.pitcherCrop|SLAB), false,false,false,false, this.type)
}else if(blockID === (blockIds.pitcherCrop | SLAB)){
world.setBlock(x, y, z, (blockIds.pitcherCrop|STAIR), false,false,false,false, this.type)
}else if(blockID === (blockIds.pitcherCrop | STAIR)){
world.setBlock(x, y, z, (blockIds.pitcherCrop|CROSS), false,false,false,false, this.type)
}else if(blockID === (blockIds.pitcherCrop | CROSS)){
world.setBlock(x, y, z, (blockIds.pitcherCrop|TALLCROSS), false,false,false,false, this.type)
}else if(blockID === (blockIds.torchflower | SLAB)){
world.setBlock(x, y, z, (blockIds.torchflower|STAIR), false,false,false,false, this.type)
}else if(blockID === (blockIds.torchflower | STAIR)){
world.setBlock(x, y, z, (blockIds.torchflower|CROSS), false,false,false,false, this.type)
}else if(block.name === "pointedDripstone"){
let renjofdxnjlasfrsjln = world.getBlock(x,y+2,z, this.type), asoieuhisd
if(blockData[renjofdxnjlasfrsjln].liquid){
let y2
for(y2=y-1; y2>y-12; y2--){
asoieuhisd = world.getBlock(x,y2,z)
if(blockData[asoieuhisd].name !== "pointedDripstone") break
}
if(!blockData[asoieuhisd].solid){
world.setBlock(x,y2,z,blockIds.pointedDripstone|FLIP,false,false,false,false,this.type)
let y3
for(y3=y2-1; y3>y2-12; y3--){
asoieuhisd = world.getBlock(x,y3,z)
if(blockData[asoieuhisd].solid) break
}
if(blockData[asoieuhisd].solid){
world.setBlock(x,y3+1,z,blockIds.pointedDripstone,false,false,false,false,this.type)
}
}
}
}else if(block.coralBlock || block.coral || block.coralFan){
let state = blockID&isState
if(state === CUBE || state === SLAB || state === STAIR || state === VERTICALSLAB){
let wall = state === STAIR || state === VERTICALSLAB
let wet = (
blockData[world.getBlock(x,y+1,z,this.type)].wet ||
blockData[world.getBlock(x,y-1,z,this.type)].wet ||
blockData[world.getBlock(x+1,y,z,this.type)].wet ||
blockData[world.getBlock(x-1,y,z,this.type)].wet ||
blockData[world.getBlock(x,y,z+1,this.type)].wet ||
blockData[world.getBlock(x,y,z-1,this.type)].wet
)
let newState = wall?(wet?STAIR:VERTICALSLAB):(wet?CUBE:SLAB)
if(newState !== state){
world.setBlock(x, y, z, (blockID&(~isState))|newState, false,false,false,false, this.type)
}
}
}else if(blockID === blockIds.cornPlant){
world.setBlock(x, y, z, (blockIds.cornPlant|SLAB), false,false,false,false, this.type)
}else if(blockID === (blockIds.cornPlant|SLAB)){
world.setBlock(x, y, z, (blockIds.cornPlant|STAIR), false,false,false,false, this.type)
}else if(blockID === (blockIds.cornPlant|STAIR)){
world.setBlock(x, y, z, (blockIds.cornPlant|CROSS), false,false,false,false, this.type)
}else if(blockID === (blockIds.cornPlant|CROSS)){
world.setBlock(x, y, z, (blockIds.cornPlant|TALLCROSS), false,false,false,false, this.type)
}else if(blockID === (blockIds.cornPlant|TALLCROSS)){
world.setBlock(x, y, z, (blockIds.cornPlant|DOOR), false,false,false,false, this.type)
}
}
if(i<40){
if(block.name === "fire" || block.name === "Lava"){
if(this.world.settings.fireSpreads) block.tick(x,y,z,this.type,this.world)
}else if(block.tick){
block.tick(block,x,y,z,this.type,this.world)
}
if(block.beacon){
block.update(x,y,z,this.type,this.world)
}
}
}
}
//block: 1:block light, 2:spreaded sky light, 3:exposed sky light
getLight(x, y, z, block = 0) {
let i = x * 256 + y * 16 + z
return block === 1 ? this.blockLight[i] : (block === 2 ? this.skyLight[i]>>4 : this.skyLight[i]&15)
}
setLight(x, y, z, level, block = 0) {
let i = x * 256 + y * 16 + z
let arr = block === 1 ? this.blockLight : this.skyLight
if(block === 2) arr[i] = (arr[i]&15) | level << 4
else arr[i] = (arr[i]&240) | level
}
getTags(x, y, z){
return this.tags[x * 256 + y * 16 + z]
}
getTagByName(x, y, z, n){
var t = this.getTags(x,y,z)
let tagBits = blockData[this.getBlock(x,y,z)].tagBits
if(tagBits){
if(!tagBits[n]) return 0
return (t >>> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
//((1 << tagBits[n][1])-1) does this: 2 -> 11,  3 -> 111
}else return t && t[n]
}
setTags(x,y,z, data){
this.tags[x * 256 + y * 16 + z] = data
}
setTagByName(x, y, z, n, data){
var i = x * 256 + y * 16 + z
var t = this.tags[i]
let tagBits = blockData[this.getBlock(x,y,z)].tagBits
if(!t){
if(tagBits) t = this.tags[i] = 0
else t = this.tags[i] = {}
}
if(tagBits){
if(!tagBits[n]) throw new Error("Cannot set "+n+" on binary tags.")
let countMask = (1 << tagBits[n][1])-1
if(data > countMask) throw new Error("Tag too large")
let mask = countMask << tagBits[n][0]
t = (t & (~mask)) | (data << tagBits[n][0])
//what this complicated thing does is: set certain bits
if(t) this.tags[i] = t
else delete this.tags[i]
}else t[n] = data
return t
}
}
let emptySection = new Section(0, 0, 0)
let fullSection = new Section(0, 0, 0)
fullSection.blocks.fill(blockIds.bedrock)
emptySection.skyLight.fill(255)
function getTagBits(t,n,block){
let tagBits = blockData[block].tagBits
return (t >>> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
}
function getTag(t,n,block){
let tagBits = block.tagBits
if(tagBits){
return (t >> tagBits[n][0]) & ((1 << tagBits[n][1])-1)
}else return t && t[n]
}
class Chunk {
constructor(x, z, type, world) {
this.x = x
this.z = z
this.maxY = 0
this.minY = 255
this.sections = []
this.cleanSections = []
this.tops = new Int16Array(16 * 16) // Store the heighest block at every (x,z) coordinate
this.ceils = new Uint8Array(16 * 16) //for nether
this.solidTops = new Int16Array(16 * 16)
this.biomes = new Uint8Array(16 * 16) // biome id at every (x,z) coordinate
this.caveY = new Int16Array(16 * 16 * 2) //Bottom and top of the highest cave
this.caveBiomes = new Uint8Array(16 * 16)
this.caves = this.type !== "" || !caves
this.generated = false; // Terrain
this.generating = false //is it currently generating?
this.populated = world.superflat === true || world.superflat === "void" // Trees and ores
this.lit = false
this.lazy = false
this.edited = false
this.loaded = false
this.type = type || ""
this.world = world
this.caves = this.type !== "" || !this.world.caves
this.entities = {}
this.columnHashs = new Uint8Array(16 * 16)//used to detect when column changes
}
getBlock(x, y, z) {
y -= minHeight
let s = y >> 4
return s < this.sections.length && s >= 0 ? this.sections[s].getBlock(x, y & 15, z) : 0
}
setBlock(x, y, z, blockID, user) {
let py = y
y -= minHeight
if(y<0) return
if(this.allGenerated && !user){//used for generating trees after populations
user = this.world
this.world.sendAllInChunk({type:"setBlock", data:{x:x+this.x, y:py, z:z+this.z, block:blockID, dimension:this.type}},this.x>>4,this.z>>4,this.type)
}
if (!this.sections[y >> 4]) {
do {
let section = new Section(this.x, this.sections.length * 16 + minHeight, this.z, this)
if(this.lit) section.skyLight.fill(15)
this.sections.push(section)
} while (!this.sections[y >> 4])
}
if (user && !this.sections[y >> 4].edited) {
this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
this.sections[y >> 4].edited = true
this.edited = true
}
this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
this.updateSolidTop(x,py,z,blockID)
this.columnHashs[z*16+x]++
}
updateSolidTop(x,y,z,blockID){
if(blockID && (blockData[blockID].solid || blockData[blockID].liquid)){
this.solidTops[z*16+x] = max(this.solidTops[z*16+x],y)
}else if(y >= this.solidTops[z*16+x]){
let top = this.solidTops[z*16+x]
while(true) {
let block = this.getBlock(x,top,z)
if(blockData[block].solid || blockData[block].liquid || top<minHeight) break
top--
}
this.solidTops[z*16+x] = top
}
}
deleteBlock(x, y, z, user) {
let py = y
y -= minHeight
if (!this.sections[y >> 4]) {
return
}
if (user && !this.sections[y >> 4].edited) {
this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
this.sections[y >> 4].edited = true
this.edited = true
}
this.sections[y >> 4].deleteBlock(x, y & 15, z)
this.minY = py < this.minY ? py : this.minY
this.maxY = py > this.maxY ? py : this.maxY
this.updateSolidTop(x,py,z,0)
this.columnHashs[z*16+x]++
}
getOriginalBlock(x,y,z){
y -= minHeight
let s = y >> 4
if(!this.cleanSections[s]) return 0
y = y & 15
let c = this.sections[s]
return this.cleanSections[s][x * c.size * c.size + y * c.size + z]
}
getTags(x, y, z){
y -= minHeight
let s = y >> 4
return s < this.sections.length && s >= 0 ? this.sections[s].getTags(x, y & 15, z) : undefined
}
getTagByName(x,y,z,n){
y -= minHeight
let s = y >> 4
return s < this.sections.length && s >= 0 ? this.sections[s].getTagByName(x, y & 15, z,n) : undefined
}
setTags(x,y,z,data){
y -= minHeight
let s = y >> 4
if(s < this.sections.length && s >= 0) this.sections[s].setTags(x, y & 15, z, data)
}
setTagByName(x,y,z,n,data){
y -= minHeight
let s = y >> 4
if(s < this.sections.length && s >= 0) return this.sections[s].setTagByName(x, y & 15, z,n,data)
}
fillLight() {
let max = this.sections.length * 16 - 1 + minHeight
let blockSpread = []
// Set virtical columns of light to level 15
for (let x = 0; x < 16; x++) {
for (let z = 0; z < 16; z++) {
let light = 15, stop = false
for (let y = max; y >= minHeight; y--) {
let data = blockData[this.getBlock(x, y, z)]
if (data.lightLevel) {
if (!blockSpread[data.lightLevel]) blockSpread[data.lightLevel] = []
blockSpread[data.lightLevel].push(x + this.x, y, z + this.z)
this.setLight(x, y, z, data.lightLevel, 1)
}
if (!stop && !data.transparent) {
this.tops[z * 16 + x] = y
light = 0
stop = true
} else if (light) {
if(data.decreaseLight) light = Math.max(light-data.decreaseLight,0)
this.setLight(x, y, z, light, 2)
this.setLight(x, y, z, light, 0)
}
}
}
}
// Spread the light to places where the virtical columns stopped earlier, plus chunk borders
let spread = []
for (let x = 0; x < 16; x++) {
for (let z = 0; z < 16; z++) {
for (let y = this.tops[z * 16 + x] + 1; y <= max; y++) {
let light = this.getLight(x, y+1, z, 2)
if(!spread[light]) spread[light] = []
if (this.getLight(x+1,y,z,2) < light) {
spread[light].push(x + this.x, y, z + this.z)
continue
}
if (this.getLight(x-1,y,z,2) < light) {
spread[light].push(x + this.x, y, z + this.z)
continue
}
if (this.getLight(x,y,z+1,2) < light) {
spread[light].push(x + this.x, y, z + this.z)
continue
}
if (this.getLight(x,y,z-z,2) < light) {
spread[light].push(x + this.x, y, z + this.z)
continue
}
break
}
}
}
/*for(let i=0; i<this.toSpread.length; i+=5){
let spreadone = this.toSpread[i+4] ? blockSpread : spread
let level = this.toSpread[i+3]
if(!spreadone[level]) spreadone[level] = []
this.trySpread(this.toSpread[i],this.toSpread[i+1],this.toSpread[i+2],level,spreadone[level],this.toSpread[i+4])
}*/
for(let i = spread.length - 1; i > 0; i--){
if(spread[i]) this.spreadLight(spread[i], i - 1)
}
for (let i = blockSpread.length - 1; i > 0; i--) {
let blocks = blockSpread[i]
if (blocks && blocks.length) {
this.spreadLight(blocks, i - 1, false, 1)
}
}
this.lit = true
}
setLight(x, y, z, level, blockLight) {
y -= minHeight
if(this.sections[y >> 4]) this.sections[y >> 4].setLight(x, y & 15, z, level, blockLight)
}
getLight(x, y, z, blockLight = 0, fullOutside) {
y -= minHeight
if (!this.sections[y >> 4]) return (!blockLight || fullOutside) * 15
return this.sections[y >> 4].getLight(x, y & 15, z, blockLight)
}
trySpread(x, y, z, level, spread, blockLight, update = false) {
if(y < minHeight) return
if (this.world.getLight(x, y, z, blockLight, this.type, 1) < level) {
let chunk = this.world.getChunk(x,z,this.type)
if (blockData[this.world.getBlock(x, y, z, this.type)].transparent) {
this.world.setLight(x, y, z, level, blockLight, this.type)
spread.push(x, y, z)
}
}
}
spreadLight(blocks, level, update = false, blockLight = 0) {
let spread = []
let x = 0, y = 0, z = 0
for (let i = 0; i < blocks.length; i += 3) {
x = blocks[i]
y = blocks[i+1]
z = blocks[i+2]
if(y < minHeight) continue
this.trySpread(x - 1, y, z, level, spread, blockLight, update)
this.trySpread(x + 1, y, z, level, spread, blockLight, update)
this.trySpread(x, y - 1, z, level, spread, blockLight, update)
this.trySpread(x, y + 1, z, level, spread, blockLight, update)
this.trySpread(x, y, z - 1, level, spread, blockLight, update)
this.trySpread(x, y, z + 1, level, spread, blockLight, update)
}
if (level > 1 && spread.length) {
this.spreadLight(spread, level - 1, update, blockLight)
}
}
tryUnSpread(x, y, z, level, spread, respread, blockLight) {
if(y < minHeight) return
let light = this.world.getLight(x, y, z, blockLight, this.type, 1)
let expose = !blockLight && this.world.getLight(x, y, z, 2, this.type)
let trans = blockData[this.world.getBlock(x, y, z, this.type)].transparent
if (light === level) {
if (trans) {
this.world.setLight(x, y, z, 0, blockLight, this.type)
spread.push(x, y, z)
}
} else if (light > level && !expose) {
respread[light].push(x, y, z)
}
if(expose) respread[expose].push(x, y, z)
}
unSpreadLight(blocks, level, respread, blockLight) {
let spread = []
let x = 0, y = 0, z = 0
for (let i = 0; i < blocks.length; i += 3) {
x = blocks[i]
y = blocks[i+1]
z = blocks[i+2]
if(y < minHeight) continue
this.tryUnSpread(x - 1, y, z, level, spread, respread, blockLight)
this.tryUnSpread(x + 1, y, z, level, spread, respread, blockLight)
this.tryUnSpread(x, y - 1, z, level, spread, respread, blockLight)
this.tryUnSpread(x, y + 1, z, level, spread, respread, blockLight)
this.tryUnSpread(x, y, z - 1, level, spread, respread, blockLight)
this.tryUnSpread(x, y, z + 1, level, spread, respread, blockLight)
}
if (level > 1 && spread.length) {
this.unSpreadLight(spread, level - 1, respread, blockLight)
}
}
reSpreadLight(respread, blockLight) {
for (let i = respread.length - 1; i > 1; i--) {
let blocks = respread[i]
let level = i - 1
let spread = respread[level]
for (let j = 0; j < blocks.length; j += 3) {
let x = blocks[j]
let y = blocks[j+1]
let z = blocks[j+2]
this.trySpread(x - 1, y, z, level, spread, blockLight)
this.trySpread(x + 1, y, z, level, spread, blockLight)
this.trySpread(x, y - 1, z, level, spread, blockLight)
this.trySpread(x, y + 1, z, level, spread, blockLight)
this.trySpread(x, y, z - 1, level, spread, blockLight)
this.trySpread(x, y, z + 1, level, spread, blockLight)
}
}
}
updateBlock(x, y, z, world, lazy, noOnupdate, sx,sy,sz) {
y -= minHeight
if (this.allGenerated) {
this.lazy = lazy
if ((this.sections.length > y >> 4) && this.sections[y >> 4]) {
this.sections[y >> 4].updateBlock(x, y & 15, z, world, noOnupdate, sx,sy,sz)
}
}
}
carveCaves() {
if(this.world.usePreBeta || this.world.superflat){
for (let i = (-minHeight)>>4; i < this.sections.length; i++) {
if (!this.sections[i].caves) {
this.sections[i].carveCaves()
}
}
}/*else if(false){
let {blocks,tops,biomes,caveY} = await doWork({caves:true, densities:this.densities, bottoms:this.densityBottoms, tops:this.tops, trueX:this.x,trueZ:this.z,blocks:this.tempSections,biomes:this.biomes,seed:this.world.worldSeed,riverCloseness:this.riverCloseness},[...Object.values(this.densities).map(r=>r.buffer),this.densityBottoms.buffer,...this.tempSections.map(r=>r.buffer),this.tops.buffer,this.riverCloseness.buffer])
for(let i=0; i<blocks.length; i++){
this.sections[i] = new Section(this.x, i*16+minHeight, this.z, this, blocks[i])
}
this.tops.set(tops)
this.solidTops.set(tops)
this.caveY.set(caveY)
this.caveBiomes = biomes
delete this.densities
delete this.densityBottoms
delete this.tempSections
delete this.riverCloseness
}*/
this.caves = true
}
async generate() {
let x = this.x >> 4
let z = this.z >> 4
let trueX = this.x
let trueZ = this.z
if (this.generated || this.generating) {
return false
}
this.generating = true
const {noiseProfile} = this.world
let smoothness = generator.smooth
let hilliness = generator.height
let biomeSmooth = generator.biomeSmooth
//{ for the nether terrain
const bottom = 0 // Minimum height of the ground
const hillSize = 0.004 // smaller = bigger; 0.005 to 0.01 seems the be a reasonable range
//}
let gen = 0, floatGen = 0
if(this.world.customChunkGenerate && !this.world.customChunkGenerate(this)){
}else if(this.world.usePreBeta || this.type !== "" || this.world.superflat){
for (let i = 0; i < 16; i++) {
for (let k = 0; k < 16; k++) {
let wx = trueX + i, wz = trueZ + k
floatGen = noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness + generator.extra
gen = this.world.superflat === "island" && this.type === "" ? this.world.islandGenerator.GetHeight(x*16+i, z*16+k) : (this.world.superflat ? 4 : Math.round(floatGen))
/*if(this.type === "nether" && superflat){
gen = Math.round(floatGen)
}*/
this.tops[k * 16 + i] = gen
if(this.type === "nether"){
let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
let b = getNetherBiome(biome)
this.biomes[k * 16 + i] = biomeIds[b]
let block = blockIds.netherrack
if(b === "warpedForest"){
block = blockIds.warpedNylium
}else if(b === "crimsonForest"){
block = blockIds.crimsonNylium
}
//const smo = noise((trueX + i) * biomeSize, (trueZ + k) * biomeSize) * flatness + 40
const smo = 40
let top = 0
let solid = false
for (let j = 1; j < netherHeight; j++) {
var noiseRes = noiseProfile.noise((trueX + i)/smo, j/smo, (trueZ + k)/smo) - ((110 + j/4) - bottom) * hillSize
if(j > netherHeight - 10){
noiseRes = lerp((j - (netherHeight - 10)) / 10, noiseRes, 0.1)
}
if (noiseRes > 0) {
this.setBlock(i, j, k, blockIds.netherrack)
if(!solid) this.ceils[k * 16 + i] = j
if(j > 31) solid = true
} else if (solid && j > 31) {
this.setBlock(i, j - 1, k, block)
/*if (chunk.getBlock(i, j - 2, k)) chunk.setBlock(i, j - 2, k, block)
if (chunk.getBlock(i, j - 3, k)) chunk.setBlock(i, j - 3, k, block)
if (chunk.getBlock(i, j - 4, k)) chunk.setBlock(i, j - 4, k, block)*/
solid = false
top = j
} else if(j < 32){
this.setBlock(i, j, k, blockIds.Lava)
if(this.getBlock(i, j - 1, k) === block) this.setBlock(i, j-2, k, blockIds.netherrack)
}
}
this.tops[k * 16 + i] = top-1
this.setBlock(i, 0, k, blockIds.bedrock)
/*block = blockIds.netherrack
for(let j=1; j<gen; j++){
chunk.setBlock(i, netherHeight - j, k, block)
}*/
this.setBlock(i,netherHeight,k, blockIds.bedrock)
}else if(this.type === "end"){
this.tops[k * 16 + i] = 0
for(let j = 0; j<64; j++){
gen = noiseProfile.noise(wx * 0.01, j*0.01, wz * 0.01) - 0.57
if(wx > -64 && wx < 64 && wz > -64 && wz < 64){
//main island
gen = gen + 0.57 - lerp(max(abs(wx),abs(wz))/64, 0,0.57)
}else if(wx > -80 && wx < 80 && wz > -80 && wz < 80){
//blend into void
gen = gen + 0.57 - lerp(max(abs(wx)-64,abs(wz)-64)/16, 0.57,1)
}else if(wx > -200 && wx < 200 && wz > -200 && wz < 200){
//blend void into outer islands
var dist = 200-64
gen = lerp(max(abs(wx)-dist,abs(wz)-dist,0)/64, -0.1,gen)
}
if(j < 32){
gen = lerp(j/32,-0.1,gen)
}
if(j > 48){
gen = lerp((j-48)/16, gen,-0.1)
}
if(gen > 0){
this.tops[k * 16 + i] = j
this.setBlock(i,j,k,blockIds.endStone)
}
}
if(wx < -200 || wx > 200 || wz < -200 || wz > 200){
this.biomes[k * 16 + i] = biomeIds.endIslands
}else{
this.biomes[k * 16 + i] = biomeIds.end
}
}else if (this.world.superflat === "island") {
if (this.world.islandGenerator.GetWaterDepth(x*16+i, z*16+k) > 0) {
this.setBlock(i, gen, k, blockIds.Water);
this.setBlock(i, gen - 1, k, blockIds.Water)
this.setBlock(i, gen - 2, k, blockIds.dirt)
this.setBlock(i, gen - 3, k, blockIds.dirt)
}   else {
let biomeHere = this.world.islandGenerator.GetBiomeType(x*16+i, z*16+k);
if (biomeHere === -3161286) {
this.setBlock(i, gen, k, blockIds.sand)
this.setBlock(i, gen - 1, k, blockIds.sand)
this.setBlock(i, gen - 2, k, blockIds.sand)
this.setBlock(i, gen - 3, k, blockIds.sand)
this.biomes[k * 16 + i] = biomeIds.desert
}   else if (biomeHere === -1) {
this.setBlock(i, gen, k, blockIds.snowBlock)
this.setBlock(i, gen - 1, k, blockIds.snowBlock)
this.setBlock(i, gen - 2, k, blockIds.stone)
this.setBlock(i, gen - 3, k, blockIds.stone)
this.biomes[k * 16 + i] = biomeIds.snowyPlains
}   else if (biomeHere === -4934476 || biomeHere === -8355712 || biomeHere === -6963874) {
this.setBlock(i, gen, k, blockIds.stone)
this.setBlock(i, gen - 1, k, blockIds.stone)
this.setBlock(i, gen - 2, k, blockIds.stone)
this.setBlock(i, gen - 3, k, blockIds.stone)
this.biomes[k * 16 + i] = biomeIds.desert
} else if (biomeHere === -65536) {
this.setBlock(i, gen, k, blockIds.Lava)
this.setBlock(i, gen - 1, k, blockIds.stone)
this.setBlock(i, gen - 2, k, blockIds.stone)
this.setBlock(i, gen - 3, k, blockIds.stone)
this.biomes[k * 16 + i] = biomeIds.desert
} else {
this.setBlock(i, gen, k, blockIds.grass)
this.setBlock(i, gen - 1, k, blockIds.dirt)
this.setBlock(i, gen - 2, k, blockIds.dirt)
this.setBlock(i, gen - 3, k, blockIds.dirt)
this.biomes[k * 16 + i] = biomeIds.plains
}
}
} else if(this.world.superflat === "void"){
this.biomes[k * 16 + i] = biomeIds.void
} else if(this.world.superflat){
this.tops[k * 16 + i] = gen;
this.biomes[k * 16 + i] = biomeIds.plains
this.setBlock(i, gen, k, blockIds.grass);
this.setBlock(i, gen - 1, k, blockIds.dirt);
this.setBlock(i, gen - 2, k, blockIds.dirt);
this.setBlock(i, gen - 3, k, blockIds.dirt);
}else{
let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth);
var b = getBiome(biome)
this.biomes[k * 16 + i] = biomeIds[b]
if(b === "desert"){
this.tops[k * 16 + i] = gen;
this.setBlock(i, gen, k, blockIds.sand);
this.setBlock(i, gen - 1, k, blockIds.sand);
this.setBlock(i, gen - 2, k, blockIds.sandstone);
this.setBlock(i, gen - 3, k, blockIds.sandstone);
if(gen<60) {
gen = 59;
this.setBlock(i, gen+1, k, blockIds.Water);
this.setBlock(i, gen, k, blockIds.Water);
this.setBlock(i, gen - 1, k, blockIds.Water);
this.setBlock(i, gen - 2, k, blockIds.gravel);
this.setBlock(i, gen - 3, k, blockIds.gravel);
}
if(gen>120){
this.setBlock(i, gen, k, blockIds.stone);
}
if(gen>140){
this.setBlock(i, gen, k, blockIds.sand);
}
}
if(b === "plains" || b === "forest"){
this.tops[k * 16 + i] = gen;
this.setBlock(i, gen, k, blockIds.grass);
this.setBlock(i, gen - 1, k, blockIds.dirt);
this.setBlock(i, gen - 2, k, blockIds.dirt);
this.setBlock(i, gen - 3, k, blockIds.dirt);
if(gen<60) {
gen = 59;
this.setBlock(i, gen+1, k, blockIds.Water);
this.setBlock(i, gen, k, blockIds.Water);
this.setBlock(i, gen - 1, k, blockIds.Water);
this.setBlock(i, gen - 2, k, blockIds.gravel);
this.setBlock(i, gen - 3, k, blockIds.gravel);
}
}
if(b === "snowyPlains"){
this.tops[k * 16 + i] = gen;
if(gen >= 60){
var h = ceil(((floatGen + 0.5) % 1) * 8)
switch(h){//really smooth terrain!
case 1:
this.setBlock(i, gen + 1, k, blockIds.snow | LAYER1)
break
case 2:
this.setBlock(i, gen + 1, k, blockIds.snow | LAYER2)
break
case 3:
this.setBlock(i, gen + 1, k, blockIds.snow | LAYER3)
break
case 4:
this.setBlock(i, gen + 1, k, blockIds.snow | LAYER4)
break
case 5:
this.setBlock(i, gen + 1, k, blockIds.snow | LAYER5)
break
case 6:
this.setBlock(i, gen + 1, k, blockIds.snow | LAYER6)
break
case 7:
this.setBlock(i, gen + 1, k, blockIds.snow | LAYER7)
break
case 8:
this.setBlock(i, gen + 1, k, blockIds.snowBlock)
break
}
this.setBlock(i, gen, k, blockIds.grass | CROSS);
this.setBlock(i, gen - 1, k, blockIds.dirt);
this.setBlock(i, gen - 2, k, blockIds.dirt);
this.setBlock(i, gen - 3, k, blockIds.dirt);
}
if(gen<60) {
gen = 59;
this.setBlock(i, gen+1, k, blockIds.ice);
this.setBlock(i, gen, k, blockIds.ice);
this.setBlock(i, gen - 1, k, blockIds.Water);
this.setBlock(i, gen - 2, k, blockIds.gravel);
this.setBlock(i, gen - 3, k, blockIds.gravel);
}
}
if(b === "sparseJungle" || b === "jungle" || b === "bambooJungle"){
this.tops[k * 16 + i] = gen;
if(b === "bambooJungle") this.setBlock(i, gen, k, blockIds.podzol)
else this.setBlock(i, gen, k, blockIds.grass)
this.setBlock(i, gen - 1, k, blockIds.dirt);
this.setBlock(i, gen - 2, k, blockIds.dirt);
this.setBlock(i, gen - 3, k, blockIds.dirt);
if(gen<60) {
this.setBlock(i, 60, k, blockIds.Water);
for(var y=59; y>=gen; y--){
this.setBlock(i, y, k, blockIds.Water);
}
this.setBlock(i, gen, k, blockIds.gravel);
this.setBlock(i, gen - 1, k, blockIds.gravel);
}
}
}
if(this.type === "" && this.world.superflat !== "void"){
for (let j = 1; j < gen - 3; j++) {
this.setBlock(i, j, k, blockIds.stone)
}
this.setBlock(i, 0, k, blockIds.bedrock)
}
}
}}else{
let {blocks,tops,biomes,minY,maxY,waterTops,caveBiomes,caveY} = await doWork({generate:true,trueX,trueZ,seed:this.world.worldSeed,fancyRivers:this.world.fancyRivers,caves:!this.caves})
this.tops.set(tops)
this.solidTops.set(tops)
this.biomes = biomes
this.minY = minY
this.maxY = maxY
this.waterTops = waterTops
for(let i=0; i<blocks.length; i++){
this.sections[i] = new Section(this.x, i*16+minHeight, this.z, this, blocks[i])
}
this.caveY.set(caveY)
this.caveBiomes = caveBiomes
if(!this.caves) this.caves = true//prevent further carving
}
this.generating = false
this.generated = true
}
generateOldBlob(replace, blockID, amount, x,y,z, size = 1){
// Blob code from https://biome-testing.lukep0wers.repl.co
// generate blobs (ore blobs, dirt blobs, etc)
let newX=0, newY=0, newZ=0
for(let cv = 0; cv < amount; cv++) {
var block = this.getBlock(x+newX, y+newY, z+newZ)
var canReplace = false
if(Array.isArray(replace)){
for(var id of replace){
if(block === id){
canReplace = true
break
}
}
}else{
if(block === replace) {
canReplace = true
}
}
if(canReplace) this.setBlock(x+newX, y+newY, z+newZ,blockID);
newX = round(random(-size, size));
newY = round(random(-size, size));
newZ = round(random(-size, size));
}
}
generateBlob(X,Y,Z,replace,oreSegments,oreWeirdness,oreSize,oreSegmentSize, flat = false){
oreSize = round(oreSize)
let {world} = this
//https://www.khanacademy.org/computer-programming/ore-generator/6387555023765504
let balls=[],bx=0,by=0,bz=0;
let dx=random()*2-1,dy=random()*2-1,dz=random()*2-1;
for(let i=0;i<oreSegments;i++){
let d=Math.hypot(dx,dy,dz);
dx /= d;
dy /= d;
dz /= d;
balls.push(bx,by,bz);
bx += dx*oreWeirdness;
if(!flat) by += dy*oreWeirdness;
bz += dz*oreWeirdness;
if(bx>oreSize){
bx = -oreSize;
}
if(bx<-oreSize){
bx = oreSize;
}
if(by>oreSize){
by = -oreSize;
}
if(by<-oreSize){
by = oreSize;
}
if(bz>oreSize){
bz = -oreSize;
}
if(bz<-oreSize){
bz = oreSize;
}
dx=random()*2-1;
dy=random()*2-1;
dz=random()*2-1;
}
for(let x=-oreSize;x<oreSize;x++){
for(let y=-oreSize;y<oreSize;y++){
for(let z=-oreSize;z<oreSize;z++){
let block = replace[world.getBlock(X+x,Y+y,Z+z,this.type)]
if(block === undefined) continue
if(typeof block === "function") block = block(X+x,Y+y,Z+z,this.type)
if(block === undefined) continue
let d=0;
for(let i=0; i<balls.length; i+=3){
d += 1/dist3(balls[i],balls[i+1],balls[i+2],x,y,z);
}
if(d>1/oreSegmentSize){
world.spawnBlock(X+x,Y+y,Z+z,block,this.type, true)
}
}
}
}
}
spawnOres(replace,tries,minY,maxY,type, oreSize, oreSegmentSize = oreSize/10, oreWeirdness = 4, oreSegments = 8){
for(let i=0;i<tries;i++){
let y
if(type === "triangle") y = round((random(minY,maxY)+random(minY,maxY))*0.5)
else y = round(random(minY,maxY))
let x = round(random(15)), z = round(random(15))
if(!replace[this.getBlock(x,y,z)] || replace.biomes && !replace.biomes.includes(biomeIds[this.biomes[z*16+x]])) continue
this.generateBlob(this.x+x,y,this.z+z,replace,oreSegments,oreWeirdness,oreSize,oreSegmentSize)
}
}
allFlowers = [blockIds.lilyOftheValley, blockIds.poppy, blockIds.dandelion, 
blockIds.blueOrchid, blockIds.pinkTulip, blockIds.orangeTulip, blockIds.redTulip, blockIds.whiteTulip,
blockIds.azureBluet, blockIds.cornFlower, blockIds.purpleFlower, blockIds.witherRose,
blockIds.allium, blockIds.oxeyeDaisy,
blockIds.lilac, blockIds.roseBush, blockIds.peony,
blockIds.TallGrass, blockIds.DoubleTallGrass]
trashland = [blockIds.grass,blockIds.blackConcrete,blockIds.blackTerracotta,blockIds.soup3,blockIds.coalBlock,blockIds.ancientDebris,blockIds.obsidian,blockIds.blackstone,blockIds.tuff,blockIds.mud]
spawnSmallTree(i,ground,k,wx,wz,isBirch,dying,thin){
let place
let {type, world} = this
let top = ground + floor(4.5 + random(2.5))
let rand = floor(random(4096))
let tree = isBirch === undefined ? (random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog) : (isBirch ? blockIds.birchLog : blockIds.oakLog)
let leaf = tree === blockIds.oakLog ? blockIds.oakLeaves : blockIds.birchLeaves
if(thin) tree |= WALLPOST
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
if(dying) worldGenArray.add(wx,j,wz,blockIds.mossCarpet)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, blockIds.dirt)
//Bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 2, wz + z, leaf, type)
}
} else {
world.spawnBlock(wx + x, top - 2, wz + z, leaf, type)
}
}
}
}
//2nd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
}
} else {
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
}
}
}
}
//3rd layer leaves
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x || z) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top, wz + z, leaf, type)
}
} else {
world.spawnBlock(wx + x, top, wz + z, leaf, type)
}
}
}
}
//Top leaves
world.spawnBlock(wx + 1, top + 1, wz, leaf, type)
world.spawnBlock(wx, top + 1, wz - 1, leaf, type)
world.spawnBlock(wx, top + 1, wz + 1, leaf, type)
world.spawnBlock(wx - 1, top + 1, wz, leaf, type)
}
spawnSnowSmallTree(i,ground,k,wx,wz){
let place
let {type, world} = this
let top = ground + floor(4.5 + random(2.5))
let rand = floor(random(4096))
let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog
let leaf = tree === blockIds.oakLog ? blockIds.oakLeaves : blockIds.birchLeaves
let snow = blockIds.snow
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, blockIds.dirt)
this.setBlock(i, top + 2, k, snow | LAYER2)
//Top leaves
world.spawnBlock(wx + 1, top + 1, wz, leaf, type)
world.spawnBlock(wx, top + 1, wz - 1, leaf, type)
world.spawnBlock(wx, top + 1, wz + 1, leaf, type)
world.spawnBlock(wx - 1, top + 1, wz, leaf, type)
world.spawnBlock(wx + 1, top + 2, wz, snow | LAYER1, type)
world.spawnBlock(wx, top + 2, wz - 1, snow | LAYER1, type)
world.spawnBlock(wx, top + 2, wz + 1, snow | LAYER1, type)
world.spawnBlock(wx - 1, top + 2, wz, snow | LAYER1, type)
//Bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 2, wz + z, leaf, type)
}
} else {
world.spawnBlock(wx + x, top - 2, wz + z, leaf, type)
}
}
}
}
//3rd layer leaves
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x || z) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top, wz + z, leaf, type)
if(rand & 2) world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER2, type)
else world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER1, type)
}
} else {
world.spawnBlock(wx + x, top, wz + z, leaf, type)
world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER1, type)
}
}
}
}
//2nd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
if(rand & 2) world.spawnBlock(wx + x, top, wz + z, snow | LAYER2, type)
else world.spawnBlock(wx + x, top, wz + z, snow | LAYER1, type)
}
} else {
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
world.spawnBlock(wx + x, top, wz + z, snow | LAYER1, type)
}
}
}
}
//get rid of snow underneath
/*for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if(x || z){
var g = world.getTop(wx,wz)
if(g) world.setBlock(wx+i, g+1, wz+k, 0)
}
}
}*/
//
}
spawnCactus(i,ground,k){
let rnd = random()
let top = ground + Math.floor(2.5 + rnd*1.5);
let rand = Math.floor(random(4096));
let tree = blockIds.cactus | CACTUS;
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree);
}
//Fruit
switch(round(rnd*4)){
case 0:
this.setBlock(i, top+1, k, blockIds.newCactusFruit|CROSS);
break
case 1:
this.setBlock(i, top+1, k, blockIds.greenCactusFruit|CROSS);
break
case 2:
this.setBlock(i, top+1, k, blockIds.redCactusFruit|CROSS);
break
}
}
spawnCocoaTree(i,ground,k,wx,wz){
let place
let {type, world} = this
let rand = floor(random(4096))
let tall = floor(5 + random(5)) //5 to 10
let top = ground + tall
let tree = blockIds.jungleLog
let leaf = blockIds.jungleLeaves
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
worldGenArray.add(wx,j,wz,blockIds.vine)
worldGenArray.add(wx,j,wz,blockIds.cocoa)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, blockIds.dirt)
//Bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 2, wz + z, leaf, type)
worldGenArray.add(wx+x,top-2,wz+z,blockIds.vine)
}
} else {
world.spawnBlock(wx + x, top - 2, wz + z, leaf, type)
worldGenArray.add(wx+x,top-2,wz+z,blockIds.vine)
}
}
}
}
//2nd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
worldGenArray.add(wx+x,top-1,wz+z,blockIds.vine)
}
} else {
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
worldGenArray.add(wx+x,top-1,wz+z,blockIds.vine)
}
}
}
}
//3rd layer leaves
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x || z) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top, wz + z, leaf, type)
worldGenArray.add(wx+x,top,wz+z,blockIds.vine)
}
} else {
world.spawnBlock(wx + x, top, wz + z, leaf, type)
worldGenArray.add(wx+x,top,wz+z,blockIds.vine)
}
}
}
}
//Top leaves
world.spawnBlock(wx + 1, top + 1, wz, leaf, type)
world.spawnBlock(wx, top + 1, wz - 1, leaf, type)
world.spawnBlock(wx, top + 1, wz + 1, leaf, type)
world.spawnBlock(wx - 1, top + 1, wz, leaf, type)
worldGenArray.add(wx+1,top+1,wz,blockIds.vine)
worldGenArray.add(wx,top+1,wz-1,blockIds.vine)
worldGenArray.add(wx,top+1,wz+1,blockIds.vine)
worldGenArray.add(wx-1,top+1,wz,blockIds.vine)
}
spawnJungleTree(i,ground,k,wx,wz){
let {type, world} = this
let tall = floor(10 + random(20)) //10 to 30
let top = ground + tall
let tree = blockIds.jungleLog
let leaf = blockIds.jungleLeaves
//Center
for (let j = ground + 1; j < top; j++) {
this.setBlock(i, j, k, tree)
world.spawnBlock(wx + 1, j, wz, tree, type)
world.spawnBlock(wx, j, wz + 1, tree, type)
world.spawnBlock(wx+1, j, wz+1, tree, type)
}
this.setBlock(i, ground, k, blockIds.dirt)
world.spawnBlock(wx + 1, ground, wz, blockIds.dirt, type, true)
world.spawnBlock(wx, ground, wz + 1, blockIds.dirt, type, true)
world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt, type, true)
//Messy part
//leaves
let w2 = 5 * 5
for(var x2=-5; x2<=5; x2++){
for(var y=2; y<5; y++){
for(var z2=-5; z2<=5; z2++){
let x = x2-0.5, z = z2-0.5
let n = x * x / w2 + y * y / w2 + z * z / w2
if (n < 1) {
world.spawnBlock(wx + x+1, top-4+y, wz + z+1, leaf, type)
worldGenArray.add(wx+x+1,top-4+y,wz+z+1,blockIds.vine)
}
}
}
}
//the diagonal branches
w2 = 3 * 3
for(y=ground+5; y<top; y += Math.floor(random(10))){
let side = floor(random(4))
let mx=0,mz=0
switch(side){
case 0:
mx=1
break
case 1:
mx=-1
break
case 2:
mz=1
break
case 3:
mz=-1
break
}
let x = mx === 1?2:mx, z = mz === 1?2:mz
let rnd = floor(random(4))+2
//branch
for(var by=0; by<rnd; by++){
world.spawnBlock(wx+x, y+by, wz+z, tree, type)
worldGenArray.add(wx+x,y+by,wz+z,blockIds.vine)
x += mx
z += mz
}
x -= mx
z -= mz
by -= 1
//leaves
for(var lx=-3; lx<3; lx++){
for(var ly=1; ly<3; ly++){
for(var lz=-3; lz<3; lz++){
let n = lx * lx / w2 + ly * ly / w2 + lz * lz / w2
if (n < 1) {
world.spawnBlock(wx+x + lx, y+by+ly, wz+z + lz, leaf, type)
worldGenArray.add(wx+x+lx,y+by+ly,wz+z+lz,blockIds.vine)
}
}
}
}
// m = move; l = leaf
}
//vines
for(var vi=0; vi<10; vi++){
var vy = random(ground, top)
var side = floor(random(4))
var vx = wx, vz = wz
switch(side){
case 0:
vz += 2
side = SOUTH
break
case 1:
vz -= 1
side = NORTH
break
case 2:
vx += 2
side = WEST
break
case 3:
vx -= 1
side = EAST
break
}
var vh = max(floor(random(ground,vy)), ground)
for(; vy > vh && !world.getBlock(vx, vy, vz, type); vy --){
world.spawnBlock(vx,vy,vz, blockIds.vine | WALLFLAT | side, type)
}
}
}
spawnJungleBush(i,k,wx,ground,wz){
let {type, world} = this
let place, rand = floor(random(512))//9 bits
let leaf = blockIds.jungleLeaves
this.setBlock(i,ground+1,k,blockIds.jungleLog)
//bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, ground+1, wz + z, leaf, type)
}
} else {
world.spawnBlock(wx + x, ground+1, wz + z, leaf, type)
}
}
}
}
//2nd layer
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, ground+2, wz + z, leaf, type)
}
} else {
world.spawnBlock(wx + x, ground+2, wz + z, leaf, type)
}
}
}
if(rand & 1){
this.setBlock(i,ground+3,k,leaf)
}
}
spawnNetherMushroom(i,ground,k,wx,wz,b){
let place
let {type, world} = this
let tall = round(random(4,12))
if(floor(random(12)) === 1) tall *= 2
let leafRadius = round(tall*0.25+1.5)
let top = ground + tall
let rand = floor(random(4096))
let tree
let leaf
if(b === "warpedForest"){
tree = blockIds.warpedStem
leaf = blockIds.warpedWartBlock
}else if(b === "crimsonForest"){
tree = blockIds.crimsonStem
leaf = blockIds.netherWartBlock
}
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, blockIds.netherrack)
let w2 = leafRadius**2, w3 = (leafRadius - 2)**2
for(let x2=-leafRadius; x2<=leafRadius; x2++){
for(let z2=-leafRadius; z2<=leafRadius; z2++){
for(let y2=0; y2<=leafRadius; y2++){
let n = x2 * x2 / w2 + z2 * z2 / w2 + y2 * y2 / w2
let n2 = x2 * x2 / w3 + y2 * y2 / w3 + z2 * z2 / w3
if(n>0.5) n += this.world.caveNoise((wx+x2)*1.5, (top+y2)*1.5, (wz+z2)*1.5)*0.5
if (n < 1 && n2 > 1) {
let thisy = top-leafRadius+2+y2
world.spawnBlock(wx+x2, thisy, wz+z2, leaf, type)
if(!world.getBlock(wx+x2, thisy-1, wz+z2)){
let randomValue = hash3(wx+x2, thisy, wz+z2)
if(randomValue<0.02) world.spawnBlock(wx+x2, thisy, wz+z2, blockIds.shroomlight, type, true)
if(y2<2){
if(randomValue>0.8){
let h = map(randomValue,0.8,1,1,3)
for(var y=0; y<h; y++){
world.spawnBlock(wx + x2, thisy - y - 1, wz + z2, leaf, type)
}
}else if(randomValue>0.7 && b === "crimsonForest"){
let h = map(randomValue,0.7,0.8,1,5)
for(var y=0; y<h; y++){
world.spawnBlock(wx + x2, thisy - y - 1, wz + z2, blockIds.weepingVinesPlant, type)
}
world.spawnBlock(wx + x2, thisy - h - 1, wz + z2, blockIds.weepingVines, type)
}
}
}
}
}
}
}
/*
//Shroomlight
for(var l=0; l<3; l++) world.spawnBlock(wx + random(-2, 2), top + random(-1,1), wz + random(-2,2), blockIds.shroomlight, type)
//Top leaves
for(var x=-1; x<2; x++){
for(var z=-1; z<2; z++){
place = (x&1) && (z&1) ? rand & 1 : true
rand >>>= 1
if(place){
world.spawnBlock(wx + x, top + 1, wz + z, leaf, type)
}
}
}
//layer 2 leaves
for(var x=-2; x<3; x++){
for(var z=-2; z<3; z++){
place = (x===2 || x===-2) && (z===2 || z==-2) ? rand & 1 : true
rand >>>= 1
if(place){
world.spawnBlock(wx + x, top, wz + z, leaf, type)
}
}
}
rand = floor(random(4096))
//layer 1 leaves
for(var x=-2; x<3; x++){
for(var z=-2; z<3; z++){
place = x===2 || x===-2 || z===2 || z==-2 ? !(rand & 1) : false
rand >>>= 1
if(place){
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
}
}
}
rand = floor(random(40964096))
//drooping leaves
for(var x=-2; x<3; x++){
for(var z=-2; z<3; z++){
place = x===2 || x===-2 || z===2 || z==-2
rand >>>= 1
if(place){
var h = rand & 4 && rand & 8 ? rand & 3 : 0
if(h){
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type) //to make sure removed ones are put back
for(var y=0; y<h; y++){
world.spawnBlock(wx + x, top - 2 - y, wz + z, leaf, type)
}
}
}
}
}
if(b === "crimsonForest"){
rand = floor(random(40964096))
//vines
for(var x=-2; x<3; x++){
for(var z=-2; z<3; z++){
place = x===2 || x===-2 || z===2 || z==-2
rand >>>= 1
if(place){
var h = (rand & 4 && rand & 8) ? (rand & (tall-2)) - 1 : 0
if(h){
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type) //to make sure removed ones are put back
for(var y=0; y<h; y++){
world.spawnBlock(wx + x, top - 2 - y, wz + z, blockIds.weepingVinesPlant, type)
}
world.spawnBlock(wx + x, top - 2 - h, wz + z, blockIds.weepingVines, type)
}
}
}
}
}*/
}
spawnBamboo(i,ground,k,wx,wz,old=false){
let {type, world} = this
if(random() < 0.2){
this.setBlock(i, ground+1, k, blockIds.bambooShoot | CROSS)
}else{
let h = old ? round(12+random()*6) : round(4+random()*10)
let top = ground+h
for(var y=ground+1; y<top+1; y++){
if(y === top){
this.setBlock(i,y,k,blockIds.bambooStalk | STAIR)
}else if(y === top-1){
this.setBlock(i,y,k,blockIds.bambooStalk | SLAB)
}else{
this.setBlock(i,y,k,blockIds.bambooStalk)
}
}
if(old){
for(let b=0; b<6; b++){
let where = random()
let j = where > 0.5 ? round(lerp((where-0.5)*2,top,top+4)) : round(lerp((where*2)**3,top,(top+ground)*0.5))
let rot = hash3(i,b,k)*Math.PId
let dx = sin(rot), dz = cos(rot)
for(let l=0; l<4; l++){
world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l),blockIds.bambooLeaves,type)
}
}
}
}
}
/*spawnLavaRiver(wx,ground,wz){//replaced with lava spring
let {type, world} = this
let it = 0
let x=wx, y=ground, z=wz
let dir=floor(random(0,8))
for(; it<100; it++){
let xp,zp
switch(dir){
case 0:
x+=1
zp=true
break
case 1:
x+=1
z+=1
break
case 2:
z+=1
xp=true
break
case 3:
x-=1
z+=1
break
case 4:
x-=1
zp=true
break
case 5:
x-=1
z-=1
break
case 6:
z-=1
xp=true
break
case 7:
x+=1
z-=1
break
}
if(random() < 0.08){
dir += round(random(-1,1))
}
let prev = world.getBlock(x,y,z, type)
world.spawnBlock(x,y,z,blockIds.Lava,type,true)
if(xp){
world.spawnBlock(x+1,y,z,blockIds.Lava,type,true)
}
if(zp){
world.spawnBlock(x,y,z+1,blockIds.Lava,type,true)
}
if(!prev && y>1){
y--
prev = world.getBlock(x,y,z, type)
world.spawnBlock(x,y,z,blockIds.Lava,type,true)
while(!prev && y>1){
y--
prev = world.getBlock(x,y,z, type)
world.spawnBlock(x,y,z,blockIds.Lava,type,true)
}
}
if(world.getBlock(x,y-1,z, type) === blockIds.Lava) break
}
}*/
tempTreeBranches = []
branchRot1 = new Quaternion()
branchRot2 = new Quaternion()
branchVec1 = new PVector()
branchVec2 = new PVector()
branchVec3 = new PVector()
spawnTreeWBranch(i,ground,k,wx,wz, log,leaf,trunkLength,lengthMul,bendUp,budSpace,branchAngle,defaultBranchRoll,weightPerBlock,budSpaceAdd,maxDepth,leafSize){
//example: spawnTreeWBranch(i,ground,k,x,z, blockIds.dirt,blockIds.leaves,10,0.9,0.25,2,Math.PI/4,0,0.05,0.2,3,3)
let {type, world} = this
let {branchVec1, branchVec2, branchRot1, branchRot2, branchVec3} = this
this.setBlock(i, ground, k, blockIds.dirt)
let branches = this.tempTreeBranches
branches.length = 0
branches.push(wx,ground,wz, 0,1,0, trunkLength,0)
let c,dx,dy,dz, subLength
for(let i=0; i<branches.length; i+=8){
let x = branches[i], y = branches[i+1], z = branches[i+2]
dx = branches[i+3], dy = branches[i+4], dz = branches[i+5]
let length = branches[i+6]
let depth = branches[i+7]
//let rx = branches[i+3], ry = branches[i+4]
//let ryx = sin(ry), ryz = cos(ry)
if(!dx && !dz){//use specified orthogonal axis
branchVec1.set(sin(defaultBranchRoll),0,cos(defaultBranchRoll))
}else{//find orthogonal axis that faces up
branchVec1.set(dx,dy,dz)
branchVec2.set(0,1,0)
branchVec2.crossProductVector(this.branchVec1)
branchVec1.set(dx,dy,dz)
branchVec1.crossProductVector(this.branchVec2)
branchVec1.normalize()
}
branchRot1.fromAxisAngle(branchAngle,branchVec1.x,branchVec1.y,branchVec1.z)
branchRot2.fromAxisAngle(-branchAngle,branchVec1.x,branchVec1.y,branchVec1.z)
branchVec1.set(dx,dy,dz)
branchRot1.rotateVector(branchVec1)
branchVec2.set(dx,dy,dz)
branchRot2.rotateVector(branchVec2)
let b = 0, alt = random()>0.5
for(let l=0; l<length; l++){
//c = cos(rx)
//dx = ryx*c, dy = sin(rx), dz = ryz*c
subLength = length-(l*l/length)
world.spawnBlock(round(x),round(y),round(z),log,type)
b++
if(depth<maxDepth && b>budSpace+budSpaceAdd*subLength){
b -= budSpace
alt = !alt
if(random()>0.2){
branchVec3.set(alt ? branchVec1 : branchVec2)
branchVec3.x += random(-weightPerBlock,weightPerBlock)//add randomness
branchVec3.y += random(-weightPerBlock,weightPerBlock)
branchVec3.z += random(-weightPerBlock,weightPerBlock)
branchVec3.normalize()
branches.push(x,y,z,branchVec3.x,branchVec3.y,branchVec3.z,subLength*(lengthMul+random(1-lengthMul)*0.8),depth+1)
}
}
x += dx, y += dy, z += dz
//rx += (Math.PI2-rx)*bendUp//make branch bend up
dy -= weightPerBlock*subLength
dx *= (1-bendUp), dz *= (1-bendUp), dy += (1-dy)*bendUp
let mag = sqrt(dx*dx+dy*dy+dz*dz)
dx /= mag, dy /= mag, dz /= mag
}
let w2 = leafSize*leafSize
for (let ly = floor(-leafSize); ly < ceil(leafSize); ly++) {
for (let lx = floor(-leafSize); lx <= ceil(leafSize); lx++) {
for (let lz = floor(-leafSize); lz <= ceil(leafSize); lz++) {
let n = lx * lx / w2 + ly * ly / w2 + lz * lz / w2
if(n > 0.2){
n += hash3(lx + x, ly + y, lz + z)*0.8
}
if (n < 1) {
world.spawnBlock(lx + x, ly + y, lz + z, leaf,type)
}
}
}
}
}
branches.length = 0
}
spawnBigOak(i,ground,k,wx,wz,dying){
let {type, world} = this
this.setBlock(i, ground, k, blockIds.dirt)
var heightLimit = Math.floor(random(8)+8)
var trunkHeight
var leafBottom = 6
var branchCount
//var branchSlope = 0.381
let tree = blockIds.oakLog
let leaf = blockIds.oakLeaves
let branches = []
trunkHeight = heightLimit
if(heightLimit > 14) branchCount = 10
else branchCount = 6
//let endy = trunkHeight//heightLimit * 0.3
let maxDist = heightLimit*0.75
let minDist = heightLimit*0.5
let tiltRot = random(Math.PId)
let tilt = random()
let dirx = sin(tiltRot)*tilt
let dirz = cos(tiltRot)*tilt
branches.push([wx+dirx*trunkHeight,ground+trunkHeight,wz+dirz*trunkHeight])
for(var b=0; b<branchCount; b++){
let arr = []
let dist = random(maxDist-minDist)+minDist
let sy = round(lerp(random()**2,leafBottom,trunkHeight))
let angle = random(Math.PI*2)
let angleY = map(sy,leafBottom,trunkHeight,0.4,0.8)*Math.PI2
let sx = sy*dirx, sz = sy*dirz
let otherBranchRand = random()
if(otherBranchRand<0.125 && branches.length>1){//connect to another branch
let otherBranch = branches[round(random(1,branches.length-1))]
dist *= 0.25
let amount = floor(otherBranch.length*otherBranchRand*4/3)*3
sx = otherBranch[amount]-wx
sy = otherBranch[amount+1]-ground
sz = otherBranch[amount+2]-wz
}
let side = cos(angleY)
let ex = wx + sx + dist*0.75*sin(angle)*side
let ez = wz + sz + dist*0.75*cos(angle)*side
let ey = sy+dist*sin(angleY)
line3D(ex,ey+ground,ez,wx+sx,sy+ground,wz+sz,arr)
branches.push(arr)
}
let trunk = []
line3DConncected(wx+round(dirx*trunkHeight),trunkHeight+ground,wz+round(dirz*trunkHeight),wx,ground,wz,trunk)
for(var i=0; i<trunk.length; i+=3){
world.spawnBlock(trunk[i],trunk[i+1],trunk[i+2],tree)
if(dying) worldGenArray.add(trunk[i],trunk[i+1],trunk[i+2],blockIds.mossCarpet)
}
var miny = heightLimit*0.2
for(var b of branches){
var x = b[0]
var y = b[1]
var z = b[2]
if(y >= miny+ground){
for(var bi=0;bi<b.length;bi+=3){
world.spawnBlock(b[bi],b[bi+1],b[bi+2],tree,type)
if(dying) worldGenArray.add(b[bi],b[bi+1],b[bi+2],blockIds.mossCarpet)
}
}
}
for(var b of branches){
var l = b.length
var x = b[l-3]
var y = b[l-2]
var z = b[l-1]
let w = 4, h = 3
let w2 = w*w, h2 = h*h
for (let ly = -h; ly < h; ly++) {
for (let lx = -w; lx <= w; lx++) {
for (let lz = -w; lz <= w; lz++) {
let n = lx * lx / w2 + ly * ly / h2 + lz * lz / w2
if(n > 0.2){
n += this.world.caveNoise((lx + x)*3.3, (ly + y)*3.3, (lz + z)*3.3)*0.8
}
if (n < 1) {
world.spawnBlock(lx + x, ly + y, lz + z, leaf,type)
}
}
}
}
}
}
spawnFallenTree(i,ground,k,wx,wz,tree,minDist,maxDist,hasVines){//oak: 4-7, birch: 5-15
let {type, world} = this
let length = round(random(minDist,maxDist))
let rnd = floor(random(8))
let distance = (rnd&1)+2
let direction = (rnd>>1)&3
let sw = blockData[tree].swId
let dx = 0, dz = 0, rot
switch(direction){
case 0:
dx = 1
rot = EAST
break
case 1:
dz = 1
rot = NORTH
break
case 2:
dx = -1
rot = WEST
break
case 3:
dz = -1
rot = SOUTH
break
}
rnd = floor(random(256))
this.setBlock(i,ground,k,blockIds.dirt)
this.setBlock(i,ground+1,k,tree)
if(hasVines && random()<hasVines){
worldGenArray.add(wx,ground+1,wz,blockIds.vine)
}
ground = world.getTop(wx+distance*dx,wz+distance*dz,type)
for(let l=0; l<length; l++){
let x = wx+(distance+l)*dx, z = wz+(distance+l)*dz
world.spawnBlock(x,ground+1,z,sw|rot,type)
if(rnd&1){
let mushroom = ((rnd>>1)&1) ? blockIds.redMushroom : blockIds.brownMushroom
world.spawnBlock(x,ground+2,z,mushroom,type)
}
rnd >>= 2
}
}
spawnSpruce(i,ground,k,wx,wz){
let {type, world} = this
let top = ground + floor(random(5,9))
let tree = blockIds.spruceLog
let leaf = blockIds.spruceLeaves
let topOffseted = top+round(random())
let bigStart = 3 //Which layer do big ones start
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, blockIds.dirt)
//Top leaves
world.spawnBlock(wx + 1, topOffseted, wz, leaf, type)
world.spawnBlock(wx, topOffseted, wz - 1, leaf, type)
world.spawnBlock(wx, topOffseted, wz + 1, leaf, type)
world.spawnBlock(wx - 1, topOffseted, wz, leaf, type)
for(let j=topOffseted-2, l=0; j>ground+1; j--, l++){
if(l > bigStart && !(l%2)){//big layer
for (let x = -3; x <= 3; x++) {
for (let z = -3; z <= 3; z++) {
if (x || z) {
if (abs(x) !== 3 || abs(z) !== 3) {
world.spawnBlock(wx + x, j, wz + z, leaf, type)
}
}
}
}
}else if((l%2) || l>bigStart){//medium big layer
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) !== 4) {
world.spawnBlock(wx + x, j, wz + z, leaf, type)
}
}
}
}
}else{//small layer
world.spawnBlock(wx + 1, j, wz, leaf, type)
world.spawnBlock(wx, j, wz - 1, leaf, type)
world.spawnBlock(wx, j, wz + 1, leaf, type)
world.spawnBlock(wx - 1, j, wz, leaf, type)
}
}
}
spawnPine(i,ground,k,wx,wz){
let {type, world} = this
let top = ground + floor(random(6,15))
let tree = blockIds.spruceLog
let leaf = blockIds.spruceLeaves
let layers = round(random(2.25,3.75))
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, blockIds.dirt)
for(let l=0; l<layers; l++){
if(layers === 3 && l === 1){//medium big layer
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) !== 4) {
world.spawnBlock(wx + x, top-l, wz + z, leaf, type)
}
}
}
}
}else{
world.spawnBlock(wx+1, top - l, wz, leaf, type)
world.spawnBlock(wx-1, top - l, wz, leaf, type)
world.spawnBlock(wx, top - l, wz+1, leaf, type)
world.spawnBlock(wx, top - l, wz-1, leaf, type)
}
}
}
spawnBigSpruce(i,ground,k,wx,wz){
let {type, world} = this
let top = ground + floor(random(25,35))
let tree = blockIds.spruceLog
let leaf = blockIds.spruceLeaves
this.generateBlob(wx,ground,wz,this.patches.podzol,4,3,6,1.5,true)
for (let j = ground + 1; j < top; j++) {
this.setBlock(i, j, k, tree)
world.spawnBlock(wx + 1, j, wz, tree, type)
world.spawnBlock(wx, j, wz + 1, tree, type)
world.spawnBlock(wx+1, j, wz+1, tree, type)
}
this.setBlock(i, ground, k, blockIds.dirt)
world.spawnBlock(wx + 1, ground, wz, blockIds.dirt, type, true)
world.spawnBlock(wx, ground, wz + 1, blockIds.dirt, type, true)
world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt, type, true)
/*//Top leaves
this.setBlock(i, top, k, leaf)
world.spawnBlock(wx + 1, top, wz, leaf, type)
world.spawnBlock(wx, top, wz + 1, leaf, type)
world.spawnBlock(wx+1, top, wz+1, leaf, type)
//2nd layer leaves
world.spawnBlock(wx-1, top-1, wz, leaf, type)
world.spawnBlock(wx-1, top-1, wz+1, leaf, type)
world.spawnBlock(wx, top-1, wz-1, leaf, type)
world.spawnBlock(wx+1, top-1, wz-1, leaf, type)
world.spawnBlock(wx+2, top-1, wz, leaf, type)
world.spawnBlock(wx+2, top-1, wz+1, leaf, type)
world.spawnBlock(wx, top-1, wz+2, leaf, type)
world.spawnBlock(wx+1, top-1, wz+2, leaf, type)*/
for (let j = top+2, l=0; j > ground+4; j--, l++) {
let size = round(l/4 + 1)
let s2 = size * size
for(let x=-size; x<=size; x++){
for(let z=-size; z<=size; z++){
let n = (x+0.5)**2 / s2 + (z+0.5)**2 / s2
if(j < ground+12){ //Make thinner
n += (ground+12-j)/12
}
/*if(n > 0.2){
n += this.world.caveNoise((wx+x)*3.3, j*3.3, (wz+z)*3.3)*0.8
}*/
let mult = 1/Math.hypot(x,z)*2
n += this.world.caveNoise(wx+x*mult, (j+n)*0.5, wz+z*mult)*0.8
if (n < 1) {
world.spawnBlock(wx + x+1, j, wz + z+1, leaf, type)
}
}
}
}
}
spawnTallSpruce(i,ground,k,wx,wz){
let {type, world} = this
let top = ground + floor(random(24,32))
let bottom = round(lerp(0.8,top,ground))
let tree = blockIds.spruceLog
let leaf = blockIds.spruceLeaves
for (let j = ground + 1; j < top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, ground, k, blockIds.dirt)
for (let j = top+8, l=0; j > bottom; j--, l++) {
let size = l/4 + 2
let s2 = size * size
let noiseAmount = (top+8-j)/(top+8-bottom)
let noiseAmountHigh = 1-(1-noiseAmount)**4
//Make thinner
for(let x=-floor(size); x<=ceil(size); x++){
for(let z=-floor(size); z<=ceil(size); z++){
let n = x**2 / s2 + z**2 / s2
let mult = 1/Math.hypot(x,z)*2
n += this.world.caveNoise(wx+x*mult, (j+n)*0.5, wz+z*mult)*2*noiseAmountHigh
if(noiseAmount>0.8) n = lerp((noiseAmount-0.8)/0.2, n,1.2)
if (n < 1) {
world.spawnBlock(wx + x, j, wz + z, leaf, type)
}
}
}
}
}
spawnBigPine(i,ground,k,wx,wz){
let {type, world} = this
let top = ground + floor(random(15,27))
let tree = blockIds.spruceLog
let leaf = blockIds.spruceLeaves
let bottom = round(lerp(0.65,top,ground))
//let h = round(random(12,20))//round(random(4,12))
this.generateBlob(wx,ground,wz,this.patches.podzol,4,3,6,1.5,true)
for (let j = ground + 1; j < top; j++) {
this.setBlock(i, j, k, tree)
world.spawnBlock(wx + 1, j, wz, tree, type)
world.spawnBlock(wx, j, wz + 1, tree, type)
world.spawnBlock(wx+1, j, wz+1, tree, type)
}
this.setBlock(i, ground, k, blockIds.dirt)
world.spawnBlock(wx + 1, ground, wz, blockIds.dirt, type, true)
world.spawnBlock(wx, ground, wz + 1, blockIds.dirt, type, true)
world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt, type, true)
/*let w = 8
let w2 = w**2, h2 = h**2
for(let x2=-w; x2<w; x2++){
for(let z2=-w; z2<w; z2++){
for(let y2=-h; y2<h; y2++){
let n = x2 * x2 / w2 + z2 * z2 / w2 + y2 * y2 / h2
if(n > 0.6){
n += this.world.caveNoise((wx+x2)*2, (top+y2), (wz+z2)*2)*0.4
}
if (n < 1) {
world.spawnBlock(wx+x2, top+y2, wz+z2, leaf, type)
}
}
}
}*/
for (let j = top+2, l=0; j > bottom; j--, l++) {
let size = l*0.4+1
let s2 = size * size
let noiseAmount = (top+2-j)/(top+2-bottom)
for(let x=-size; x<=size; x++){
for(let z=-size; z<=size; z++){
let n = (x+0.5)**2 / s2 + (z+0.5)**2 / s2
//if(j < (top-h)+4){ //Make thinner
//	n += ((top-h)+4-j)/4
//}
n += this.world.caveNoise((wx+x), j, (wz+z))*2.5*noiseAmount
if(noiseAmount>0.8) n = lerp((noiseAmount-0.8)/0.2, n,1.2)
if (n < 1) {
world.spawnBlock(wx + x+1, j, wz + z+1, leaf, type)
}
}
}
}
}
spawnAcacia(i,ground,k,wx,wz){
let {type, world} = this
let top = ground + floor(random(6,8))
let tree = blockIds.acaciaLog
let leaf = blockIds.acaciaLeaves
for (let j = ground + 1; j < top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, ground, k, blockIds.dirt)
let rnd = floor(random(16384))
let branch1 = rnd&3 //branch length
let branch2 = (rnd>>2)&3
let branch1Top = (rnd>>4)&1//vertical part of branch
let branch2Top = (rnd>>5)&1
let size1 = 3+((rnd>>6)&1)//radius of leaves
let size2 = 3+((rnd>>7)&1)
let dir1 = (rnd>>8)&3//direction of branch
let dir2 = (rnd>>10)&3
let offset1 = (rnd>>12)&1//branch go down
let offset2 = (rnd>>13)&1
//branch 1
let dx = 0, dz = 0, y = top-1-offset1, x = wx, z = wz
switch(dir1){
case 0: dx = 1; break
case 1: dz = 1; break
case 2: dx = -1; break
case 3: dz = -1; break
}
for(let i=0; i<branch1; i++){
x += dx, z += dz, y++
world.spawnBlock(x,y,z,tree,type)
}
if(branch1Top){
y++
world.spawnBlock(x,y,z,tree,type)
}
let s2 = size1 ** 2
for(var x2=-size1; x2<size1; x2++){
for(var y2=size1-2; y2<size1; y2++){
for(var z2=-size1; z2<size1; z2++){
let n = x2 * x2 / s2 + y2 * y2 / s2 + z2 * z2 / s2
if (n < 1) {
world.spawnBlock(x+x2, y-1+y2, z+z2, leaf, type)
}
}
}
}
if(!branch1 && !branch2 || dir1 === dir2) return
//branch 2
dx = 0, dz = 0, y = top-1-offset2, x = wx, z = wz
switch(dir2){
case 0: dx = 1; break
case 1: dz = 1; break
case 2: dx = -1; break
case 3: dz = -1; break
}
for(let i=0; i<branch2; i++){
x += dx, z += dz, y++
world.spawnBlock(x,y,z,tree,type)
}
if(branch2Top){
y++
world.spawnBlock(x,y,z,tree,type)
}
s2 = size2 ** 2
for(var x2=-size2; x2<size2; x2++){
for(var y2=size2-2; y2<size2; y2++){
for(var z2=-size2; z2<size2; z2++){
let n = x2 * x2 / s2 + y2 * y2 / s2 + z2 * z2 / s2
if (n < 1) {
world.spawnBlock(x+x2, y-1+y2, z+z2, leaf, type)
}
}
}
}
}
spawnBigAcacia(i,ground,k,wx,wz){
let {type, world} = this
let top = ground + floor(random(14,20))
let tree = blockIds.acaciaLog
let leaf = blockIds.acaciaLeaves
let sw = blockData[tree].swId
for (let j = ground + 1; j < top; j++) {
this.setBlock(i, j, k, tree)
}
for (let j = top-6; j < top; j++) {//branches
if(j === top-1 || random()>0.5){
let dir = floor(random(16))
let dx = 0, dz = 0, dy = ((dir>>2)+1)/4, y = j, x = wx, z = wz, rot
switch(dir&3){
case 0: dx = 1; rot = EAST; break
case 1: dz = 1; rot = NORTH; break
case 2: dx = -1; rot = WEST; break
case 3: dz = -1; rot = SOUTH; break
}
let length = (1-dy+0.25)*8
for(let l=0; l<length; l++){
x += dx, z += dz, y += dy
world.spawnBlock(x,round(y),z,sw|rot,type)
}
y = round(y)
for(var x2=-8; x2<8; x2++){
for(var y2=6; y2<8; y2++){
for(var z2=-8; z2<8; z2++){
let n = x2 * x2 / 64 + y2 * y2 / 64 + z2 * z2 / 64
if (n < 1) {
world.spawnBlock(x+x2, y-6+y2, z+z2, leaf, type)
}
}
}
}
}
}
}
spawnDisk(wx,wz, replace, block, underBlock = block, radius){
let {type, world} = this
let r2 = radius**2
let maxY = world.getSolidTop(wx,wz,type)+10
for(let x2=-radius; x2<radius; x2++){
for(let z2=-radius; z2<radius; z2++){
let n = x2 * x2 / r2 + z2 * z2 / r2
if (n < 1) {
let y = world.getSolidTop(wx+x2,wz+z2,type)
if(y>maxY) continue
let blockHere = world.getBlock(wx+x2, y, wz+z2,type)
if(!replace.includes(blockHere)) continue
let under = block !== underBlock && world.getBlock(wx+x2, y+1, wz+z2,type)
world.spawnBlock(wx+x2, y, wz+z2, under ? underBlock : block, type, true)
}
}
}
}
spawnRock(X,Y,Z,type){
const {world} = this
let oreWeirdness, oreW, oreH
if(type === "big"){
oreWeirdness = 0.02, oreW = 16, oreH = 12
}else if(type === "mossy" || type === "small"){
oreWeirdness = 0.1, oreW = oreH = 3
}else if(type === "medium"){
oreWeirdness = 0.04, oreW = 8, oreH = 4
}else if(type === "flat"){
oreWeirdness = 0.01, oreW = 10, oreH = 4
}
let block
for(let x=-oreW;x<oreW;x++){
for(let z=-oreW;z<oreW;z++){
const horizontalSubtract = ((x/oreW)**2 + (z/oreW)**2)**2
for(let y=oreH-1;y>=-oreH;y--){
if(blockData[world.getBlock(X+x,Y+y,Z+z,this.type)].solid) break //Skip to next column
const n = mapClamped(this.world.noiseProfile.noise((X+x)*oreWeirdness*4,(Y+y)*oreWeirdness*1.5,(Z+z)*oreWeirdness*4),0.1,0.7)
//const n2 = this.world.noiseProfile.noise((Y+y)*oreWeirdness,(Z+z)*oreWeirdness*4,(X+x)*oreWeirdness*4)
const subtract = ((y+oreH)/oreH/2) + horizontalSubtract//preferMiddle((y+oreH)/oreH/2, 0.1, 0,1)
if(n>subtract){
if(type === "mossy"){
block = blockIds.mossyCobble
}else if(type === "small"){
block = blockIds.cobblestone
}else if(type === "flat"){
if(!world.getBlock(X+x,Y+y+1,Z+z,this.type) && this.world.caveNoise((X+x)*0.5,(Y+y)*0.5,(Z+z)*0.5) > 0.65){
block = blockIds.grass
}else{
block = blockIds.limestone
}
}else{
if(!world.getBlock(X+x,Y+y+1,Z+z,this.type) && this.world.caveNoise((X+x)*0.25,(Y+y)*0.25,(Z+z)*0.25) > 0.6){
block = blockIds.grass
if(random()>0.75) world.spawnBlock(X+x,Y+y+1,Z+z, blockIds.TallGrass, this.type, true)
}else{
block = blockIds.stone
}
}
world.spawnBlock(X+x,Y+y,Z+z,block,this.type, true)
//const under = world.getBlock(X+x,Y+y-1,Z+z,this.type)
//if(under === blockIds.grass || under === (blockIds.grass|CROSS) || under === blockIds.podzol || under === blockIds.mycelium){
//	world.spawnBlock(X+x,Y+y-1,Z+z,blockIds.dirt,this.type, true)
//}
if(y === -oreH){
let y2 = Y+y-1, under = 0
if(block === blockIds.grass) block = blockIds.dirt
while(Y+y-y2<64 && !blockData[under].solid || under === blockIds.dirt || under === blockIds.grass || under === (blockIds.grass|CROSS) || under === blockIds.podzol || under === blockIds.mycelium){
world.spawnBlock(X+x,y2,Z+z,block,this.type, true)
y2--
under = world.getBlock(X+x,y2,Z+z,this.type)
}
}
}
}
}
}
}
generatePatch(X,Y,Z,size,blocks){
let {world} = this
for(let x=-size;x<=size;x++){
for(let y=size;y>=-size;y--){
for(let z=-size;z<=size;z++){
let blockHere = blockData[world.getBlock(X+x,Y+y,Z+z,this.type)]
if(hash3(X+x,Y+y,Z+z)*((x/size)**2+(y/size)**2+(z/size)**2) < 0.5 && !blockHere.solid && !blockHere.liquid && blockData[world.getBlock(X+x,Y+y-1,Z+z,this.type)].type === "ground"){
world.spawnBlock(X+x,Y+y,Z+z,blocks[floor(random(blocks.length))],this.type,true)
}
}
}
}
}
spawnBigBirch(i,ground,k,wx,wz,tall){
let {type, world} = this
let top = ground + (tall ? floor(random(16,20)) : floor(random(6,10)))
let tree = tall ? blockIds.birchLog : blockIds.birchLog|WALLPOST
let leaf = blockIds.birchLeaves
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, ground, k, blockIds.dirt)
for(let b=0; b<16; b++){
let j = round(lerp(random()**3,top+2,(top+ground)*0.5))
let rot = hash3(i,b,k)*Math.PId
let dx = sin(rot), dz = cos(rot)
if(tall) for(let l=0; l<6; l++){
world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l),leaf,type)
world.spawnBlock(round(wx+dx*l+1),round(j+l*-0.5),round(wz+dz*l),leaf,type)
world.spawnBlock(round(wx+dx*l-1),round(j+l*-0.5),round(wz+dz*l),leaf,type)
world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l+1),leaf,type)
world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l-1),leaf,type)
world.spawnBlock(round(wx+dx*l),round(j+l*+0.5),round(wz+dz*l),leaf,type)
world.spawnBlock(round(wx+dx*l),round(j+l*-1.5),round(wz+dz*l),leaf,type)
}else for(let l=0; l<6; l++){
world.spawnBlock(round(wx+dx*l),round(j+l*-0.5),round(wz+dz*l),leaf,type)
}
}
/*let leafBottom = round(lerp(0.25,ground,top)), leafTop = top+4
for(let y=leafBottom; y<leafTop; y++){
let w = lerp((y-leafBottom)/(leafTop-leafBottom),0,1-(1-(leafTop-y)/(leafTop-leafBottom))**4)*8
let w2 = w**2
for(let x2=floor(-w); x2<=ceil(w); x2++){
for(let z2=floor(-w); z2<=ceil(w); z2++){
let n = x2 * x2 / w2 + z2 * z2 / w2
n += this.world.caveNoise((wx+x2)*1.5, y*1.5, (wz+z2)*1.5)
if (n < 1) {
world.spawnBlock(wx+x2, y, wz+z2, leaf, type)
}
}
}
}*/
/*let w = 5, h = tall?10:6
let w2 = w**2, h2 = h**2
for(let x2=-w; x2<=w; x2++){
for(let z2=-w; z2<=w; z2++){
for(let y2=-h; y2<=h; y2++){
let x = x2, z = z2
if(y2 < 0){//make thinner
x *= 1-y2/h
z *= 1-y2/h
}
let n = x * x / w2 + z * z / w2 + y2 * y2 / h2
n += this.world.caveNoise((wx+x2)*1.5, (top+y2)*1.5, (wz+z2)*1.5)*1.25
if (n < 1) {
world.spawnBlock(wx+x2, top+y2, wz+z2, leaf, type)
}
}
}
}*/
}
spawnShrub(i,ground,k,wx,wz,leafType){
let {type, world} = this
let sides = random()>0.5
let tree, leaf
let treeType = leafType === "big" ? round(lerp(random()**2,0,2)) : (leafType === "wet" ? 0 : round(random(-1,0)))
switch(treeType){
case -1:
tree = blockIds.acaciaLog, leaf = blockIds.acaciaLeaves
break
case 0:
tree = blockIds.oakLog, leaf = blockIds.oakLeaves
break
case 1:
tree = blockIds.oakLog, leaf = blockIds.redBerryLeaves
break
case 2:
tree = blockIds.oakLog, leaf = blockIds.blueBerryLeaves
break
}
this.setBlock(i,ground+1,k,leaf)
if(sides){
this.setBlock(i,ground+2,k,leaf|SLAB)
world.spawnBlock(wx,ground+1,wz-1,leaf|VERTICALSLAB|NORTH,type)
world.spawnBlock(wx,ground+1,wz+1,leaf|VERTICALSLAB|SOUTH,type)
world.spawnBlock(wx-1,ground+1,wz,leaf|VERTICALSLAB|EAST,type)
world.spawnBlock(wx+1,ground+1,wz,leaf|VERTICALSLAB|WEST,type)
}
}
spawnBush(i,ground,k,wx,wz,leafType){
let {type, world} = this
let rand = floor(random(4096))
let tree, leaf, leaf2
let treeType = leafType === "big" ? round(lerp(random()**2,0,2)) : (leafType === "wet" ? 0 : round(random(-1,0)))
let big = leafType === "big"
switch(treeType){
case -1:
tree = blockIds.acaciaLog, leaf = blockIds.acaciaLeaves
break
case 0:
tree = blockIds.oakLog, leaf = blockIds.oakLeaves
break
case 1:
tree = blockIds.oakLog, leaf = blockIds.redBerryLeaves, leaf2 = leaf|FENCE
break
case 2:
tree = blockIds.oakLog, leaf = blockIds.blueBerryLeaves, leaf2 = leaf|FENCE
break
}
let w = big ? random(2,5) : random(2,3), h = big ? w*0.9 : lerp(random()**2,0,4)
let top = floor(h*0.75)+ground
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, ground, k, blockIds.rootedDirt)
let w2 = w**2, h2 = h**2
for(let x2=floor(-w); x2<=ceil(w); x2++){
for(let z2=floor(-w); z2<=ceil(w); z2++){
for(let y2=floor(-h); y2<=ceil(h); y2++){
let x = x2, z = z2
if(y2 < 0){//make thinner
x *= 1-y2/h*2
z *= 1-y2/h*2
}
let n = x * x / w2 + z * z / w2 + y2 * y2 / h2
if(n > 0.6){
n += this.world.caveNoise((wx+x2)*2, (top+y2), (wz+z2)*2)*0.4
}
if (n < 1) {
world.spawnBlock(wx+x2, top+y2, wz+z2, leaf2 && hash3(wx+x2, top+y2, wz+z2) > 0.2 ? leaf2 : leaf, type)
}
}
}
}
}
spawnDarkOak(i,ground,k,wx,wz){
let {type, world} = this
let top = ground+round(random(12,18))
let tree = blockIds.darkOakLog, leaf = blockIds.darkOakLeaves
let hasLight = random()>0.85
let offX, offZ, pOffX, pOffZ
for (let j = ground + 1; j < top; j++) {
pOffX = offX, pOffZ = offZ
offX = round(lerp(Math.min((j-ground-1)*0.25,1),0,world.noiseProfile.generator.noise3d(wx,j*0.05,wz))*8)
offZ = round(lerp(Math.min((j-ground-1)*0.25,1),0,world.noiseProfile.generator.noise3d(wx,-j*0.05,wz)*8))
world.spawnBlock(wx+offX, j, wz+offZ, tree, type)
world.spawnBlock(wx + 1+offX, j, wz+offZ, tree, type)
world.spawnBlock(wx+offX, j, wz + 1+offZ, tree, type)
world.spawnBlock(wx+1+offX, j, wz+1+offZ, tree, type)
if(pOffX !== offX || pOffZ !== offZ){
world.spawnBlock(wx+offX, j-1, wz+offZ, tree, type)
world.spawnBlock(wx + 1+offX, j-1, wz+offZ, tree, type)
world.spawnBlock(wx+offX, j-1, wz + 1+offZ, tree, type)
world.spawnBlock(wx+1+offX, j-1, wz+1+offZ, tree, type)
}
}
world.spawnBlock(wx, ground, wz, blockIds.dirt, type, true)
world.spawnBlock(wx + 1, ground, wz, blockIds.dirt, type, true)
world.spawnBlock(wx, ground, wz + 1, blockIds.dirt, type, true)
world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt, type, true)
let topX = wx+offX, topZ = wz+offZ
let branch = []
for(let b=0; b<4; b++){//branches
let endX = topX+round(random(-6,6))
let endZ = topZ+round(random(-6,6))
let startY = round(random(max(ground+5,top-16),top-5))
let startX = wx+round(world.noiseProfile.generator.noise3d(wx,startY*0.05,wz)*8)
let startZ = wz+round(world.noiseProfile.generator.noise3d(wx,-startY*0.05,wz)*8)
branch.length = 0
line3D(endX,top,endZ,startX,startY,startZ,branch)
for(let bi=0; bi<branch.length; bi+=3){
world.spawnBlock(branch[bi],branch[bi+1],branch[bi+2],tree,type)
}
}
let w = 10, h = 5
let w2 = w**2, h2 = h**2
for(let x2=-w; x2<=w+1; x2++){
for(let z2=-w; z2<=w+1; z2++){
for(let y2=-h; y2<=h; y2++){
let x = x2-0.5, z = z2-0.5
if(y2 < 0){//make thinner
x *= 1-y2/h*2
z *= 1-y2/h*2
}
let n = x * x / w2 + z * z / w2 + y2 * y2 / h2
if(n > 0.6){
n += this.world.caveNoise((topX+x2)*0.4, (top+y2), (topZ+z2)*0.4)*0.4
}
if (n < 1) {
world.spawnBlock(topX+x2, top+y2, topZ+z2, leaf, type)
if(n>0.75 && hash3(topX+x2, top+y2, topZ+z2) > 0.75){
worldGenArray.add(topX+x2, top+y2, topZ+z2,blockIds.vine)
if(hasLight && !world.getBlock(topX+x2, top+y2-1, topZ+z2,type) && hash3(topX+x2, top+y2, topZ+z2) > 0.9){
let length = round(random(5,12))
for(let l=1; l<length; l++){
world.spawnBlock(topX+x2, top+y2-l, topZ+z2, hash3(topX+x2, top+y2-l, topZ+z2)>0.75 ? blockIds.caveVinesPlantLit : blockIds.caveVinesPlant, type)
}
world.spawnBlock(topX+x2, top+y2-length, topZ+z2, hash3(topX+x2, top+y2-length, topZ+z2)>0.75 ? blockIds.caveVinesLit : blockIds.caveVines, type)
}
}
}
}
}
}
}
spawnHugeMushroomPiece3x3(x,y,z,dx,dz,rot,nextRot,mushroom){
let {type, world} = this
world.spawnBlock(x-dx,y,z-dz,mushroom|PANE|rot,type)
world.spawnBlock(x,y,z,mushroom|DOOR|rot,type)
world.spawnBlock(x+dx,y,z+dz,mushroom|PANE|nextRot,type)
world.spawnBlock(x-dx,y-1,z-dz,mushroom|PORTAL|rot,type)
world.spawnBlock(x,y-1,z,mushroom|WALLFLAT|rot,type)
world.spawnBlock(x+dx,y-1,z+dz,mushroom|PORTAL|nextRot,type)
world.spawnBlock(x-dx,y-2,z-dz,mushroom|PORTAL|rot,type)
world.spawnBlock(x,y-2,z,mushroom|WALLFLAT|rot,type)
world.spawnBlock(x+dx,y-2,z+dz,mushroom|PORTAL|nextRot,type)
}
spawnHugeMushroom(i,ground,k,wx,wz,isBrown){
let {type, world} = this
let height = round(random(5,9))
if(random()<0.1) height *= 2
let top = ground+height
for (let j = ground + 1; j < top; j++) {
this.setBlock(i, j, k, blockIds.mushroomStem | TALLCROSS)
}
this.setBlock(i, ground, k, blockIds.dirt)
if(isBrown){//Brown mushroom (flat)
let mushroom = blockIds.brownMushroomBlock
world.spawnBlock(wx+3,top,wz-2,mushroom|PANE|EAST,type)
world.spawnBlock(wx+3,top,wz-1,mushroom|DOOR|EAST,type)
world.spawnBlock(wx+3,top,wz,mushroom|DOOR|EAST,type)
world.spawnBlock(wx+3,top,wz+1,mushroom|DOOR|EAST,type)
world.spawnBlock(wx+3,top,wz+2,mushroom|PANE|NORTH,type)
world.spawnBlock(wx+2,top,wz+3,mushroom|PANE|NORTH,type)
world.spawnBlock(wx+1,top,wz+3,mushroom|DOOR|NORTH,type)
world.spawnBlock(wx,top,wz+3,mushroom|DOOR|NORTH,type)
world.spawnBlock(wx-1,top,wz+3,mushroom|DOOR|NORTH,type)
world.spawnBlock(wx-2,top,wz+3,mushroom|PANE|WEST,type)
world.spawnBlock(wx-3,top,wz+2,mushroom|PANE|WEST,type)
world.spawnBlock(wx-3,top,wz+1,mushroom|DOOR|WEST,type)
world.spawnBlock(wx-3,top,wz,mushroom|DOOR|WEST,type)
world.spawnBlock(wx-3,top,wz-1,mushroom|DOOR|WEST,type)
world.spawnBlock(wx-3,top,wz-2,mushroom|PANE|SOUTH,type)
world.spawnBlock(wx-2,top,wz-3,mushroom|PANE|SOUTH,type)
world.spawnBlock(wx-1,top,wz-3,mushroom|DOOR|SOUTH,type)
world.spawnBlock(wx,top,wz-3,mushroom|DOOR|SOUTH,type)
world.spawnBlock(wx+1,top,wz-3,mushroom|DOOR|SOUTH,type)
world.spawnBlock(wx+2,top,wz-3,mushroom|PANE|EAST,type)
for(let x=-2; x<=2; x++){
for(let z=-2; z<=2; z++){
world.spawnBlock(wx+x,top,wz+z,mushroom|STAIR,type)
}
}
}else{
let mushroom = blockIds.redMushroomBlock
world.spawnBlock(wx,top,wz,mushroom|STAIR,type)
world.spawnBlock(wx+1,top,wz,mushroom|DOOR|EAST,type)
world.spawnBlock(wx-1,top,wz,mushroom|DOOR|WEST,type)
world.spawnBlock(wx,top,wz+1,mushroom|DOOR|NORTH,type)
world.spawnBlock(wx,top,wz-1,mushroom|DOOR|SOUTH,type)
world.spawnBlock(wx+1,top,wz-1,mushroom|PANE|EAST,type)
world.spawnBlock(wx-1,top,wz+1,mushroom|PANE|WEST,type)
world.spawnBlock(wx+1,top,wz+1,mushroom|PANE|NORTH,type)
world.spawnBlock(wx-1,top,wz-1,mushroom|PANE|SOUTH,type)
this.spawnHugeMushroomPiece3x3(wx+2,top-1,wz,0,1,EAST,NORTH,mushroom)
this.spawnHugeMushroomPiece3x3(wx,top-1,wz+2,-1,0,NORTH,WEST,mushroom)
this.spawnHugeMushroomPiece3x3(wx-2,top-1,wz,0,-1,WEST,SOUTH,mushroom)
this.spawnHugeMushroomPiece3x3(wx,top-1,wz-2,1,0,SOUTH,EAST,mushroom)
}
}
spawnCherryTree(i,ground,k,wx,wz){
let {type, world} = this
this.setBlock(i, ground, k, blockIds.dirt)
let branchCount = round(random(1,3))
let tree = blockIds.cherryLog
let treeSW = blockIds.cherryLogSW
let leaf = blockIds.cherryLeaves
let top = ground+7
let branches = [wx,top,wz], branch = []
for(let y=ground; y<top; y++){
this.setBlock(i,y,k,tree)
}
this.setBlock(i,ground,k,blockIds.dirt)
for(let b=0; b<branchCount; b++){
let startY = top-round(random(3,4))
let endY = top-round(random())
let branchLength = round(random(2,4))
let dx = 0, dz = 0, rot
switch(round(random(3))){
case 0:
dx = 1, rot = EAST
break
case 1:
dz = 1, rot = NORTH
break
case 2:
dx = -1, rot = WEST
break
case 3:
dz = -1, rot = SOUTH
break
}
branches.push(wx+dx*branchLength,endY,wz+dz*branchLength)
if(random()>0.5){
branch.length = 0
line3DConncected(wx+dx*branchLength,endY,wz+dz*branchLength,wx,startY,wz,branch)
let swornot = (endY-startY)/branchLength >= 1 ? tree : treeSW|rot
for(let bi=0; bi<branch.length; bi+=3){
world.spawnBlock(branch[bi],branch[bi+1],branch[bi+2],swornot,type)
}
}else{
for(let bi=0; bi<=branchLength; bi++){
world.spawnBlock(wx+dx*bi,startY,wz+dz*bi,treeSW|rot,type)
}
for(let y=startY; y<endY; y++){
world.spawnBlock(wx+dx*branchLength,y,wz+dz*branchLength,tree,type)
}
}
}
for(let b=0; b<branches.length; b+=3){
let x = branches[b], y = branches[b+1], z = branches[b+2]
let w = 5, h = 2.5
let w2 = w**2, h2 = h**2
for(let x2=-w; x2<=w; x2++){
for(let z2=-w; z2<=w; z2++){
for(let y2=floor(-h); y2<=ceil(h); y2++){
let n = x2 * x2 / w2 + z2 * z2 / w2 + y2 * y2 / h2
if(n > 0.5) n += this.world.caveNoise((wx+x2)*1.5, (top+y2)*1.5, (wz+z2)*1.5)*0.5
if (n < 1) {
world.spawnBlock(x+x2, y+y2, z+z2, leaf, type)
if(!world.getBlock(x+x2,y+y2-1,z+z2)){//hanging leaves
let length = round(lerp(hash3(x+x2,y+y2,z+z2),-1,1.8))
if(length>0){
world.spawnBlock(x+x2, y+y2-1, z+z2, leaf, type)
if(length>1) world.spawnBlock(x+x2, y+y2-2, z+z2, leaf, type)
}
}
}
}
}
}
}
}
spawnSwampOak(i,ground,k,wx,wz){
let place
let {type, world} = this
let top = ground + floor(4.5 + random(2.5))
let rand = floor(random(4096))
let tree = blockIds.oakLog
let leaf = blockIds.oakLeaves
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, blockIds.dirt)
//Bottom leaves
for (let x = -3; x <= 3; x++) {
for (let z = -3; z <= 3; z++) {
if (x || z) {
if (abs(x) === 3 && abs(z) === 3) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 2, wz + z, leaf, type)
worldGenArray.add(wx + x, top - 2, wz + z, blockIds.vine)
worldGenArray.add(wx + x, top - 2, wz + z, blockIds.vine)
}
} else {
world.spawnBlock(wx + x, top - 2, wz + z, leaf, type)
worldGenArray.add(wx + x, top - 2, wz + z, blockIds.vine)
worldGenArray.add(wx + x, top - 2, wz + z, blockIds.vine)
}
}
}
}
//2nd layer leaves
for (let x = -3; x <= 3; x++) {
for (let z = -3; z <= 3; z++) {
if (x || z) {
if (abs(x) === 3 && abs(z) === 3) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
worldGenArray.add(wx + x, top - 1, wz + z, blockIds.vine)
worldGenArray.add(wx + x, top - 1, wz + z, blockIds.vine)
}
} else {
world.spawnBlock(wx + x, top - 1, wz + z, leaf, type)
worldGenArray.add(wx + x, top - 1, wz + z, blockIds.vine)
worldGenArray.add(wx + x, top - 1, wz + z, blockIds.vine)
}
}
}
}
//3rd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if (abs(x) === 2 && abs(z) === 2) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top, wz + z, leaf, type)
worldGenArray.add(wx + x, top, wz + z, blockIds.vine)
}
} else {
world.spawnBlock(wx + x, top, wz + z, leaf, type)
worldGenArray.add(wx + x, top, wz + z, blockIds.vine)
}
}
}
}
//Top leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if ((x || z) && (abs(x) !== 2 || abs(z) !== 2)) {
world.spawnBlock(wx + x, top+1, wz + z, leaf, type)
worldGenArray.add(wx + x, top+1, wz + z, blockIds.vine)
}
}
}
}
spawnIceberg(wx,wz){
let {type, world} = this
let topH = random()>0.1 ? round(random(10,42)) : round(random(3,17))
let bottomH = round(random(3,18))
let radius = round((topH+bottomH)/8)
let iceRnd = random()
let ice = iceRnd>0.99 ? blockIds.blueIce : (iceRnd>0.9 ? blockIds.packedIce : blockIds.ice)
let w2 = radius**2
for(let x2=-radius; x2<=radius; x2++){
for(let y2=-bottomH; y2<=topH; y2++){
for(let z2=-radius; z2<=radius; z2++){
let n = x2 * x2 / w2 + z2 * z2 / w2 + y2 * y2 / (y2>0 ? topH : bottomH)
if(n > 0.5) n += this.world.caveNoise((wx+x2)*1.5, (waterHeight+y2)*1.5, (wz+z2)*1.5)*0.5
if (n < 1) {
world.spawnBlock(wx+x2, waterHeight+y2, wz+z2, ice, type)
}
}
}
}
}
/*spawnAquifer(){ //Unused because it can affect ores and trees differntly each load
let {type, world} = this
let ax = 6//floor(random(16))+this.x
let az = 8//floor(random(16))+this.z
let ay = 12//floor(random(minHeight,this.tops[az*16+ax]))
if(world.getBlock(ax,ay,az,type)) return
let aquiferSpreadAt = [ax,ay,az,0], aquiferSpreaded = 0
let maxHeight = ay //Will get lower if the aquifer overflows so that it doesn't overflow
let maxDist = 16**2
let barrierDist = 15**2
let dist
while(aquiferSpreadAt.length){
let [x,y,z] = aquiferSpreadAt.splice(0,4)
if(y > maxHeight) continue //Prevent doing extra unneeded stuff
dist = (ax-x)**2 + (ay-y)**2 + (az-z)**2
if(dist > maxDist){
maxHeight = min(maxHeight, world.getTop(x,z,type)) //Prevent overflow if outside cave
}else{
if(!world.getBlock(x+1,y,z,type) && !xyArrayHas(aquiferSpreadAt,bigArray,x+1,y,z,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x+1,y,z,0)
if(!world.getBlock(x-1,y,z,type) && !xyArrayHas(aquiferSpreadAt,bigArray,x-1,y,z,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x-1,y,z,0)
if(!world.getBlock(x,y,z+1,type) && !xyArrayHas(aquiferSpreadAt,bigArray,x,y,z+1,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x,y,z+1,0)
if(!world.getBlock(x,y,z-1,type) && !xyArrayHas(aquiferSpreadAt,bigArray,x,y,z-1,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x,y,z-1,0)
if(!world.getBlock(x,y-1,z,type) && !xyArrayHas(aquiferSpreadAt,bigArray,x,y-1,z,undefined,aquiferSpreaded)) aquiferSpreadAt.push(x,y-1,z,0)
}
bigArray[aquiferSpreaded++] = x
bigArray[aquiferSpreaded++] = y
bigArray[aquiferSpreaded++] = z
bigArray[aquiferSpreaded++] = dist>barrierDist
}
console.log(ax,ay,az,aquiferSpreaded)
for(let i=0; i<aquiferSpreaded; i+=4){
if(bigArray[i+1] > maxHeight) continue
let x = bigArray[i], y = bigArray[i+1], z = bigArray[i+2]
let barrier = bigArray[i+3]
world.spawnBlock(x,y,z,barrier?blockIds.stone:blockIds.Water,type,true)
}
}*/
/*spawnAmethystGeode(X,Y,Z){
const {world} = this
let oreSegments = 4, oreWeirdness = 1, oreSize = 9
//https://www.khanacademy.org/computer-programming/ore-generator/6387555023765504
let balls=[],bx=0,by=0,bz=0;
let dx=random()*2-1,dy=1,dz=random()*2-1;
for(let i=0;i<oreSegments;i++){
let d=Math.hypot(dx,dy,dz);
dx /= d;
dy /= d;
dz /= d;
balls.push(bx,by,bz);
bx += dx*oreWeirdness;
by += dy*oreWeirdness;
bz += dz*oreWeirdness;
if(bx>oreSize){
bx = -oreSize;
}
if(bx<-oreSize){
bx = oreSize;
}
if(by>oreSize){
by = -oreSize;
}
if(by<-oreSize){
by = oreSize;
}
if(bz>oreSize){
bz = -oreSize;
}
if(bz<-oreSize){
bz = oreSize;
}
dx=random()*2-1;
dy=random()*2-1;
dz=random()*2-1;
}
let buds = []
for(let x=-oreSize;x<=oreSize;x++){
for(let y=oreSize;y>=-oreSize;y--){
for(let z=-oreSize;z<=oreSize;z++){
let d=0;
for(let i=0; i<balls.length; i+=3){
d += 1/dist3(balls[i],balls[i+1],balls[i+2],x,y,z);
}
if(d>0.8){
world.spawnBlock(X+x,Y+y,Z+z,0,this.type,true)
}else if(d>0.7){
let bud = random()>0.8
world.spawnBlock(X+x,Y+y,Z+z, bud?blockIds.buddingAmethyst:blockIds.amethystBlock,this.type,true)
if(bud) buds.push(X+x,Y+y,Z+z)
}else if(d>0.6){
world.spawnBlock(X+x,Y+y,Z+z,blockIds.calcite,this.type,true)
}else if(d>0.5){
world.spawnBlock(X+x,Y+y,Z+z,blockIds.smoothBasalt,this.type,true)
}
}
}
}
for(let i=0; i<buds.length; i+=3){
let x = buds[i], y = buds[i+1], z = buds[i+2]
let type = round(random(3))
let block
switch(type){
case 0:
block = blockIds.amethystCluster
break
case 1:
block = blockIds.smallAmethystBud
break
case 2:
block = blockIds.mediumAmethystBud
break
case 3:
block = blockIds.largeAmethystBud
break
}
world.spawnBlock(x,y+1,z,block|CROSS,this.type)
world.spawnBlock(x,y-1,z,block|SLAB,this.type)
world.spawnBlock(x+1,y,z,block|WEST,this.type)
world.spawnBlock(x-1,y,z,block|EAST,this.type)
world.spawnBlock(x,y,z+1,block|SOUTH,this.type)
world.spawnBlock(x,y,z-1,block|NORTH,this.type)
}
}*/
patches = {
flowers:[blockIds.poppy,blockIds.dandelion],
forestFlowers:[blockIds.poppy,blockIds.dandelion,blockIds.lilac,blockIds.roseBush,blockIds.peony,blockIds.lilyOftheValley],
plainsFlowers:[blockIds.poppy,blockIds.poppy,blockIds.azureBluet,blockIds.azureBluet,blockIds.oxeyeDaisy,blockIds.oxeyeDaisy,blockIds.cornFlower,blockIds.cornFlower,blockIds.orangeTulip,blockIds.pinkTulip,blockIds.redTulip,blockIds.whiteTulip],
flowerForestFlowers:[blockIds.dandelion,blockIds.poppy,blockIds.allium,blockIds.azureBluet,blockIds.orangeTulip,blockIds.pinkTulip,blockIds.redTulip,blockIds.whiteTulip,blockIds.oxeyeDaisy,blockIds.cornFlower,blockIds.lilyOftheValley,blockIds.pinkPetals,blockIds.pinkPetals],
sunflowerPlainsFlowers:[blockIds.sunflower,blockIds.sunflower,blockIds.sunflower,blockIds.sunflower,blockIds.sunflower,blockIds.sunflower,blockIds.poppy,blockIds.azureBluet,blockIds.oxeyeDaisy,blockIds.cornFlower],
meadowFlowers:[blockIds.poppy,blockIds.dandelion,blockIds.allium,blockIds.azureBluet,blockIds.cornFlower,blockIds.oxeyeDaisy,blockIds.torchflower],
pinkPetals:[blockIds.pinkPetals,blockIds.pinkPetals|SLAB,blockIds.pinkPetals|STAIR,blockIds.pinkPetals|DOOR],
blueOrchids:[blockIds.blueOrchid],
grass:[blockIds.TallGrass],
tallGrass:[blockIds.TallGrass,blockIds.DoubleTallGrass],
fernGrass:[blockIds.fern|SLAB,blockIds.largeFern,blockIds.TallGrass,blockIds.DoubleTallGrass],
fernBerries:[blockIds.fern|SLAB,blockIds.sweetBerryBush|CROSS,blockIds.largeFern,blockIds.TallGrass,blockIds.TallGrass,blockIds.DoubleTallGrass],
grassLeaves:[blockIds.driedOakLeaves,blockIds.driedBirchLeaves,blockIds.driedOakLeaves|SLAB,blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass],
lushCaves:[blockIds.TallGrass,blockIds.DoubleTallGrass,blockIds.mossCarpet,blockIds.azalea,blockIds.floweringAzalea],
jungle:[blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass,blockIds.DoubleTallGrass,blockIds.DoubleTallGrass,blockIds.DoubleTallGrass,blockIds.DoubleTallGrass,blockIds.fern|SLAB,blockIds.fern|SLAB,blockIds.largeFern,blockIds.largeFern,blockIds.mossCarpet,blockIds.azalea,blockIds.floweringAzalea,blockIds.pitcherPlant],
seagrass:[blockIds.seagrass,blockIds.tallSeagrass],
grassAndRareTallGrass:[blockIds.TallGrass,blockIds.TallGrass,blockIds.TallGrass,blockIds.DoubleTallGrass],
mostThickLeaves:[blockIds.driedOakLeaves|SLAB,blockIds.driedOakLeaves,blockIds.driedOakLeaves,blockIds.driedBirchLeaves,blockIds.TallGrass,blockIds.TallGrass,blockIds.driedSpruceLeaves],
fernGrassSpruceLeaves:[blockIds.driedSpruceLeaves,blockIds.sweetBerryBush|CROSS,blockIds.TallGrass,blockIds.DoubleTallGrass,blockIds.fern|SLAB,blockIds.largeFern],
mostTallGrass:[blockIds.DoubleTallGrass,blockIds.DoubleTallGrass,blockIds.TallGrass],
grassLeavesFern:[blockIds.driedBambooLeaves,blockIds.driedBambooLeaves,blockIds.driedBambooLeaves,blockIds.TallGrass,blockIds.fern|SLAB],
grassLeavesBirch:[blockIds.driedBirchLeaves,blockIds.driedBirchLeaves,blockIds.TallGrass],
dirtOre: {[blockIds.stone]:blockIds.dirt},
gravelOre: {[blockIds.stone]:blockIds.gravel,[blockIds.deepslate]:blockIds.gravel},
graniteOre: {[blockIds.stone]:blockIds.granite,[blockIds.deepslate]:blockIds.granite},
dioriteOre: {[blockIds.stone]:blockIds.diorite,[blockIds.deepslate]:blockIds.diorite},
andesiteOre: {[blockIds.stone]:blockIds.andesite,[blockIds.deepslate]:blockIds.andesite},
tuffOre: {[blockIds.stone]:blockIds.tuff,[blockIds.deepslate]:blockIds.tuff},
coalOre: {[blockIds.stone]:blockIds.coalOre,[blockIds.deepslate]:blockIds.deepslateCoalOre},
ironOre: {[blockIds.stone]:blockIds.ironOre,[blockIds.deepslate]:blockIds.deepslateIronOre},
copperOre: {[blockIds.stone]:blockIds.copperOre,[blockIds.deepslate]:blockIds.deepslateCopperOre},
redstoneOre: {[blockIds.stone]:blockIds.redstoneOre,[blockIds.deepslate]:blockIds.deepslateRedstoneOre},
lapisOre: {[blockIds.stone]:blockIds.lapisOre,[blockIds.deepslate]:blockIds.deepslateLapisOre},
goldOre: {[blockIds.stone]:blockIds.goldOre,[blockIds.deepslate]:blockIds.deepslateGoldOre},
diamondOre: {[blockIds.stone]:blockIds.diamondOre,[blockIds.deepslate]:blockIds.deepslateDiamondOre},
emeraldOre: {biomes:["windsweptHills","grove","jaggedPeaks","meadow","frozenPeaks","stonePeaks","windsweptForest","snowySlopes","windsweptGravellyHills","cherryGrove"], [blockIds.stone]:blockIds.emeraldOre,[blockIds.deepslate]:blockIds.deepslateEmeraldOre},
badlandsGoldOre: {biomes:["badlands,erodedBadlands,woodedBadlands"], [blockIds.stone]:blockIds.goldOre,[blockIds.deepslate]:blockIds.deepslateGoldOre},
limestoneOre: {[blockIds.stone]:blockIds.limestone,[blockIds.deepslate]:blockIds.limestone},
//For big spruce & pine
podzol:{[blockIds.grass]:blockIds.podzol, [blockIds.air]: (x,y,z,dimension) => hash3(x,y,z) > 0.7 || !blockData[this.world.getBlock(x,y-1,z,dimension)].solid || this.world.getBlock(x,y+1,z,dimension) ? undefined : blockIds.driedSpruceLeaves},
sandDisk:[blockIds.dirt,blockIds.grass,blockIds.coarseDirt,blockIds.rootedDirt],
clayDisk:[blockIds.dirt],
dirtDisk:[blockIds.mud,blockIds.clay],
aboveGroundDisk:[blockIds.grass],
azaleaLeaves:{0:(x,y,z,dimension) => hash3(x,y,z) > 0.65 ? blockIds.floweringAzaleaLeaves : blockIds.azaleaLeaves},
mushrooms:[blockIds.redMushroom,blockIds.brownMushroom],
groundBerries:[blockIds.groundBerries],
fern:[blockIds.fern|SLAB,blockIds.fern|SLAB,blockIds.fern|SLAB,blockIds.fern|SLAB,blockIds.largeFern]
}
async populate() {
const world = this.world
const {trees} = world
seedHash(world.worldSeed)
randomSeed(hash(this.x, this.z) * 210000000)
const {noiseProfile} = world
let wx = 0, wz = 0, ground = 0
let trueX = this.x, trueY = this.y, trueZ = this.z
let biome = 0
const type = this.type
worldGenArray.clear() //generate extras like vines
if(this.world.customChunkPopulate && !this.world.customChunkPopulate(this)){
}else if((world.usePreBeta || world.superflat === "island") && type === ""){
const flowers = this.allFlowers
const clayReplaceable = [blockIds.dirt, blockIds.stone, blockIds.gravel]
const dirtReplaceable = [blockIds.stone,blockIds.gravel]
let smoothness = generator.smooth, hilliness = generator.height, biomeSmooth = generator.biomeSmooth
for (let i = 0; i < 16; i++) {
for (let k = 0; k < 16; k++) {
wx = this.x + i
wz = this.z + k
ground = this.tops[k * 16 + i]
//biome = superflat ? 0 : noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
//var b
//if(superflat){b = "plains"}else b = getBiome(biome)
//let nb = getNetherBiome(biome)
let b = biomes[this.biomes[k * 16 + i]]
if (trees && random() < 0.01 && type === "" && b === "plains" && this.getBlock(i, ground, k) === blockIds.grass) {
this.spawnSmallTree(i,ground,k,wx,wz)
}
if(b === "snowyPlains" && trees && random() < 0.01 && type === "" && this.getBlock(i, ground, k)){
this.spawnSnowSmallTree(i,ground,k,wx,wz)
}
// Cactus
if (random() < 0.01 && this.getBlock(i, ground, k) && b === "desert" && ground > 60 && this.type === "") {
this.spawnCactus(i,ground,k)
}
if (random() < 0.006 && this.getBlock(i, ground, k) && b === "desert" && ground > 60 && this.type === "") {
this.setBlock(i,ground+1,k, blockIds.deadBush | CROSS);
}
// Jungle trees
if(trees && random() < 0.01 && type === "" && (b === "sparseJungle" || b === "jungle") && this.getBlock(i, ground, k)){
this.spawnCocoaTree(i,ground,k,wx,wz)
}
//Giant jungle trees
if(trees && random() < 0.01 && type === "" && b === "jungle" && this.getBlock(i, ground, k)){
this.spawnJungleTree(i,ground,k,wx,wz)
}
if(trees && random() < 0.015 && type === "" && (b === "sparseJungle" || b === "jungle") && this.getBlock(i, ground, k)){
let w2 = 3 * 3
let d2 = 3 * 3
let h2 = 3 * 3
for(var x=-3; x<3; x++){
for(var y=1; y<3; y++){
for(var z=-3; z<3; z++){
let n = x * x / w2 + y * y / h2 + z * z / d2
if (n < 1) {
world.spawnBlock(wx+x, ground+y, wz+z, blockIds.jungleLeaves, type)
worldGenArray.add(wx+x,ground+y,wz+z,blockIds.vine)
}
}
}
}
this.setBlock(i, ground+1, k, blockIds.jungleLog)
}
//flowers and vines
if (random() < 0.05 && this.getBlock(i, ground, k, type) === blockIds.grass) {
var rnd = random()
var flower
if(b === "jungle"){
if(rnd > 0.75){
flower = blockIds.TallGrass
}else if(rnd > 0.5){
flower = blockIds.DoubleTallGrass
}else if(rnd > 0.25){
flower = blockIds.fern
}else{
flower = blockIds.largeFern
}
}else flower = flowers[Math.round(rnd * (flowers.length - 1))]
world.spawnBlock(wx, ground+1, wz, flower, type);
}
//bamboo
if(random() < 0.2 && this.getBlock(i, ground, k) && b === "bambooJungle" && ground > 60 && this.type === ""){
this.spawnBamboo(i,ground,k,wx,wz)
}
// Blocks of each per chunk in Minecraft
// Coal: 185.5
// Iron: 111.5
// Gold: 10.4
// Redstone: 29.1
// Diamond: 3.7
// Lapis: 4.1
//there is also copper
ground -= 4
if (random() < 3.7 / 256) {
let y = random() * 16 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre)
this.generateOldBlob(blockIds.stone, blockIds.diamondOre, round(random(3, 8)), i,y,k, 10)
}
}
if (random() < 111.5 / 256) {
let y = random() * 64 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre)
this.generateOldBlob(blockIds.stone, blockIds.ironOre, round(random(1, 13)), i,y,k, 9)
}
}
if (random() < 51 / 256) {
let y = random() * 64 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.copperOre)
this.generateOldBlob(blockIds.stone, blockIds.copperOre, round(random(1, 16)), i,y,k, 9)
}
}
if (random() < 185.5 / 256) {
let y = random() * ground | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre)
this.generateOldBlob(blockIds.stone, blockIds.coalOre, round(random(1, 37)), i,y,k, 20)
}
}
if (random() < 10.4 / 256) {
let y = random() * 32 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre)
this.generateOldBlob(blockIds.stone, blockIds.goldOre, round(random(1, 13)), i,y,k, 9)
}
}
if (random() < 29.1 / 256) {
let y = random() * 16 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre)
this.generateOldBlob(blockIds.stone, blockIds.redstoneOre, round(random(1, 10)), i,y,k, 8)
}
}
if (random() < 4.1 / 256) {
let y = random() * 32 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre)
this.generateOldBlob(blockIds.stone, blockIds.lapisOre, round(random(1, 9)), i,y,k, 9)
}
}
//clay & dirt
if (random() < 0.1) {
let y = random() * ground | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)/* && blockData[this.getBlock(i, y+1, k)].name === "Water"*/) {
this.generateOldBlob(clayReplaceable, blockIds.clay, round(random(20, 40)), i,y,k, 5)
}
}
if (random() < 0.1) {
let y = random() * ground | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
this.generateOldBlob(dirtReplaceable, blockIds.dirt, round(random(20, 40)), i,y,k, 5)
}
}
}
}
}else if(this.type === "nether"){
for (let i = 0; i < 16; i++) {
for (let k = 0; k < 16; k++) {
if (random() < 0.005 && type === "nether" && ground > 79 && (b === "crimsonForest" || b === "warpedForest")){
this.spawnNetherMushroom(i,ground,k,wx,wz,b)
}
var block = this.getBlock(i, ground, k)
if(random() < 0.05){
if(block === blockIds.crimsonNylium){
world.spawnBlock(wx, ground+1, wz, blockIds.crimsonRoots, type);
}else if(block === blockIds.warpedNylium){
world.spawnBlock(wx, ground+1, wz, blockIds.warpedRoots, type);
}
}
//lava springs
if(random() < 0.05 && this.getBlock(i,ground,k, type) && this.type==="nether"){
let y = round(random(netherHeight))
if(this.getBlock(i,y,k) && !this.getBlock(i,y-1,k)){
this.setBlock(this.x+i,y,this.z+k,blockIds.Lava)
await blockData[blockIds.Lava].spawnFlow(this.x+i,y,this.z+k,type,world)
}
}
let l
if(random() < 0.005){
/*let r = random(12345123451234512345)*3
let x=wx, y=this.ceils[k * 16 + i], z=wz
let ri=floor(random(5,15))
for(l=0; l<ri; l++){
x += r&1 - 1; r >>>= 1
y += r&3 - 2; r >>>= 1
z += r&1 - 1; r >>>= 1
world.spawnBlock(x,y,z, blockIds.glowstone)
}*/
this.generateOldBlob(0, blockIds.glowstone, 20, wx,this.ceils[k * 16 + i],wz, 2)
}
for(l=0; l<16; l++){
let x = random(0, 16)
let y = random(10, 177)
let z = random(0, 16)
if(world.getBlock(wx+x,y,wz+z,this.type) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z,this.type) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z,this.type) === blockIds.netherrack){
world.setBlock(wx+x,y,wz+z, blockIds.netherQuartzOre, false,false,false,false,this.type)
}
}
for(l=0; l<10; l++){
let x = random(0, 16)
let y = random(10, 177)
let z = random(0, 16)
if(world.getBlock(wx+x,y,wz+z,this.type) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z,this.type) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z,this.type) === blockIds.netherrack){
world.setBlock(wx+x,y,wz+z, blockIds.netherGoldOre, false,false,false,false,this.type)
}
}
}
}
}else if(this.type === "end"){
if(!this.x && !this.z){//center
let top = this.tops[0]
//pillar
world.spawnBlock(0,top+1,0,blockIds.bedrock,"end")
world.spawnBlock(0,top+2,0,blockIds.bedrock,"end")
world.spawnBlock(0,top+3,0,blockIds.bedrock,"end")
//torches
world.spawnBlock(0,top+2,-1,blockIds.torch|SLAB|NORTH,"end")
world.spawnBlock(0,top+2,1,blockIds.torch|SLAB|SOUTH,"end")
world.spawnBlock(-1,top+2,0,blockIds.torch|SLAB|EAST,"end")
world.spawnBlock(1,top+2,0,blockIds.torch|SLAB|WEST,"end")
//base
world.spawnBlock(-1,top,-1,blockIds.bedrock,"end")
world.spawnBlock(-1,top,0,blockIds.bedrock,"end")
world.spawnBlock(-1,top,1,blockIds.bedrock,"end")
world.spawnBlock(0,top,-1,blockIds.bedrock,"end")
world.spawnBlock(0,top,0,blockIds.bedrock,"end")
world.spawnBlock(0,top,1,blockIds.bedrock,"end")
world.spawnBlock(1,top,-1,blockIds.bedrock,"end")
world.spawnBlock(1,top,0,blockIds.bedrock,"end")
world.spawnBlock(1,top,1,blockIds.bedrock,"end")
world.spawnBlock(-1,top,-2,blockIds.bedrock,"end")
world.spawnBlock(0,top,-2,blockIds.bedrock,"end")
world.spawnBlock(1,top,-2,blockIds.bedrock,"end")
world.spawnBlock(-1,top,2,blockIds.bedrock,"end")
world.spawnBlock(0,top,2,blockIds.bedrock,"end")
world.spawnBlock(1,top,2,blockIds.bedrock,"end")
world.spawnBlock(2,top,-1,blockIds.bedrock,"end")
world.spawnBlock(2,top,0,blockIds.bedrock,"end")
world.spawnBlock(2,top,1,blockIds.bedrock,"end")
world.spawnBlock(-2,top,-1,blockIds.bedrock,"end")
world.spawnBlock(-2,top,0,blockIds.bedrock,"end")
world.spawnBlock(-2,top,1,blockIds.bedrock,"end")
//side
world.spawnBlock(-1,top+1,-3,blockIds.bedrock,"end")
world.spawnBlock(0,top+1,-3,blockIds.bedrock,"end")
world.spawnBlock(1,top+1,-3,blockIds.bedrock,"end")
world.spawnBlock(-1,top+1,3,blockIds.bedrock,"end")
world.spawnBlock(0,top+1,3,blockIds.bedrock,"end")
world.spawnBlock(1,top+1,3,blockIds.bedrock,"end")
world.spawnBlock(-3,top+1,-1,blockIds.bedrock,"end")
world.spawnBlock(-3,top+1,0,blockIds.bedrock,"end")
world.spawnBlock(-3,top+1,1,blockIds.bedrock,"end")
world.spawnBlock(3,top+1,-1,blockIds.bedrock,"end")
world.spawnBlock(3,top+1,0,blockIds.bedrock,"end")
world.spawnBlock(3,top+1,1,blockIds.bedrock,"end")
//side corners
world.spawnBlock(-2,top+1,-2,blockIds.bedrock,"end")
world.spawnBlock(2,top+1,-2,blockIds.bedrock,"end")
world.spawnBlock(-2,top+1,2,blockIds.bedrock,"end")
world.spawnBlock(2,top+1,2,blockIds.bedrock,"end")
world.spawnBlock(0,top+4,0,blockIds.oakSign,"end")
const text = atob("QmV3YXJlIHRoZQpvbmUgdGhhdApyb2xscy4=")
world.setTags(0, top+4, 0, {rot:0,text,text2:text}, true, "end",true)
}
}else if(!world.usePreBeta){
let topX, topZ, topx, topz, steepX, steepZ
for (let i = 0; i < 16; i++) {
wx = this.x + i
for (let k = 0; k < 16; k++) {
wz = this.z + k
ground = this.tops[k * 16 + i]
let biome = biomes[this.biomes[k * 16 + i]]
if(biome === "frozenPeaks" || biome === "snowySlopes" || biome === "jaggedPeaks" || biome === "windsweptHills" || biome === "windsweptGravellyHills"){
topX = world.getTop(wx+1,wz,type)
topZ = world.getTop(wx,wz+1,type)
topx = world.getTop(wx-1,wz,type)
topz = world.getTop(wx,wz-1,type)
steepX = (topX-ground)-(topx-ground)
steepZ = (topZ-ground)-(topz-ground)
let steepness = sqrt(steepX*steepX+steepZ*steepZ)
steepX /= steepness, steepZ /= steepness
if(biome === "frozenPeaks"){
if(steepness>2){
if(steepZ < -0.75 || steepZ > 0.75){
let y = ground-1
while(this.getBlock(i,y,k) === blockIds.snowBlock){//snow on top of ice
this.setBlock(i,y,k,blockIds.packedIce)
y--
}
}else if(steepX > 0){
let y = ground
while(this.getBlock(i,y,k) === blockIds.snowBlock){
this.setBlock(i,y,k,blockIds.packedIce)
y--
}
}
}
}else if(biome === "snowySlopes" || biome === "jaggedPeaks"){
if(steepness>4){
let y = ground
while(this.getBlock(i,y,k) === blockIds.snowBlock){
this.setBlock(i,y,k,blockIds.stone)
y--
}
}
}else if(biome === "windsweptHills"){
if(steepness>2.5){
let y = ground
while(this.getBlock(i,y,k) === blockIds.grass || this.getBlock(i,y,k) === blockIds.dirt){
this.setBlock(i,y,k,blockIds.stone)
y--
}
}
}else if(biome === "windsweptGravellyHills"){
if(steepness>2.5){
let y = ground
while(this.getBlock(i,y,k) === blockIds.grass || this.getBlock(i,y,k) === blockIds.dirt){
this.setBlock(i,y,k,blockIds.gravel)
y--
}
}
}
}
if(biome === "swamp"){
if(this.getBlock(i,waterHeight,k) === blockIds.grass && noiseProfile.generator.noise2d(wx*0.25,wz*0.25)>0){
this.setBlock(i,waterHeight,k,blockIds.Water)
}
}
if(biome === "marsh"){
if(ground === waterHeight) this.setBlock(i,ground,k,blockIds.mud)
else if(ground === waterHeight+1 && noiseProfile.generator.noise2d(wx*0.25,wz*0.25)>0) this.setBlock(i,ground,k,blockIds.mud)
}
}
}
if(trees) for (let i = 0; i < 16; i++) {
let flowerNoiseOffsetX = hash(world.worldSeed,24987398), flowerNoiseOffsetZ = hash(world.worldSeed,91264824)
wx = this.x + i
for (let k = 0; k < 16; k++) {
wz = this.z + k
ground = this.tops[k * 16 + i]
let b = biomes[this.biomes[k * 16 + i]]
let waterTop = this.waterTops[k*16+i]
let birchAndOak, bigOak, oak, birch, tallBirch, cocoa, bigJungle, spruce, pine, bigSpruce, bigPine, acacia, bigAcacia, bigBirch, tallSpruce, darkOak, cherry, swampOak
let deadBush, cactus, sugarcane = 0.2, melonPatch, kelp, hugeMushroom, shrubBush, bush, shrubBushType = "big", lilyPad, bamboo, bambooWithLeaves, jungleBush
let rock = ground > 90 ? 0.15 : 0.05, rockType = ground > 90 ? "flat" : "medium", iceberg
let grassType, flowerType, flowerDensity = 0.65, flowerNoiseSize = 0.04, grassDensity = 0.4, seagrass, groundBerries, fern //flowerDensity more is less flowers
let fallenOak, fallenBirch, fallenTallBirch, fallenCocoa, fallenSpruce, fallenTallSpruce
switch(b){
case "forest":
//bush = 2, shrubBushType = "wet", birchAndOak = 10, bigBirch = 0.5, flowerType = this.patches.forestFlowers, grassType = this.patches.grassLeaves, grassDensity = 0.15, groundBerries = 0.25
birchAndOak = 8, flowerType = this.patches.forestFlowers, grassType = this.patches.grass, grassDensity = 0.15, groundBerries = 0.25
break
case "plains":
oak = 0.1, bigOak = 0.0333333333, rock = 0, flowerType = this.patches.plainsFlowers, grassType = this.patches.tallGrass
break
case "flowerForest":
birchAndOak = 4, flowerDensity = 0.35, flowerType = this.patches.flowerForestFlowers, grassType = this.patches.grass
break
case "sunflowerPlains":
flowerDensity = 0.4, flowerType = this.patches.sunflowerPlainsFlowers, grassType = this.patches.tallGrass
break
case "meadow":
birchAndOak = 0.02, flowerDensity = 0.2, flowerNoiseSize = 0.004, rock = 0, flowerType = this.patches.meadowFlowers, grassType = this.patches.grassAndRareTallGrass, grassDensity = 0.1
break
case "birchForest":
bigBirch = 4, birch = 4, flowerType = this.patches.forestFlowers, grassType = this.patches.grassLeavesBirch, grassDensity = 0.1
break
case "oldBirchForest":
tallBirch = 7, flowerType = this.patches.forestFlowers, grassType = this.patches.grassLeavesBirch, grassDensity = 0.1
break
case "sparseJungle":
bamboo = 0.25, cocoa = 2, bigOak = 0.125, jungleBush = 2, melonPatch = true, grassType = this.patches.tallGrass, grassDensity = 0.1
worldGenArray.add(wx,ground,wz,blockIds.vine)
break
case "jungle":
bamboo = 0.25, cocoa = 4, bigJungle = 1, bigOak = 1, melonPatch = true, jungleBush = 8, bush = 2, shrubBushType = "wet", grassType = this.patches.jungle, grassDensity = 0.1, fern = 0.5
worldGenArray.add(wx,ground,wz,blockIds.vine)
break
case "bambooJungle":
bamboo = 180, bigJungle = 1, bigOak = 0.5, melonPatch = true, grassType = this.patches.grass
worldGenArray.add(wx,ground,wz,blockIds.vine)
break
case "desert":
deadBush = 1, cactus = 1, sugarcane = 0.4, rock = 0
break
case "oldSpruceTaiga":
bigOak = 0.25, oak = 0.125, bush = 1, shrubBushType = "wet", deadBush = 1, tallSpruce = 8, spruce = 1, bigSpruce = 0.25, pine = 0.25, bigPine = 0.125, rock = 1, rockType = "mossy", grassType = this.patches.fernGrassSpruceLeaves, flowerType = this.patches.flowers, groundBerries = 1, fern = 1
break
case "oldPineTaiga":
bigOak = 1, oak = 2, bush = 1, shrubBushType = "wet", deadBush = 1, tallSpruce = 0.5, pine = 1, bigPine = 2, spruce = 0.25, bigSpruce = 0.125, rock = 1, rockType = "mossy", grassType = this.patches.fernGrassSpruceLeaves, flowerType = this.patches.flowers, groundBerries = 0.5, fern = 0.75
break
case "grove":
spruce = 2, pine = 0.666666667, rock = 0
break
case "windsweptGravellyHills":
oak = 0.05, spruce = 0.0333, bigOak = 0.005, flowerDensity = 0.8, rock = 1, rockType = "small", flowerType = this.patches.flowers, grassType = this.patches.grass, grassDensity = 0.6
break
case "windsweptForest":
tallSpruce = 2, oak = 1, spruce = 0.666, bigSpruce = 0.3, bigOak = 0.1, flowerDensity = 0.8, rock = 1, rockType = "small", rock = 0, flowerType = this.patches.flowers, grassType = this.patches.grass, grassDensity = 0.6
break
case "windsweptHills":
rock = 1, rockType = "small", bigOak = 0.1, bigSpruce = 0.1
break
case "taiga":
spruce = 4, pine = 2, bigSpruce = 0.075, bigPine = 0.075, tallSpruce = 0.075, flowerDensity = 0.8, flowerType = this.patches.flowers, grassType = this.patches.fernBerries, grassDensity = 0.4
break
case "snowyTaiga":
spruce = 2, pine = 0.666, bigSpruce = 0.075, bigPine = 0.075, tallSpruce = 2, flowerDensity = 0.8, flowerType = this.patches.flowers, grassType = this.patches.fernGrass, grassDensity = 0.4
break
case "snowyPlains":
spruce = 0.08, flowerType = this.patches.flowers, flowerDensity = 0.8, grassType = this.patches.grass, grassDensity = 0.65
break
case "woodedBadlands":
oak = 4, rock = 0, grassType = this.patches.grass, grassDensity = 0.65, deadBush = 1, cactus = 0.25
break
case "badlands":
case "erodedBadlands":
deadBush = 1, cactus = 1, rock = 0
break
case "savanna":
case "savannaPlateau":
acacia = 0.75, bigAcacia = 0.05, oak = 0.1, bush = 0.5, shrubBushType = "dry", grassType = this.patches.tallGrass, flowerType = this.patches.flowers
break
case "grassySavanna":
acacia = 0.1, bigAcacia = 0.01, oak = 0.02, bush = 0.1, shrubBushType = "dry", grassType = this.patches.mostTallGrass, flowerType = this.patches.flowers, grassDensity = 0.1
break
case "shrubland":
rock = 0.1, rockType = "small", shrubBush = 16, shrubBushType = "big", oak = 1, deadBush = 2, grassType = this.patches.tallGrass, grassDensity = 0.2, flowerType = this.patches.flowers
break
case "sparseForest":
bush = 2, shrubBushType = "wet", tallBirch = 0.125, bigOak = 3, tallSpruce = 0.1, flowerType = this.patches.forestFlowers, grassType = this.patches.mostThickLeaves, grassDensity = 0.1
break
case "alpineHills":
spruce = 0.1, tallSpruce = 1, pine = 0.05, grassType = this.patches.tallGrass
break
case "darkForest":
hugeMushroom = 0.5, darkOak = 4, birchAndOak = 1, grassType = this.patches.grass, flowerType = this.patches.forestFlowers
break
case "rockyPlains":
rock = 0.2, rockType = "big", bigOak = 0.04, bigSpruce = 0.04, grassType = this.patches.tallGrass, grassDensity = 0.2
break
case "windsweptSavanna":
acacia = 0.5, grassType = this.patches.grass, flowerType = this.patches.flowers
break
case "cherryGrove":
cherry = 1, flowerType = this.patches.pinkPetals, flowerDensity = 0.3, flowerNoiseSize = 0.1, grassType = this.patches.tallGrass, grassDensity = 0.4
break
case "dryShrubland":
shrubBush = 6, shrubBushType = "dry", deadBush = 1, cactus = 1, rock = 0, sugarcane = 0.4
break
case "bambooForest":
bambooWithLeaves = 80, bush = 1, shrubBushType = "wet", grassType = this.patches.grassLeavesFern, grassDensity = 0, groundBerries = 0.5, fern = 0.1
break
case "snowySlopes":
case "frozenPeaks":
case "jaggedPeaks":
case "stonePeaks":
case "beach":
case "stonyShore":
case "snowyBeach":
rock = 0
break
case "frozenOcean":
iceberg = 0.5
break
case "deepFrozenOcean":
iceberg = 0.25
break
case "ocean":
case "deepOcean":
case "coldOcean":
case "deepColdOcean":
//kelp = 0.5, seagrass = true, grassType = this.patches.seagrass
break
case "lukewarmOcean":
case "deepLukewarmOcean":
//kelp = 0.3, seagrass = true, grassType = this.patches.seagrass
break
case "warmOcean":
//seagrass = true, grassType = this.patches.seagrass
//todo: put coral
break
case "mushroomFields":
hugeMushroom = 1, flowerType = this.patches.mushrooms, flowerDensity = 0.5, flowerNoiseSize = 0.1
break
case "rockyRiver":
lilyPad = 0.2, rock = 1, rockType = "big"
break
case "swamp":
swampOak = 4, lilyPad = 12, flowerType = this.patches.blueOrchids, flowerDensity = 0.75, grassType = this.patches.grass, deadBush = 1, hugeMushroom = 0.25
break
case "marsh":
grassType = this.patches.grass
if(ground>waterHeight+1) bush = 6, shrubBushType = "wet", deadBush = 1, grassDensity = 0.2
else if(ground>=waterHeight) grassDensity = 0.1
break
}
let under = this.getBlock(i,ground,k), aboveGround = this.getBlock(i,ground+1,k), underWater = blockData[aboveGround].liquid
useRandom(0)
if(!underWater){
if(bamboo && (under === blockIds.grass || under === blockIds.podzol) && random(256) < bamboo){
this.spawnBamboo(i,ground,k,wx,wz)
}
if(birchAndOak && under && random(256) < birchAndOak){
let rand = random()
if(rand<0.1) this.spawnBigOak(i,ground,k,wx,wz,random() > 0.9)
else this.spawnSmallTree(i,ground,k,wx,wz,rand > 0.8, random() > 0.9)
}
if(oak && under && random(256) < oak){
this.spawnSmallTree(i,ground,k,wx,wz, false)
}
if(birch && under && random(256) < birch){
this.spawnSmallTree(i,ground,k,wx,wz,true,false,true)
}
if(bigOak && under && random(256) < bigOak){
this.spawnBigOak(i,ground,k,wx,wz,random() > 0.9)
}
if(cocoa && under === blockIds.grass && random(256) < cocoa){
this.spawnJungleBush(i,k,wx,ground,wz)
}
if(jungleBush && under === blockIds.grass && random(256) < jungleBush){
this.spawnJungleBush(i,k,wx,ground,wz)
}
if(bigJungle && under === blockIds.grass && random(256) < bigJungle){
this.spawnJungleTree(i,ground,k,wx,wz)
}
if(deadBush && under && random(256) < deadBush){
this.setBlock(i,ground+1,k, blockIds.deadBush | CROSS);
}
if(cactus && under && random(256) < cactus){
this.spawnCactus(i,ground,k)
}
if(spruce && under && random(256) < spruce){
this.spawnSpruce(i,ground,k,wx,wz)
}
if(pine && under && random(256) < pine){
this.spawnPine(i,ground,k,wx,wz)
}
if(bigSpruce && under && random(256) < bigSpruce){
this.spawnBigSpruce(i,ground,k,wx,wz)
}
if(bigPine && under && random(256) < bigPine){
this.spawnBigPine(i,ground,k,wx,wz)
}
if(acacia && under && random(256) < acacia){
this.spawnAcacia(i,ground,k,wx,wz)
}
if(bigAcacia && under && random(256) < bigAcacia){
this.spawnBigAcacia(i,ground,k,wx,wz)
}
if(bigBirch && under && random(256) < bigBirch){
this.spawnBigBirch(i,ground,k,wx,wz)
}
if(tallBirch && under && random(256) < tallBirch){
this.spawnBigBirch(i,ground,k,wx,wz,true)
}
if(shrubBush && under && random(256) < shrubBush){
if(random() > 0.5){
this.spawnBush(i,ground,k,wx,wz,shrubBushType)
}else{
this.spawnShrub(i,ground,k,wx,wz,shrubBushType)
}
}
if(bush && under && random(256) < bush){
this.spawnBush(i,ground,k,wx,wz,shrubBushType)
}
if(tallSpruce && under && random(256) < tallSpruce){
this.spawnTallSpruce(i,ground,k,wx,wz)
}
if(darkOak && under && random(256) < darkOak){
this.spawnDarkOak(i,ground,k,wx,wz)
}
if(hugeMushroom && under && random(256) < hugeMushroom){
this.spawnHugeMushroom(i,ground,k,wx,wz, random()>0.5)
}
if(cherry && under && random(256) < cherry){
this.spawnCherryTree(i,ground,k,wx,wz)
}
if(bambooWithLeaves && random(256) < bambooWithLeaves && under){
this.spawnBamboo(i,ground,k,wx,wz,true)
}
}
if(swampOak && under && random(256) < swampOak){
if(random() > 0.5) this.spawnSwampOak(i,ground,k,wx,wz)
else this.spawnBigOak(i,ground,k,wx,wz,true)
}
fallenOak = (birchAndOak||oak||0) * 0.05, fallenBirch = (birchAndOak||birch||0) * 0.05, fallenTallBirch = (tallBirch||0) * 0.05
fallenCocoa = (cocoa||0) * 0.05, fallenSpruce = (spruce||pine||0) * 0.05, fallenTallSpruce = (tallSpruce||0) * 0.05
if(!underWater){
if(fallenOak && random(256) < fallenOak){
this.spawnFallenTree(i,ground,k,wx,wz,blockIds.oakLog,4,7,0.75)
}
if(fallenBirch && random(256) < fallenBirch){
this.spawnFallenTree(i,ground,k,wx,wz,blockIds.birchLog,5,8)
}
if(fallenTallBirch && random(256) < fallenTallBirch){
this.spawnFallenTree(i,ground,k,wx,wz,blockIds.birchLog,5,15)
}
if(fallenCocoa && random(256) < fallenCocoa){
this.spawnFallenTree(i,ground,k,wx,wz,blockIds.jungleLog,4,11,0.75)
}
if(fallenSpruce && random(256) < fallenSpruce){
this.spawnFallenTree(i,ground,k,wx,wz,blockIds.spruceLog,6,10)
}
if(fallenTallSpruce && random(256) < fallenTallSpruce){
this.spawnFallenTree(i,ground,k,wx,wz,blockIds.spruceLog,12,16)
}
}
useRandom(1)
if(!underWater && ground < 64 && (under === blockIds.grass || under === blockIds.sand) && mapClamped(noiseProfile.noise(wx*0.1,5,wz*0.1),0.3,0.7) < sugarcane){
if(
world.getBlock(wx+1,ground,wz,this.type) === blockIds.Water ||
world.getBlock(wx-1,ground,wz,this.type) === blockIds.Water ||
world.getBlock(wx,ground,wz+1,this.type) === blockIds.Water ||
world.getBlock(wx,ground,wz-1,this.type) === blockIds.Water
){
let block = random() > biomeData[b][1]*0.2+0.9 ? blockIds.sugarCane|SLAB : blockIds.sugarCane|CROSS
this.setBlock(i,ground+1,k, block)
this.setBlock(i,ground+2,k, block)
if(random()>0.5) this.setBlock(i,ground+3,k, block)
}
}
if(b==="trashland"){
let block=this.trashland[floor(random(this.trashland.length))]
let h = ceil(mapClamped(noiseProfile.noise(wx*0.2,7,wz*0.2),0.3,0.7)*3)
if(h===1 && !underWater && random()>0.6)block=blockIds.oil
for(let l=0;l<h;l++){
this.setBlock(i,ground+l,k, block)
}
}
if(!underWater && flowerType && blockData[under].type === "ground" && random(mapClamped(noiseProfile.noise(wx*0.1,2,wz*0.1),0.3,0.7)) > flowerDensity){
let f = flowerType[round(mapClamped(noiseProfile.noise(wx*flowerNoiseSize+flowerNoiseOffsetX,3,wz*flowerNoiseSize+flowerNoiseOffsetZ),0.3,0.7)*(flowerType.length-1))]
world.spawnBlock(wx, ground+1, wz, f, type)
}
if((!underWater || seagrass) && grassType && blockData[under].type === "ground" && random(mapClamped(noiseProfile.noise(wx*0.1,4,wz*0.1),0.3,0.7)) > grassDensity){
let f = grassType[floor(random()**3*grassType.length)] //first items are more common than last items
world.spawnBlock(wx, ground+1, wz, f, type, seagrass)
}
if(!underWater && under === blockIds.grass && mapClamped(noiseProfile.noise(wx*0.1,6,wz*0.1),0.3,0.7) > 0.9){
if(random() > 0.5){
world.spawnBlock(wx, ground+1, wz, melonPatch ? blockIds.melon : blockIds.pumpkin, type)
if(under === blockIds.grass || under === blockIds.mycelium) this.setBlock(i,ground,k,blockIds.dirt)
}
}
if(!underWater && groundBerries && blockData[under].type === "ground" && random(256) < groundBerries){
this.generatePatch(wx,ground,wz,4,this.patches.groundBerries)
}
if(!underWater && fern && blockData[under].type === "ground" && random(256) < fern){
this.generatePatch(wx,ground,wz,6,this.patches.fern)
}
if(kelp && random(mapClamped(noiseProfile.noise(wx*0.02,8,wz*0.02),0.3,0.7))>kelp){
let height = min(round(random(16,32)), 63-ground)
for(let l=0; l<height; l++){
world.spawnBlock(wx, ground+1+l, wz, l+1 === height ? blockIds.kelp : blockIds.kelpPlant, type,true)
}
}
if(lilyPad && random(256) < lilyPad && this.getBlock(i,waterHeight,k) === blockIds.Water && !this.getBlock(i,64,k)){
world.spawnBlock(wx, waterHeight+1, wz, blockIds.lilyPad, type)
}
if(aboveGround === blockIds.Water && random() < (8-Math.max((60-ground)/2/*deeper water has less disks*/,0))/256){
let disk = waterTop ? round(random(4)) : round(random(-0.6,3)), block, underBlock, replace
switch(disk){
case -1: block = blockIds.quicksand; replace = this.patches.aboveGroundDisk; break
case 0: block = blockIds.sand; replace = this.patches.sandDisk; break
case 1: block = blockIds.gravel; replace = this.patches.sandDisk; break
case 2: block = blockIds.clay; replace = this.patches.clayDisk; break
case 3: block = blockIds.grass; underBlock = blockIds.dirt; replace = this.patches.dirtDisk; break
case 4: block = blockIds.mud; replace = this.patches.sandDisk; break
}
this.spawnDisk(wx,wz, replace, block, underBlock, round(random(3,7)))
}
useRandom(4)
if(rock && random(256) < rock){
this.spawnRock(wx,ground,wz,rockType)
}
if(iceberg && random(256) < iceberg){
this.spawnIceberg(wx,wz)
}
if(waterTop && biomeData[b][1] > 0.5 && random(256)<12){
let x = wx+round(random())*8-4, z = wz+round(random())*8-4
this.spawnRock(x,world.getTop(x,z,type),z,"mossy")
}
await yieldThread()
}
}
useRandom(1)
//Place mushrooms
for (let i = 0; i < 16; i++) {
let wx = i+this.x
for (let k = 0; k < 16; k++) {
let wz = k+this.z
let b = biomes[this.biomes[k * 16 + i]]
ground = this.tops[k * 16 + i]
let mushroomChance = (biomeData[b][1]-0.5)*0.005+0.5
let top = this.solidTops[k * 16 + i]
if(top > ground+1 && mushroomChance > 0.5 && random()**2*mushroomChance > 0.5){
this.generatePatch(wx,ground,wz,2,this.patches.mushrooms)
}
}
}
useRandom(2)
if(trees) for (let i = 0; i < 16; i++) {
let wx = i+this.x
for (let k = 0; k < 16; k++) {
let wz = k+this.z
let b = biomes[this.caveBiomes[k * 16 + i]]
let caveMin = this.caveY[k*16+i]
let caveMax = this.caveY[k*16+i+256]
ground = this.tops[k * 16 + i]
if(b === "void" || caveMin === caveMax || !this.getBlock(i,caveMin-1,k) || !this.getBlock(i,caveMax+1,k)) continue
if(b === "dripstoneCaves"){
if(noiseProfile.noise(wx*0.1,22,wz*0.1) > 0.55 && !blockData[world.getBlock(wx+1,caveMin,wz)].transparent && !blockData[world.getBlock(wx-1,caveMin,wz)].transparent && !blockData[world.getBlock(wx,caveMin,wz+1)].transparent && !blockData[world.getBlock(wx,caveMin,wz-1)].transparent){
this.setBlock(i,caveMin,k,blockIds.Water)
continue
}
if(noiseProfile.noise(wx*0.04,20,wz*0.04) > 0.4){
this.setBlock(i,caveMin,k,blockIds.dripstoneBlock)
this.setBlock(i,caveMax,k,blockIds.dripstoneBlock)
}
if(random() > 0.75){
let h = round(random(8))
for(let l=1; l<h; l++){
this.setBlock(i,caveMin+l,k,blockIds.pointedDripstone)
if(caveMax-l <= caveMin+l) break
this.setBlock(i,caveMax-l,k,blockIds.pointedDripstone|FLIP)
}
for(let l=1; l<h; l++){
blockData[blockIds.pointedDripstone].spawnUpdate(trueX+i,caveMin+l,trueZ+k,blockIds.pointedDripstone,this.world,type)
if(caveMax-l <= caveMin+l) break
blockData[blockIds.pointedDripstone].spawnUpdate(trueX+i,caveMax-l,trueZ+k,blockIds.pointedDripstone|FLIP,this.world,type)
}
}
}else if(b === "lushCaves"){
if(noiseProfile.noise(wx*0.02,21,wz*0.02) > 0.55){
if(noiseProfile.noise(wx*0.05,23,wz*0.05) > 0.5 && world.getBlock(wx+1,caveMin,wz) && world.getBlock(wx-1,caveMin,wz) && world.getBlock(wx,caveMin,wz+1) && world.getBlock(wx,caveMin,wz-1)){
this.setBlock(i,caveMin,k, blockIds.Water)
}else{
this.setBlock(i,caveMin,k, blockIds.clay)
if(random() > 0.96){
let h = round(random(1,4))
if(h === 1){
this.setBlock(i,caveMin+1,k, blockIds.smallDripleaf)
}else{
for(let l=0; l<h; l++){
this.setBlock(i,caveMin+1+l,k, l === h-1 ? blockIds.bigDripleaf : (blockIds.bigDripleaf|CROSS))
}
}
}
}
}else{
this.setBlock(i,caveMin,k, blockIds.mossBlock)
let grassType = this.patches.lushCaves
if(grassType && random() > 0.5){
let f = grassType[floor(random()**3*grassType.length)] //first items are more common than last items
world.spawnBlock(wx, caveMin+1, wz, f, type)
}
}
this.setBlock(i,caveMax,k, blockIds.mossBlock)
if(random() > 0.9){
let h = round(random(1,6))
for(let l=0; l<h; l++){
this.setBlock(i, caveMax-1-l, k, (random() > 0.25 ? (l === h-1 ? blockIds.caveVines : blockIds.caveVinesPlant) : (l === h-1 ? blockIds.caveVinesLit : blockIds.caveVinesPlantLit)) | CROSS)
}
}else if(random() > 0.98){
this.setBlock(i,caveMax-1,k, blockIds.sporeBlossom)
}
}
//glow lichen
let x = wx, z = wz
let y = round(random(0,caveMax))
if(!this.getBlock(x,y,z)) continue
let block = blockIds.glowLichen | WALLFLAT
switch(floor(random()*4)){
case 0:
z++
block = block | SOUTH
break
case 1:
z--
block = block | NORTH
break
case 2:
x++
block = block | WEST
break
case 3:
x--
block = block | EAST
break
}
if(!world.getBlock(x,y,z)) world.setBlock(x,y,z,block)
//azalea trees
if(b === "lushCaves" && random() < 0.001){
let top = ground + floor(6 + random(2.5))
for (let j = ground; j <= top; j++) {
this.setBlock(i, j, k, blockIds.oakLog)
}
this.generateBlob(wx,top,wz,this.patches.azaleaLeaves, 8,1,8,0.4)
for(var l = 0; ground+l > caveMax-3; l--) {
for(var m = 0; m < 14; m++) {
let rX = round(random(-2.75, 2.75));
let rZ = round(random(-2.75, 2.75));
let here = this.getBlock(i+rX, ground+l, k+rZ)
if(here !== blockIds.grass && here !== blockIds.air) {
this.setBlock(i+rX, ground+l, k+rZ, blockIds.rootedDirt);
} else if(this.getBlock(i+rX, ground+l+1, k+rZ)===blockIds.rootedDirt) {
this.setBlock(i+rX, ground+l, k+rZ, blockIds.hangingRoots | CROSS);
}
}
}
}
await yieldThread()
}
}
useRandom(3)
this.spawnOres(this.patches.dirtOre,7,0,160,"", 8)
this.spawnOres(this.patches.gravelOre,14,0,320,"", 8)
this.spawnOres(this.patches.graniteOre,2,0,128,"", 8)
this.spawnOres(this.patches.dioriteOre,2,0,128,"", 8)
this.spawnOres(this.patches.andesiteOre,2,0,128,"", 8)
this.spawnOres(this.patches.tuffOre,2,-64,0,"", 8)
await yieldThread()
this.spawnOres(this.patches.coalOre,20,0,192,"triangle", 4)
this.spawnOres(this.patches.coalOre,30,136,320,"", 4)
this.spawnOres(this.patches.ironOre,20,-64,72,"", 3)
this.spawnOres(this.patches.ironOre,20,-24,56,"triangle", 3)
this.spawnOres(this.patches.copperOre,20,-16,112,"triangle", 3)
this.spawnOres(this.patches.redstoneOre,8,-64,15,"", 3)
await yieldThread()
this.spawnOres(this.patches.redstoneOre,16,-96,-32,"triangle", 3)
this.spawnOres(this.patches.lapisOre,4,-32,32,"triangle", 3)
this.spawnOres(this.patches.lapisOre,8,-64,64,"", 3)
this.spawnOres(this.patches.goldOre,8,-64,32,"triangle", 3)
this.spawnOres(this.patches.badlandsGoldOre,50,32,256,"", 3)
this.spawnOres(this.patches.diamondOre,16,-144,16,"triangle", 2.5)
await yieldThread()
this.spawnOres(this.patches.emeraldOre,16,-16,480,"triangle", 4)
this.spawnOres(this.patches.limestoneOre,1,0,128,"triangle", 6)
useRandom(5)
for(let i=0; i<16; i++){//spawn springs
let x = floor(random(16))
let z = floor(random(16))
let y = floor(random(-64,192))
let wx = x+trueX, wz = z+trueZ
if(
(blockData[this.getBlock(x,y,z)].type||"").startsWith("rock") &&
(
!world.getBlock(wx+1,y,wz,this.type) ||
!world.getBlock(wx-1,y,wz,this.type) ||
!world.getBlock(wx,y,wz+1,this.type) ||
!world.getBlock(wx,y,wz-1,this.type)
)
){
let block = random(-16,y)<0 ? blockIds.Lava : blockIds.Water
this.setBlock(x,y,z,block)
await blockData[block].spawnFlow(wx,y,wz,type,world)
}
}
//place snow
for (let i = 0; i < 16; i++) {
wx = trueX+i
for (let k = 0; k < 16; k++) {
wz = trueZ+k
let top = max(this.solidTops[k*16+i],waterHeight)
let block = this.getBlock(i,top,k)
if(!blockData[block].slide && getBiomeTemperature(biomes[this.biomes[k*16+i]],top)+(noiseProfile.noise(wx*0.1,wz*0.1)*2-1)*0.02 <= 0.15){
if(block === blockIds.Water){
this.setBlock(i,top,k,blockIds.ice)
}else if(blockData[block].solid && !this.getBlock(i,top+1,k)){
this.setBlock(i,top+1,k,blockIds.snow|LAYER1)
if(block === blockIds.grass){
this.setBlock(i,top,k,blockIds.grass|CROSS)
}
}
}
top = this.waterTops[k*16+i]
block = this.getBlock(i,top,k)
if(top){
let times = 0
let minTop = max(min(world.getTop(wx+1,wz,this.type),world.getTop(wx-1,wz,this.type),world.getTop(wx,wz+1,this.type),world.getTop(wx,wz-1,this.type)), waterHeight)
/*while(!blockData[world.getBlock(wx+1,top,wz,this.type)].solid+
!blockData[world.getBlock(wx-1,top,wz,this.type)].solid+
!blockData[world.getBlock(wx,top,wz+1,this.type)].solid+
!blockData[world.getBlock(wx,top,wz-1,this.type)].solid
>2 && times<3){
this.setBlock(i,top,k,blockIds.air)
times++
top--
}*/
for(let y=top; y>minTop; y--){
if(blockData[this.getBlock(i,y,k)].solid) this.setBlock(i,y,k,blockIds.air)
}
if(getBiomeTemperature(biomes[this.biomes[k*16+i]],minTop) <= 0.15){
this.setBlock(i,minTop,k,blockIds.ice)
}else{
this.setBlock(i,minTop,k,blockIds.Water)
await blockData[blockIds.Water].spawnFlow(wx,minTop,wz,type,world)
}
}
}
}
this.waterTops = null
}
useRandom(1)
if(worldGenArray.size){
for(var l=0; l<round(worldGenArray.size*0.75); l++){
var rnd = (random()*worldGenArray.size)|0
var block = worldGenArray.array[rnd][3]
let x = worldGenArray.array[rnd][0], y = worldGenArray.array[rnd][1], z = worldGenArray.array[rnd][2]
if(block === blockIds.vine){
block = block | WALLFLAT
switch(floor(random()*4)){
case 0:
z++
block = block | SOUTH
break
case 1:
z--
block = block | NORTH
break
case 2:
x++
block = block | WEST
break
case 3:
x--
block = block | EAST
break
}
let length = round(random(1,8))
for(var m=0; m<length; m++){
if(world.getBlock(x,y-m,z,type)) break
world.spawnBlock(x,y-m,z,block,type)
}
}else if(block === blockIds.cocoa){
switch(floor(random(3))){
case 1:
block |= SLAB
break
case 2:
block |= STAIR
break
}
switch(floor(random(4))){
case 0:
z++
block = block | SOUTH
break
case 1:
z--
block = block | NORTH
break
case 2:
x++
block = block | WEST
break
case 3:
x--
block = block | EAST
break
}
world.spawnBlock(x,y,z,block,type)
}else if(block === blockIds.mossCarpet){
block = block | VERTICALSLAB
switch(floor(random()*4)){
case 0:
z++
block = block | SOUTH
break
case 1:
z--
block = block | NORTH
break
case 2:
x++
block = block | WEST
break
case 3:
x--
block = block | EAST
break
}
world.spawnBlock(x,y,z,block,type)
}
}
}
//Structures
//dont use random after because generateStructureLayout calls randomSeed
if(trees && !world.superflat){
let genStructs = []
for(let x = Math.floor((this.x-structureCheckDist)/structureSpacing)*structureSpacing; x <= Math.ceil((this.x+structureCheckDist)/structureSpacing)*structureSpacing; x+=structureSpacing){
for(let z = Math.floor((this.z-structureCheckDist)/structureSpacing)*structureSpacing; z <= Math.ceil((this.z+structureCheckDist)/structureSpacing)*structureSpacing; z+=structureSpacing){
let i=0
for(let s of structures){
i++
if(hash3(x,z,i)<s.chance){
let struct = world.structureData[x+","+z+","+type]
if(!struct) world.structureData[x+","+z+","+type] = struct = this.generateStructureLayout(x,z,s)
genStructs.push(struct)
break
}
}
}
}
for(let s of genStructs){
for(let j of s){
let {x,y,z,data:jigsaw} = j
let {w,h,d,data} = jigsaw
if(!(
x < this.x+16 &&
x+w >= this.x &&
z < this.z+16 &&
z+d >= this.z
)) continue
if(jigsaw.onGround){
y = world.getTop(x+jigsaw.centerPos[0],z+jigsaw.centerPos[2],type)-jigsaw.centerPos[1]
}
let {rotN, rotS, rotE, rotW} = jigsaw
for(let i=0;i<data.length;i+=4){
const bx = data[i]+x
const bz = data[i+2]+z
const by = data[i+1] + (jigsaw.flatOnGround ? this.tops[(bz-this.z)*16+(bx-this.x)] : y)
if(!(
bx < this.x+16 &&
bx >= this.x &&
bz < this.z+16 &&
bz >= this.z
)) continue
let block = data[i+3]
const prevBlock = this.getBlock(bx-this.x,by,bz-this.z)
if(typeof block === "function") block = block(rotN,rotE,rotS,rotW,bx,by,bz,prevBlock)
if(typeof block === "string") block = blockIds[block]
if(block === undefined) continue
this.setBlock(bx-this.x,by,bz-this.z,block)
if(block && blockData[block].solid){
const under = this.getBlock(bx-this.x,by-1,bz-this.z)
if(under === blockIds.grass){
this.setBlock(bx-this.x,by-1,bz-this.z,blockIds.dirt)
}
}
}
}
}
}
/*if(trees && !world.superflat && random() > 0.96){
let rnd = random(256)
let x = (rnd >> 4) + this.x
let z = (rnd & 15) + this.z
let structure = structureArr[Math.floor(random(structureArr.length))]
let rot = Math.floor(random(4))
let {data,w,h,d} = structures[structure].variants[rot]
let rotS, rotE, rotW
switch(rot){
case 0:
rot = NORTH
rotE = EAST
rotS = SOUTH
rotW = WEST
break
case 1:
rot = EAST
rotE = NORTH
rotS = WEST
rotW = SOUTH
break
case 2:
rot = SOUTH
rotE = WEST
rotS = NORTH
rotW = EAST
break
case 3:
rot = WEST
rotE = SOUTH
rotS = EAST
rotW = NORTH
break
}
let y = structures[structure].getY(x,z,rnd)
x -= Math.round(w/2)
y -= Math.round(h/2)
z -= Math.round(d/2)
for(let i=0;i<data.length;i+=4){
let block = data[i+3]
if(!block) continue
if(typeof block === "function") block = block(rot,rotE,rotS,rotW)
if(typeof block === "string") block = blockIds[block]
world.spawnBlock(x+data[i],y+data[i+1],z+data[i+2],block,type,true)
}
}*/
this.populated = true
}
rndStructVariant(structure){
const rot = Math.floor(random(structure.variants.length))
let j = structure.variants[rot]
switch(rot){
case 0:
j.rotN = NORTH
j.rotE = EAST
j.rotS = SOUTH
j.rotW = WEST
break
case 1:
j.rotN = EAST
j.rotE = SOUTH
j.rotS = WEST
j.rotW = NORTH
break
case 2:
j.rotN = SOUTH
j.rotE = WEST
j.rotS = NORTH
j.rotW = EAST
break
case 3:
j.rotN = WEST
j.rotE = NORTH
j.rotS = EAST
j.rotW = SOUTH
break
}
return structure.variants[rot]
}
generateStructureLayout(x,z,structure){
randomSeed(hash(x, z) * 210000000)
let sx = x+Math.floor(random(structureSpacing))//start position
let sz = z+Math.floor(random(structureSpacing))
let sy = structure.getY(sx,sz,random())
let layout = [{
data: this.rndStructVariant(jigsaws[structure.start[Math.floor(random(structure.start.length))]]),
x:sx,
y:sy,
z:sz
}]
if(structure.type === "compound"){
let adds = layout[0].data.newJigsawTries ? [...layout] : []
addLoop:for(let i=0; i<structure.maxTries; i++){
if(!adds.length) break
let addIdx = Math.floor(
(random() > 0.5 ? 
(1-(1-random())**2)
: random()
)*adds.length)
let addTo = adds[addIdx]
if(!addTo.data.newJigsawTries) continue
tryAddLoop:for(let t=0; t<addTo.data.newJigsawTries; t++){
let addPos = addTo.data.nextJigsawPos[Math.floor(random(addTo.data.nextJigsawPos.length))]
let newJigsaw = this.rndStructVariant(jigsaws[addPos[3]])
let nx = addPos[0]+addTo.x-newJigsaw.centerPos[0]
let ny = addPos[1]+addTo.y-newJigsaw.centerPos[1]
let nz = addPos[2]+addTo.z-newJigsaw.centerPos[2]
if(!(
nx < sx+structure.maxSize &&
nx+newJigsaw.w-1 > sx-structure.maxSize &&
ny < sy+structure.maxSize &&
ny+newJigsaw.h-1 > sy-structure.maxSize &&
nz < sz+structure.maxSize &&
nz+newJigsaw.d-1 > sz-structure.maxSize
)) continue tryAddLoop
for(let j of layout){
if(
//allow overlap by 1 block on x and z
nx < j.x+j.data.w-1 &&
nx+newJigsaw.w-1 > j.x &&
ny <= j.y+j.data.h-1 &&
ny+newJigsaw.h-1 >= j.y &&
nz < j.z+j.data.d-1 &&
nz+newJigsaw.d-1 > j.z
/*:
nx < j.x+j.data.w &&
nx+newJigsaw.w >= j.x &&
ny < j.y+j.data.h &&
ny+newJigsaw.h >= j.y &&
nz < j.z+j.data.d &&
nz+newJigsaw.d >= j.z*/
) continue tryAddLoop //Prevent overlap
}
let add = {
data:newJigsaw,
x:nx, y:ny, z: nz
}
layout.push(add)
if(newJigsaw.newJigsawTries) adds.push(add)
if(layout.length >= structure.jigsawCount) break addLoop
}
}
}
return layout
}
tick() {
const {world} = this
if (this.edited) {
for (let i = 0; i < this.sections.length; i++) {
if (this.sections[i].edited) {
this.sections[i].tick()
}
}
}
if(this.allGenerated) for (let i in this.entities) {
const entity = this.entities[i]
entity.update()
if (entity.canDespawn || (entity.y <= minEntityY)) {
world.deleteEntity(i)
}
}
if(this.world.weather)weatherStuff:{
let x = rand(16) | 0, z = rand(16) | 0
snow:if(this.world.weather === "snow" || this.world.weather === "rain"){
if(this.world.weather === "rain" && getBiomeTemperature(biomes[this.biomes[z * 16 + x]]) > 0.15) break snow
if(this.edited && rand(this.world.weatherAmount) > 0.9){
let y = this.solidTops[z * 16 + x]
if(y < minHeight || y > weatherHeight) break snow
let b = this.getBlock(x,y,z), blockMode, set
let layer = 0
if((b & LAYER1) === LAYER1) layer = 1
if((b & LAYER2) === LAYER2) layer = 2
if((b & LAYER3) === LAYER3) layer = 3
if((b & LAYER4) === LAYER4) layer = 4
if((b & LAYER5) === LAYER5) layer = 5
if((b & LAYER6) === LAYER6) layer = 6
if((b & LAYER7) === LAYER7) layer = 7
if((b & LAYER8) === LAYER8) layer = 8
if(((b & blockIds.snow) === blockIds.snow) && layer > 0 && layer < 8){
layer ++
switch(layer){
case 2:
blockMode = LAYER2
break
case 3:
blockMode = LAYER3
break
case 4:
blockMode = LAYER4
break
case 5:
blockMode = LAYER5
break
case 6:
blockMode = LAYER6
break
case 7:
blockMode = LAYER7
break
case 8:
blockMode = LAYER8
break
}
set = true
}else if(!this.getBlock(x,y+1,z)){
blockMode = LAYER1
y++
set = true
}
if(set) world.setBlock(x+this.x,y,z+this.z, blockIds.snow | blockMode, false,false,false,false,this.type)
}
break weatherStuff
}
}
if(this.world.settings.mobSpawning){
for(let s of this.sections) s.spawnMobs()
}
}
load() {
if (this.loaded) {
return
}
const { world } = this
let chunkX = this.x >> 4
let chunkZ = this.z >> 4
let str = `${chunkX},${chunkZ},${this.type}`
let load = world.loadFrom[str]
if (load) {
for (let j in load.blocks) {
let block = load.blocks[j], tags = load.tags[j]
if(!blockData[block]) continue
const z = j & 15, x = (j >> 4) & 15, y = (j >> 8) + minHeight
this.setBlock(x,y,z,block,world)
if(tags) this.setTags(x,y,z,tags)
}
delete world.loadFrom[str]
}
this.loaded = true
}
async getData(){
/*according to artificial intelligence:
There are several techniques you can use to optimize JavaScript code that compresses data by checking patterns in an array:
1. Use a more efficient pattern matching algorithm: Look for specific patterns in the array data and use more optimized pattern matching algorithms, such as the Knuth-Morris-Pratt (KMP) algorithm or the Boyer-Moore algorithm.
2. Implement memoization: If your compression algorithm involves performing repetitive computations on the same array elements, memoization can help you store the results of these computations and avoid redundant operations.
3. Utilize data structures: Choose appropriate data structures to improve the speed of pattern searching. For example, you can use hash tables or sets to store patterns and quickly check for their existence.
4. Optimize loops and iteration: Make sure your loop code is as efficient as possible by minimizing unnecessary iterations and avoiding excessive function calls or variable lookups within the loop.
5. Parallelize operations: If the pattern matching operations can be executed independently, consider parallelizing the code using technologies like Web Workers or ES2017's async/await, which can help utilize multiple CPU cores efficiently.
6. Leverage built-in JavaScript functions: Use standard JavaScript functions that are specifically designed for performance-critical operations. For example, the `indexOf()` or `includes()` functions can quickly search for patterns in arrays.
7. Avoid unnecessary memory allocations: Minimize additional memory allocations by reusing existing variables or arrays instead of creating new ones.
8. Perform benchmarking and profiling: Measure the performance of your code using browser developer tools and profiling tools to identify bottlenecks and areas for optimization.
Remember to balance optimization with maintainability and readability. Sometimes, heavily optimized code can become hard to understand and debug. Aim for a balance that achieves a good trade-off between performance and code maintainability.
*/
let ax, ay, az, idx
let blockSet = new Set()
let sections = []
let sectionMap = [], sectionTags = [], sectionTagsLength = [], sectionSkyLights = [], sectionBlockLights = []
for (let y = 0; y < this.sections.length; y++) {
const section = this.sections[y], blocks = section.blocks, tags = section.tags, skyLight = section.skyLight, blockLight = section.blockLight
for (let i = 0; i < blocks.length; i++) {
if(blocks[i]){
blockSet.add(blocks[i])
ax = (i >> 8)
ay = (i >> 4 & 15) + section.y - minHeight
az = (i & 15)
//let str = `${x>>3},${y>>3},${z>>3}` // 8x8x8 sections
idx = (ax>>3) | (az>>3)<<1 | (ay>>3)<<2
if (!sectionMap[idx]) {
sectionMap[idx] = []
for (let k = 0; k < 6; k++) sectionMap[idx].push(new Int32Array(512).fill(-1))
sectionTags[idx] = []
sectionTagsLength[idx] = 0
sections.push(idx)
}
// 6 copies of the chunk, all oriented in different directions so we can see which one compresses the most
sectionMap[idx][0][(ay & 7) << 6 | (ax & 7) << 3 | az & 7] = blocks[i]
sectionMap[idx][1][(ay & 7) << 6 | (az & 7) << 3 | ax & 7] = blocks[i]
sectionMap[idx][2][(ax & 7) << 6 | (ay & 7) << 3 | az & 7] = blocks[i]
sectionMap[idx][3][(ax & 7) << 6 | (az & 7) << 3 | ay & 7] = blocks[i]
sectionMap[idx][4][(az & 7) << 6 | (ax & 7) << 3 | ay & 7] = blocks[i]
sectionMap[idx][5][(az & 7) << 6 | (ay & 7) << 3 | ax & 7] = blocks[i]
if(tags[i]){
sectionTags[idx][(ay & 7) << 6 | (ax & 7) << 3 | az & 7] = typeof tags[i] === "number" ? tags[i] : JSON.stringify(tags[i])
sectionTagsLength[idx]++
}
}
lightcheck:if(skyLight[i]){
ax = (i >> 8)
ay = (i >> 4 & 15) + section.y - minHeight
az = (i & 15)
idx = (ax>>3) | (az>>3)<<1 | (ay>>3)<<2
if(!sectionSkyLights[idx]){
sectionSkyLights[idx] = []
for (let k = 0; k < 6; k++) sectionSkyLights[idx].push(new Uint8Array(512))
sections.push(idx)
}
sectionSkyLights[idx][0][(ay & 7) << 6 | (ax & 7) << 3 | az & 7] = skyLight[i]
sectionSkyLights[idx][1][(ay & 7) << 6 | (az & 7) << 3 | ax & 7] = skyLight[i]
sectionSkyLights[idx][2][(ax & 7) << 6 | (ay & 7) << 3 | az & 7] = skyLight[i]
sectionSkyLights[idx][3][(ax & 7) << 6 | (az & 7) << 3 | ay & 7] = skyLight[i]
sectionSkyLights[idx][4][(az & 7) << 6 | (ax & 7) << 3 | ay & 7] = skyLight[i]
sectionSkyLights[idx][5][(az & 7) << 6 | (ay & 7) << 3 | ax & 7] = skyLight[i]
}
lightcheck:if(blockLight[i]){
ax = (i >> 8)
ay = (i >> 4 & 15) + section.y - minHeight
az = (i & 15)
idx = (ax>>3) | (az>>3)<<1 | (ay>>3)<<2
if(!sectionBlockLights[idx]){
sectionBlockLights[idx] = []
for (let k = 0; k < 6; k++) sectionBlockLights[idx].push(new Uint8Array(512))
sections.push(idx)
}
sectionBlockLights[idx][0][(ay & 7) << 6 | (ax & 7) << 3 | az & 7] = blockLight[i]
sectionBlockLights[idx][1][(ay & 7) << 6 | (az & 7) << 3 | ax & 7] = blockLight[i]
sectionBlockLights[idx][2][(ax & 7) << 6 | (ay & 7) << 3 | az & 7] = blockLight[i]
sectionBlockLights[idx][3][(ax & 7) << 6 | (az & 7) << 3 | ay & 7] = blockLight[i]
sectionBlockLights[idx][4][(az & 7) << 6 | (ax & 7) << 3 | ay & 7] = blockLight[i]
sectionBlockLights[idx][5][(az & 7) << 6 | (ay & 7) << 3 | ax & 7] = blockLight[i]
}
}
await yieldThread()
}
let bab = new BitArrayBuilder()
let blocks = Array.from(blockSet)
let palette = {}
blocks.forEach((block, index) => palette[block] = index)
let paletteBits = BitArrayBuilder.bits(blocks.length)
bab.add(blocks.length, 32)
for (let block of blocks) bab.add(block, 32)
bab.add(sections.length, 32)
for (let coords of sections) {
let sx = coords&1, sz = (coords>>1)&1, sy = coords>>2
bab.add(sx, 1).add(sy, 8).add(sz, 1)
// Determine the most compact orientation by checking all 6!
let bestLength = Infinity, bestRuns, bestSingles, bestDir, bestSkyLightRuns, bestBlockLightRuns
for (let i = 0; i < 6; i++) {
let blocks = sectionMap[coords] && sectionMap[coords][i]
let thisLength = 0
let runs = []
let singles = []
if(blocks){
let run = null
for (let i = 0; i < blocks.length; i++) {
const block = blocks[i]
if (block >= 0) {
if (run) {
if (block === run[1][run[1].length-1][1]) run[1][run[1].length-1][0]++
else run[1].push([1, block])
}else if (i < blocks.length - 2 && blocks[i + 1] >= 0 && blocks[i + 2] >= 0) {
run = [i, [[1, block]]]
runs.push(run)
}else singles.push([i, blocks[i]])
}
else run = null
}
for (let run of runs) {
// Determine the number of bits needed to store the lengths of each block type
let maxBlocks = 0
for (let block of run[1]) maxBlocks = Math.max(maxBlocks, block[0])
let lenBits = BitArrayBuilder.bits(maxBlocks)
thisLength += 9+9+4
thisLength += run[1].length*(lenBits+paletteBits)
run[2] = lenBits
}
thisLength += singles.length*(9+paletteBits)
}
let slights = sectionSkyLights[coords] && sectionSkyLights[coords][i], blights = sectionBlockLights[coords] && sectionBlockLights[coords][i]
let skyLightRuns = [], blockLightRuns = []
if(slights){
let run = null, run2 = null
for (let i = 0; i < slights.length; i++) {
const level = slights[i]
if (level > 0) {
if (run) {
if (level === run[1][run[1].length-1][1]+(run[1][run[1].length-1][2]*run[1][run[1].length-1][0])) run[1][run[1].length-1][0]++
else run[1].push([1, level, (slights[i+1]||0)-level])
}else{
run = [i, [[1, level, (slights[i+1]||0)-level]]]//The 3rd item is which way the gradient goes
skyLightRuns.push(run)
}
}else run = null
}
for (let run of skyLightRuns) {
let maxBlocks = 0
for (let block of run[1]) maxBlocks = Math.max(maxBlocks, block[0])
let lenBits = BitArrayBuilder.bits(maxBlocks)
thisLength += 9+9+4
thisLength += run[1].length*(lenBits+8+5)
run[2] = lenBits
}
}
if(blights){
let run = null, run2 = null
for (let i = 0; i < blights.length; i++) {
const level = blights[i]
if (level > 0) {
if (run) {
if (level === run[1][run[1].length-1][1]+(run[1][run[1].length-1][2]*run[1][run[1].length-1][0])) run[1][run[1].length-1][0]++
else run[1].push([1, level, (blights[i+1]||0)-level])
}else{
run = [i, [[1, level, (blights[i+1]||0)-level]]]//The 3rd item is which way the gradient goes
blockLightRuns.push(run)
}
}else run = null
}
for (let run of blockLightRuns) {
let maxBlocks = 0
for (let block of run[1]) maxBlocks = Math.max(maxBlocks, block[0])
let lenBits = BitArrayBuilder.bits(maxBlocks)
thisLength += 9+9+4
thisLength += run[1].length*(lenBits+4+9)
run[2] = lenBits
}
}
if (thisLength < bestLength) {
bestLength = thisLength
bestRuns = runs
bestSingles = singles
bestDir = i
bestSkyLightRuns = skyLightRuns
bestBlockLightRuns = blockLightRuns
}
await yieldThread()
}
bab.add(bestDir, 3)
bab.add(bestRuns.length, 8)
bab.add(bestSingles.length, 9)
for (let [start, blocks, lenBits] of bestRuns) {
bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
for (let [count, block] of blocks) bab.add(count - 1, lenBits).add(palette[block], paletteBits)
}
for (let [index, block] of bestSingles) {
bab.add(index, 9).add(palette[block], paletteBits)
}
bab.add(sectionTagsLength[coords] || 0,9)
if(sectionTagsLength[coords]) for(let i in sectionTags[coords]){
let tags = sectionTags[coords][i]
bab.add(i,9)
if(typeof tags === "number"){
bab.add(0,1)
bab.add(tags,32)
}else{
bab.add(1,1)
bab.addString(tags,16)
}
}
bab.add(bestSkyLightRuns.length, 9)
for (let [start, blocks, lenBits] of bestSkyLightRuns) {
bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
for (let [count, level, gradDir] of blocks) bab.add(count - 1, lenBits).add(level, 8).add(gradDir, 9)
}
bab.add(bestBlockLightRuns.length, 9)
for (let [start, blocks, lenBits] of bestBlockLightRuns) {
bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
for (let [count, level, gradDir] of blocks) bab.add(count - 1, lenBits).add(level, 4).add(gradDir, 5)
}
await yieldThread()
}
return bab.array
}
}
let explodeSounds = ["random.explode1", "random.explode2", "random.explode3", "random.explode4"]
function explodeSound(x,y,z, power = 1, world){
var sound, soundPower
//explodeSounds[Math.floor(Math.random()*explodeSounds.length)]
if(power >= 10) {sound = explodeSounds[0], soundPower = 10}
else if(power >= 8) {sound = explodeSounds[1], soundPower = 8}
else if(power >= 4) {sound = explodeSounds[2], soundPower = 4}
else {sound = explodeSounds[3], soundPower = 1}
var pitch = 1 - ((power - soundPower) / 10)
if(pitch <= 0) return
world.playSound(x,y,z,sound,1, pitch)
}
let doorSounds = {
fence_gateOpen:2,
fence_gateClose:2,
wooden_doorOpen:4,
wooden_doorClose:6,
iron_doorOpen:4,
iron_doorClose:4,
wooden_trapdoorOpen:5,
wooden_trapdoorClose:3,
iron_trapdoorOpen:4,
iron_trapdoorClose:4
}
function doorSound(x,y,z,type,open, world){
let a = doorSounds[type+(open?"Open":"Close")]
var i = type+"."+(open?"open":"close")+Math.ceil(Math.random()*a)
world.playSound(x,y,z,i)
}
function fall(x,y,z,b,world, instant,dimension, solid = true){
if(!world.settings.blocksFall || world.getBlock(x,y-1,z,dimension)) return
if(instant){
world.setBlock(x,y,z, 0, false,false,false,false,dimension)
world.addEntity(new entities[entityIds.BlockEntity](b, x,y,z, solid),false,dimension)
}else{
world.setTimeout(() => {
if(world.getBlock(x,y-1,z,dimension)) return
world.setBlock(x,y,z, 0, false,false,false,false,dimension)
world.addEntity(new entities[entityIds.BlockEntity](b, x,y,z, solid),false,dimension)
}, tickTime, x,y,z,dimension)
}
return true
}
function needsSupportingBlocks(x,y,z, b,world,dimension){ // if block under is gone, dissapear
if(!world.settings.blocksFall) return
var under = world.getBlock(x,y-1,z,dimension)
if(!under || !blockData[under].solid){
world.setTimeout(() => {
var under = world.getBlock(x,y-1,z,dimension)
if(under && blockData[under].solid) return
world.setBlock(x,y,z, 0,false,false,false,false,dimension)
world.addItems(x,y,z,dimension,0,0,0,b&isCube,true)
world.blockParticles(b,x,y,z,30, "break",dimension)
world.blockSound(b, "dig", x,y,z)
}, tickTime, x,y,z,dimension)
return true
}
}
function putItemInContainer(x,y,z,dimension,id,durability,customName,lazy,world){
var tags = world.getTags(x,y,z,dimension)
if(typeof tags === "number") return false
if(!tags || !tags.contents){
var block = world.getBlock(x,y,z,dimension)
if(blockData[block].setContents) tags = blockData[block].setContents(x,y,z,dimension,world)
else return false
}
for(var i=0; i<tags.contents.length; i++){
if(!tags.contents[i]){
tags.contents[i] = {id,amount:1,durability,customName}
if(!lazy) world.setTags(x,y,z,tags,false,dimension)
return true
}else if(tags.contents[i].id === id && (!tags.contents[i].customName && !customName || tags.contents[i].customName === customName) && tags.contents[i].amount < blockData[id].stackSize){
tags.contents[i].amount++
if(!lazy) world.setTags(x,y,z,tags,false,dimension)
return true
}
}
return false
}
function getContainerFullness(x,y,z,dimension,world){
var tags = world.getTags(x,y,z,dimension)
var block = world.getBlock(x,y,z,dimension)
if(tags && blockData[block].name === "furnace"){
return (
(tags.input && tags.input.id && tags.input.amount / blockData[tags.input.id].stackSize || 0)
+(tags.output && tags.output.id && tags.output.amount / blockData[tags.output.id].stackSize || 0)
+(tags.fuel && tags.fuel.id && tags.fuel.amount / blockData[tags.fuel.id].stackSize || 0)
) / 3
}else if(blockData[block].name === "composter"){
return blockData[block].getLevel(block) / 16
}else if(blockData[block].name === "endPortalFrame"){
return ((block & SLAB) === SLAB) * 1
}else if(tags && blockData[block].itemFrame){
return (tags.rot || 0) / 16
}else if((typeof tags === "object") && tags.contents){
var f = 0
for(var i of tags.contents){
if(i && i.id) f += i.amount / blockData[i.id].stackSize
}
f /= tags.contents.length
return f
}
}
let nearEntityArray = []
function pressurePlateHasPressure(x,y,z,dimension,world){
world.getEntitiesNear(x,y,z,dimension, 2, nearEntityArray)
for(var ent of nearEntityArray){
let w2 = ent.width/2, h2 = ent.height/2, d2 = ent.depth/2
if(x - 0.5 < ent.x + w2 &&
x + 0.5 > ent.x - w2 &&
y - 0.5 < ent.y + h2 &&
y - 0.25 > ent.y - h2 &&
z - 0.5 < ent.z + d2 &&
z + 0.5 > ent.z - d2) return true
}
for(let ent of world.players){
let w2 = ent.width/2, h2 = ent.height/2, d2 = ent.depth/2
if(x - 0.5 < ent.x + w2 &&
x + 0.5 > ent.x - w2 &&
y - 0.5 < ent.y + h2 &&
y - 0.25 > ent.y - h2 &&
z - 0.5 < ent.z + d2 &&
z + 0.5 > ent.z - d2) return true
}
return false
}
function hitSound(p){
var i = Math.ceil(Math.random()*3)
p.world.sendAll({type:"playSound", data:"damage.hit"+i, x:p.x,y:p.y,z:p.z})
}
function drownHurtSound(p){
var i = Math.ceil(Math.random()*4)
p.world.sendAll({type:"playSound", data:"damage.drown"+i, x:p.x,y:p.y,z:p.z})
}
function freezeHurtSound(p){
var i = Math.ceil(Math.random()*5)
p.world.sendAll({type:"playSound", data:"damage.freeze"+i, x:p.x,y:p.y,z:p.z})
}
function fireHurtSound(p){
var i = Math.ceil(Math.random()*3)
p.world.sendAll({type:"playSound", data:"damage.fire"+i, x:p.x,y:p.y,z:p.z})
}
function berrybushHurtSound(p){
var i = Math.ceil(Math.random()*2)
p.world.sendAll({type:"playSound", data:"damage.berrybush"+i, x:p.x,y:p.y,z:p.z})
}
function oofSound(p){
p.world.sendAll({type:"playSound", data:"damage.classic_hurt", x:p.x,y:p.y,z:p.z})
}
function getEntityOrPlayer(id,world){
for(let p of world.players){
if(p.id === id) return p
}
for(let i=0; i<world.entities.length; i++){
if(world.entities[i].id === id){
return world.entities[i]
}
}
}
function getPlayerByUsername(username2,world){
for(let p of world.players){
if(p.username === username2) return p
}
}
function getPlayerById(id,world){
for(let p of world.players){
if(p.id === id) return p
}
}
let entPlayerCollided
function entCollided(ent){
var w2 = ent.width/2, h2 = ent.height/2, d2 = ent.depth/2
entPlayerCollided = false
ent.world.getEntitiesNear(ent.x,ent.y,ent.z,ent.dimension, 2, nearEntityArray)
for(var e of nearEntityArray){
if(e === ent || e.dimension !== ent.dimension) continue
let ew2 = e.width/2, eh2 = e.height/2, ed2 = e.depth/2
if(ent.x - w2 < e.x + ew2 &&
ent.x + w2 > e.x - ew2 &&
ent.y - h2 < e.y + eh2 &&
ent.y - h2 > e.y - eh2 &&
ent.z - d2 < e.z + ed2 &&
ent.z + d2 > e.z - ed2) return e
}
for(let e of ent.world.players){
if(e === ent || e.dimension !== ent.dimension || e.hidden || e.die) continue
let ew2 = e.width/2, eh2 = e.height/2, ed2 = e.depth/2
if(ent.x - w2 < e.x + ew2 &&
ent.x + w2 > e.x - ew2 &&
ent.y - h2 < e.y + eh2 &&
ent.y - h2 > e.y - eh2 &&
ent.z - d2 < e.z + ed2 &&
ent.z + d2 > e.z - ed2){
entPlayerCollided = true
return e
}
}
}
function getSignSide(tags,p){
let ry = p.ry*16/Math.PId
let diff = tags.rot - ry
if(diff < 0) diff += 16
if(diff >= 16) diff -= 16
return diff>4 && diff<12
}
function maxDist(x, z, x2, z2) {
let ax = abs(x2 - x)
let az = abs(z2 - z)
return max(ax, az)
}
let chunkPlayerDistArr = []
let sortChunkPX = 0
let sortChunkPZ = 0
function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
let dx1 = sortChunkPX - c1.x - 8
let dy1 = sortChunkPZ - c1.z - 8
let dx2 = sortChunkPX - c2.x - 8
let dy2 = sortChunkPZ - c2.z - 8
return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2)
}
const {
seedHash,
hash, hash3
} = (() => {
// closure around mutable `seed`; updated via calls to `seedHash`
let seed = Math.random() * 2100000000 | 0;
const PRIME32_2 = 1883677709;
const PRIME32_3 = 2034071983;
const PRIME32_4 = 668265263;
const PRIME32_5 = 374761393;
const seedHash = s => {
seed = s | 0;
}
const { imul } = Math;
const hash = (x, y) => {
let h32 = 0;
h32 = seed + PRIME32_5 | 0;
h32 += 8;
h32 += imul(x, PRIME32_3);
h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
h32 += imul(y, PRIME32_3);
h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
h32 ^= h32 >> 15;
h32 *= PRIME32_2;
h32 ^= h32 >> 13;
h32 *= PRIME32_3;
h32 ^= h32 >> 16;
return h32 / 2147483647;
};
const hash3 = (x, y, z) => {
let h32 = 0;
h32 = seed + PRIME32_5 | 0;
h32 += 8;
h32 += imul(x, PRIME32_3);
h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
h32 += imul(y, PRIME32_3);
h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
h32 += imul(z, PRIME32_3);
h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
h32 ^= h32 >> 15;
h32 *= PRIME32_2;
h32 ^= h32 >> 13;
h32 *= PRIME32_3;
h32 ^= h32 >> 16;
return h32 / 2147483647;
};
return {
seedHash,
hash, hash3
};
})();
class Marsaglia {
// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c
nextInt() {
const { z, w } = this;
this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;
return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
}
nextDouble() {
const i = this.nextInt() / 4294967296;
const is_less_than_zero = (i < 0) | 0; // cast to 1 or 0
return is_less_than_zero + i;
}
constructor(i1, i2) { // better param names
this.z = (i1 | 0) || 362436069;
this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
}
}
// The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls
const {
randomSeed,
random,
useRandom
} = (() => {
// closure around mut `currentRandom`
let currentRandoms = [], currentRandom, currentRandomId
let randoms = {}
const randomSeed = seed => {
currentRandoms.length = 0
currentRandoms.push(new Marsaglia(seed))
for(let i=0; i<5; i++) currentRandoms.push(new Marsaglia(hash(seed,i) * 210000000))
//Random types: Trees, grass and flowers, cave foliage, ores, rocks
currentRandom = currentRandoms[0]
};
function useRandom(id){
currentRandomId = id
currentRandom = currentRandoms[id]
}
const random = (min, max) => {
if (!max) {
if (min) {
max = min;
min = 0;
} else {
min = 0;
max = 1;
}
}
return currentRandom.nextDouble() * (max - min) + min;
};
win.serverRandomRandom = () => currentRandom = new Marsaglia(Math.random() * 210000000)
win.serverRestoreRandom = () => currentRandom = currentRandom[currentRandomId]//prevent random in populate from messing up because it is async
return {
randomSeed,
random,
useRandom
};
})()
let savedWorldGenArrayLen
win.serverSaveWorldGen = () => {
win.serverRandomRandom()
savedWorldGenArrayLen = worldGenArray.size
}
win.serverRestoreWorldGen = () => {
win.serverRestoreRandom()
worldGenArray.size = savedWorldGenArrayLen
}
class PerlinNoise {
// http://www.noisemachine.com/talk1/17b.html
// http://mrl.nyu.edu/~perlin/noise/
static grad3d(i, x, y, z) {
const h = i & 15; // convert into 12 gradient directions
const u = h < 8
? x
: y;
const v = h < 4
? y
: h === 12 || h === 14
? x
: z;
return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
}
static grad2d(i, x, y) {
const v = (i & 1) === 0
? x
: y;
return (i & 2) === 0
? -v
: v;
}
static grad1d(i, x) {
return (i & 1) === 0
? -x
: x;
}
static lerp(t, a, b) {
return a + t * (b - a);
}
// end of statics
// permutation
perm = new Uint8Array(0x200);
// prototype functions:
noise3d(x, y, z) {
const { floor } = Math;
const X = floor(x) & 0xff;
const Y = floor(y) & 0xff;
const Z = floor(z) & 0xff;
x -= floor(x);
y -= floor(y);
z -= floor(z);
const fx = (3 - 2 * x) * x * x;
const fy = (3 - 2 * y) * y * y;
const fz = (3 - 2 * z) * z * z;
const { perm } = this;
const p0 = perm[X] + Y;
const p00 = perm[p0] + Z;
const p01 = perm[p0 + 1] + Z;
const p1 = perm[X + 1] + Y;
const p10 = perm[p1] + Z;
const p11 = perm[p1 + 1] + Z;
const { lerp, grad3d } = PerlinNoise;
return lerp(
fz,
lerp(
fy,
lerp(
fx,
grad3d(perm[p00], x, y, z),
grad3d(perm[p10], x - 1, y, z)
),
lerp(
fx,
grad3d(perm[p01], x, y - 1, z),
grad3d(perm[p11],x - 1, y - 1, z)
)
),
lerp(
fy,
lerp(
fx,
grad3d(perm[p00 + 1], x, y, z - 1),
grad3d(perm[p10 + 1], x - 1, y, z - 1)
),
lerp(
fx,
grad3d(perm[p01 + 1], x, y - 1, z - 1),
grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
)
)
);
}
noise2d(x, y) {
const { floor } = Math;
const X = floor(x) & 0xff;
const Y = floor(y) & 0xff;
x -= floor(x);
y -= floor(y);
const { perm } = this;
const fx = (3 - 2 * x) * x * x;
const fy = (3 - 2 * y) * y * y;
const p0 = perm[X] + Y;
const p1 = perm[X + 1] + Y;
const { lerp, grad2d } = PerlinNoise;
return lerp(
fy,
lerp(
fx,
grad2d(
perm[p0],
x,
y
),
grad2d(
perm[p1],
x - 1,
y
)
),
lerp(
fx,
grad2d(
perm[p0 + 1],
x,
y - 1
),
grad2d(
perm[p1 + 1],
x - 1,
y - 1
)
)
);
}
noise1d(x) {
const { floor } = Math;
const X = floor(x) & 0xff;
x -= floor(x);
const fx = (3 - 2 * x) * x * x;
const { lerp, grad1d } = PerlinNoise;
return lerp(
fx,
grad1d(perm[X], x),
grad1d(perm[X + 1], x - 1)
);
}
constructor(seed) {
if (seed === undefined) {
throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
}
const rnd = new Marsaglia(seed);
// generate permutation
const { perm } = this;
// fill 0x0..0x100
for (let i = 0; i < 0x100; ++i) {
perm[i] = i;
}
for (let i = 0; i < 0x100; ++i) {
const j = rnd.nextInt() & 0xFF;
const t = perm[j];
perm[j] = perm[i];
perm[i] = t;
}
// copy to avoid taking mod in perm[0]
// copies from first half of array, into the second half
perm.copyWithin(0x100, 0x0, 0x100);
}
}
win.PerlinNoise = PerlinNoise
// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
function openSimplexNoise(clientSeed) {
const SQ4 = 2
const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) }
const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) }
const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) }
const NORM_3D = 1.0 / 206.0
const SQUISH_3D = 1 / 3
const STRETCH_3D = -1 / 6
var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011")
const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70")
var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) }
var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131")
const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a }
const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} }
function shuffleSeed(seed,count){
seed = seed * 1664525 + 1013904223 | 0
count -= 1
return count > 0 ? shuffleSeed(seed, count) : seed
}
const types = {
_3D : {
base : base3D,
squish : SQUISH_3D,
dimensions : 3,
pD : p3D,
lookup : lookupPairs3D,
}
}
function createContribution(type, baseSet, index) {
var i = 0
const multiplier = baseSet[index ++]
const c = { next : undefined }
while(i < type.dimensions) {
const axis = ("xyzw")[i]
c[axis + "sb"] = baseSet[index + i]
c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish
}
return c
}
function createLookupPairs(lookupArray, contributions){
var i
const a = lookupArray()
const res = new Map()
for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
return res
}
function createContributionArray(type) {
const conts = []
const d = type.dimensions
const baseStep = d * d
var k, i = 0
while (i < type.pD.length) {
const baseSet = type.base[type.pD[i]]
let previous, current
k = 0
do {
current = createContribution(type, baseSet, k)
if (!previous) { conts[i / baseStep] = current; }
else { previous.next = current; }
previous = current
k += d + 1
} while(k < baseSet.length)
current.next = createContribution(type, type.pD, i + 1)
if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
i += baseStep
}
const result = [conts, createLookupPairs(type.lookup, conts)]
type.base = undefined
type.lookup = undefined
return result
}
let temp = createContributionArray(types._3D)
const contributions3D = temp[0], lookup3D = temp[1]
const perm = new Uint8Array(256)
const perm3D = new Uint8Array(256)
const source = new Uint8Array(setOf(256))
var seed = shuffleSeed(clientSeed, 3)
doFor(256, function(i) {
i = 255 - i
seed = shuffleSeed(seed, 1)
var r = (seed + 31) % (i + 1)
r += r < 0 ? i + 1 : 0
perm[i] = source[r]
perm3D[i] = (perm[i] % 24) * 3
source[r] = source[i]
})
base3D = undefined
lookupPairs3D = undefined
p3D = undefined
return function(x, y, z) {
const pD = perm3D
const p = perm
const g = gradients3D
const stretchOffset = (x + y + z) * STRETCH_3D
const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset
const xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)
const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D
const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)
const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb
const inSum = xins + yins + zins
var c = lookup3D.get(
(yins - zins + 1) |
((xins - yins + 1) << 1) |
((xins - zins + 1) << 2) |
(inSum << 3) |
((inSum + zins) << 5) |
((inSum + yins) << 7) |
((inSum + xins) << 9)
)
var i, value = 0
while (c !== undefined) {
const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz
let attn = 2 - dx * dx - dy * dy - dz * dz
if (attn > 0) {
i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF]
attn *= attn
value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)
}
c = c.next
}
return value * NORM_3D + 0.5
}
}
// Save the coords for a small sphere used to carve out caves
let sphere;
{
let blocks = []
let radius = 3.5
let radsq = radius * radius
for (let i = -radius; i <= radius; i++) {
for (let j = -radius; j <= radius; j++) {
for (let k = -radius; k <= radius; k++) {
if (i*i + j*j + k*k < radsq) {
blocks.push(i|0, j|0, k|0)
}
}
}
}
sphere = new Int8Array(blocks)
}
function isCave(x, y, z, world) {
// Generate a 3D rigid multifractal noise shell.
// Then generate another one with different coordinates.
// Overlay them on top of each other, and the overlapping parts should form a cave-like structure.
// This is extremely slow, and requires generating 2 noise values for every single block in the world.
// TODO: replace with a crawler system of some sort, that will never rely on a head position in un-generated chunks.
let smooth = 0.02
let caveSize = 0.0055
return abs(0.5 - world.caveNoise(x * smooth, y * smooth, z * smooth)) < caveSize
&& abs(0.5 - world.caveNoise(y * smooth, z * smooth, x * smooth)) < caveSize
}
class PVector {
constructor(x, y, z) {
this.x = x
this.y = y
this.z = z
}
set(x, y, z) {
if (y === undefined) {
this.x = x.x
this.y = x.y
this.z = x.z
} else {
this.x = x
this.y = y
this.z = z
}
}
normalize() {
let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
this.x /= mag
this.y /= mag
this.z /= mag
}
add(x,y,z) {
if (y === undefined) {
this.x += x.x
this.y += x.y
this.z += x.z
} else {
this.x += x
this.y += y
this.z += z
}
}
mult(m) {
this.x *= m
this.y *= m
this.z *= m
}
mag() {
return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
}
magSquared() {
return this.x * this.x + this.y * this.y + this.z * this.z
}
crossProduct(x,y,z,vector) {
vector.x = this.y * z - this.z * y
vector.y = this.z * x - this.x * z
vector.z = this.x * y - this.y * x
return vector
}
crossProductVector(vector) {
this.set(
this.y * vector.z - this.z * vector.y,
this.z * vector.x - this.x * vector.z,
this.x * vector.y - this.y * vector.x
)
}
product(x,y,z,vector) {
vector.x = this.x * x
vector.y = this.y * y
vector.z = this.z * z
return vector
}
}
win.PVector = PVector
let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector(), vec4 = new PVector()
class Quaternion{
constructor(x, y, z, w) {
this.x = x
this.y = y
this.z = z
this.w = w
}
set(x, y, z, w) {
this.x = x
this.y = y
this.z = z
this.w = w
}
static fromAxisAngle(angle, dx,dy,dz){
let s = sin(angle*0.5)
return new this(dx*s,dy*s,dz*s,cos(angle*0.5))
}
fromAxisAngle(angle, dx,dy,dz){
let s = sin(angle*0.5)
this.set(dx*s,dy*s,dz*s,cos(angle*0.5))
}
mult(other){
this.set(
-other.x * this.x - other.y * this.y - other.z * this.z + other.w * this.w,
other.x * this.w + other.y * this.z - other.z * this.y + other.w * this.x,
-other.x * this.z + other.y * this.w + other.z * this.x + other.w * this.y,
other.x * this.y - other.y * this.x + other.z * this.w + other.w * this.z
)
}
rotateVector(v){//from https://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion
let num12 = this.x + this.x;
let num2 = this.y + this.y;
let num = this.z + this.z;
let num11 = this.w * num12;
let num10 = this.w * num2;
let num9 = this.w * num;
let num8 = this.x * num12;
let num7 = this.x * num2;
let num6 = this.x * num;
let num5 = this.y * num2;
let num4 = this.y * num;
let num3 = this.z * num;
let num15 = ((v.x * ((1 - num5) - num3)) + (v.y * (num7 - num9))) + (v.z * (num6 + num10));
let num14 = ((v.x * (num7 + num9)) + (v.y * ((1 - num8) - num3))) + (v.z * (num4 - num11));
let num13 = ((v.x * (num6 - num10)) + (v.y * (num4 + num11))) + (v.z * ((1 - num8) - num5));
v.x = num15;
v.y = num14;
v.z = num13;
}
}
//piston extend & retract
const pistonPushLimit = 12
function pistonFindStickyBlocksConnectedTo(cx,cy,cz,tx,ty,tz,block,blocks,checkProp,dimension,world){
//c = current position, t = direction
var spreadAt = [cx,cy,cz,block]
while(spreadAt.length){
var sx = spreadAt[0]
var sy = spreadAt[1]
var sz = spreadAt[2]
var block2
block2 = world.getBlock(sx,sy,sz+1,dimension)
if(block2 && !xyArrayHas(blocks,spreadAt,sx,sy,sz+1)){
if(!blockData[block2][checkProp]){
if(!tx && !ty && tz === 1) return false
}else if(blockData[block2].sticky && block2 !== block && !(!tx && !ty && tz === 1)){
}else{
blocks.push(sx,sy,sz+1,block2)
if(blockData[block2].sticky){
spreadAt.push(sx,sy,sz+1,block2)
}else if(!(!tx && !ty && tz === -1)){
if(pistonFindStack(sx,sy,sz+1,tx,ty,tz,blocks,dimension,world) === false) return false
}
}
}
block2 = world.getBlock(sx,sy,sz-1,dimension)
if(block2 && !xyArrayHas(blocks,spreadAt,sx,sy,sz-1)){
if(!blockData[block2][checkProp]){
if(!tx && !ty && tz === -1) return false
}else if(blockData[block2].sticky && block2 !== block && !(!tx && !ty && tz === -1)){
}else{
blocks.push(sx,sy,sz-1,block2)
if(blockData[block2].sticky){
spreadAt.push(sx,sy,sz-1,block2)
}else if(!(!tx && !ty && tz === 1)){
if(pistonFindStack(sx,sy,sz-1,tx,ty,tz,blocks,dimension,world) === false) return false
}
}
}
block2 = world.getBlock(sx,sy+1,sz,dimension)
if(block2 && !xyArrayHas(blocks,spreadAt,sx,sy+1,sz)){
if(!blockData[block2][checkProp]){
if(!tx && ty === 1 && !tz) return false
}else if(blockData[block2].sticky && block2 !== block && !(!tx && ty === 1 && !tz)){
}else{
blocks.push(sx,sy+1,sz,block2)
if(blockData[block2].sticky){
spreadAt.push(sx,sy+1,sz,block2)
}else if(!(!tx && ty === -1 && !tz)){
if(pistonFindStack(sx,sy+1,sz,tx,ty,tz,blocks,dimension,world) === false) return false
}
}
}
block2 = world.getBlock(sx,sy-1,sz,dimension)
if(block2 && !xyArrayHas(blocks,spreadAt,sx,sy-1,sz)){
if(!blockData[block2][checkProp]){
if(!tx && ty === -1 && !tz) return false
}else if(blockData[block2].sticky && block2 !== block && !(!tx && ty === -1 && !tz)){
}else{
blocks.push(sx,sy-1,sz,block2)
if(blockData[block2].sticky){
spreadAt.push(sx,sy-1,sz,block2)
}else if(!(!tx && ty === 1 && !tz)){
if(pistonFindStack(sx,sy-1,sz,tx,ty,tz,blocks,dimension,world) === false) return false
}
}
}
block2 = world.getBlock(sx+1,sy,sz,dimension)
if(block2 && !xyArrayHas(blocks,spreadAt,sx+1,sy,sz)){
if(!blockData[block2][checkProp]){
if(tx === 1 && !ty && !tz) return false
}else if(blockData[block2].sticky && block2 !== block && !(tx === 1 && !ty && !tz)){
}else{
blocks.push(sx+1,sy,sz,block2)
if(blockData[block2].sticky){
spreadAt.push(sx+1,sy,sz,block2)
}else if(!(tx === -1 && !ty && !tz)){
if(pistonFindStack(sx+1,sy,sz,tx,ty,tz,blocks,dimension,world) === false) return false
}
}
}
block2 = world.getBlock(sx-1,sy,sz,dimension)
if(block2 && !xyArrayHas(blocks,spreadAt,sx-1,sy,sz)){
if(!blockData[block2][checkProp]){
if(tx === -1 && !ty && !tz) return false
}else if(blockData[block2].sticky && block2 !== block && !(tx === -1 && !ty && !tz)){
}else{
blocks.push(sx-1,sy,sz,block2)
if(blockData[block2].sticky){
spreadAt.push(sx-1,sy,sz,block2)
}else if(!(tx === 1 && !ty && !tz)){
if(pistonFindStack(sx-1,sy,sz,tx,ty,tz,blocks,dimension,world) === false) return false
}
}
}
spreadAt.splice(0,4)
}
}
win.pistonFindStickyBlocksConnectedTo = pistonFindStickyBlocksConnectedTo
function pistonFindStack(x,y,z,tx,ty,tz,blocks,dimension,world){
var cx = x, cy = y, cz = z  //current position
for(var i=0; i<pistonPushLimit+1; i++){
cx += tx
cy += ty
cz += tz
var block = world.getBlock(cx,cy,cz,dimension)
if(block && !blockData[block].pistonPush) return false
if(blockData[block].sticky){
if(pistonFindStickyBlocksConnectedTo(cx,cy,cz,tx,ty,tz,block,blocks,"pistonPush",dimension,world) === false) return false
}
if(block){if(!xyArrayHas(blocks,null,cx,cy,cz)){blocks.push(cx,cy,cz,block)}}
else break
}
}
function getPistonPushedBlocks(x,y,z,tx,ty,tz,dimension,world){
var blocks = [x,y,z,0]
if(pistonFindStack(x,y,z,tx,ty,tz,blocks,dimension,world) === false) return false
blocks.splice(0,4) //remove the temporary coordinates
if((blocks.length / 4) > pistonPushLimit) return false
return blocks
}
win.getPistonPushedBlocks = getPistonPushedBlocks
function getPistonPulledBlocks(x,y,z,tx,ty,tz,dimension,world){
var blocks = [x,y,z,0]
var cx = x+tx, cy = y+ty, cz = z+tz
cx += tx
cy += ty
cz += tz
var block = world.getBlock(cx,cy,cz,dimension)
if(blockData[block].sticky){
if(pistonFindStickyBlocksConnectedTo(cx,cy,cz,-tx,-ty,-tz,block,blocks,"pistonPull",dimension,world) === false) return false
}
if(block && !xyArrayHas(blocks,null,cx,cy,cz) && blockData[block].pistonPull) blocks.push(cx,cy,cz,block)
blocks.splice(0,4)
if(blocks.length/4 > pistonPushLimit) return false
return blocks
}
win.getPistonPulledBlocks = getPistonPulledBlocks
let movePositionByFaceArr = []
function movePositionByFace(face,x,y,z){
switch(face){
case "top": y++; break
case "bottom": y--; break
case "north": z++; break
case "south": z--; break
case "east": x++; break
case "west": x--; break
}
movePositionByFaceArr[0] = x
movePositionByFaceArr[1] = y
movePositionByFaceArr[2] = z
return movePositionByFaceArr
}
let colors = {
rgb:{
0: [0,0,0],
1: [0,0,170],
2: [0,170,0],
3: [0,170,170],
4: [170,0,0],
5: [170,0,170],
6: [255,170,0],
7: [170,170,170],
8: [85,85,85],
9: [85,85,255],
a: [85,255,85],
b: [85,255,255],
c: [255,85,85],
d: [255,85,255],
e: [255,255,85],
f: [255,255,255],
g: [221,214,5],//minecoin gold
h: [227,212,209],//quartz
i: [206,202,202],
j: [68,58,59],
m: [151,22,7],
n: [180,104,77],
p: [222,177,45],
q: [71,160,54],
s: [44,186,168],
t: [33,73,123],
u: [154,92,198]
},
css:{},
dye:{
red:[176/255, 46/255, 38/255],
lightGray:[157/255, 157/255, 151/255],
lightBlue:[58/255, 178/255, 218/255],
magenta:[199/255, 78/255, 189/255],
yellow:[254/255, 215/255, 61/255],
purple:[137/255, 50/255, 184/255],
orange:[249/255, 128/255, 29/255],
white:[249/255, 1, 254/255],
green:[93/255, 124/255, 22/255],
brown:[131/255, 84/255, 50/255],
black:[29/255, 29/255, 33/255],
pink:[243/255, 139/255, 170/255],
lime:[128/255, 199/255, 31/255],
gray:[71/255, 79/255, 82/255],
cyan:[22/255, 156/255, 156/255],
blue:[60/255, 67/255, 170/255]
}
}
for(var c in colors.rgb){
colors.css[c] = "rgb("+colors.rgb[c].join(",")+")"
colors.rgb[c][0] /= 255
colors.rgb[c][1] /= 255
colors.rgb[c][2] /= 255
}
win.colors = colors
//each mob: [mob name, min, max]
const defaultMobs = [["Sheep",4,4],["Pig",4,4],["Chicken",4,4],["Cow",4,4]]
const grassMobs = [...defaultMobs,["Horse",2,6],["Donkey",1,3]]
const taigaMobs = [...grassMobs,["Rabbit",2,3],["Fox",2,4]]
const beachMobs = [["Turtle",4,4]]
const peakMobs = [["Rabbit",2,3],["Goat",1,3]]
const defaultHostileMobs = [["Zombie",4,4],["Skeleton",4,4],["Creeper",4,4],["Enderman",4,4],["Spider",4,4]]
const meadowMobs = [["Rabbit",2,6],["Sheep",2,4],["Donkey",1,2]]
const swampMobs = [...defaultMobs,["Frog",2,5]]
const swampHostileMobs = [["Slime",4,4],["Witch",1,1]]
let biomeData = { //[temperature, rainfall (snow exluded), passive mobs, hostile mobs]
void:[0.5,0.5],
ocean:[0.5,0.5],
deepOcean:[0.5,0.5],
warmOcean:[0.8,0.6],
lukewarmOcean:[0.6,0.5],
deepLukewarmOcean:[0.6,0.5],
coldOcean:[0.35,0.5],
deepColdOcean:[0.35,0.5],
frozenOcean:[0.1515,0.5],
deepFrozenOcean:[0.152,0.5],
plains:[0.8,0.4, grassMobs],
iceSpikes:[0,0.1],
snowyPlains:[0,0.1, [["Rabbit",1,1],["PolarBear",1,1]]],
grove:[-0.2,0.5, taigaMobs],
alpineHills:[0.18,0.25,taigaMobs],
snowyTaiga:[-0.5,0.1, taigaMobs],
taiga:[0.25,0.8, taigaMobs],
shrubland:[0.85,0.4, grassMobs],
meadow:[0.3,0.5, meadowMobs],
forest:[0.7,0.8, grassMobs],
sparseForest:[0.6,0.6, grassMobs],
oldPineTaiga:[0.3,0.8, taigaMobs],
oldSpruceTaiga:[0.25,0.8, taigaMobs],
flowerForest:[0.7,0.8, grassMobs],
oldBirchForest:[0.6,0.6, grassMobs],
birchForest:[0.7,0.8, grassMobs],
darkForest:[0.6,0.6, grassMobs],
savanna:[1.2,0.2, grassMobs],
grassySavanna:[1.2,0.2, grassMobs],
sparseJungle:[0.95,0.8, grassMobs],
bambooJungle:[0.95,0.9, grassMobs],
jungle:[0.95,0.9, grassMobs],
desert:[2,0],
snowyBeach:[0.05,0.3, beachMobs],
beach:[0.8,0.4, beachMobs],
snowySlopes:[-0.3,0.9, peakMobs],
windsweptGravellyHills:[0.2,0.3, grassMobs],
//lushHills:[0.2,0.8, grassMobs],
windsweptHills:[0.2,0.3, grassMobs],
windsweptForest:[0.2,0.3, grassMobs],
frozenPeaks:[-0.7,0.9],
stonePeaks:[1,0.3],
jaggedPeaks:[-0.7,0.9, peakMobs],
frozenRiver:[0,0.5],
river:[0.5,0.5],
dryRiver:[1,0.1],
rockyRiver:[0.5,0.4],
sunflowerPlains:[0.8,0.4, grassMobs],
stonyShore:[0.2,0.3],
savannaPlateau:[1,0, grassMobs],
erodedBadlands:[2,0],
badlands:[2,0],
woodedBadlands:[2,0],
windsweptSavanna:[1.1,0.5, grassMobs],
rockyPlains:[0.8,0.4, grassMobs],
mushroomFields:[0.9,1, ["Mooshroom",4,4]],
cherryGrove:[0.3,0.5, meadowMobs],
dryShrubland:[1,0.2],
swamp:[0.8,0.5,swampMobs,swampHostileMobs],
mangroveSwamp:[0.8,0.9],
bambooForest:[0.7,0.8, grassMobs],
marsh:[0.8,0.3],
trashland:[0.25,0],
dripstoneCaves:[0.2,0],
lushCaves:[0.9,0],
warpedForest:[2,0],
crimsonForest:[2,0],
netherWastes:[2,0, ["Blaze",4,4]],
end:[0.5,0.5],
endIslands:[0.5,0.5]
}
win.biomeData = biomeData
let biomes = Object.keys(biomeData)
let biomeIds = Object.fromEntries(biomes.map((b,i) => [b,i]))
win.biomeIds = biomeIds
function getNetherBiome(biome) {
if(biome > 0.4 && biome < 0.5){
return "warpedForest"
}else if(biome > 0.4){
return "crimsonForest"
}
return "netherWastes"
}
function getBiome(biome){
if(biome > 0.6){
return "snowyPlains"
}else if(biome > 0.5){
return "desert"
}else if(biome > 0.4){
return "plains"
}else if(biome > 0.37){
return "sparseJungle"
}else if(biome > 0.35){
return "jungle"
}else if(biome > 0.3){
return "bambooJungle"
}else{
return "forest"
}
}
function getBiomeTemperature(biome,y){
if(!biomeData[biome]) return 0
let t = biomeData[biome][0]
if(y > 80) t -= (y-80)/800
return t
}
let now = 0
function debug(message) {
let ellapsed = performance.now() - debug.start
if (ellapsed > 30) {
console.log(message, ellapsed.toFixed(2), "milliseconds")
}
}
const worldGenArray = {
array: [],
size: 0,
add: function(x, y, z, block) {
if (this.size === this.array.length) {
this.array.push([ x, y, z, block ])
} else {
this.array[this.size][0] = x
this.array[this.size][1] = y
this.array[this.size][2] = z
this.array[this.size][3] = block
}
this.size++
},
clear: function() {
this.size = 0
},
get:function(n){
if(n < this.size) return this.array[n]
}
}
class World{
constructor({
trees = true, caves = true, fancyRivers = true, superflat = false,
preBeta, gameMode = "creative", cheats = true,
settings = defaultWorldSettings,
customChunkGenerate, customChunkPopulate
} = {}) {
this.version = version
this.usePreBeta = preBeta
//Initialize the world's arrays
this.chunks = []
this.netherChunks = []
this.endChunks = []
this.loaded = []
this.loadedNear = []
this.sortedChunks = []
this.chunkGenQueue = []
this.populateQueue = []
this.generateQueue = []
this.lightingQueue = []
this.loadQueue = []
this.timeoutQueue = []
this.updateQueue = []
this.loadFrom = {}
this.loadKeys = []
this.generatedChunks = 0
this.entities = []
//this.resourcePacks = []
this.activeResourcePacks = []
this.ticking = false
this.players = []
this.loadDistance = 4
this.loadedUpdate = true
this.playersInv = {}
this.trees = trees
this.caves = caves
this.fancyRivers = fancyRivers
this.superflat = superflat
this.structureData = {}//Structure data for temporary use while generating structure
this.gameMode = gameMode //game mode on join
this.cheats = cheats //game mode on join
this.spawnPoint = {
x:8,z:8,y:70,
landProg:0
}//Global Spawn point
this.loadPromises = [] //Array of promises (load save, find land)
this.weather = ""
this.slowWeatherAmount = 0
this.weatherAmount = 0
this.nextWeather = rand(0.5,7.5)*1000
this.time = 375
this.skyLight = 0
this.settings = Object.assign({},settings)
this.commandNodes = []
/*this.commandNodes = defaultServerCommandNodes.map(r => ({...r, func:undefined}))
this.commandFuncs = Object.fromEntries(defaultServerCommandNodes.map(r => [r.name,r.func]))
this.commandMap = {}
for(let i=0; i<this.commandNodes.length; i++){
let c = this.commandNodes[i]
if(c.name) this.commandMap[c.id] = c
}*/
initDefaultCommands(this)
this.runCmd = runCmd
this.worldSeed = 0
this.islandGenerator = new IslandGenerator(this);
this.setSeed = (seed, noFindSpawn) => {
this.worldSeed = seed
seedHash(seed)
this.caveNoise = openSimplexNoise(seed)
this.noiseProfile.noiseSeed(seed)
this.islandGenerator.SetSeed(seed)
sendAllWorkers({newSeed:seed})
if(!noFindSpawn) this.findSpawnPoint()
}
this.noiseProfile = {
generator: undefined,
octaves: 4,
fallout: 0.5,
seed: undefined,
noiseSeed(seed) {
this.seed = seed;
this.generator = new PerlinNoise(this.seed);
},
noise(x, y, z) {
const { generator, octaves, fallout } = this;
let effect = 1,
k = 1,
sum = 0;
for (let i = 0; i < octaves; ++i) {
effect *= fallout;
const k = 1 << i;
let temp;
switch (arguments.length) {
case 1: {
temp = generator.noise1d(k * x);
break;
} case 2: {
temp = generator.noise2d(k * x, k * y);
break;
} case 3: {
temp = generator.noise3d(k * x, k * y, k * z);
break;
}
}
sum += effect * (1 + temp) / 2;
}
return sum;
}
}
this.pos = setInterval(this.onpos.bind(this), 500)
this.customChunkGenerate = customChunkGenerate
this.customChunkPopulate = customChunkPopulate
}
findSpawnPoint(){
if(!this.usePreBeta && !this.superflat){
this.loadPromises.push(
doWork({findLand:true, seed:this.worldSeed}, progress => {
this.spawnPoint.landProg = progress
}).then(land => {
this.spawnPoint.x = land.x
this.spawnPoint.y = land.y
this.spawnPoint.z = land.z
this.spawnPoint.land = true
})
)
}else{
this.spawnPoint.y = this.superflat ? 4 : round(this.noiseProfile.noise(this.spawnPoint.x * generator.smooth, this.spawnPoint.z * generator.smooth) * generator.height) + generator.extra
}
}
serverChangeBlock(x,y,z,dimension,place,p,face,shift,blockMode){
let holding = p.inventory.hotbar[p.inventory.hotbarSlot] ? p.inventory.hotbar[p.inventory.hotbarSlot].id : 0
let blockDat = blockData[holding], holdObj = p.inventory.hotbar[p.inventory.hotbarSlot]
let ox = x, oy = y, oz = z
let side = false
if(place){
switch(face) {
case "top":
y += 1
break
case "bottom":
y -= 1
break
case "south":
z -= 1
side = true
break
case "north":
z += 1
side = true
break
case "west":
x -= 1
side = true
break
case "east":
x += 1
side = true
break
}
}
let prevBlock = this.getBlock(x,y,z, dimension)
let prevTags = this.getTags(x,y,z, dimension)
let dnow = Date.now()
let breakTime
if(!place && p.survival){
breakTime = blockData[prevBlock].hardness*1000
let breakType = blockData[prevBlock].type
if(handBreakable.includes(breakType) || breakTypes[breakType] && breakTypes[breakType].includes(blockData[holding].name)){
breakTime *= 1.5
}else breakTime *= 5
if(holding && blockData[holding].shears && blockData[block].shearBreakTime){
breakTime = blockData[prevBlock].shearBreakTime
}
if(holding && (blockData[holding].pickaxe || (blockData[holding].shovel && breakType === "ground") || (blockData[holding].axe && breakType === "wood") || (blockData[holding].hoe && breakType === "plant2"))){
breakTime /= blockData[holding].mineSpeed
}
if(p.liquid) breakTime *= 5
if(!p.onGround) breakTime *= 5
}
if(dimension !== p.dimension || breakTime !== undefined && (p.crackPos[0] !== x || p.crackPos[1] !== y || p.crackPos[2] !== z || dnow-p.breakStart<breakTime-250)){
return p.connection.send({type:"setBlock", data:{x:x, y:y, z:z, block:prevBlock, dimension}})
}
if(place){//placed
let cblock = this.getBlock(ox,oy,oz,dimension)
if(blockData[cblock].onclick && !shift){
if(!blockData[cblock].onclick(ox,oy,oz,dimension,this,p,holdObj)){
if(holdObj && !holdObj.amount) p.inventory.hotbar[p.inventory.hotbarSlot] = null
return
}
}else if(holding && blockData[holding].shovel){
if(cblock === blockIds.grass || cblock === blockIds.dirt || cblock === blockIds.rootedDirt || cblock === blockIds.mycelium || cblock === blockIds.podzol){
this.setBlock(ox,oy,oz,blockIds.grass | TALLCROSS, false,false,false,false,p.dimension)
holdObj.durability --
}
if(blockData[cblock].campfire){
this.setBlock(ox,oy,oz,blockData[cblock].id | SLAB, false,false,false,false,p.dimension)
holdObj.durability --
}
return
}else if(holding && cblock && blockData[holding].axe){
var name = blockData[cblock].name
name = name[0].toUpperCase() + name.substring(1)
name = "stripped"+name
if(blockIds[name]){
this.setBlock(ox,oy,oz,blockIds[name], p.dimension)
holdObj.durability --
}
return
}else if(holding && cblock && blockData[holding].hoe){
if((blockData[cblock].name === "grass" || cblock === blockIds.dirt) && !this.getBlock(ox,oy+1,oz)){
this.setBlock(ox,oy,oz,blockIds.farmland, false,false,false,false,p.dimension)
holdObj.durability --
}
if(cblock === blockIds.rootedDirt){
this.setBlock(ox,oy,oz,blockIds.dirt, false,false,false,false,p.dimension)
this.addItems(ox, oy+0.5, oz,p.dimension, 0, 0, 0, blockIds.hangingRoots, true)
holdObj.durability --
}
return
}else if(holding && cblock && blockData[holding].shears){
if(cblock === blockIds.pumpkin){
this.setBlock(ox,oy,oz,blockIds.carvedPumpkin, false,false,false,false,p.dimension)
this.addItems(ox, oy+0.5, oz,p.dimension, 0, 0, 0, blockIds.pumpkinSeeds, true, 4)
holdObj.durability --
}
return
}else if(holding && cblock && blockData[holding].name === "eyeOfEnder" && blockData[cblock].name === "endPortalFrame"){
this.setBlock(ox,oy,oz,cblock | SLAB, false,false,false,false,p.dimension)
blockData[cblock].eyeplace(ox,oy,oz,p.dimension,this)
this.blockSound(holding, "place", ox,oy,oz)
return
}else if(holding && cblock && blockData[holding].flowerbed && blockData[holding].id === blockData[cblock].id){
blockData[cblock].addPetal(ox,oy,oz,dimension,this)
return
}
if(blockDat.serveronuse && (blockDat.useAnywhere || cblock)){
let cont = blockDat.serveronuse(ox,oy,oz,cblock,dimension,this,face,holdObj,p)
if(holdObj && !holdObj.amount) p.inventory.hotbar[p.inventory.hotbarSlot] = null
if(!cont) return
}
}
if(place){
if(!holding || blockDat.item) return
let under = this.getBlock(x,y-1,z, dimension)
let onPot = !side && blockData[under] && blockData[under].pot
if(blockData[holding].potCross && onPot){
blockMode = POTCROSS
}else if(blockData[holding].crossShape){
if(onPot && blockIds[blockData[holding].name+"Pot"]){
block = blockIds[blockData[holding].name+"Pot"]
blockMode = POTCROSS
}else{
blockMode = CROSS
}
}
if(blockData[holding].sideCross){
if(side){
blockMode = CUBE
}else if(face === "bottom"){
blockMode = SLAB
}else blockMode = CROSS
}
if(blockData[holding].tallcrossShape){
blockMode = TALLCROSS
}
if(blockData[holding].door && blockMode !== SLAB){
blockMode = DOOR
}
if(blockData[holding].torch){
blockMode = TORCH
if(side) blockMode = SLAB
}
if(blockData[holding].lantern){
if(this.getBlock(x,y+1,z, dimension)){
blockMode = LANTERNHANG
}else{
blockMode = LANTERN
}
}
if(blockData[holding].beacon){
blockMode = BEACON
}
if(blockData[holding].cactus && blockMode !== POTCROSS){
blockMode = CACTUS
}
if(blockData[holding].pane){
if(side) blockMode = SLAB
else blockMode = PANE
}
if(blockData[holding].portal){
blockMode = PORTAL
}
if(blockData[holding].wallFlat){
blockMode = WALLFLAT
}
if(blockData[holding].trapdoor){
if(side){
blockMode = TRAPDOOROPEN
}else{
blockMode = TRAPDOOR
}
}
if(blockData[holding].chain){
if(side)blockMode = SLAB
else blockMode = CHAIN
}
if(blockData[holding].button){
blockMode = BUTTON
}
if(blockData[holding].pot){
blockMode = POT
}
if(blockData[holding].name === "endRod"){
if(side){
blockMode = SLAB
}else{
blockMode = CUBE
}
}
if(blockData[holding].barrel || blockData[holding].commandBlock){
if(side) blockMode = SLAB
else if(face === "bottom") blockMode = STAIR
else blockMode = CUBE
}
if(blockData[holding].redstoneTorch){
if(side) blockMode = SLAB
else blockMode = CUBE
}
if(blockData[holding].lever){
if(side) blockMode = CUBE
else if(face === "top") blockMode = STAIR
else if(face === "bottom") blockMode = TALLCROSS
}
if(blockData[holding].piston){
if(face === "top") blockMode = CUBE
else if(face === "bottom") blockMode = FLIP
else if(side) blockMode = SLAB
}
if(blockData[holding].name === "observer"){
if(face === "top") blockMode = SLAB | FLIP
else if(face === "bottom") blockMode = SLAB
else blockMode = CUBE
}
if(blockData[holding].name === "pointedDripstone"){
if(face === "top") blockMode = CUBE
else blockMode = FLIP
}
if(blockData[holding].sign){
if(side) blockMode = STAIR
else blockMode = CUBE
}
if(blockData[holding].name === "dropper" || blockData[holding].name === "dispenser"){
if(face === "top") blockMode = SLAB
else if(face === "bottom") blockMode = STAIR
else blockMode = CUBE
}
if(blockData[holding].name === "hopper"){
if(side) blockMode = SLAB
else blockMode = CUBE
}
if(blockData[holding].coralFan){
if(side) blockMode = STAIR
else blockMode = CUBE
}
if(side && blockData[holding].swId){
block = blockData[holding].swId
}
if(blockData[holding].layers){
let b = this.getBlock(ox,oy,oz,dimension)
let layer = 0
let state = b&isState
if(state === LAYER1) layer = 1
if(state === LAYER2) layer = 2
if(state === LAYER3) layer = 3
if(state === LAYER4) layer = 4
if(state === LAYER5) layer = 5
if(state === LAYER6) layer = 6
if(state === LAYER7) layer = 7
if(state === LAYER8) layer = 8
if(((b & isCube) === (holding & isCube)) && layer > 0 && layer < 8){
p.connection.send({type:"setBlock", data:{x:x, y:y, z:z, block:this.getBlock(x,y,z, dimension), dimension}})
x = ox, y = oy, z = oz
layer ++
switch(layer){
case 2:
blockMode = LAYER2
break
case 3:
blockMode = LAYER3
break
case 4:
blockMode = LAYER4
break
case 5:
blockMode = LAYER5
break
case 6:
blockMode = LAYER6
break
case 7:
blockMode = LAYER7
break
case 8:
blockMode = LAYER8
break
}
}else{
blockMode = LAYER1
}
}
holding |= blockMode
}
let dropAmount, drop
if(p.survival && !place){
drop = 0
let block = prevBlock
let theDrop = blockData[prevBlock].drop
let amount = blockData[prevBlock].dropAmount
let canDrop = handBreakable.includes(blockData[prevBlock].type)
if(holding && breakTypes[blockData[prevBlock].type] && breakTypes[blockData[prevBlock].type].includes(blockData[holding].name)) canDrop = true
if(!blockData[prevBlock].type) canDrop = true
if(canDrop){
if(amount === undefined) amount = 1
if(amount.length === 2){
amount = round(rand(amount[0], amount[1]))
}
if(holding && blockData[holding].shears && blockData[prevBlock].dropSelfWhenSheared){
if(blockData[prevBlock].shearDropAmount){
amount = blockData[prevBlock].shearDropAmount
}
}else{
if(typeof theDrop === "number") block = theDrop
else if(typeof theDrop === "function"){
block = blockIds[theDrop()]
}else if(Array.isArray(theDrop)){
block = theDrop
}else if(theDrop) block = blockIds[theDrop]
}
if(block){
drop = block
dropAmount = amount
}
}
let breakType = blockData[prevBlock].type
if(holding && blockData[holding].pickaxe) {
holdObj.durability --
}
if(holding && blockData[holding].sword) {
holdObj.durability -= 2
}
if(holding && blockData[holding].shovel) {
holdObj.durability -= 1
}
if(holding && blockData[holding].axe) {
holdObj.durability -= 1
}
if(holding && blockData[holding].hoe && breakType !== "plant2") {
holdObj.durability -= 1
}
p.breakStart = dnow
}
let worked = this.setBlock(x, y, z, place ? holding : 0, false,false,false,false,dimension)
if(worked === false) return p.connection.send({type:"setBlock", data:{x:x, y:y, z:z, block:prevBlock, dimension}})
if(drop){
if(Array.isArray(drop)){//drop multiple items
for(let d of drop){
if(typeof d === "string") d = blockIds[d]
this.addItems(x, y, z,dimension, 0, 0, 0, d, true, dropAmount,null,null,p.id)
}
}else{
this.addItems(x, y, z,dimension, 0, 0, 0, drop, true, dropAmount,null,null,p.id)
}
}
if(place){
if(blockData[holding].onplace) blockData[holding].onplace(x,y,z,dimension,p,this)
if(p.survival) holdObj.amount--
if(holdObj && !holdObj.amount) p.inventory.hotbar[p.inventory.hotbarSlot] = null
}else{
this.blockParticles(prevBlock,x,y,z,30, "break",dimension)
if(blockData[prevBlock].onbreak){
blockData[prevBlock].onbreak(x,y,z, prevBlock, prevTags,dimension,this)
}
this.blockSound(prevBlock, "dig", x, y, z)
if(p.survival && blockData[prevBlock].experience) this.addEntity(new entities[entityIds.ExperienceOrb](x, y, z, blockData[prevBlock].experience),false,dimension)
}
}
entInteract(id,hit,cooldown,p){
let ent = getEntityOrPlayer(id,this)
let holdObj = p.inventory.hotbar[p.inventory.hotbarSlot]
let block = blockData[holdObj ? holdObj.id : 0]
if(hit){
let atime = (typeof block.attackTime === "number") ? block.attackTime : 5
let attackDamage = (block && block.attackDamage) || 1
let damage, critical
damage = cooldown
if(p.vely < 0 && !p.onGround && !p.liquid && !p.flying && !p.sprinting && damage > 0.848) critical = true
damage = max(min(damage, 1), 0.2) * attackDamage
if(critical) damage *= 1.5
if(ent.type === "Player"){
if (this.settings.attack) {
let msg = (p.username+" killed "+ent.username+(holdObj && blockData[holdObj.id].attackDamage ? " with "+(holdObj.customName || blockData[holdObj.id].Name) : "")+".")
ent.damage(damage,msg,false,null,p.x,p.y,p.z,p)
//send({type:"hit", username:p.username, id:p.id, damage:damage, velx:pd.x/2, velz:pd.z/2, holding:inventory.hotbar[inventory.hotbarSlot],x:p.x,y:p.y,z:p.z}, ent.id)
}
}else{
let pd = p.direction
ent.damage(damage,pd.x/2,0.5,pd.z/2)
}
if(block.pickaxe){
holdObj.durability -= 2
}
if(block.sword){
holdObj.durability --
}
if(block.shovel){
holdObj.durability -= 2
}
if(block.axe){
holdObj.durability -= 2
}
p.foodExhaustion += 0.1
}else{
if(block.onentityuse){
if(block.onserverentityuse) block.onserverentityuse(ent,holdObj)
}
if(ent.onclick){
ent.onclick(holdObj,p)
}
}
if(holdObj && !holdObj.amount) p.inventory.hotbar[p.inventory.hotbarSlot] = null
}
blockParticles(block,x,y,z,amount, type, dimension, dir, remote){
if(!remote) this.sendAll({
type:"particles", particleType:"blockParticles",
x,y,z,amount,dimension,data:{block,thisType:type,dir}
})
}
explode(x,y,z, r, type, dimension){
/*world.setBlock(x,y,z,blockIds.air);
for(var i=radius; i>0; i--){
sphereoidAt(x,y,z,i,i,i, blockIds.air)
}*/
//ball(x,y,z,r,r,r,0)
if(!type)this.setBlock(x,y,z, 0, false,false,false,false,dimension)
else if(type === "original") this.setBlock(x,y,z, this.getOriginalBlock(x,y,z,dimension), false,false,false,false,dimension)
/*let w2 = r * r
let h2 = w2
let d2 = w2
for (let Y = -r; Y < r; Y++) {
for (let X = -r; X <= r; X++) {
for (let Z = -r; Z <= r; Z++) {
let n = X * X / w2 + Y * Y / h2 + Z * Z / d2
if (n < 1) {
if(world.getBlock(X + x, Y + y, Z + z) === blockIds.tnt){
blockData[blockIds.tnt].explode(X+x,Y+y,Z+z, "explosion")
}
if(Math.random() > 0.5){
var time = Math.random()*1000
if(time < 10){
world.particles.push(new ExplodeParticle(X + x, Y + y, Z + z))
}else{
setTimeout(() => world.particles.push(new ExplodeParticle(X + x, Y + y, Z + z)), time)
}
}
if(!liquid){
var block = world.getBlock(X+x,Y+y,Z+z)
if(blockData[block].ongetexploded){
blockData[block].ongetexploded(x+X,y+Y,z+Z,block,world)
}
world.setBlock(X + x, Y + y, Z + z, 0)
}
}
}
}
}*/
//create rays rays coming from the center of the cube to each outer edge
let destroyed = {}, particles = []
for(var cx=0; cx<16; cx++){
for(var cy=0; cy<16; cy++){
for(var cz=0; cz<16; cz++){
if(!(cx === 0 || cx === 15 || cy === 0 || cy === 15 || cz === 0 || cz === 15)) continue
var intensity =  (0.7 + rand(0.6)) * r
var x2 = cx / 16, y2 = cy / 16, z2 = cz / 16
//step 0.3 blocks each time
var d = abs(dist3(0,0,0, (x2-0.5)*2*r,(y2-0.5)*2*r,(z2-0.5)*2*r))
var step = (0.3/d)/2 //how much to go along ray
for(var i=0; i<1; i+=step){
var sx = round(lerp(i, x, (x2-0.5)*2*r+x))
var sy = round(lerp(i, y, (y2-0.5)*2*r+y))
var sz = round(lerp(i, z, (z2-0.5)*2*r+z))
intensity -= 0.3 * 0.75
var block = this.getBlock(sx,sy,sz, dimension)
var isDestroyed = destroyed[sx+","+sy+","+sz]
//if block isn't air, reduce intensity based on blast resistance
if(block && !isDestroyed){
var br = blockData[block].blastResistance || 0
intensity -= (br + 0.3) * 0.3
if(intensity > 0) {
destroyed[sx+","+sy+","+sz] = true
if(!type){
if(blockData[block].ongetexploded){
blockData[block].ongetexploded(sx,sy,sz,block,this,dimension)
}
this.setBlock(sx, sy, sz, 0, false,false,false,false, dimension)
if(round(rand(r-1)) === 0){
this.addItems(sx, sy, sz, dimension, 0, 0, 0, block, true)
}
}
if(block === blockIds.tnt){
blockData[blockIds.tnt].explode(sx,sy,sz, "explosion",dimension,this)
}else if(block === blockIds.untnt){
blockData[blockIds.untnt].explode(sx,sy,sz, "explosion",dimension,this)
}
}/*end if(intensity > 0)*/else{
continue
}
}
if(intensity > 0 && type === "original" && !isDestroyed){
this.setBlock(sx,sy,sz, this.getOriginalBlock(sx,sy,sz,dimension), false,false,false,false,dimension)
}
if(intensity > 0 && rand() > 0.995){
let time = rand()*1000
particles.push(sx,sy,sz,dimension,time)
}
}
}//end for loop
}
}
this.sendAll({type:"particles", particleType:"explosion", data:particles, dimension})
//the calculation below is not from minecraft
let nearEntities = this.getEntitiesNear(x,y,z,dimension,r)
for(let ent of nearEntities){
if(ent.dimension !== dimension) continue
let dist = dist3(x,y,z, ent.x, ent.y, ent.z)
if(dist <= r){
let speed = (r-dist)
let X = ent.x - x
let Y = ent.y - y
let Z = ent.z - z
let velx = X/dist*speed, vely = Y/dist*speed, velz = Z/dist*speed
/*
velx = ((Math.sign(X)*r)-X)/5
vely = ((Math.sign(Y)*r)-Y)/5
velz = ((Math.sign(Z)*r)-Z)/5*/
if(ent.damage){
let damageTook = (r - dist) * 6
ent.damage(damageTook,velx,vely,velz)
}else{
ent.velx += velx
ent.vely += vely
ent.velz += velz
}
}
}
for(let ent of this.players){
if(ent.dimension !== dimension || ent.hidden || ent.die) continue
let dist = dist3(x,y,z, ent.x, ent.y, ent.z)
if(dist <= r){
let speed = (r-dist)
let X = ent.x - x
let Y = ent.y - y
let Z = ent.z - z
let velx = X/dist*speed, vely = Y/dist*speed, velz = Z/dist*speed
let damageTook = (r - dist) * 6
ent.damage(damageTook,ent.username+" blew up", false,null, x,y,z, null,velx,vely,velz)
}
}
explodeSound(x,y,z, r, this)
}
blockSound(blockID, type, x,y,z, volume){
let block = blockData[blockID]
if(typeof volume !== "number") volume = 1
let sound, pitch = 1
switch(type){
case "place":
sound = block.placeSound || block.digSound
break;
case "dig":
sound = block.digSound
break;
case "step":
sound = block.stepSound
break;
case "lowStep":
sound = block.stepSound
pitch = 0.5
break;
case "breaking":
sound = block.stepSound
pitch = 0.5
volume *= 0.5
break;
case "land":
sound = block.landSound || block.digSound
}
if(typeof sound === "function") return sound()
if(Array.isArray(sound)){
sound = sound[Math.floor(Math.random()*sound.length)]
}
if(sound){
this.playSound(x,y,z,sound, volume, pitch)
}
}
playSound(x,y,z, name, volume = 1, pitch = 1){
this.sendAll({type:"playSound", data:name, volume, pitch, x,y,z, hasPos: (typeof x === "number")})
}
poof(x,y,z,amount,dimension, w,h,d, unremote){
if(!amount) amount = w*h*d*20
if(unremote) this.sendAll({
type:"particles",particleType:"poof",
x,y,z,dimension,amount,data:{w,h,d}
})
}
glint(x,y,z,dimension,remote){
if(!remote) this.sendAll({
type:"particles", particleType:"glint",
x,y,z,dimension
})
}
updateBlock(x, y, z, lazy, noOnupdate, sx,sy,sz, dimension) {
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
let chunk = chunks[x >> 4] && chunks[x >> 4][z >> 4]
if (chunk && chunk.allGenerated) {
chunk.updateBlock(x & 15, y, z & 15, this, lazy, noOnupdate, sx,sy,sz)
}
}
getChunk(x, z, dimension) {
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
return chunks[x >> 4] && chunks[x >> 4][z >> 4]
}
getOrNewChunk(x,z,dimension){
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
const xm = x>>4, zm = z>>4
if (!chunks[xm]) {
chunks[xm] = []
}
if (!chunks[xm][zm]) {
return chunks[xm][zm] = new Chunk(xm<<4, zm<<4, dimension,this)
}
return chunks[xm][zm]
}
getBlock(x, y, z, dimension) {
if (y > maxHeight) {
return blockIds.air
} else if (y < minHeight) {
return blockIds.air
}
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
if (!chunks[x >> 4] || !chunks[x >> 4][z >> 4]) {
return blockIds.air
}
return chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15)
}
getOriginalBlock(x, y, z, dimension) {
let chunk = this.getChunk(x,z,dimension)
return chunk ? chunk.getOriginalBlock(x & 15, y, z & 15) : blockIds.air
}
setBlock(x, y, z, blockID, lazy, noOnupdate, remote, keepTags, dimension) {
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
if (!chunks[x >> 4] || !chunks[x >> 4][z >> 4]) {
return false
}
if(y < minHeight) return false
let chunk = chunks[x >> 4] && chunks[x >> 4][z >> 4]
let xm = x & 15
let zm = z & 15
let prev = chunk.getBlock(xm,y,zm)
if (blockID) {
if(prev){ //block gets replaced
let prevData = blockData[prev]
chunk.deleteBlock(xm, y, zm, !lazy)
if (!lazy && chunk.allGenerated && (!prevData.transparent || prevData.lightLevel || prevData.decreaseLight) && chunk.lit) {
this.updateLight(x, y, z, false, prevData.lightLevel, dimension)
}
}
let data = blockData[blockID]
chunk.setBlock(xm, y, zm, blockID, !lazy)
if (!lazy && chunk.allGenerated && (!data.transparent || data.lightLevel || data.decreaseLight) && chunk.lit) {
this.updateLight(x, y, z, true, data.lightLevel, dimension)
}
} else {
let data = blockData[prev]
chunk.deleteBlock(xm, y, zm, !lazy)
if (!lazy && chunk.allGenerated && (!data.transparent || data.lightLevel || data.decreaseLight) && chunk.lit) {
this.updateLight(x, y, z, false, data.lightLevel, dimension)
}
}
if (lazy) {
return
}
let prevTags = this.getTags(x,y,z, dimension)
if(!keepTags) this.setTags(x, y, z, undefined, remote, dimension)
for(let i = this.timeoutQueue.length-1; i>=0; i--){
let timeout = this.timeoutQueue[i]
if(timeout.x === x && timeout.y === y && timeout.z === z && timeout.dimension === dimension && (timeout.block === undefined || timeout.block === blockID)){
this.timeoutQueue.splice(i,1)
break
}
}
let nameChanged = blockData[prev].name !== blockData[blockID || 0].name
if(!noOnupdate && prev && blockData[prev].ondelete && nameChanged){
blockData[prev].ondelete(x,y,z, prevTags, prev, dimension,this)
}
if(!noOnupdate && blockID && blockData[blockID].onset && nameChanged){
blockData[blockID].onset(x,y,z, dimension,this)
}
if(!remote) this.sendAllInChunk({type:"setBlock", data:{x:x, y:y, z:z, block:blockID, dimension:dimension, keepTags:keepTags}},x>>4,z>>4,dimension)
//Update the 6 adjacent blocks and 1 changed block
if (xm && xm !== 15 && zm && zm !== 15) {
chunk.updateBlock(xm - 1, y, zm, this, lazy, false, x,y,z)
chunk.updateBlock(xm, y - 1, zm, this, lazy, false, x,y,z)
chunk.updateBlock(xm + 1, y, zm, this, lazy, false, x,y,z)
chunk.updateBlock(xm, y + 1, zm, this, lazy, false, x,y,z)
chunk.updateBlock(xm, y, zm - 1, this, lazy, false, x,y,z)
chunk.updateBlock(xm, y, zm + 1, this, lazy, false, x,y,z)
}
else {
this.updateBlock(x - 1, y, z, lazy, false, x,y,z, dimension)
this.updateBlock(x + 1, y, z, lazy, false, x,y,z, dimension)
this.updateBlock(x, y - 1, z, lazy, false, x,y,z, dimension)
this.updateBlock(x, y + 1, z, lazy, false, x,y,z, dimension)
this.updateBlock(x, y, z - 1, lazy, false, x,y,z, dimension)
this.updateBlock(x, y, z + 1, lazy, false, x,y,z, dimension)
}
chunk.updateBlock(xm, y, zm, this, lazy, noOnupdate, x,y,z)
// Update the corner chunks so shadows in adjacent chunks update correctly
if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy, true,x,y,z,dimension); }
if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy, true,x,y,z,dimension); }
if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy, true,x,y,z,dimension); }
if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy, true,x,y,z,dimension); }
}
tagUpdate(x,y,z,dimension,t){
var block = this.getBlock(x,y,z,dimension)
if(block && blockData[block].ontagsupdate) blockData[block].ontagsupdate(x,y,z,dimension,t,this)
}
tagsChanged(x,y,z, t, remote, dimension, lazy){
/*var str = x.toString(36)+","+y.toString(36)+","+z.toString(36)
var editedTags = dimension === "nether" ? this.netherEditedTags : (dimension === "end" ? this.endEditedTags : this.editedTags)
if(t){
if(!editedTags.includes(str)) editedTags.push(str)
}else{
if(editedTags.includes(str)){
editedTags.splice(editedTags.indexOf(str),1)
}
}*/
if(!lazy){
this.tagUpdate(x,y,z,dimension,t)
this.tagUpdate(x-1,y,z,dimension,t)
this.tagUpdate(x+1,y,z,dimension,t)
this.tagUpdate(x,y-1,z,dimension,t)
this.tagUpdate(x,y+1,z,dimension,t)
this.tagUpdate(x,y,z-1,dimension,t)
this.tagUpdate(x,y,z+1,dimension,t)
}
if(!remote){
this.sendAllInChunk({type:"setTags", x, y, z, data:t, dimension, lazy},x>>4,z>>4,dimension)
}
}
getTags(x,y,z,dimension){
if (y > maxHeight) {
return
} else if (y < minHeight) {
return
}
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
if (!chunks[x >> 4] || !chunks[x >> 4][z >> 4]) {
return
}
return chunks[x >> 4][z >> 4].getTags(x & 15, y, z & 15)
}
getTagByName(x,y,z,n,dimension){
if (y > maxHeight) {
return
} else if (y < minHeight) {
return
}
return this.getChunk(x, z, dimension).getTagByName(x & 15, y, z & 15, n)
}
setTags(x,y,z,data, remote,dimension, lazy){
var chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
if (!chunks[x >> 4] || !chunks[x >> 4][z >> 4]) {
return
}
if(y < minHeight) return
let chunk = chunks[x >> 4] && chunks[x >> 4][z >> 4]
let xm = x & 15
let zm = z & 15
chunk.setTags(xm, y, zm, data)
this.tagsChanged(x,y,z,data, remote, dimension, lazy)
}
setTagByName(x,y,z,n,data, remote,dimension, lazy){
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
if (!chunks[x >> 4] || !chunks[x >> 4][z >> 4]) {
return
}
if(y < minHeight) return
let chunk = chunks[x >> 4] && chunks[x >> 4][z >> 4]
let xm = x & 15
let zm = z & 15
var t = chunk.setTagByName(xm, y, zm, n,data)
this.tagsChanged(x,y,z,t, remote,dimension, lazy)
}
updateTags(x,y,z,dimension,lazy){
var t = this.getTags(x,y,z,dimension)
this.tagsChanged(x,y,z,t,false,dimension,lazy)
}
getLight(x, y, z, blockLight = 0, dimension, fullOutside = 0) {
if(y < minHeight) return 0
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
let chunk = chunks[x >> 4] && chunks[x >> 4][z >> 4]
if(chunk){
return chunk.getLight(x & 15, y, z & 15, blockLight, fullOutside)
}
return (!blockLight || fullOutside) * 15
}
setLight(x, y, z, level, block, dimension) {
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
let chunk = chunks[x >> 4] && chunks[x >> 4][z >> 4]
if (chunk) {
return chunk.setLight(x & 15, y, z & 15, level, block)
}
}
updateLight(x, y, z, place, blockLight = 0, dimension) {
let chunk = this.getChunk(x, z, dimension)
let cx = x & 15
let cz = z & 15
let center = chunk.getLight(cx, y, cz, 0)
let centerExposed = chunk.getLight(cx, y, cz, 2)
let blight = chunk.getLight(cx, y, cz, 1)
let up = this.getLight(x, y+1, z, 0, dimension)
let upExposed = this.getLight(x, y+1, z, 2, dimension)
let down = this.getLight(x, y-1, z, 0, dimension)
let north = this.getLight(x, y, z+1, 0, dimension)
let south = this.getLight(x, y, z-1, 0, dimension)
let east = this.getLight(x+1, y, z, 0, dimension)
let west = this.getLight(x-1, y, z, 0, dimension)
/*if(place){ //set vertical column to 15
let spread = []
for(let x2 = x-1; x2 <= x+1; x2++) for(let z2 = z-1; z2 <= z+1; z2++){
//spread around side too so the sides won't get dark
let i = chunk.sections.length * 16 - 1
let cx2 = x2 & 15, cz2 = z2 & 15
for(; i >= 0; i--){
if(!blockData[chunk.getBlock(cx2,i,cz2)].transparent) break
if(chunk.getLight(cx2,i,cz2,0) !== 15){
chunk.setLight(cx2,i,cz2,15,0)
spread.push(x2,i,z2)
}
}
}
if(spread.length) chunk.spreadLight(spread, 14, true)
}*/
let spread = []
for (let i = 0; i <= 15; i++) spread[i] = []
if (!place) { // Block was removed; increase light levels
if (upExposed) {
let light = upExposed
for (let i = y; i >= minHeight; i--) {
let block = blockData[chunk.getBlock(cx, i, cz)]
if (block.transparent) {
if(block.decreaseLight){
light = max(light - block.decreaseLight,0)
}
chunk.setLight(cx, i, cz, light, 2)
if(light > chunk.getLight(cx, i, cz, 0)) chunk.setLight(cx, i, cz, light, 0)
spread[light].push(x, i, z)
} else {
break
}
}
for (let i = 0; i < spread.length; i++){
if(spread[i].length) chunk.spreadLight(spread[i], i-1, true)
}
} else {
center = max(up, down, north, south, east, west)
if (center > 0) center -= 1
this.setLight(x, y, z, center, 0, dimension)
if (center > 1) {
spread[center].push(x, y, z)
chunk.spreadLight(spread[center], center - 1, true)
}
}
// Block light levels
if (!blockLight || blockLight < blight) {
up = this.getLight(x, y+1, z, 1, dimension)
down = this.getLight(x, y-1, z, 1, dimension)
north = this.getLight(x, y, z+1, 1, dimension)
south = this.getLight(x, y, z-1, 1, dimension)
east = this.getLight(x+1, y, z, 1, dimension)
west = this.getLight(x-1, y, z, 1, dimension)
blight = max(up, down, north, south, east, west)
spread[blight].length = 0
if (blight > 0) blight -= 1
this.setLight(x, y, z, blight, 1, dimension)
if (blight > 1) {
spread[blight].push(x, y, z)
chunk.spreadLight(spread[blight], blight - 1, true, 1)
}
spread[blight].length = 0
}
}
else if (place && (center !== 0 || blight !== 0)) { // Block was placed; decrease light levels
let respread = []
for (let i = 0; i <= 15/*center + 1*/; i++) respread[i] = []
chunk.setLight(cx, y, cz, 0, 0)
chunk.setLight(cx, y, cz, 0, 1)
spread[center].push(x, y, z)
// Sky light
let light = centerExposed, startY = y
if(!blockData[chunk.getBlock(cx, y, cz)].transparent){
chunk.setLight(cx, y, cz, 0, 0)
chunk.setLight(cx, y, cz, 0, 1)
chunk.setLight(cx, y, cz, 0, 2)
spread[center].push(x, y, z)
startY--
light = 0
}
if(centerExposed){
for (let i = startY; i >= minHeight; i--) {
let block = blockData[chunk.getBlock(cx, i, cz)]
if (block.transparent) {
if(block.decreaseLight){
light = max(light - block.decreaseLight,0)
}
chunk.setLight(cx, i, cz, light, 2)
let prevLight = chunk.getLight(cx, i, cz, 0)
chunk.setLight(cx, i, cz, light, 0)
spread[prevLight].push(x, i, z)
} else {
break
}
}
}
for (let i = 0; i <= 15; i++){
if(spread[i].length) chunk.unSpreadLight(spread[i], i - 1, respread)
}
chunk.reSpreadLight(respread)
// Block light
if (blight) {
respread.length = 0
for (let i = 0; i <= 15/*blight + 1*/; i++) respread[i] = []
spread[blight].length = 0
spread[blight].push(x, y, z)
chunk.unSpreadLight(spread[blight], blight - 1, respread, 1)
chunk.reSpreadLight(respread, 1)
spread[blight].length = 0
}
}
if (place && blockLight) { // Light block was placed
this.setLight(x, y, z, blockLight, 1, dimension)
spread[blockLight].length = 0
spread[blockLight].push(x, y, z)
chunk.spreadLight(spread[blockLight], blockLight - 1, true, 1)
} else if (!place && blockLight) { // Light block was removed
this.setLight(x, y, z, 0, 1, dimension)
spread[blockLight].length = 0
spread[blockLight].push(x, y, z)
let respread = []
for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
chunk.unSpreadLight(spread[blockLight], blockLight - 1, respread, 1)
chunk.reSpreadLight(respread, 1)
}
}
spawnBlock(x, y, z, blockID, dimension, force) {
//Sets a block anywhere without causing block updates around it. Only to be used in world gen.
if(blockData[blockID].crossShape) blockID |= CROSS
if(blockData[blockID].tallcrossShape) blockID |= TALLCROSS
if(blockData[blockID].cactus) blockID |= CACTUS
if(blockData[blockID].randomRotateOnSpawn){
switch(round(hash3(x,y,z)*3)){
case 0:
blockID |= NORTH
break
case 1:
blockID |= WEST
break
case 2:
blockID |= SOUTH
break
case 3:
blockID |= EAST
break
}
}
let chunkX = x >> 4
let chunkZ = z >> 4
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
if (!chunks[chunkX]) {
chunks[chunkX] = []
}
let chunk = this.getOrNewChunk(x,z,dimension)
let solid = blockData[chunk.getBlock(x & 15, y, z & 15)].solid
if (chunk.allGenerated) {
//Only used if spawning a block post-gen
if(!solid) this.setBlock(x, y, z, blockID, false, false,false,false, dimension)
} else if (force || !solid) {
chunk.setBlock(x & 15, y, z & 15, blockID)
}
}
getBiome(x,y,z,dimension){
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
if (!chunks[x >> 4] || !chunks[x >> 4][z >> 4]) {
return
}
let X = x & 15
let Z = z & 15
let caveMinY = chunks[x >> 4][z >> 4].caveY[Z * 16 + X]
let caveMaxY = chunks[x >> 4][z >> 4].caveY[Z * 16 + X + 256]
return biomes[y < caveMaxY && y > caveMinY ? (chunks[x >> 4][z >> 4].caveBiomes[Z * 16 + X]) : (chunks[x >> 4][z >> 4].biomes[Z * 16 + X])]
}
getEntity(id){
for(var i=0; i<this.entities.length; i++){
if(this.entities[i].id === id){
return i
}
}
}
static entityPacketType = [
["version","constant",0],["id","basicString"],["entId","byte"],["x","double"],["y","double"],["z","double"],packetDimension,
["pitch","double"],["yaw","double"],["velx","double"],["vely","double"],["velz","double"],["spawnRelative","double"],
[ent=>ent.type==="Item"||ent.type==="ExperienceOrb","includeIf",[["amount","double"]]],
[ent=>ent.type==="Item"||(ent instanceof BlockEntity),"includeIf",[["block","uint"]]],
[ent=>ent.type==="Item","includeIf",[["from","basicString"],["durability","int"],["name","string"]]],
[ent=>ent.type==="BlockEntity","includeIf",[["solidOnGround","boolean"]]],
[ent=>ent.type==="MovingBlock","includeIf",[["sx","int"],["sy","int"],["sz","int"],["mx","int"],["my","int"],["mz","int"],["despawns","int"],["solidWhenDone","boolean"]]],
[ent=>ent.type==="TextDisplay","includeIf",[["text","string"],["size","double"],["color","array",[null,"number",8,255]],["background","array",[null,"number",8,255]],["glow","boolean"]]],
[ent=>ent.mob,"includeIf",[
["harmEffect","number",6,1],["health","double"],["burning","boolean"],["burnTimer","double"],["oxygen","double"],["spinTarget","double"],
[ent=>ent.path,"includeIf",[["path","array",[null,"int"]]]],
[ent=>ent.type==="Sheep"||ent.type==="Spider","includeIf",[["fur","boolean"]]],
[ent=>ent.type==="Sheep","includeIf",[["wool","basicString"]]],
[ent=>ent.type==="Sheep"||ent.type==="Wolf","includeIf",[["color","array",[null,"number",8,255]]]],
["eating","boolean"],["target","basicString"],["tame","boolean"],["sitting","boolean"],["owner","string"],["holding","uint"],["attractedBy","basicString"],
[ent=>ent.type==="Creeper","includeIf",[["explodeAmount","byte"],["timerStartRelative","double"]]],
["attackCooldown","byte"],["effects","mapObject",[null,"object",[["level","byte"],["time","int"],["showParticles","boolean"]]]]
]],
[ent=>ent.type==="BlockDisplay","includeIf",[["width","double"],["height","double"],["depth","double"]]],
[ent=>ent.type==="Minecart","includeIf",[["harmEffect","number",6,1],["health","double"]]],
["doingPortal","uint"]
]
getEntPos(ent,now){
ent.spawnRelative = now-ent.spawn
if(ent.type === "Creeper") ent.timerStartRelative = now-ent.timerStart
return packetToBitArray(ent,this.constructor.entityPacketType,true)
/*let bab = new BitArrayBuilder()
bab.add(min(ent.id.length,255),8)
for(let c of ent.id.substring(0,255)) bab.add(c.charCodeAt(0),8)
bab.add(ent.entId,8)
bab.add(ent.x*16,24).add(ent.y*16,15).add(ent.z*16,24)
bab.add(ent.dimension === "nether" ? 1 : (ent.dimension === "end" ? 2 : 0),3)
bab.add(ent.pitch*100,11)
bab.add(ent.yaw*100,11)
bab.add(ent.velx*100,11).add(ent.vely*100,11).add(ent.velz*100,11)
bab.add(now-ent.spawn,32) //entity should despawn before limit or have no limit
bab.add((ent.amount||0)*10,20)
bab.add(ent.block||0,32)
bab.add(ent.from ? min(ent.from.length,255) : 0,8)
if(ent.from) for(let c of ent.from.substring(0,255)) bab.add(c.charCodeAt(0),8)
bab.add(ent.durability||0,16)
bab.addString(ent.name||"")
if(ent.type === "BlockEntity"){
bab.add(ent.solidOnGround||0,1)
}else if(ent.type === "MovingBlock"){
bab.add(ent.sx,20).add(ent.sy,20).add(ent.sz,20)
bab.add(ent.mx,20).add(ent.my,20).add(ent.mz,20)
bab.add(ent.despawns,32)
bab.add(ent.solidWhenDone,1)
}else if(ent.type === "TextDisplay"){
bab.addString(ent.text)
bab.add(ent.size*256,8)
bab.add(ent.color[0]*255,8).add(ent.color[1]*255,8).add(ent.color[2]*255,8)
bab.add(ent.background[0]*255,8).add(ent.background[1]*255,8).add(ent.background[2]*255,8).add(ent.background[3]*255,8)
bab.add(ent.glow,1)
}else if(ent.mob){
bab.add(ent.harmEffect,6)
bab.add(round(ent.health),16)
bab.add(ent.burning,1)
bab.add(ent.burnTimer*16,8)
bab.add(ent.oxygen,5)
bab.add(ent.spinTarget*100,11)
bab.add(ent.path ? ent.path.length : 0,8)
if(ent.path && ent.path.length > 255) logError("entity path too long")
if(ent.path){
for(let i of ent.path){
bab.add(i,20)
}
}
bab.add(ent.fur||0,1)
if(ent.color) bab.add(ent.color[0]*255,8).add(ent.color[1]*255,8).add(ent.color[2]*255,8)
else bab.add(0,24)
bab.add(ent.eating||0,6)
bab.add(ent.target ? min(ent.target.length,255) : 0,8)
if(ent.target) for(let c of ent.target.substring(0,255)) bab.add(c.charCodeAt(0),8)
if(ent.type === "Sheep"){
bab.add(ent.wool ? min(ent.wool.length,255) : 0,8)
if(ent.wool) for(let c of ent.wool.substring(0,255)) bab.add(c.charCodeAt(0),8)
}
bab.add(ent.tame||0,1)
bab.add(ent.sitting||0,1)
bab.add(ent.owner ? min(ent.owner.length,255) : 0,8)
if(ent.owner) for(let c of ent.owner.substring(0,255)) bab.add(c.charCodeAt(0),8)
bab.add(ent.holding||0, 32)
bab.add(ent.attractedBy ? min(ent.attractedBy.length,255) : 0,8)
if(ent.attractedBy) for(let c of ent.attractedBy.substring(0,255)) bab.add(c.charCodeAt(0),8)
if(ent.type === "Creeper"){
bab.add(ent.explodeAmount,7)
bab.add(now-ent.timerStart,32)
}
bab.add(ent.attackCooldown, 8)
let effects = Object.keys(ent.effects)
bab.add(effects.length,8)
for(let i of effects){
bab.addBasicString(i)
bab.add(ent.effects[i].level,8)
bab.add(ent.effects[i].time,32)
bab.add(ent.effects[i].showParticles ? 1 : 0, 1)
}
}else if(ent.type === "BlockDisplay"){
bab.add(ent.width*256,16).add(ent.height*256,16).add(ent.depth*256,16)
}else if(ent.type === "Minecart"){
bab.add(ent.harmEffect,6)
bab.add(round(ent.health),16)
}
return bab*/
}
addEntity(ent, remote, dimension){
if(!ent.id) ent.id = generateID()
ent.world = this
if(dimension || dimension === "") ent.dimension = ent.chunkDimension = dimension
if(!remote && !ent.remote){
//host controls entities
this.sendEntityPos(ent)
}
this.entities.push(ent)
//if(ent.alwaysRender) this.alwaysRenderEntities.push(ent)
let chunk = this.getOrNewChunk(ent.chunkX<<4,ent.chunkZ<<4,ent.dimension)
chunk.entities[ent.id] = ent
}
deleteEntity(id, remote, i){
i = (i || i===0) ? i : this.getEntity(id)
let ent = this.entities[i]
if(!ent || remote && ent.noRemoteDelete) return
id = ent.id
if(!remote){
this.sendAllInChunk({type:"entityDelete", id}, ent.chunkX,ent.chunkZ,ent.dimension)
}
if(i || i===0) this.entities.splice(i, 1)
/*if(ent.alwaysRender){
let i = this.alwaysRenderEntities.indexOf(ent)
this.alwaysRenderEntities.splice(i,1)
}*/
const {chunkX, chunkZ} = ent
let chunk = this.getChunk(chunkX<<4,chunkZ<<4,ent.dimension)
if(chunk) delete chunk.entities[id]
}
posEntity(p, m, preBetaVersion/*preBetaVersion only used in loadsave*/){
if (typeof p === "string") {
try {
p = BitArrayReader(atoarr(p),true)
}catch(e){
return
}
}else if(!(p instanceof BitArrayReader)) return
if(p.data[0] !== 0 || preBetaVersion) return this.posEntityOldBab(p, m, preBetaVersion)
let now = performance.now()
p = bitArrayToPacket(p,this.constructor.entityPacketType)
const entType = entityOrder[p.entId]
let ent = this.entities[this.getEntity(p.id)]
if(ent){
if(entType === "TextDisplay" && ent.text !== p.text) ent.setText(p.text)
if(entType === "Item" && ent.amount !== p.amount) ent.amount = p.amount, ent.willUpdateShape = true
}else{
ent = entities[p.entId]
switch(entType){
case "Item":
ent = new ent(p.x, p.y, p.z, p.velx, p.vely, p.velz, p.block, false, p.amount, p.durability||null, null)
break
case "BlockEntity":
ent = new ent(p.block, p.x,p.y,p.z, p.solidOnGround)
break
case "PrimedTNT":
case "PrimedSuperTNT":
case "PrimedUltraTNT":
case "PrimedUnTNT":
ent = new ent(p.x,p.y,p.z)
break
case "MovingBlock":
ent = new ent(p.block, p.sx,p.sy,p.sz,p.mx,p.my,p.mz,p.despawns,p.solidWhenDone)
break
case "BlockDisplay":
ent = new ent(p.block,p.x,p.y,p.z,0,0,0)
break
case "EnderPearl":
case "Snowball":
case "SmallFireball":
case "Egg":
case "SlingshotShot":
case "Arrow":
ent = new ent(p.x,p.y,p.z,0,0,0)
break
case "ExperienceOrb":
ent = new ent(p.x,p.y,p.z,p.amount)
break
case "Cow":
case "Pig":
case "Creeper":
case "Chicken":
case "Zombie":
case "Skeleton":
case "Wolf":
case "Blaze":
case "Enderman":
ent = new ent(p.x,p.y,p.z)
break
case "Sheep":
ent = new ent(p.x,p.y,p.z, p.color, p.wool)
break
case "Spider":
ent = new ent(p.x,p.y,p.z,p.fur)
break
case "EnderDragon":
ent = new ent(p.x,p.y,p.z)
break
case "TextDisplay":
ent = new ent(p.x,p.y,p.z,p.text,p.size,p.color,p.background,p.glow)
case "Minecart":
ent = new ent(p.x,p.y,p.z)
default:
break
}
if(!ent) return
ent.id = p.id
this.addEntity(ent, true)
ent.previousX = p.x
ent.previousY = p.y
ent.previousZ = p.z
}
if(!ent) return
ent.setPos(p.x,p.y,p.z,p.velx,p.vely,p.velz)
ent.dimension = p.dimension
if(!ent.facesPlayer){
ent.yaw = p.yaw
ent.pitch = p.pitch
}
ent.spawn = now - p.spawnRelative
if("from" in ent) ent.from = p.from
if(p.name) ent.name = p.name
ent.doingPortal = p.doingPortal
if(ent.mob){
ent.harmEffect = p.harmEffect
ent.health = p.health
ent.burning = p.burning
ent.burnTimer = p.burnTimer
ent.oxygen = p.oxygen
ent.spinTarget = p.spinTarget
if(p.path){
ent.path = p.path
}else ent.path = null
if("fur" in ent) ent.fur = p.fur
if("color" in ent){
ent.color = p.color
}
if("eating" in ent) ent.eating = p.eating
ent.target = p.target
if(entType === "Sheep") ent.wool = p.wool
if("tame" in ent) ent.tame = p.tame
if("sitting" in ent) ent.sitting = p.sitting
if("owner" in ent) ent.owner = p.owner
ent.holding = p.holding
ent.attractedBy = p.attractedBy
if(entType === "Creeper"){
ent.explodeAmount = p.explodeAmount
ent.timerStart = now - p.timerStartRelative
}
ent.attackCooldown = p.attackCooldown
ent.effects = p.effects
}else if(ent.type === "BlockDisplay"){
ent.width = p.width
ent.height = p.height
ent.depth = p.depth
}else if(ent.type === "Minecart"){
ent.harmEffect = p.harmEffect
ent.health = p.health
}
ent.updateChunk()
return ent
}
posEntityOldBab(p, m, preBetaVersion){
let now = performance.now()
let nameLen = p.read(8)
let id = ""
for (let i = 0; i < nameLen; i++) id += String.fromCharCode(p.read(8))
const type = p.read(8)
let i = this.getEntity(id)
let ent
const entType = entityOrder[type]
const x = p.read(24,true)/16, y = p.read(preBetaVersion?12:15,true)/16, z = p.read(24,true)/16
let dimension = p.read(3)
dimension = dimension === 1 ? "nether" : (dimension === 2 ? "end" : "")
const pitch = p.read(11,true)/100
const yaw = p.read(11,true)/100
const velx = p.read(11,true)/100
const vely = p.read(11,true)/100
const velz = p.read(11,true)/100
const spawn = now - p.read(32,true)
const amount = preBetaVersion ? p.read(16) : p.read(20)/10
const block = p.read(32)
nameLen = p.read(8)
let from = ""
for (let i = 0; i < nameLen; i++) from += String.fromCharCode(p.read(8))
const durability = p.read(16)
let name = p.readString()
//below var because it can be accessed outside block scope
if(entType === "BlockEntity"){
var solidOnGround = Boolean(p.read(1))
}else if(entType === "MovingBlock"){
var sx = p.read(20,true), sy = p.read(20,true), sz = p.read(20,true)
var mx = p.read(20,true), my = p.read(20,true), mz = p.read(20,true)
var despawns = p.read(32)
var solidWhenDone = p.read(1)
}else if(entType === "TextDisplay"){
var text = p.readString()
var size = p.read(8)/256
var color = [p.read(8)/255,p.read(8)/255,p.read(8)/255]
var background = [p.read(8)/255,p.read(8)/255,p.read(8)/255,p.read(8)/255]
var glow = !!p.read(1)
}else if(entities[type].mob){
var harmEffect = p.read(6)
var health = p.read(16)
var burning = Boolean(p.read(1))
var burnTimer = p.read(8)/16
var oxygen = p.read(5)
var spinTarget = p.read(11)/100
nameLen = p.read(8)
if(nameLen){
var path = []
for(let i = 0; i < nameLen; i++){
path.push(p.read(20,true))
}
}
var fur = Boolean(p.read(1))
var color = [p.read(8)/255,p.read(8)/255,p.read(8)/255]
var eating = p.read(6)
nameLen = p.read(8)
var target = ""
for (let i = 0; i < nameLen; i++) target += String.fromCharCode(p.read(8))
if(entType === "Sheep"){
nameLen = p.read(8)
var wool = ""
for (let i = 0; i < nameLen; i++) wool += String.fromCharCode(p.read(8))
}
var tame = Boolean(p.read(1))
var sitting = Boolean(p.read(1))
nameLen = p.read(8)
var owner = ""
for (let i = 0; i < nameLen; i++) owner += String.fromCharCode(p.read(8))
var holding = p.read(32)
nameLen = p.read(8)
var attractedBy = ""
for (let i = 0; i < nameLen; i++) attractedBy += String.fromCharCode(p.read(8))
if(entType === "Creeper"){
var explodeAmount = p.read(7)
var timerStart = now - p.read(32)
}
var attackCooldown = p.read(8)
let effectsLen = p.read(8)
var effects = {}
for(let i=0; i<effectsLen; i++){
effects[p.readBasicString()] = {level:p.read(8), time:p.read(32), showParticles:p.read(1)}
}
}else if(entType === "BlockDisplay"){
var width = p.read(16)/256, height = p.read(16)/256, depth = p.read(16)/256
}else if(entType === "Minecart"){
var harmEffect = p.read(6)
var health = p.read(16)
}
if(i || i===0){
ent = this.entities[i]
if(entType === "TextDisplay" && ent.text !== text) ent.setText(text)
if(entType === "Item" && ent.amount !== amount) ent.amount = amount, ent.willUpdateShape = true
}else{
ent = entities[type]
switch(entType){
case "Item":
ent = new ent(x, y, z, velx, vely, velz, block, false, amount, durability||null, null)
break
case "BlockEntity":
ent = new ent(block, x,y,z, solidOnGround)
break
case "PrimedTNT":
case "PrimedSuperTNT":
case "PrimedUltraTNT":
case "PrimedUnTNT":
ent = new ent(x,y,z)
break
case "MovingBlock":
ent = new ent(block, sx,sy,sz,mx,my,mz,despawns,solidWhenDone)
break
case "BlockDisplay":
ent = new ent(block,x,y,z,0,0,0)
break
case "EnderPearl":
case "Snowball":
case "SmallFireball":
case "Egg":
case "SlingshotShot":
case "Arrow":
ent = new ent(x,y,z,0,0,0)
break
case "ExperienceOrb":
ent = new ent(x,y,z,amount)
break
case "Cow":
case "Pig":
case "Creeper":
case "Chicken":
case "Zombie":
case "Skeleton":
case "Wolf":
case "Blaze":
case "Enderman":
ent = new ent(x,y,z)
break
case "Sheep":
ent = new ent(x,y,z, color, wool)
break
case "Spider":
ent = new ent(x,y,z,fur)
break
case "EnderDragon":
ent = new ent(x,y,z)
break
case "TextDisplay":
ent = new ent(x,y,z,text,size,color,background,glow)
case "Minecart":
ent = new ent(x,y,z)
default:
break
}
if(!ent) return
ent.id = id
this.addEntity(ent, true)
ent.previousX = parseFloat(p[0])
ent.previousY = parseFloat(p[1])
ent.previousZ = parseFloat(p[2])
}
if(!ent) return
ent.setPos(x,y,z,velx,vely,velz)
ent.dimension = dimension
if(!ent.facesPlayer){
ent.yaw = yaw
ent.pitch = pitch
}
ent.spawn = spawn
if("from" in ent) ent.from = from
if(name) ent.name = name
if(ent.mob){
ent.harmEffect = harmEffect
ent.health = health
ent.burning = burning
ent.burnTimer = burnTimer
ent.oxygen = oxygen
ent.spinTarget = spinTarget
if(path){
ent.path = path
}else ent.path = null
if("fur" in ent) ent.fur = fur
if("color" in ent){
ent.color = color
}
if("eating" in ent) ent.eating = eating
ent.target = target
if(entType === "Sheep") ent.wool = wool
if("tame" in ent) ent.tame = tame
if("sitting" in ent) ent.sitting = sitting
if("owner" in ent) ent.owner = owner
ent.holding = holding
ent.attractedBy = attractedBy
if(entType === "Creeper"){
ent.explodeAmount = explodeAmount
ent.timerStart = timerStart
}
ent.attackCooldown = attackCooldown
ent.effects = effects
}else if(ent.type === "BlockDisplay"){
ent.width = width
ent.height = height
ent.depth = depth
}else if(ent.type === "Minecart"){
ent.harmEffect = harmEffect
ent.health = health
}
ent.updateChunk()
return ent
}
sendEntityPos(ent){
this.sendAllInChunk({type:"entityPos", data:this.getEntPos(ent,performance.now()).array}, ent.chunkX,ent.chunkZ,ent.chunkDimension)
}
getEntities(p){
let x = p.x >> 4
let z = p.z >> 4
let {dimension, loadDistance} = p
loadDistance--
//if(!this.entities.length) return this.entities //its an empty array, so no problemslet minChunkX = x - d >> 4
let minChunkX = x - loadDistance
let maxChunkX = x + loadDistance
let minChunkZ = z - loadDistance
let maxChunkZ = z + loadDistance
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
let arr = []
for (x = minChunkX; x <= maxChunkX; x++) {
for (z = minChunkZ; z <= maxChunkZ; z++) {
if (chunks[x] && chunks[x][z]) {
let chunk = chunks[x][z]
for(let i in chunk.entities){
let now = performance.now()
//if(ent.remote) return
arr.push(this.getEntPos(chunk.entities[i],now).array)
}
}
}
}
return arr
}
getEntitiesNear(x,y,z,dimension,d, ret = []){
let chunks = dimension === "nether" ? this.netherChunks : (dimension === "end" ? this.endChunks : this.chunks)
let minChunkX = x - d >> 4
let maxChunkX = x + d >> 4
let minChunkY = y - d >> 4
let maxChunkY = y + d >> 4
let minChunkZ = z - d >> 4
let maxChunkZ = z + d >> 4
let section = null
ret.length = 0
let i = 0
for (x = minChunkX; x <= maxChunkX; x++) {
for (z = minChunkZ; z <= maxChunkZ; z++) {
if (chunks[x] && chunks[x][z]) {
let ents = chunks[x][z].entities
for(let i in ents){
ret.push(ents[i])
}
}
}
}
return ret
}
addItems(x,y,z,dimension,vx,vy,vz,block,autoSetVel,amount = 1,durability,customName,from){
if(!block) return
var data = blockData[block]
while(amount){
var a = min(amount,data.stackSize)
amount -= a
this.addEntity(new entities[entityIds.Item](x, y, z, vx, vy, vz, block, autoSetVel, a,durability,customName,from),false,dimension)
}
}
getRedstoneConnectedTo(x,y,z, level, dimension){
let spreaded = []
let spreadAt = []
spreadAt.push(x,y,z,0)
let tempblock
while(spreadAt.length){
let x = spreadAt[0]
let y = spreadAt[1]
let z = spreadAt[2]
let i = spreadAt[3]
if(i < level) {
if(!xyArrayHas(spreaded,spreadAt,x+1,y,z) && blockData[this.getBlock(x+1,y,z,dimension)].carryRedstone) spreadAt.push(x+1,y,z,i+1)
if(!xyArrayHas(spreaded,spreadAt,x-1,y,z) && blockData[this.getBlock(x-1,y,z,dimension)].carryRedstone) spreadAt.push(x-1,y,z,i+1)
if(!xyArrayHas(spreaded,spreadAt,x,y,z+1) && blockData[this.getBlock(x,y,z+1,dimension)].carryRedstone) spreadAt.push(x,y,z+1,i+1)
if(!xyArrayHas(spreaded,spreadAt,x,y,z-1) && blockData[this.getBlock(x,y,z-1,dimension)].carryRedstone) spreadAt.push(x,y,z-1,i+1)
if(!xyArrayHas(spreaded,spreadAt,x,y+1,z) && blockData[this.getBlock(x,y+1,z,dimension)].carryRedstone) spreadAt.push(x,y+1,z,i+1)
if(!xyArrayHas(spreaded,spreadAt,x,y-1,z) && blockData[this.getBlock(x,y-1,z,dimension)].carryRedstone) spreadAt.push(x,y-1,z,i+1)
let tags = this.getTags(x,y,z, dimension), block = this.getBlock(x,y,z,dimension)
if(blockData[block].name === "redstoneDust"){
if(getTagBits(tags,"westUp",block) && !xyArrayHas(spreaded,spreadAt,x+1,y+1,z)) spreadAt.push(x+1,y+1,z,i+1)
if(getTagBits(tags,"eastUp",block) && !xyArrayHas(spreaded,spreadAt,x-1,y+1,z)) spreadAt.push(x-1,y+1,z,i+1)
if(getTagBits(tags,"northUp",block) && !xyArrayHas(spreaded,spreadAt,x,y+1,z+1)) spreadAt.push(x,y+1,z+1,i+1)
if(getTagBits(tags,"southUp",block) && !xyArrayHas(spreaded,spreadAt,x,y+1,z-1)) spreadAt.push(x,y+1,z-1,i+1)
if(getTagBits(tags,"westDown",block) && !xyArrayHas(spreaded,spreadAt,x+1,y-1,z)) spreadAt.push(x+1,y-1,z,i+1)
if(getTagBits(tags,"eastDown",block) && !xyArrayHas(spreaded,spreadAt,x-1,y-1,z)) spreadAt.push(x-1,y-1,z,i+1)
if(getTagBits(tags,"northDown",block) && !xyArrayHas(spreaded,spreadAt,x,y-1,z+1)) spreadAt.push(x,y-1,z+1,i+1)
if(getTagBits(tags,"southDown",block) && !xyArrayHas(spreaded,spreadAt,x,y-1,z-1)) spreadAt.push(x,y-1,z-1,i+1)
}
if(blockData[block].rail){
tempblock = this.getBlock(x+1,y+1,z,dimension); if(!xyArrayHas(spreaded,spreadAt,x+1,y+1,z) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x+1,y+1,z,i+1)
tempblock = this.getBlock(x-1,y+1,z,dimension); if(!xyArrayHas(spreaded,spreadAt,x-1,y+1,z) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x-1,y+1,z,i+1)
tempblock = this.getBlock(x,y+1,z+1,dimension); if(!xyArrayHas(spreaded,spreadAt,x,y+1,z+1) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x,y+1,z+1,i+1)
tempblock = this.getBlock(x,y+1,z-1,dimension); if(!xyArrayHas(spreaded,spreadAt,x,y+1,z-1) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x,y+1,z-1,i+1)
tempblock = this.getBlock(x+1,y-1,z,dimension); if(!xyArrayHas(spreaded,spreadAt,x+1,y-1,z) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x+1,y-1,z,i+1)
tempblock = this.getBlock(x-1,y-1,z,dimension); if(!xyArrayHas(spreaded,spreadAt,x-1,y-1,z) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x-1,y-1,z,i+1)
tempblock = this.getBlock(x,y-1,z+1,dimension); if(!xyArrayHas(spreaded,spreadAt,x,y-1,z+1) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x,y-1,z+1,i+1)
tempblock = this.getBlock(x,y-1,z-1,dimension); if(!xyArrayHas(spreaded,spreadAt,x,y-1,z-1) && blockData[tempblock].rail && blockData[tempblock].carryRedstone) spreadAt.push(x,y-1,z-1,i+1)
}
spreaded.push(x,y,z,i)
}
spreadAt.splice(0,4)
}
return spreaded
}
spreadPower(x,y,z, level,dimension){
if(!level) return
var spread = this.getRedstoneConnectedTo(x,y,z,level,dimension)
for(var i=0; i<spread.length; i+=4){
var bx = spread[i]
var by = spread[i+1]
var bz = spread[i+2]
if(bx === x && by === y && bz === z) continue
var l = this.getRedstoneWirePower(bx,by,bz,dimension)
if(l !== this.getPower(bx,by,bz,dimension)) this.setPower(bx,by,bz, l,false,dimension)
}
}
unspreadPower(x,y,z, level, includeSource,dimension){
if(!level) return
var spread = this.getRedstoneConnectedTo(x,y,z,level,dimension)
var toUpdate = []
for(var n=0; n<level; n++){
for(var i=0; i<spread.length; i+=4){
var bx = spread[i]
var by = spread[i+1]
var bz = spread[i+2]
if(!includeSource && bx === x && by === y && bz === z) continue
var l = this.getRedstoneWirePower(bx,by,bz,dimension)
if(l !== this.getPower(bx,by,bz,dimension)) this.setPower(bx,by,bz, l, true,dimension), toUpdate[i] = true
}
}
for(var i=0; i<toUpdate.length; i+=4){
if(toUpdate[i]){
var x = spread[i], y = spread[i+1], z = spread[i+2]
this.powerChangeUpdate(x,y,z, x,y,z, false,dimension)
this.powerChangeUpdate(x+1,y,z, x,y,z, false,dimension)
this.powerChangeUpdate(x-1,y,z, x,y,z, false,dimension)
this.powerChangeUpdate(x,y,z+1, x,y,z, false,dimension)
this.powerChangeUpdate(x,y,z-1, x,y,z, false,dimension)
this.powerChangeUpdate(x,y+1,z, x,y,z, false,dimension)
this.powerChangeUpdate(x,y-1,z, x,y,z, false,dimension)
this.updateTags(x,y,z,dimension,true)
}
}
/*this.powerChangeUpdate(x+1,y,z)
this.powerChangeUpdate(x-1,y,z)
this.powerChangeUpdate(x,y,z+1)
this.powerChangeUpdate(x,y,z-1)*/
}
getPowerForWire(x,y,z,dimension,blue=0,rail=false){
let block = this.getBlock(x,y,z,dimension)
if(blockData[block].name === "redstoneDust" && blue !== (block & FLIP)) return 0
if(rail && !blockData[block].rail) return 0
return this.getPower(x,y,z,dimension)
}
getRedstoneWirePower(x,y,z,dimension){
let tags = this.getTags(x,y,z,dimension), block = this.getBlock(x,y,z,dimension), blue = block & FLIP
let right = this.getPowerForWire(x+1,y,z,dimension,blue)
let left = this.getPowerForWire(x-1,y,z,dimension,blue)
let down = this.getPowerForWire(x,y,z+1,dimension,blue)
let up = this.getPowerForWire(x,y,z-1,dimension,blue)
let top = this.getPowerForWire(x,y+1,z,dimension,blue)
let bottom = this.getPowerForWire(x,y-1,z,dimension,blue)
let westUp = 0, eastUp = 0, northUp = 0, southUp = 0, westDown = 0, eastDown = 0, northDown = 0, southDown = 0
if(tags && blockData[block].name === "redstoneDust"){
westUp = getTagBits(tags,"westUp",block) ? this.getPowerForWire(x+1,y+1,z,dimension,blue) : 0
eastUp = getTagBits(tags,"eastUp",block) ? this.getPowerForWire(x-1,y+1,z,dimension,blue) : 0
northUp = getTagBits(tags,"northUp",block) ? this.getPowerForWire(x,y+1,z+1,dimension,blue) : 0
southUp = getTagBits(tags,"southUp",block) ? this.getPowerForWire(x,y+1,z-1,dimension,blue) : 0
westDown = getTagBits(tags,"westDown",block) ? this.getPowerForWire(x+1,y-1,z,dimension,blue) : 0
eastDown = getTagBits(tags,"eastDown",block) ? this.getPowerForWire(x-1,y-1,z,dimension,blue) : 0
northDown = getTagBits(tags,"northDown",block) ? this.getPowerForWire(x,y-1,z+1,dimension,blue) : 0
southDown = getTagBits(tags,"southDown",block) ? this.getPowerForWire(x,y-1,z-1,dimension,blue) : 0
}
if(blockData[block].rail){
westUp = this.getPowerForWire(x+1,y+1,z,dimension,0,true)
eastUp = this.getPowerForWire(x-1,y+1,z,dimension,0,true)
northUp = this.getPowerForWire(x,y+1,z+1,dimension,0,true)
southUp = this.getPowerForWire(x,y+1,z-1,dimension,0,true)
westDown = this.getPowerForWire(x+1,y-1,z,dimension,0,true)
eastDown = this.getPowerForWire(x-1,y-1,z,dimension,0,true)
northDown = this.getPowerForWire(x,y-1,z+1,dimension,0,true)
southDown = this.getPowerForWire(x,y-1,z-1,dimension,0,true)
}
let level = max(right,left,down,up, top,bottom, northUp,southUp,eastUp,westUp, northDown,southDown,eastDown,westDown,this.redstoneComponentPowering(x,y,z,dimension)+1) - 1
if(this.getSurroundingBlockPower(x,y,z,dimension) === "strong"){
level = 15
}
return level < 0 ? 0 : level
}
repeaterIsPowering(x,y,z,rx,ry,rz,dimension){
var block = this.getBlock(rx,ry,rz,dimension)
if(block && (blockData[block].name === "repeater" || blockData[block].logicGate || blockData[block].name === "comparator")){
return blockData[block].canHavePower(rx,ry,rz,x,y,z,dimension,this)
}
return 0
}
observerIsPowering(x,y,z,rx,ry,rz,dimension){
var block = this.getBlock(rx,ry,rz,dimension)
if(block && blockData[block].name === "observer"){
return blockData[block].canHavePower(rx,ry,rz,x,y,z,dimension,this)
}
return 0
}
redstoneComponentPowering(x,y,z,dimension){
return max(
this.repeaterIsPowering(x,y,z,x+1,y,z,dimension),
this.repeaterIsPowering(x,y,z,x-1,y,z,dimension),
this.repeaterIsPowering(x,y,z,x,y,z+1,dimension),
this.repeaterIsPowering(x,y,z,x,y,z-1,dimension),
this.observerIsPowering(x,y,z,x+1,y,z,dimension),
this.observerIsPowering(x,y,z,x-1,y,z,dimension),
this.observerIsPowering(x,y,z,x,y+1,z,dimension),
this.observerIsPowering(x,y,z,x,y-1,z,dimension),
this.observerIsPowering(x,y,z,x,y,z+1,dimension),
this.observerIsPowering(x,y,z,x,y,z-1,dimension)
)
}
getRedstonePower(x,y,z,dimension){
var right = this.getPower(x+1,y,z,dimension)
var left = this.getPower(x-1,y,z,dimension)
var down = this.getPower(x,y,z+1,dimension)
var up = this.getPower(x,y,z-1,dimension)
var top = this.getPower(x,y+1,z,dimension)
var bottom = this.getPower(x,y-1,z,dimension)
var level = max(right,left,down,up,top,bottom, this.redstoneComponentPowering(x,y,z,dimension))
return level
}
getRepeaterPower(x,y,z,fx,fy,fz,dimension){
var level = max(this.getPower(fx,fy,fz,dimension), this.repeaterIsPowering(x,y,z,fx,fy,fz,dimension), this.observerIsPowering(x,y,z,fx,fy,fz,dimension))
return level
}
getPower(x,y,z,dimension){
return this.getTagByName(x,y,z,"power",dimension) || 0
}
setPower(x,y,z, level, lazy,dimension){
var block = this.getBlock(x,y,z,dimension)
if(block && blockData[block].noSetPower) return
let tagBits = blockData[block].tagBits
if(tagBits){
this.setTagByName(x,y,z,"power",level,lazy,dimension,true)
}else{
var tags = this.getTags(x,y,z,dimension) || {}
if(level) tags.power = level
else delete tags.power
this.setTags(x,y,z,tags,false,dimension,true)
}
this.updateBlock(x,y,z,false,true,null,null,null,dimension)
if(lazy) return //don't update blocks if lazy
this.powerChangeUpdate(x,y,z, x,y,z, false,dimension)
this.powerChangeUpdate(x+1,y,z, x,y,z, false,dimension)
this.powerChangeUpdate(x-1,y,z, x,y,z, false,dimension)
this.powerChangeUpdate(x,y,z+1, x,y,z, false,dimension)
this.powerChangeUpdate(x,y,z-1, x,y,z, false,dimension)
this.powerChangeUpdate(x,y+1,z, x,y,z, false,dimension)
this.powerChangeUpdate(x,y-1,z, x,y,z, false,dimension)
}
blockPowerNames = {top:"blockPowerTop",bottom:"blockPowerBottom",north:"blockPowerNorth",south:"blockPowerSouth",east:"blockPowerEast",west:"blockPowerWest"}
setBlockPower(x,y,z, type, fromDir,dimension){
var block = this.getBlock(x,y,z,dimension)
if(block && blockData[block].noSetPower) return
if(type !== null && type !== "weak" && type !== "strong") {type = null; console.error("Oh no! It can only be strong or weak or null. But it was",type)}
let tagBits = blockData[block].tagBits
type = !type ? 0 : (type === "strong" ? 2 : 1)
if(tagBits){
this.setTagByName(x,y,z,this.blockPowerNames[fromDir],type,false,dimension)
}else{
var tags = this.getTags(x,y,z,dimension) || {}
if(type){
if(!tags.blockPower) tags.blockPower = {}
tags.blockPower[fromDir] = type
}else if(tags.blockPower){
delete tags.blockPower[fromDir]
if(!tags.blockPower.top && !tags.blockPower.bottom && !tags.blockPower.north && !tags.blockPower.south && !tags.blockPower.east && !tags.blockPower.west) delete tags.blockPower
}
this.setTags(x,y,z,tags,false,dimension)
}
this.powerChangeUpdate(x,y,z, x,y,z, true,dimension)
if(fromDir !== "west") this.powerChangeUpdate(x+1,y,z, x,y,z, true,dimension)
if(fromDir !== "east") this.powerChangeUpdate(x-1,y,z, x,y,z, true,dimension)
if(fromDir !== "north") this.powerChangeUpdate(x,y,z+1, x,y,z, true,dimension)
if(fromDir !== "south") this.powerChangeUpdate(x,y,z-1, x,y,z, true,dimension)
if(fromDir !== "top") this.powerChangeUpdate(x,y+1,z, x,y,z, true,dimension)
if(fromDir !== "bottom") this.powerChangeUpdate(x,y-1,z, x,y,z, true,dimension)
}
getBlockPower(x,y,z, dir,dimension){
var tags = this.getTags(x,y,z,dimension)
if(!tags) return null
let block = this.getBlock(x,y,z,dimension)
let tagBits = blockData[block].tagBits
let power
if(tagBits){
if(dir){
power = this.getTagByName(x,y,z,this.blockPowerNames[dir],dimension)
}else{
power = max(
this.getTagByName(x,y,z,this.blockPowerNames["top"],dimension),
this.getTagByName(x,y,z,this.blockPowerNames["bottom"],dimension),
this.getTagByName(x,y,z,this.blockPowerNames["north"],dimension),
this.getTagByName(x,y,z,this.blockPowerNames["south"],dimension),
this.getTagByName(x,y,z,this.blockPowerNames["east"],dimension),
this.getTagByName(x,y,z,this.blockPowerNames["west"],dimension),
)
}
}else{
var blockPower = tags.blockPower
if(!blockPower) return null
if(dir){
power = blockPower[dir]
}else{
power = max(blockPower.top, blockPower.bottom, blockPower.north, blockPower.south, blockPower.east, blockPower.west)
}
}
return !power ? null : (power === 2 ? "strong" : "weak")
}
getSurroundingBlockPower(x,y,z,dimension){
var north = this.getBlockPower(x,y,z-1,null,dimension)
var south = this.getBlockPower(x,y,z+1,null,dimension)
var east = this.getBlockPower(x-1,y,z,null,dimension)
var west = this.getBlockPower(x+1,y,z,null,dimension)
var top = this.getBlockPower(x,y+1,z,null,dimension)
var bottom = this.getBlockPower(x,y-1,z,null,dimension)
if(top === "strong" || bottom === "strong" || north === "strong" || south === "strong" || east === "strong" || west === "strong"){
return "strong"
}else if(top === "weak" || bottom === "weak" || north === "weak" || south === "weak" || east === "weak" || west === "weak"){
return "weak"
}
return null
}
powerChangeUpdate(x,y,z,sx,sy,sz, blockPowerChanged,dimension){
var block = this.getBlock(x,y,z,dimension)
if(block && blockData[block].onpowerupdate){
blockData[block].onpowerupdate(x,y,z,sx,sy,sz, blockPowerChanged,dimension,this)
}
}
getBlockRotation(block){
switch(block&ROTATION){
case NORTH:
return 0
case EAST:
return 1
case SOUTH:
return 2
case WEST:
return 3
}
}
getRotationBlock(rot){
switch(rot){
case 0:
return NORTH
case 1:
return EAST
case 2:
return SOUTH
case 3:
return WEST
}
}
canStairConnect(sourceBlock,otherBlock,isBack){
if((sourceBlock&FLIP) !== (otherBlock&FLIP)) return
let sourceRot = this.getBlockRotation(sourceBlock)
let otherRot = this.getBlockRotation(otherBlock)
let rotDiff = mod(sourceRot-otherRot,4)
if((otherBlock&isState) === STAIR){
if(rotDiff === 1) return 1
else if(rotDiff === 3) return -1
}else if((otherBlock&isState) === CORNERSTAIRIN){
if(rotDiff === 0 && isBack || rotDiff === 1 && !isBack) return 1
else if(rotDiff === 3 && isBack || rotDiff === 2 && !isBack) return -1
}else if((otherBlock&isState) === CORNERSTAIROUT){
if(rotDiff === 1 && isBack || rotDiff === 0 && !isBack) return 1
else if(rotDiff === 2 && isBack || rotDiff === 3 && !isBack) return -1
}
}
setTimeout(func,time,x,y,z,dimension,block){
let exist
if(x || x === 0) for(let i = this.timeoutQueue.length-1; i>=0; i--){
let timeout = this.timeoutQueue[i]
if(timeout.x === x && timeout.y === y && timeout.z === z && timeout.dimension === dimension){
exist = timeout
break
}
}
if(exist){
exist.func = func
exist.time = performance.now() + time
exist.x = x, exist.y = y, exist.z = z, exist.dimension = dimension
}else this.timeoutQueue.push({
func,
time:performance.now() + time,
x,y,z,dimension
})
}
doBlockUpdate(x,y,z,dimension,sx,sy,sz){
let block = this.getBlock(x,y,z,dimension)
if(blockData[block].onupdate) blockData[block].onupdate(x,y,z,block,this,sx,sy,sz,dimension)
else if((block & isState) === STAIR && blockData[block].shape.varients.includes(shapes.stair)){//stair corner update
let front, back //front is lower side
switch(block&ROTATION){
case NORTH:
front = this.getBlock(x,y,z-1,dimension)
back = this.getBlock(x,y,z+1,dimension)
break
case SOUTH:
front = this.getBlock(x,y,z+1,dimension)
back = this.getBlock(x,y,z-1,dimension)
break
case EAST:
front = this.getBlock(x-1,y,z,dimension)
back = this.getBlock(x+1,y,z,dimension)
break
case WEST:
front = this.getBlock(x+1,y,z,dimension)
back = this.getBlock(x-1,y,z,dimension)
break
}
let connectBack = this.canStairConnect(block,back,true)
let connectFront = this.canStairConnect(block,front,false)
if(connectBack || connectFront) this.setTimeout(() => {
if(connectBack === -1 || connectFront === -1) block = block&(~ROTATION) | this.getRotationBlock(mod(this.getBlockRotation(block)+1,4))
if(connectBack) this.setBlock(x,y,z,(block&(~isState))|CORNERSTAIROUT,false,false,false,false,dimension)
else if(connectFront) this.setBlock(x,y,z,(block&(~isState))|CORNERSTAIRIN,false,false,false,false,dimension)
},tickTime)
}
}
loadChunks(){
this.chunkGenQueue.length = 0
this.lightingQueue.length = 0
this.populateQueue.length = 0
this.generateQueue.length = 0
this.loadQueue.length = 0
this.loaded.length = 0
this.loadedNear.length = 0
for(let p of this.players){
let cx = p.x >> 4
let cz = p.z >> 4
let loadDistance = min(this.loadDistance,p.loadDistance)
chunkPlayerDistArr.length = 0
sortChunkPX = p.x
sortChunkPZ = p.z
let minChunkX = cx - loadDistance - 3 //Load extra for generating & populating
let maxChunkX = cx + loadDistance + 3 //if you change this, change amount in fillReqs
let minChunkZ = cz - loadDistance - 3
let maxChunkZ = cz + loadDistance + 3
for (let x = minChunkX; x <= maxChunkX; x++) {
for (let z = minChunkZ; z <= maxChunkZ; z++) {
let chunk = this.getOrNewChunk(x*16,z*16,p.dimension)
if(maxDist(cx, cz, x, z) <= loadDistance){
if(!chunk.allGenerated && !this.chunkGenQueue.includes(chunk)) chunkPlayerDistArr.push(chunk)
if(!this.loadedNear.includes(chunk)){
this.loadedNear[this.loadedNear.length] = chunk
}
}
if(!this.loaded.includes(chunk)){
this.loaded[this.loaded.length] = chunk
}
}
}
this.chunkGenQueue.push(...chunkPlayerDistArr.sort(sortChunks))
}
}
async tick() {
let tickStart = performance.now()
if(this.loadedUpdate) this.loadChunks()
now = tickStart
let sleep = 0, sleepTotal = 0
for(var p of this.players){
if(p.hidden) continue
if(p.sleeping) sleep++
sleepTotal++
}
let allSleeping = sleepTotal && sleep === sleepTotal
if(this.settings.dayNightCycle){
if(allSleeping){
this.time += 6.25
}else this.time += 0.125
}
if(this.settings.weatherCycle){
this.nextWeather -= allSleeping ? 6.25 : 0.125
if(this.nextWeather <= 0) {
this.nextWeather = 0
this.weather = this.weather ? "" : "rain"
this.nextWeather = this.weather ? rand(0.5,1)*1000 : rand(0.5,7.5)*1000
}
}
if(this.weather === "rain" || this.weather === "snow"){
if(this.slowWeatherAmount >= 0.5){
this.weatherAmount += 0.02
if(this.weatherAmount > 1) this.weatherAmount = 1
}
this.slowWeatherAmount += 0.01
if(this.slowWeatherAmount > 1) this.slowWeatherAmount = 1
}else{
this.weatherAmount -= 0.02
if(this.weatherAmount < 0) this.weatherAmount = 0
this.slowWeatherAmount -= 0.01
if(this.slowWeatherAmount < 0) this.slowWeatherAmount = 0
}
let time = this.time % 1000
if(time > 725 && time < 850) this.skyLight = 1 - ((time - 725) / 125) //get darker
else if(time > 150 && time < 275) this.skyLight = (time - 150) / 125 //get brighter
else if(time >= 850 || time <= 150) this.skyLight = 0
else this.skyLight = 1
for (let c of this.loadedNear) {
c.tick()
}
for(let ent of this.entities){
if(ent.updateAlways) ent.updateAlways()
}
for(let i in this.players){
this.players[i].update()
this.players[i].updateLoaded()
}
for(let i = this.timeoutQueue.length-1; i>=0; i--){
if(tickStart - this.timeoutQueue[i].time >= 0) this.timeoutQueue.splice(i,1)[0].func()
}
for(let i=0; i<this.updateQueue.length; i+=7){
let x = this.updateQueue[i]
let y = this.updateQueue[i+1]
let z = this.updateQueue[i+2]
let dimension = this.updateQueue[i+3]
let sx = this.updateQueue[i+4]
let sy = this.updateQueue[i+5]
let sz = this.updateQueue[i+6]
this.doBlockUpdate(x,y,z,dimension,sx,sy,sz)
}
this.updateQueue.length = 0
if(this.superflat === "island" && this.islandGenerator.stage < 10){
if(!this.islandGenerator.promise){
this.islandGenerator.promise = new Promise(resolve => this.islandGenerator.promiseResolve = resolve)
this.loadPromises.push(this.islandGenerator.promise)
}
this.islandGenerator.Generate(performance.now())
if(this.islandGenerator.stage >= 10) this.islandGenerator.promiseResolve()
return
}
if(this.ticking) return
this.ticking = true
let doneWork = true
while(doneWork) {
doneWork = false
debug.start = performance.now()
if(this.generateQueue.length){
for(let i=0; i<this.generateQueue.length; i++){
let chunk = this.generateQueue[i]
if(!chunk.generated){
chunk.generate()
}else{
this.generateQueue.splice(i,1)
i--
}
}
doneWork = true
}
if(this.populateQueue.length && !doneWork){
let chunk = this.populateQueue[this.populateQueue.length - 1]
if(chunk.populated){
this.populateQueue.pop()
if(this.populateQueue.length) doneWork = true
}else{
if (!chunk.caves) {
chunk.carveCaves()
} else if (!chunk.populated) {
await chunk.populate()
}
doneWork = true
}
}
if (this.loadQueue.length && !doneWork) {
this.loadQueue.pop().load()
doneWork = true
}
if (this.lightingQueue.length && !doneWork) {
this.lightingQueue.pop().fillLight()
doneWork = true
}
if (this.chunkGenQueue.length && !doneWork) {
let chunk = this.chunkGenQueue[0]
if(this.fillReqs(chunk.x >> 4, chunk.z >> 4, chunk.type)) {
chunk.allGenerated = true
this.chunkGenQueue.shift()
this.generatedChunks++
}
doneWork = true
}
if (doneWork) await yieldThread()
}
this.ticking = false
}
fillReqs(x, z, dimension) {
// Chunks must all be loaded first.
let done = true
for (let i = x - 3; i <= x + 3; i++) {//if you change the size, change the adding in loadChunks
for (let j = z - 3; j <= z + 3; j++) {
let chunk = this.getChunk(i*16,j*16,dimension)
/*if(!chunk){
done = false
continue
}*/
if ((!chunk.generated || !chunk.caves && !this.usePreBeta) && !this.generateQueue.includes(chunk)) {
this.generateQueue.push(chunk)
done = false
}
if (!chunk.populated && i >= x - 2 && i <= x + 2 && j >= z - 2 && j <= z + 2 && !this.populateQueue.includes(chunk)) {
this.populateQueue.push(chunk)
done = false
}
if (!chunk.loaded && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1 && !this.loadQueue.includes(chunk)) {
if(this.loadFrom[i+","+j+","+dimension]) this.loadQueue.push(chunk)
else chunk.loaded = true
done = false
}
}
}
let chunk = this.getChunk(x*16,z*16,dimension)
if (!chunk.lit && !this.lightingQueue.includes(chunk)) {
this.lightingQueue.push(chunk)
done = false
}
return done
}
getTop(x,z,dimension){
let chunk = this.getChunk(x,z,dimension)
return chunk && chunk.tops[(z&15) * 16 + (x&15)] || 0
}
getSolidTop(x,z,dimension){
let chunk = this.getChunk(x,z,dimension)
return chunk && chunk.solidTops[(z&15) * 16 + (x&15)] || 0
}
getSaveString(){
let world = this
let chunks = this.chunks, netherChunks = this.netherChunks, endChunks = this.endChunks
let blockSet = new Set()
let sectionMap = {}, sectionTags = {}, sectionTagsLength = {}
for (let x in chunks) {
for (let z in chunks[x]) {
let chunk = chunks[x][z]
if (chunk.edited) {
for (let y = 0; y < chunk.sections.length; y++) {
const section = chunk.sections[y], original = chunk.cleanSections[y], blocks = section.blocks, tags = section.tags
if(!section.edited) continue
let changes = false
for (let i = 0; i < blocks.length; i++) {
if (blocks[i] !== original[i] || tags[i]) {
blockSet.add(blocks[i])
changes = true
let x = (i >> 8) + section.x
let y = (i >> 4 & 15) + section.y - minHeight
let z = (i & 15) + section.z
let str = `${x>>3},${y>>3},${z>>3},` // 8x8x8 sections
if (!sectionMap[str]) {
sectionMap[str] = []
for (let k = 0; k < 6; k++) sectionMap[str].push(new Int32Array(8*8*8).fill(-1))
sectionTags[str] = []
sectionTagsLength[str] = 0
}
// 6 copies of the chunk, all oriented in different directions so we can see which one compresses the most
sectionMap[str][0][(y & 7) << 6 | (x & 7) << 3 | z & 7] = blocks[i]
sectionMap[str][1][(y & 7) << 6 | (z & 7) << 3 | x & 7] = blocks[i]
sectionMap[str][2][(x & 7) << 6 | (y & 7) << 3 | z & 7] = blocks[i]
sectionMap[str][3][(x & 7) << 6 | (z & 7) << 3 | y & 7] = blocks[i]
sectionMap[str][4][(z & 7) << 6 | (x & 7) << 3 | y & 7] = blocks[i]
sectionMap[str][5][(z & 7) << 6 | (y & 7) << 3 | x & 7] = blocks[i]
if(tags[i]){
sectionTags[str][(y & 7) << 6 | (x & 7) << 3 | z & 7] = typeof tags[i] === "number" ? tags[i] : JSON.stringify(tags[i]).substring(0,65535)
sectionTagsLength[str]++
}
}
}
if (!changes) {
section.edited = false
}
}
}
}
}
for(let j in this.loadFrom){
const section = this.loadFrom[j], blocks = section.blocks, tags = section.tags
let [sx, sz, dimension] = j.split(",")
sx = +sx, sz = +sz
for(let i in blocks){
blockSet.add(blocks[i])
const z = (i & 15)+sz*16, x = ((i >> 4) & 15)+sx*16, y = (i >> 8) & 255
let str = `${x>>3},${y>>3},${z>>3},${dimension}`
if (!sectionMap[str]) {
sectionMap[str] = []
for (let k = 0; k < 6; k++) sectionMap[str].push(new Int32Array(8*8*8).fill(-1))
sectionTags[str] = []
sectionTagsLength[str] = 0
}
sectionMap[str][0][(y & 7) << 6 | (x & 7) << 3 | z & 7] = blocks[i]
sectionMap[str][1][(y & 7) << 6 | (z & 7) << 3 | x & 7] = blocks[i]
sectionMap[str][2][(x & 7) << 6 | (y & 7) << 3 | z & 7] = blocks[i]
sectionMap[str][3][(x & 7) << 6 | (z & 7) << 3 | y & 7] = blocks[i]
sectionMap[str][4][(z & 7) << 6 | (x & 7) << 3 | y & 7] = blocks[i]
sectionMap[str][5][(z & 7) << 6 | (y & 7) << 3 | x & 7] = blocks[i]
if(tags[i]){
sectionTags[str][(y & 7) << 6 | (x & 7) << 3 | z & 7] = typeof tags[i] === "number" ? tags[i] : JSON.stringify(tags[i]).substring(0,65535)
sectionTagsLength[str]++
}
}
}
//nether
for (let x in netherChunks) {
for (let z in netherChunks[x]) {
let chunk = netherChunks[x][z]
if (chunk.edited) {
for (let y = 0; y < chunk.sections.length; y++) {
const section = chunk.sections[y], original = chunk.cleanSections[y], blocks = section.blocks, tags = section.tags
if(!section.edited) continue
let changes = false
for (let i = 0; i < blocks.length; i++) {
if (blocks[i] !== original[i] || tags[i]) {
blockSet.add(blocks[i])
changes = true
let x = (i >> 8) + section.x
let y = (i >> 4 & 15) + section.y - minHeight
let z = (i & 15) + section.z
let str = `${x>>3},${y>>3},${z>>3},nether` // 8x8x8 sections
if (!sectionMap[str]) {
sectionMap[str] = []
for (let k = 0; k < 6; k++) sectionMap[str].push(new Int32Array(8*8*8).fill(-1))
sectionTags[str] = []
sectionTagsLength[str] = 0
}
// 6 copies of the chunk, all oriented in different directions so we can see which one compresses the most
sectionMap[str][0][(y & 7) << 6 | (x & 7) << 3 | z & 7] = blocks[i]
sectionMap[str][1][(y & 7) << 6 | (z & 7) << 3 | x & 7] = blocks[i]
sectionMap[str][2][(x & 7) << 6 | (y & 7) << 3 | z & 7] = blocks[i]
sectionMap[str][3][(x & 7) << 6 | (z & 7) << 3 | y & 7] = blocks[i]
sectionMap[str][4][(z & 7) << 6 | (x & 7) << 3 | y & 7] = blocks[i]
sectionMap[str][5][(z & 7) << 6 | (y & 7) << 3 | x & 7] = blocks[i]
if(tags[i]){
sectionTags[str][(y & 7) << 6 | (x & 7) << 3 | z & 7] = typeof tags[i] === "number" ? tags[i] : JSON.stringify(tags[i]).substring(0,65535)
sectionTagsLength[str]++
}
}
}
if (!changes) {
section.edited = false
}
}
}
}
}
//end
for (let x in endChunks) {
for (let z in endChunks[x]) {
let chunk = endChunks[x][z]
if (chunk.edited) {
for (let y = 0; y < chunk.sections.length; y++) {
const section = chunk.sections[y], original = chunk.cleanSections[y], blocks = section.blocks, tags = section.tags
if(!section.edited) continue
let changes = false
for (let i = 0; i < blocks.length; i++) {
if (blocks[i] !== original[i] || tags[i]) {
blockSet.add(blocks[i])
changes = true
let x = (i >> 8) + section.x
let y = (i >> 4 & 15) + section.y - minHeight
let z = (i & 15) + section.z
let str = `${x>>3},${y>>3},${z>>3},end` // 8x8x8 sections
if (!sectionMap[str]) {
sectionMap[str] = []
for (let k = 0; k < 6; k++) sectionMap[str].push(new Int32Array(8*8*8).fill(-1))
sectionTags[str] = []
sectionTagsLength[str] = 0
}
// 6 copies of the chunk, all oriented in different directions so we can see which one compresses the most
sectionMap[str][0][(y & 7) << 6 | (x & 7) << 3 | z & 7] = blocks[i]
sectionMap[str][1][(y & 7) << 6 | (z & 7) << 3 | x & 7] = blocks[i]
sectionMap[str][2][(x & 7) << 6 | (y & 7) << 3 | z & 7] = blocks[i]
sectionMap[str][3][(x & 7) << 6 | (z & 7) << 3 | y & 7] = blocks[i]
sectionMap[str][4][(z & 7) << 6 | (x & 7) << 3 | y & 7] = blocks[i]
sectionMap[str][5][(z & 7) << 6 | (y & 7) << 3 | x & 7] = blocks[i]
if(tags[i]){
sectionTags[str][(y & 7) << 6 | (x & 7) << 3 | z & 7] = typeof tags[i] === "number" ? tags[i] : JSON.stringify(tags[i]).substring(0,65535)
sectionTagsLength[str]++
}
}
}
if (!changes) {
section.edited = false
}
}
}
}
}
let blocks = Array.from(blockSet)
let palette = {}
blocks.forEach((block, index) => palette[block] = index)
let paletteBits = BitArrayBuilder.bits(blocks.length)
let worldTypeBits1 = this.superflat==="island" ? 2 : (this.superflat === "void" ? 3 : this.superflat)
let worldTypeBits2 = this.usePreBeta ? 1 : 0
let weatherBits = this.weather==="rain" ? 1 : (this.weather === "snow" ? 2 : 0)
let bab = new BitArrayBuilder()
bab.addString(this.name)
bab.add(this.worldSeed, 32)
bab.add(round(this.time), 32)
bab.add(weatherBits,2).add(this.nextWeather,17)
bab.add(worldTypeBits1, 2).add(this.caves, 1).add(this.trees, 1)
bab.add(version.length, 8)
for (let c of version) bab.add(c.charCodeAt(0), 8)
bab.add(worldTypeBits2,1)
bab.add(blocks.length, 32)
for (let block of blocks) bab.add(block, 32)
let sections = Object.entries(sectionMap)
bab.add(sections.length, 32)
for (let [coords, section] of sections) {
let [sx, sy, sz, dimension] = coords.split(",")
sx = +sx, sy = +sy, sz = +sz
bab.add(sx, 16).add(sy, 8).add(sz, 16).add((dimension === "nether" ? 1 : (dimension === "end" ? 2 : 0)), 3)
// Determine the most compact orientation by checking all 6!
let bestBAB = null
for (let i = 0; i < 6; i++) {
let bab = new BitArrayBuilder()
let blocks = section[i]
bab.add(i, 3)
let run = null
let runs = []
let singles = []
for (let i = 0; i < blocks.length; i++) {
const block = blocks[i]
if (block >= 0) {
if (!run && i < blocks.length - 2 && blocks[i + 1] >= 0 && blocks[i + 2] >= 0) {
run = [i, []]
runs.push(run)
}
if (run) {
if (run[1].length && block === run[1][run[1].length-1][1]) run[1][run[1].length-1][0]++
else run[1].push([1, block])
}
else singles.push([i, blocks[i]])
}
else run = null
}
bab.add(runs.length, 8)
bab.add(singles.length, 9)
for (let [start, blocks] of runs) {
// Determine the number of bits needed to store the lengths of each block type
let maxBlocks = 0
for (let block of blocks) maxBlocks = Math.max(maxBlocks, block[0])
let lenBits = BitArrayBuilder.bits(maxBlocks)
bab.add(start, 9).add(blocks.length, 9).add(lenBits, 4)
for (let [count, block] of blocks) bab.add(count - 1, lenBits).add(palette[block], paletteBits)
}
for (let [index, block] of singles) {
bab.add(index, 9).add(palette[block], paletteBits)
}
bab.add(sectionTagsLength[coords],9)
if(sectionTagsLength[coords]) for(let i in sectionTags[coords]){
let tags = sectionTags[coords][i]
bab.add(i,9)
if(typeof tags === "number"){
bab.add(0,1)
bab.add(tags,32)
}else{
bab.add(1,1)
bab.addString(tags,16)
}
}
if (!bestBAB || bab.bitLength < bestBAB.bitLength) {
bestBAB = bab
}
}
bab.append(bestBAB)
}
bab.add(worldSettingKeys.length,8)
for(let i of worldSettingKeys){
bab.add(this.settings[i]?1:0, 1)
}
let entities = this.entities.filter(r => !r.remote)
bab.add(entities.length,32)
let now = performance.now()
for(let i of entities){
let pos = this.getEntPos(i,now)
bab.add(pos.bitLength,16)
bab.append(pos)
}
bab.add(this.gameMode === "survival" ? 1 : (this.gameMode==="hardcore"?2:0),2).add(this.cheats?1:0,1)
bab.add(this.fancyRivers, 1)
return bab.array
}
loadSave(data, onlyMetdata = false) {
if (typeof data === "string") {
if (data.includes("Alpha")) {
try {
return this.loadOldSave(data, onlyMetdata)
}
catch(e) {
console.error(e)
alert("Unable to load save string.")
}
}
try {
data = atoarr(data)
}
catch(e) {
alert("Malformatted save string. Unable to load")
throw e
}
}
let reader = new BitArrayReader(data)
this.name = reader.readString()
this.setSeed(reader.read(32),true)
this.time = reader.read(32)
let weatherBits = reader.read(2)
this.weather = weatherBits === 1 ? "rain" : (weatherBits === 2 ? "snow" : "")
this.nextWeather = reader.read(17)
let worldTypeBits1 = reader.read(2)
this.caves = reader.read(1)
this.trees = reader.read(1)
let nameLen = reader.read(8)
try{
this.version = ""
for (let i = 0; i < nameLen; i++) this.version += String.fromCharCode(reader.read(8))
if(!this.version.includes("Alpha") && !this.version.includes("Beta")) throw ""
}catch(e){
console.error(e)
return this.loadCrossSaveCode(data, onlyMetdata)
}
let preBetaVersion = verMoreThan("1.1.0",this.version.replace(/(Alpha|Beta) /, ''))
let worldTypeBits2 = preBetaVersion ? 1 : reader.read(1)
if(worldTypeBits2 && worldTypeBits1 === 0){
this.superflat = false, this.usePreBeta = true
}else{
this.superflat = worldTypeBits1 === 2 ? "island" : (worldTypeBits1 === 3 ? "void" : Boolean(worldTypeBits1))
this.usePreBeta = false
}
if(onlyMetdata) return
let paletteLen = reader.read(32)
let palette = []
let paletteBits = BitArrayBuilder.bits(paletteLen)
for (let i = 0; i < paletteLen; i++) palette.push(reader.read(32))
const getIndex = [
(index, x, y, z) => (y + (index >> 6 & 7))*256 + (x + (index >> 3 & 7))*16 + z + (index >> 0 & 7),
(index, x, y, z) => (y + (index >> 6 & 7))*256 + (x + (index >> 0 & 7))*16 + z + (index >> 3 & 7),
(index, x, y, z) => (y + (index >> 3 & 7))*256 + (x + (index >> 6 & 7))*16 + z + (index >> 0 & 7),
(index, x, y, z) => (y + (index >> 0 & 7))*256 + (x + (index >> 6 & 7))*16 + z + (index >> 3 & 7),
(index, x, y, z) => (y + (index >> 0 & 7))*256 + (x + (index >> 3 & 7))*16 + z + (index >> 6 & 7),
(index, x, y, z) => (y + (index >> 3 & 7))*256 + (x + (index >> 0 & 7))*16 + z + (index >> 6 & 7)
]
let sectionCount = reader.read(32)
let chunks = {}
for (let i = 0; i < sectionCount; i++) {
let x = reader.read(16, true) * 8
let y = reader.read(preBetaVersion?5:8, false) * 8
let z = reader.read(16, true) * 8
let dimension = reader.read(3)
dimension = dimension === 1 ? "nether" : (dimension === 2 ? "end" : "")
let orientation = reader.read(3)
if(preBetaVersion) y -= minHeight
let cx = x >> 4
let cz = z >> 4
// Make them into local chunk coords
x = x !== cx * 16 ? 8 : 0
z = z !== cz * 16 ? 8 : 0
let ckey = `${cx},${cz},${dimension}`
let chunk = chunks[ckey]
if (!chunk) {
chunk = {blocks:[],tags:[]}
chunks[ckey] = chunk
}
let runs = reader.read(8)
let singles = reader.read(9)
for (let j = 0; j < runs; j++) {
let index = reader.read(9)
let types = reader.read(9)
let lenSize = reader.read(4)
for (let k = 0; k < types; k++) {
let chain = reader.read(lenSize) + 1
let block = reader.read(paletteBits)
for (let l = 0; l < chain; l++) {
chunk.blocks[getIndex[orientation](index, x, y, z)] = palette[block]
index++
}
}
}
for (let j = 0; j < singles; j++) {
let index = reader.read(9)
let block = reader.read(paletteBits)
chunk.blocks[getIndex[orientation](index, x, y, z)] = palette[block]
}
let tagsCount = reader.read(9)
for(let j=0; j<tagsCount; j++){
let index = reader.read(9)
if(reader.read(1)){
let tags = reader.readString(16)
try{
chunk.tags[getIndex[0](index, x, y, z)] = JSON.parse(tags)
}catch(e){console.log(e)}
}else{
chunk.tags[getIndex[0](index, x, y, z)] = reader.read(32)
}
}
}
this.loadFrom = chunks
this.loadKeys = Object.keys(chunks)
let settingsKeys = reader.read(8)
Object.assign(this.settings,defaultWorldSettings)
for(let i=0; i<settingsKeys; i++){
this.settings[worldSettingKeys[i]] = reader.read(1) ? true : false
}
if(preBetaVersion){
let inv = this.playersInv[":host"] = this.playersInv[":host"] || {}
let survivLength = reader.read(8)
if(survivLength){
inv.survivStr = reader.readToArrayBits(survivLength)
let asdf = {}
this.loadSurvivStr(new BitArrayReader(inv.survivStr,true),preBetaVersion,asdf)
this.cheats = asdf.cheats
this.gameMode = asdf.survival ? "survival" : "creative"
}
let invLength = reader.read(16)
if(invLength) inv.inv = reader.readToArrayBits(invLength)
}
let entsLen = reader.read(32)
for(let i=0; i<entsLen; i++){
let entLen = reader.read(16)
this.posEntity(reader.readToNew(entLen, true), null, preBetaVersion)
}
if(!preBetaVersion){
let survival = reader.read(2)
this.gameMode = survival === 1 ? "survival" : (survival === 2 ? "hardcore" : "creative")
this.cheats = reader.read(1)
if(reader.canRead) this.fancyRivers = reader.read(1)
else this.fancyRivers = false
}
this.findSpawnPoint()
}
getBlockConvert(){
const oldSLAB     = 0x100 // 9th bit
const oldSTAIR    = 0x200 // 10th bit
const oldFLIP     = 0x400 // 11th bit
const oldSOUTH    = 0x800
const oldEAST     = 0x1000
const oldWEST     = 0x1800
return [
"air",
"grass",
"dirt",
"stone",
"bedrock",
"sand",
"gravel",
"leaves",
"glass",
"cobblestone",
"mossyCobble",
"stoneBricks",
"mossyStoneBricks",
"bricks",
"coalOre",
"ironOre",
"goldOre",
"diamondOre",
"redstoneOre",
"lapisOre",
"emeraldOre",
"coalBlock",
"ironBlock",
"goldBlock",
"diamondBlock",
"redstoneBlock",
"lapisBlock",
"emeraldBlock",
"oakPlanks",
"oakLog",
"acaciaPlanks",
"acaciaLog",
"birchPlanks",
"birchLog",
"darkOakPlanks",
"darkOakLog",
"junglePlanks",
"jungleLog",
"sprucePlanks",
"spruceLog",
"whiteWool",
"orangeWool",
"magentaWool",
"lightBlueWool",
"yellowWool",
"limeWool",
"pinkWool",
"grayWool",
"lightGrayWool",
"cyanWool",
"purpleWool",
"blueWool",
"brownWool",
"greenWool",
"redWool",
"blackWool",
"whiteConcrete",
"orangeConcrete",
"magentaConcrete",
"lightBlueConcrete",
"yellowConcrete",
"limeConcrete",
"pinkConcrete",
"grayConcrete",
"lightGrayConcrete",
"cyanConcrete",
"purpleConcrete",
"blueConcrete",
"brownConcrete",
"greenConcrete",
"redConcrete",
"blackConcrete",
"bookshelf",
"netherrack",
"soulSand",
"glowstone",
"netherWartBlock",
"netherBricks",
"redNetherBricks",
"netherQuartzOre",
"quartzBlock",
"quartzPillar",
"chiseledQuartzBlock",
"chiseledStoneBricks",
"smoothStone",
"andesite",
"polishedAndesite",
"diorite",
"polishedDiorite",
"granite",
"polishedGranite",
"light",
"water",
"lava",
"obsidian",
"cryingObsidian",
"endStone",
"endStoneBricks",
"chiseledNetherBricks",
"crackedNetherBricks",
"crackedPolishedBlackstoneBricks",
"crackedStoneBricks",
"polishedBlackstoneBricks",
"prismarineBricks",
"quartzBricks",
"oakDoorTop",
"oakDoorBottom",
"warpedDoorTop",
"warpedDoorBottom",
"ironTrapdoor"
].reduce((a, v, i) => ({
...a,
[i]: blockIds[v],
[i|oldSLAB]: blockIds[v]|SLAB,
[i|oldSLAB|oldFLIP]: blockIds[v]|FLIP,
[i|oldSTAIR]: blockIds[v]|STAIR,
[i|oldSTAIR|oldSOUTH]: blockIds[v]|STAIR|SOUTH,
[i|oldSTAIR|oldEAST]: blockIds[v]|STAIR|EAST,
[i|oldSTAIR|oldWEST]: blockIds[v]|STAIR|WEST,
[i|oldSTAIR|oldFLIP]: blockIds[v]|STAIR|FLIP,
[i|oldSTAIR|oldSOUTH|oldFLIP]: blockIds[v]|STAIR|SOUTH|FLIP,
[i|oldSTAIR|oldEAST|oldFLIP]: blockIds[v]|STAIR|EAST|FLIP,
[i|oldSTAIR|oldWEST|oldFLIP]: blockIds[v]|STAIR|WEST|FLIP,
}), {})
}
loadCrossSaveCode(data, onlyMetdata){
const blockConvert = this.getBlockConvert()
let reader = new BitArrayReader(data)
let nameLen = reader.read(8)
this.name = ""
for (let i = 0; i < nameLen; i++) this.name += String.fromCharCode(reader.read(8))
this.setSeed(reader.read(32),true)
this.time = reader.read(32)*0+500
let inv = this.playersInv[":host"] = {}
inv.x = reader.read(20, true)
inv.y = reader.read(8)
inv.z = reader.read(20, true)
reader.skip(11)
reader.skip(11)
for (let i = 0; i < 9; i++){
reader.skip(16)
}
reader.skip(4)
reader.skip(1)
reader.skip(1)
this.superflat = Boolean(reader.read(1))
this.caves = reader.read(1)
this.trees = reader.read(1)
this.version = "Alpha " + [reader.read(8), reader.read(8), reader.read(8)].join(".")
this.usePreBeta = !this.superflat //Superflat and other types can be upgraded
if(onlyMetdata) return
let paletteLen = reader.read(16)
let palette = []
let paletteBits = BitArrayBuilder.bits(paletteLen)
for (let i = 0; i < paletteLen; i++) palette.push(reader.read(16))
for(let i=0; i<palette.length; i++){
if(blockConvert[palette[i]]) palette[i] = blockConvert[palette[i]]
}
const getIndex = [
(index, x, y, z) => (y + (index >> 6 & 7))*256 + (x + (index >> 3 & 7))*16 + z + (index >> 0 & 7),
(index, x, y, z) => (y + (index >> 6 & 7))*256 + (x + (index >> 0 & 7))*16 + z + (index >> 3 & 7),
(index, x, y, z) => (y + (index >> 3 & 7))*256 + (x + (index >> 6 & 7))*16 + z + (index >> 0 & 7),
(index, x, y, z) => (y + (index >> 0 & 7))*256 + (x + (index >> 6 & 7))*16 + z + (index >> 3 & 7),
(index, x, y, z) => (y + (index >> 0 & 7))*256 + (x + (index >> 3 & 7))*16 + z + (index >> 6 & 7),
(index, x, y, z) => (y + (index >> 3 & 7))*256 + (x + (index >> 0 & 7))*16 + z + (index >> 6 & 7)
]
let sectionCount = reader.read(32)
let chunks = {}
for (let i = 0; i < sectionCount; i++) {
let x = reader.read(16, true) * 8
let y = reader.read(5, false) * 8 - minHeight
let z = reader.read(16, true) * 8
let orientation = reader.read(3)
let cx = x >> 4
let cz = z >> 4
// Make them into local chunk coords
x = x !== cx * 16 ? 8 : 0
z = z !== cz * 16 ? 8 : 0
let ckey = `${cx},${cz}`
let chunk = chunks[ckey]
if (!chunk) {
chunk = {blocks:[],tags:[]}
chunks[ckey] = chunk
}
let runs = reader.read(8)
let singles = reader.read(9)
for (let j = 0; j < runs; j++) {
let index = reader.read(9)
let types = reader.read(9)
let lenSize = reader.read(4)
for (let k = 0; k < types; k++) {
let chain = reader.read(lenSize) + 1
let block = reader.read(paletteBits)
for (let l = 0; l < chain; l++) {
chunk.blocks[getIndex[orientation](index, x, y, z)] = palette[block]
index++
}
}
}
for (let j = 0; j < singles; j++) {
let index = reader.read(9)
let block = reader.read(paletteBits)
chunk.blocks[getIndex[orientation](index, x, y, z)] = palette[block]
}
}
this.loadFrom = chunks
this.loadKeys = Object.keys(chunks)
this.spawnPoint.y = this.superflat ? 6 : (round(this.noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
Object.assign(this.settings, defaultWorldSettings)
}
loadOldSave(str, onlyMetdata){
let data = str.split(";")
if (!str.includes("Alpha ")) {
return alert("too old")
}
this.name = data.shift()
let worldData = data.shift().split(",")
this.setSeed(parseInt(worldData.shift(), 36),true)
this.time = typeof worldData[0] === "string" ? parseFloat(worldData.shift()) : (worldData.shift(), 375)
this.weather = worldData.shift() || ""
this.nextWeather = parseFloat(worldData.shift()) || this.nextWeather
let inv = this.playersInv[":host"] = {}
let playerData = data.shift().split(",")
inv.x = parseInt(playerData[0], 36)
inv.y = parseInt(playerData[1], 36)
inv.z = parseInt(playerData[2], 36)
let options = parseInt(playerData[5], 36)
let v = data[0].replace("Alpha ","")
this.superflat = options >> 1 & 3
if(this.superflat === 0) this.superflat = false
if(this.superflat === 1) this.superflat = true
if(this.superflat === 2) this.superflat = "island"
if(this.superflat === 3) this.superflat = "void"
this.caves = options >> 4 & 1
this.trees = options >> 5 & 1
this.gameMode = (options >> 6 & 1) ? "survival" : "creative"
this.cheats = this.gameMode === "creative"
let version = data.shift()
this.version = version
this.usePreBeta = !this.superflat //Superflat and other types can be upgraded
if(onlyMetdata) return
// if (version.split(" ")[1].split(".").join("") < 70) {
// 	alert("This save code is for an older version. 0.7.0 or later is needed")
// }
let palletes = data.shift().split("|")
let pallete = palletes[0].split(",").map(n => parseInt(n, 36)), netherPallete = palletes[1] ? palletes[1].split(",").map(n => parseInt(n, 36)) : "", endPallete = palletes[2] ? palletes[2].split(",").map(n => parseInt(n, 36)) : ""
let chunks = {}
if(!verMoreThan(version.replace("Alpha ",""),"0.7.1")){
const blockConvert = this.getBlockConvert()
for(let i=0; i<pallete.length; i++){
if(blockConvert[pallete[i]]){
pallete[i] = blockConvert[pallete[i]]
}
}
}
let dimension = ""
for (let i = 0; data.length; i++) {
let blocks = data.shift().split(",")
if(blocks[0].startsWith("|")){
blocks[0] = blocks[0].substring(1)
if(dimension === "") dimension = "nether"
else if(dimension === "nether") dimension = "end"
else alert("Error: Save string cotains extra dimensions not in this version.")
}
if(!blocks[0]) continue //maybe it was only the "|"
let cx = parseInt(blocks.shift(), 36)
let cy = parseInt(blocks.shift(), 36)
let cz = parseInt(blocks.shift(), 36)
let str = `${cx},${cz},${dimension}`
if (!chunks[str]) chunks[str] = {blocks:[],tags:[]}
let chunk = chunks[str]
var currentPallete = dimension === "nether" ? netherPallete : (dimension === "end" ? endPallete : pallete)
for (let j = 0; j < blocks.length; j++) {
let block, tags
if(blocks[j].includes("/")){
let data = blocks[j].split("/")
block = parseInt(data[0], 36)
try{
tags = parseInt(data[1], 36) || JSON.parse(data[1].replace(/\\x2f/g,"/").replace(/\\x3b/g,";").replace(/\\x2c/g,",").replace(/\\x7c/g,"|"))
}catch(e){
console.error(e,data[1])
}
}else block = parseInt(blocks[j], 36)
// Old index was 0xXYZ, new index is 0xYYXZ
let x = block >> 8 & 15
let y = block >> 4 & 15
let z = block & 15
let index = (cy * 16 + y - minHeight) * 256 + x * 16 + z
let pid = block >> 12
chunk.blocks[index] = currentPallete[pid]
chunk.tags[index] = tags
}
}
this.loadFrom = chunks
this.loadKeys = Object.keys(chunks)
this.spawnPoint.y = this.superflat ? 6 : (round(this.noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
Object.assign(this.settings, defaultWorldSettings)
}
loadInv(reader,p){
let {inventory} = p
inventory.hotbarSlot = reader.read(4)
for(let i=0;i<9;i++){
let id = reader.read(32), amount = reader.read(7)
inventory.hotbar[i] = amount && {id,amount}
}
for(let i=0;i<27;i++){
let id = reader.read(32), amount = reader.read(7)
inventory.main[i] = amount && {id,amount}
}
let durability = reader.read(4), durabilityInv = reader.read(5)
for(let i=0;i<durability;i++){
let index = reader.read(4)
inventory.hotbar[index].durability = reader.read(16)
}
for(let i=0;i<durabilityInv;i++){
let index = reader.read(5)
inventory.main[index].durability = reader.read(16)
}
let customName = reader.read(4), customNameInv = reader.read(5)
for(let i=0;i<customName;i++){
let index = reader.read(4)
let name = reader.readString()
inventory.hotbar[index].customName = name
}
for(let i=0;i<customNameInv;i++){
let index = reader.read(5)
let name = reader.readString()
inventory.main[index].customName = name
}
let achievmentLen = reader.read(32)
p.achievments.length = 0
for(let i=0;i<achievmentLen;i++){
p.achievments.push(reader.read(32))
}
}
loadOldInv(str,p){
let arr = str.split("|")
let inv = arr[1].split(",")
let hotb = arr[0].split(",")
inventory.hotbar = []
for(let i=0; i<18; i+=2){
if(hotb[i]){
inventory.hotbar.push({
id: parseInt(hotb[i]) || 0,
amount: parseInt(hotb[i+1]) || 0
})
}else inventory.hotbar.push(0)
}
inventory.main = []
for(let i=0; i<inv.length; i+=2){
if(inv[i]){
inventory.main.push({
id: parseInt(inv[i]) || 0,
amount: parseInt(inv[i+1]) || 0
})
}else inventory.main.push(0)
}
if(arr.length < 3) return
inv = arr[3].split(",")
hotb = arr[2].split(",")
for(let i=0; i<len; i++){
hotb[i] = parseInt(hotb[i]) || 0
if(hotb[i] && inventory.hotbar[i]){
inventory.hotbar[i].durability = hotb[i]
}
}
for(let i=0; i<inv.length; i++){
inv[i] = parseInt(inv[i]) || 0
if(inv[i] && inventory.main[i]){
inventory.main[i].durability = inv[i]
}
}
if(arr.length < 5) return
inv = arr[5].split(",")
hotb = arr[4].split(",")
for(let i=0; i<len; i++){
if(hotb[i]){
inventory.hotbar[i].customName = hotb[i]
}
}
for(let i=0; i<inv.length; i++){
if(inv[i]){
inventory.main[i].customName = inv[i]
}
}
}
getInv(p){
let {inventory} = p
let bab = new BitArrayBuilder()
bab.add(inventory.hotbarSlot,4)
for(let i of inventory.hotbar){
bab.add(i && i.id || 0,32)
bab.add(i && i.amount || 0, 7)
}
for(let i of inventory.main){
bab.add(i && i.id || 0,32)
bab.add(i && i.amount || 0, 7)
}
let durability = [], durabilityInv = []
let customName = [], customNameInv = []
for(let i in inventory.hotbar){
let j = inventory.hotbar[i]
if(j){
if(j.durability) durability.push(+i,j.durability)
if(j.customName) customName.push(+i,j.customName)
}
}
for(let i in inventory.main){
let j = inventory.main[i]
if(j){
if(j.durability) durabilityInv.push(+i,j.durability)
if(j.customName) customNameInv.push(+i,j.customName)
}
}
bab.add(durability.length/2,4).add(durabilityInv.length/2,5)
for(let i=0; i<durability.length; i+=2) bab.add(durability[i],4).add(durability[i+1],16)
for(let i=0; i<durabilityInv.length; i+=2) bab.add(durabilityInv[i],5).add(durabilityInv[i+1],16)
bab.add(customName.length/2,4).add(customNameInv.length/2,5)
for(let i=0; i<customName.length; i+=2){
bab.add(customName[i],4)
bab.addString(customName[i+1],8)
}
for(let i=0; i<customNameInv.length; i+=2){
bab.add(customNameInv[i],5)
bab.addString(customNameInv[i+1],8)
}
bab.add(p.achievments.length,32)
for(let i of p.achievments){
bab.add(i,32)
}
return bab
}
setResourcePacks(active){
this.activeResourcePacks.length = 0
this.activeResourcePacks.push(...active)
this.sendAll({type:"resourcePacks",activeResourcePacks:this.activeResourcePacks})
}
loadMod(code){
this.mod = code
if(this.modContainer){
this.modContainer.contentWindow.postMessage({close:true})
this.modContainer.remove()
}
//const modURL = window.URL.createObjectURL(new Blob([document.querySelector('#modPreCode').text,"const host="+(host?"true":"false")+"\n",data], { type: "text/javascript" }))
const sandboxURL = window.URL.createObjectURL(new Blob([`
<!doctype html>
<html><head><meta charset="utf-8"></head><body><script>
let worker
addEventListener('message',e => {
if(e.data.createWorker){
const workerURL = window.URL.createObjectURL(new Blob(e.data.data, { type: "text/javascript" }))
worker = new Worker(workerURL)
worker.onmessage = e => {
window.parent.postMessage(e.data, "*")
}
}else if(e.data.close){
worker.terminate()
}else{
worker.postMessage(e.data)
}
})
window.parent.postMessage({ready:true}, "*")
<\/script></body></html>
`], { type: 'text/html' }))
let mod = this.modContainer = document.createElement("iframe")//new Worker(modURL)
mod.src = sandboxURL
mod.className = "hidden"
mod.sandbox = "allow-scripts"
doc.body.appendChild(mod)
let world = this
const safeFunctions = ["getBlock","setBlock","getTags","setTags","getTagByName","setTagByName"]
const safeGlobalFunctions = {showTitle,sideMessage,customMenu,safeEval}
mod.messageListener = addEventListener('message',e => {
if(e.source !== mod.contentWindow) return
if(e.data.ready){
mod.contentWindow.postMessage({
createWorker:true,
data:[
document.querySelector('#modPreCode').text.replace("SAFEFUNCTIONS",JSON.stringify(safeFunctions)).replace("SAFEGLOBALFUNCTIONS",JSON.stringify(Object.keys(safeGlobalFunctions)))+"\n",
"const host="+(host?"true":"false")+"\n",code
]
},"*")
}else{
const {data} = e
if(safeFunctions.includes(data.action)){
mod.contentWindow.postMessage({id:data.id,data:world[data.action](...data.data)},"*")
}else if(safeGlobalFunctions[data.action]){
mod.contentWindow.postMessage({id:data.id,data:safeGlobalFunctions[data.action](...data.data)},"*")
}
}
})
}
getSurvivStr(p){
let bab = new BitArrayBuilder()
//position
bab.add(round(p.x), 20).add(round(p.y), 11).add(round(p.z), 20)
bab.add(p.dimension === "nether" ? 1 : (p.dimension === "end" ? 2 : 0),3)
bab.add(p.rx * 100, 11).add(p.ry * 100, 11)
bab.add(p.flying, 1).add(p.gameMode==="spectator", 1)
//survival stuff like player health
bab.add(round(p.health),5)
bab.add(0,28)//unused
bab.add(p.spawnPoint.x,20).add(p.spawnPoint.y,20).add(p.spawnPoint.z,20)
bab.add(p.food,5).add(p.foodSaturation,5).add(p.foodExhaustion,2)
bab.add(p.oxygen,5)
bab.add(p.gameMode==="survival"?1:(p.gameMode==="hardcore"?2:0),2).add(p.cheats?1:0,1)
bab.add(p.freezeEffect,8)
bab.add(p.XP*100,16).add(p.level,16)
bab.add(p.didEndPoem?1:0,1)
bab.add(p.lastY,11)
let effects = Object.keys(p.effects)
bab.add(effects.length,8)
for(let i of effects){
bab.addBasicString(i)
bab.add(p.effects[i].level,8)
bab.add(p.effects[i].time,32)
bab.add(p.effects[i].showParticles ? 1 : 0, 1)
}
bab.addBasicString(p.riding||"")
bab.add(p.doingPortal,32)
return bab
}
loadSurvivStr(reader,preBetaVersion,p){
p.x = reader.read(20, true)
p.y = preBetaVersion ? reader.read(8) : reader.read(11,true)
p.z = reader.read(20, true)
let d = reader.read(3)
p.dimension = d === 1 ? "nether" : (d === 2 ? "end" : "")
p.rx = reader.read(11, true) / 100
p.ry = reader.read(11, true) / 100
p.flying = reader.read(1)
let spectator = reader.read(1)
p.health = reader.read(5)
reader.skip(28)//unused
p.spawnPoint.x = reader.read(20,true)
p.spawnPoint.y = reader.read(20,true)
p.spawnPoint.z = reader.read(20,true)
p.food = reader.read(5)
p.foodSaturation = reader.read(5)
p.foodExhaustion = reader.read(2)
p.oxygen = reader.read(5)
let survival = reader.read(2)
if(spectator) p.gameMode = "spectator"
else if(survival === 0) p.gameMode = "creative"
else if(survival === 1) p.gameMode = "survival"
else if(survival === 2) p.gameMode = "hardcore"
//survival = survival === 1 ? true : (survival === 2 ? "hardcore" : false)
p.cheats = Boolean(reader.read(1))
p.freezeEffect = reader.read(8)
p.XP = reader.read(16)/100
p.level = reader.read(16); p.setLevel()
p.didEndPoem = Boolean(reader.read(1))
p.lastY = preBetaVersion ? reader.read(8) : reader.read(11,true)
let effectsLen = reader.read(8)
p.effects = {}
for(let i=0; i<effectsLen; i++){
p.effects[reader.readBasicString()] = {level:reader.read(8), time:reader.read(32), showParticles:reader.read(1)}
}
p.riding = reader.readBasicString() || null
if(reader.canRead) p.doingPortal = reader.read(32)
}
onpos(){
/*let entities = this.getEntities(), arr = [], length = 0
for(let i=0; i<entities.length; i++){
let ent = entities[i]
let l = ent.length
if(length+l > 10000){
this.sendAll({type:"entityPosAll", data: arr})
length = 0
arr.length = 0
}
length += l
arr.push(ent)
}
if(length) this.sendAll({type:"entityPosAll", data: arr})*/
this.sendAll({type:"settings", data:this.settings, time:this.time, weather:this.weather})
}
//c must be a connection: {send: function, onmessage, onclose, close: function}	
/*p: {
loadChunks: chunks that need to be sent to player,
loadDistance
update,
updateingLoaded,
updateingLoadedI
}*/
getPlayersInv(){
for(let p of this.players) p.saveInv()
return this.playersInv
}
serverAddPlayer(c, id, username, host = false, admin = false){
let p = new Player()
p.id = id
p.host = host
p.connection = c
p.admin = admin
p.loadChunks = [], p.loadDistance = 0
p.posUpdated = {} //List of updated player positions
for(let p2 of this.players){
if(p2.pos && p2 !== p) p.posUpdated[p2.id] = p2.pos
}
p.lastSendEntities = 0
p.updateingLoadedI = 0
p.world = this
p.inventory.slotMapPlace = new Map()
p.inventory.slotMapIdx = new Map()
p.inventory.prevSlots = []
this.players.push(p)
let world = this
function sendOthers(msg){
for(let p2 of world.players){
if(p2 !== p) p2.connection.send(msg)
}
}
c.onmessage = async function(data){
if(data.type === "connect"){
username = p.username = username || data.username
await Promise.all(world.loadPromises)
//let saveStr = world.getSaveString()
p.cheats = world.cheats//will be overwritten if inv exists
p.gameMode = world.gameMode
p.respawn()
let inv = world.playersInv[host ? ":host" : username]
if(inv){//older stuff
if(typeof inv.inv === "string"){
inv.inv = atoarr(inv.inv)
}
if(typeof inv.survivStr === "string"){
inv.survivStr = atoarr(inv.survivStr)
}
if(inv.survivStr && inv.survivStr.length){
world.loadSurvivStr(new BitArrayReader(inv.survivStr),false,p)
}
if(inv.inv && inv.inv.length){
world.loadInv(new BitArrayReader(inv.inv),p)
}
}
c.send({
type:"loadSave",
name:world.name,
mod: world.mod,
id: world.id,
inv,
//resourcePacks:world.resourcePacks,
activeResourcePacks:world.activeResourcePacks,
x:p.x,
y:p.y,
z:p.z,
version:world.version,
weather:world.weather,
time:world.time,
gameMode:p.gameMode,
cheats:p.cheats,
hotbarSlot:p.inventory.hotbarSlot,
flying:p.flying,
achievments:p.achievments
})
c.send({
type:"serverCmds",
data:world.commandNodes.map(r => ({type:r.type,name:r.name,id:r.id,next:r.next,redirect:r.redirect,info:r.info,argType:r.argType,func:Boolean(r.func||r.anonymousFunc),noCheats:r.noCheats}))
})
p.sendHealth()
p.setRot(p.rx,p.ry,p.bodyRot,true)
p.sendEffects()
sendOthers(data)
}else if(data.type === "pos"){
let pos = data.data
p.setPos(pos.x,pos.y,pos.z,pos.velx,pos.vely,pos.velz)
p.setRot(pos.rx, pos.ry, pos.bodyRot)
p.onGround = pos.onGround
p.sneaking = pos.sneaking
p.harmEffect = pos.harmEffect
/*if(thisplayer.username !== pos.username){
thisplayer.username = pos.username
//thisplayer.changeBlock(abs((pos.username || "").hashCode()) % 80 + 1)
}*/
p.crack = pos.crack //crack number
p.walking = pos.walking
p.sprinting = pos.sprinting
p.punchEffect = pos.punchEffect
p.eating = pos.eating
p.sleeping = pos.sleeping
p.sitting = pos.sitting
p.swimming = pos.swimming
p.usingItem = pos.usingItem
p.spectating = pos.spectating
p.afk = data.afk
p.scale = pos.scale
p.riding = pos.riding
p.flying = pos.flying
pos.username = username
pos.burning = p.burning
pos.holding = p.holding
pos.die = p.die
pos.crackPos = p.crackPos
pos.dimension = p.dimension
p.pos = data
for(let p2 of world.players){
if(p2 !== p && p2.pos) p2.posUpdated[id] = p.pos
}
for(let u in p.posUpdated){
if(p.posUpdated[u]){
c.send(p.posUpdated[u])
p.posUpdated[u] = null
}
}
let now = performance.now()
if(now - p.lastSendEntities > 125){
p.lastSendEntities = now
let entities = world.getEntities(p), arr = [], length = 0
for(let i=0; i<entities.length; i++){
let ent = entities[i]
let l = ent.length
if(length+l > 10000){
p.connection.send({type:"entityPosAll", data: arr})
length = 0
arr.length = 0
}
length += l
arr.push(ent)
}
if(length) p.connection.send({type:"entityPosAll", data: arr})
}
if(p.resendHealth){
p.sendHealth()
p.resendHealth = false
}
if(p.resendEffects){
p.sendEffects()
p.resendEffects = false
}
updateContainer()
c.send({type:"canSendPos"})
}else if(data.type === "loadChunks"){
p.updateingLoadedI++
p.loadDistance = data.loadDistance
p.loadChunks = data.data
p.dimension = data.dimension
world.loadedUpdate = true
}else if(data.type === "mySkin" || data.type === "particles" || data.type === "achievment" || data.type === "harmEffect" || data.type === "playSound" || data.type === "title" || data.type === "joined"){
sendOthers(data)
}else if(data.type === "hit"){
if(data.isEntity){
let ent = world.entities[world.getEntity(data.TO)]
if(ent) ent.onhit(data.damage,false, data.velx,data.velz, data.id)
}else world.sendPlayer(data,data.TO)
}else if(data.type === "message"){
data.fromServer = false
data.username = username
sendOthers(data)
}/*else if(data.type === "setBlock"){
let pos = data.data
world.setBlock(pos.x, pos.y, pos.z, pos.block, false, false, true, pos.keepTags, pos.dimension)
world.sendAllInChunk(data, pos.x>>4,pos.z>>4,pos.dimension)
}else if(data.type === "setTags"){
world.setTags(data.x,data.y,data.z,data.data, true, data.dimension, data.lazy)
sendOthers(data)
}*/else if(data.type === "serverChangeBlock"){
world.serverChangeBlock(data.x,data.y,data.z,data.dimension,data.place,p,data.face,data.shift,data.blockMode)
}else if(data.type === "entityPos"){
let ent = world.posEntity(new BitArrayReader(data.data, true), true)
return world.deleteEntity(ent.id)
sendOthers(data)
}else if(data.type === "entityDelete"){
world.deleteEntity(data.id, true)
sendOthers(data)
}/*else if(data.type === "entEvent"){
var ent = world && world.entities[world.getEntity(data.id)]
if(!ent) return
if(data.event === "itemAmount"){
ent.amount = data.data
}else if(data.event === "damageMob"){
ent.onhit(data.data.damage,true,data.data.vx,data.data.vz,data.data.from)
}else if(data.event === "creeperForceExplode"){
ent.forceExplode(true)
}else if(data.event === "sheepFur"){
ent.fur = data.data
}else if(data.event === "sheepEat"){
ent.eating = 1
}else if(data.event === "sheepColor"){
ent.color = data.data.color
ent.wool = data.data.wool
}else if(data.event === "mobAttack"){
ent.attackCooldown = ent.maxAttackCooldown
}else if(data.event === "tame"){
ent.tame = true
ent.owner = data.data
}else if(data.event === "wolfCollarColor"){
ent.color = data.data
}else if(data.event === "sit"){
ent.sitting = data.data
}else if(data.event === "tp"){
ent.x = data.data.x
ent.y = data.data.y
ent.z = data.data.z
ent.lastY = 0
if(ent.path) ent.path = null
}else if(data.event === "wolfTarget"){
ent.target = data.data
}else if(data.event === "healthAdd"){
ent.health += data.data
}else if(data.event === "name"){
ent.name = data.data
}
sendOthers(data)
}else if(data.type === "kill"){
if(data.data === "@a"){
sendOthers({type:"kill",data:data.message})
}else{
world.sendPlayerName({
type:"kill",
data:data.message
}, data.data)
}
}*/else if(data.type === "remoteControl"){
if(host || admin) world.sendPlayer(data,data.TO)
}else if(data.type === "runCmd"){
runCmd(data.data,p,world,false, (output,newOutputs) => {
for(let i=0; i<newOutputs.length; i+=2) c.send({type:"message",data:newOutputs[i],fromServer:true})
}, p.cheats)
//runCmdFromClient(data.data,data.args,p,data.scope||{},world,data.id,p.cheats)
}else if(data.type === "openContainer"){
p.inventory.containerData.x = data.x
p.inventory.containerData.y = data.y
p.inventory.containerData.z = data.z
p.inventory.containerData.dimension = data.dimension
orderInvSlots(data.data)
if(data.data === "inventory") p.addAchievment("Taking Inventory")
}else if(data.type === "containerChange"){
let {inventory} = p
check:{
if(data.data.length === 1){
let pitem = getSlot(data.idxs[0])
let nitem = data.data[0]//drop item is allowed
if(pitem && (!nitem || nitem.amount < pitem.amount && nitem.id === pitem.id && (!nitem.customName && !pitem.custonName || nitem.customName === pitem.customName) && nitem.durability === pitem.durability)){
let change = nitem ? pitem.amount-nitem.amount : pitem.amount
let d = p.direction
let place = inventory.slotMapPlace.get(data.idxs[0])
if(p.survival || place !== "holding" && p.cheats) world.addItems(p.x, p.y, p.z, p.dimension, d.x/4, d.y/4, d.z/4, pitem.id, false, change,pitem.durability,pitem.customName,p.id)
break check
}
}
let nmap = new Map(), pmap = new Map()//new, previous
for(let i=0; i<data.data.length; i++){//check for correctness
let nitem = data.data[i]
if(nitem && nitem.amount > blockData[nitem.id].stackSize) return updateContainer(true)
let pitem = getSlot(data.idxs[i])
if(nitem){
let nname = nitem.id+"|"+(nitem.customName||"")
nmap.set(nname,(nmap.get(nname)||0)+nitem.amount)
}
if(pitem){
let pname = pitem.id+"|"+(pitem.customName||"")
pmap.set(pname,(pmap.get(pname)||0)+pitem.amount)
}
let place = inventory.slotMapPlace.get(data.idxs[i])
if((place === "craftingResult" || place === "furnaceOutput" || place === "anvilOutput") && nitem) return updateContainer(true)//cant put things in this slot
if(place === "anvilOutput" && inventory.anvilCost>p.level && p.survival) return updateContainer(true)
}
if(p.survival && !compareMaps(nmap,pmap)) return updateContainer(true)
/*for(let i=0; i<data.data.length; i++){//check for correctness
let ritem = data.data[i]
let item = getSlot(data.idxs[i])
if(ritem){
if(ritem.amount > blockData[ritem.id].stackSize || ritem.id !== first.id || ritem.customName !== first.customName) return orderInvSlots()
reqTotal += ritem.amount
}
if(item){
if(item.id !== first.id || item.customName !== first.customName) return orderInvSlots()
toTotal += item.amount
}
}
if(toTotal !== reqTotal) return orderInvSlots()*/
}
let craftUpdate, craftRes, anvilUpdate, anvilIn, anvilOut
for(let i=0; i<data.data.length; i++){
let prev = getSlot(data.idxs[i])
setSlot(data.idxs[i], data.data[i])
let place = inventory.slotMapPlace.get(data.idxs[i])
if(place === "crafting2" || place === "crafting3"){
craftUpdate = true
}
if(place === "craftingResult" && prev) craftRes = true
if(place === "anvilInput" || place === "anvilMaterial" || place === "anvilOutput"){
anvilUpdate = true
if(place === "anvilInput") anvilIn = true
if(place === "anvilOutput" && prev) anvilOut = prev
}
}
if(craftUpdate) updateCraftingGrid()
if(craftRes){//decrease amount
let res = crafts[inventory.craftingName]
let crafting = inventory.currentContainer === "crafting" ? inventory.crafting3 : inventory.crafting2
for(let i=0; i< (inventory.currentContainer === "crafting" ? 9 : 4); i++){
let block = crafting[i]
if(block && block.id){
if(res.replace && res.replace[blockData[block.id].name]){
block.id = blockIds[res.replace[blockData[block.id].name]]
}else{
block.amount --
if(block.amount <= 0) crafting[i] = null
}
}
}
let r = res.id
if(r === blockIds.craftingTable){
p.addAchievment("Benchmaking")
}else if(r && blockData[r].pickaxe){
p.addAchievment("Time to Mine!")
}else if(r === blockIds.stonePickaxe){
p.addAchievment("Getting an Upgrade")
}else if(r === blockIds.bread){
p.addAchievment("Bake Bread")
}else if(r && blockData[r].sword){
p.addAchievment("Time to Strike!")
}else if(r && blockData[r].hoe){
p.addAchievment("Time to Farm!")
}else if(r && blockData[r].bed){
p.addAchievment("Make a bed")
}
p.addDiscovery(r)
updateCraftingGrid()
}
if(anvilIn){
let item = inventory.anvilInput
inventory.anvilRename = item ? (item.customName || blockData[item.id].Name) : ""
}
if(anvilOut){
if(inventory.anvilInput && inventory.anvilInput.durability && inventory.anvilInput.durability !== anvilOut.durability){
inventory.anvilMaterial.amount--
if(inventory.anvilMaterial.amount <= 0) inventory.anvilMaterial = null
}
inventory.anvilInput = null
if(p.survival){
p.level -= inventory.anvilCost
p.setLevel()
p.resendHealth = true
}
world.playSound(p.x,p.y,p.z,"anvil.land")
setTimeout(()=>world.playSound(p.x,p.y,p.z,"anvil.land"),500)
setTimeout(()=>world.playSound(p.x,p.y,p.z,"anvil.land"),1000)
}
if(anvilUpdate) updateAnvil()
}else if(data.type === "hotbar"){
p.inventory.hotbarSlot = data.slot
}else if(data.type === "containerChangeAnvil"){
p.inventory.anvilRename = data.rename
updateAnvil()
}else if(data.type === "containerChangeCommandBlock"){
let {containerData} = p.inventory
world.setTagByName(containerData.x,containerData.y,containerData.z,"data",data.data,false,containerData.dimension)
}else if(data.type === "containerChangeSign"){
let {containerData} = p.inventory
world.setTagByName(containerData.x,containerData.y,containerData.z,data.side?"text2":"text",data.data,false,containerData.dimension)
}else if(data.type === "entInteract"){
world.entInteract(data.data,data.hit,data.cooldown,p)
}else if(data.type === "respawn"){
if(p.die){
if(p.gameMode === "hardcore"){
p.gameMode = "spectator"
p.health = 1
c.send({type:"gameMode",gameMode:p.gameMode})
}else p.respawn()
p.sendHealth()
c.send({type:"respawn"})
}
}else if(data.type === "gameMode"){
if(p.cheats){
p.gameMode = data.gameMode
c.send({type:"gameMode",gameMode:p.gameMode})
}
}else if(data.type === "jump"){
if(p.survival) p.foodExhaustion += p.sprinting ? 0.2 : 0.05
}else if(data.type === "startBreak"){
p.crackPos[0] = data.x
p.crackPos[1] = data.y
p.crackPos[2] = data.z
p.breakStart = Date.now()
}
}
c.onclose = function(){
p.saveInv()
let i = world.players.indexOf(p)
if(i !== -1) world.players.splice(i,1)
for(let p2 of world.players){
delete p2.posUpdated[id]
}
world.sendAll({type:"dc",data:p.id})
}
p.updateLoaded = async function(){
for(let i=0; i<9; i++){
let item = p.inventory.hotbar[i]
if(!item) continue
if(blockData[item.id].durability){
if(typeof item.durability !== "number"){
item.durability = blockData[item.id].durability
}else if(item.durability <= 0){
p.inventory.hotbar[i] = 0
world.playSound(p.x,p.y,p.z,"random.break")
}
}
}
if(this.updateingLoaded || p.doingPortal) return
let id = this.updateingLoadedI
this.updateingLoaded = true
for(let i=0; i<p.loadChunks.length; i+=2){
if(this.updateingLoadedI !== id) break
let x = p.loadChunks[i], z = p.loadChunks[i+1]
let chunk = world.getChunk(x*16,z*16,p.dimension)
if(chunk && chunk.allGenerated){
if(host) c.send({type:"chunkData",x,z})
else c.send({
type:"chunkData",
x,z,
data:await chunk.getData(),
tops:chunk.tops,
solidTops:chunk.solidTops,
biomes:chunk.biomes,
caveY:chunk.caveY,
caveBiomes:chunk.caveBiomes
})
p.loadChunks.splice(i,2)
i -= 2
}
}
this.updateingLoaded = false
}
function orderInvSlots(currentContainer = p.inventory.currentContainer){
let prev = p.inventory.currentContainer
if(prev !== currentContainer){
if(prev === "inventory"){//make things drop
for(let i=0; i<4; i++) dropSlot(p.inventory.slotIds.crafting2[i])
p.inventory.craftingResult = null
}else if(prev === "crafting"){
for(let i=0; i<9; i++) dropSlot(p.inventory.slotIds.crafting3[i])
p.inventory.craftingResult = null
}else if(prev === "anvil"){
dropSlot(p.inventory.slotIds.anvilInput)
dropSlot(p.inventory.slotIds.anvilMaterial)
p.inventory.anvilOutput = null
}
}
p.inventory.currentContainer = currentContainer
let id = 0
p.inventory.slotMapPlace.clear()
p.inventory.slotMapIdx.clear()
p.inventory.slotMapPlace.set(id,"holding"), p.inventory.slotIds.holding = id++
if(currentContainer === "inventory"){
for(let i=0; i<4; i++) p.inventory.slotMapPlace.set(id,"crafting2"), p.inventory.slotMapIdx.set(id,i), p.inventory.slotIds.crafting2[i] = id++
p.inventory.slotMapPlace.set(id,"craftingResult"), p.inventory.slotIds.craftingResult = id++
}else if(currentContainer === "crafting"){
for(let i=0; i<9; i++) p.inventory.slotMapPlace.set(id,"crafting3"), p.inventory.slotMapIdx.set(id,i),  p.inventory.slotIds.crafting3[i] = id++
p.inventory.slotMapPlace.set(id,"craftingResult"), p.inventory.slotIds.craftingResult = id++
}else if(currentContainer === "furnace"){
p.inventory.slotMapPlace.set(id,"furnaceInput"), p.inventory.slotIds.furnaceInput = id++
p.inventory.slotMapPlace.set(id,"furnaceOutput"), p.inventory.slotIds.furnaceOutput = id++
p.inventory.slotMapPlace.set(id,"furnaceFuel"), p.inventory.slotIds.furnaceFuel = id++
}else if(currentContainer === "chest"){
for(let i=0; i<27; i++) p.inventory.slotMapPlace.set(id,"chest"), p.inventory.slotMapIdx.set(id,i),  p.inventory.slotIds.chest[i] = id++
}else if(currentContainer === "anvil"){
p.inventory.slotMapPlace.set(id,"anvilInput"), p.inventory.slotIds.anvilInput = id++
p.inventory.slotMapPlace.set(id,"anvilMaterial"), p.inventory.slotIds.anvilMaterial = id++
p.inventory.slotMapPlace.set(id,"anvilOutput"), p.inventory.slotIds.anvilOutput = id++
}else if(currentContainer === "dispenser"){
for(let i=0; i<9; i++) p.inventory.slotMapPlace.set(id,"dispenser"), p.inventory.slotMapIdx.set(id,i),  p.inventory.slotIds.dispenser[i] = id++
}else if(currentContainer === "hopper"){
for(let i=0; i<5; i++) p.inventory.slotMapPlace.set(id,"hopper"), p.inventory.slotMapIdx.set(id,i),  p.inventory.slotIds.hopper[i] = id++
}
for(let i=0; i<27; i++) p.inventory.slotMapPlace.set(id,"main"), p.inventory.slotMapIdx.set(id,i), p.inventory.slotIds.main[i] = id++
for(let i=0; i<9; i++) p.inventory.slotMapPlace.set(id,"hotbar"), p.inventory.slotMapIdx.set(id,i), p.inventory.slotIds.hotbar[i] = id++
updateContainer(true)//c.send({type:"containerData",data:arr})
}
function getSlot(id){
let containerData = p.inventory.containerData
let place = p.inventory.slotMapPlace.get(id), idx = p.inventory.slotMapIdx.get(id)
if(place === "hotbar" || place === "main" || place === "crafting2" || place === "crafting3"){
return p.inventory[place][idx]
}else if(place === "holding" || place === "craftingResult" || place === "anvilInput" || place === "anvilMaterial" || place === "anvilOutput"){
return p.inventory[place]
}else if(place === "furnaceInput"){
return containerData.data.input
}else if(place === "furnaceOutput"){
return containerData.data.output
}else if(place === "furnaceFuel"){
return containerData.data.fuel
}else if(place === "chest" || place === "dispenser" || place === "hopper"){
return containerData.data.contents[idx]
}
}
function setSlot(id,item){
let containerData = p.inventory.containerData
let place = p.inventory.slotMapPlace.get(id), idx = p.inventory.slotMapIdx.get(id)
if(place === "hotbar" || place === "main" || place === "crafting2" || place === "crafting3"){
p.inventory[place][idx] = item
}else if(place === "holding" || place === "craftingResult" || place === "anvilInput" || place === "anvilMaterial" || place === "anvilOutput"){
p.inventory[place] = item
}else if(place === "furnaceInput"){
containerData.data.input = item
world.updateTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
}else if(place === "furnaceOutput"){
containerData.data.output = item
world.updateTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
}else if(place === "furnaceFuel"){
containerData.data.fuel = item
world.updateTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
}else if(place === "chest" || place === "dispenser" || place === "hopper"){
containerData.data.contents[idx] = item
world.updateTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
}
let len = p.inventory.slotMapPlace.size
let prevSlots = p.inventory.prevSlots
if(item){//prevent updating
prevSlots[id] = item.id
prevSlots[id+len] = item.amount
prevSlots[id+len*2] = item.customName
prevSlots[id+len*3] = item.durability
}else prevSlots[id] = null
}
function dropSlot(id){
let item
let place = p.inventory.slotMapPlace.get(id), idx = p.inventory.slotMapIdx.get(id)
if(place === "crafting2" || place === "crafting3"){
item = p.inventory[place][idx]
p.inventory[place][idx] = null
}
if(place === "anvilInput" || place === "anvilMaterial" || place === "anvilOutput"){
item = p.inventory[place]
p.inventory[place] = null
}
if(item){
let d = p.direction
world.addItems(p.x, p.y, p.z, p.dimension, d.x/4, d.y/4, d.z/4, item.id, false, item.amount,item.durability,item.customName,p.id)
}
}
let tempCraftGrid = new Array(9)
function updateCraftingGrid(){
let parr = (p.inventory.currentContainer === "crafting" ? p.inventory.crafting3 : p.inventory.crafting2)
let arr = tempCraftGrid
if(p.inventory.currentContainer === "crafting"){
for(let i=0; i<9; i++) arr[i] = parr[i] ? parr[i].id : 0
}else{
arr.fill(0)
arr[0] = parr[0] ? parr[0].id : 0
arr[1] = parr[1] ? parr[1].id : 0
arr[3] = parr[2] ? parr[2].id : 0
arr[4] = parr[3] ? parr[3].id : 0
}
let craft = getCraft(arr)
if(craft){
let c = crafts[craft]
p.inventory.craftingResult = {id:c.id,amount:c.amount}
p.inventory.craftingName = craft
}else{
let shapeless = shapelessCraft(arr)
if(shapeless){
let c = crafts[shapeless]
p.inventory.craftingResult = {id:c.id,amount:c.amount}
p.inventory.craftingName = shapeless
}else{
p.inventory.craftingResult = null
p.inventory.craftingName = null
}
}
}
function updateAnvil(){
let {inventory} = p
inventory.anvilCost = 0
if(inventory.anvilInput){
let {id,amount,durability} = inventory.anvilInput
inventory.anvilOutput = {id,amount,durability}
if(inventory.anvilRename !== blockData[id].Name){
inventory.anvilOutput.customName = inventory.anvilRename
inventory.anvilCost++
}
if(blockData[id].durability && blockData[id].material && inventory.anvilMaterial){
let materialName = blockData[inventory.anvilMaterial.id].name
let maxDurability = blockData[id].durability
if(blockData[id].material === materialName){
inventory.anvilOutput.durability += maxDurability/4
if(inventory.anvilOutput.durability > maxDurability) inventory.anvilOutput.durability = maxDurability
inventory.anvilCost++
}
}
}else inventory.anvilOutput = 0, anvilTextbox.value = ""
c.send({type:"containerChangeAnvil",rename:inventory.anvilRename,cost:inventory.anvilCost})
}
function updateContainer(redoAll){//done at differing intervals
if(!p.inventory.currentContainer) return
//below: for containers
if(p.inventory.currentContainer === "furnace" || p.inventory.currentContainer === "chest" || p.inventory.currentContainer === "dispenser" || p.inventory.currentContainer === "hopper"){
let containerData = p.inventory.containerData
let tags = world.getTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
let block = world.getBlock(containerData.x, containerData.y, containerData.z,containerData.dimension)
let {currentContainer} = p.inventory
const bname = blockData[block].name
if(currentContainer === "furnace" && bname === "furnace" || currentContainer === "chest" && (bname === "chest" || bname === "barrel") || currentContainer === "dispenser" && (bname === "dispenser" || bname === "dropper") || currentContainer === "hopper" && bname === "hopper"){
if(!tags || !tags.contents){
tags = blockData[block].setContents(containerData.x,containerData.y,containerData.z,containerData.dimension,world)
}
}else{
p.inventory.currentContainer = null
c.send({type:"closeContainer"})
return
}
if(p.inventory.currentContainer === "furnace"){
c.send({type:"containerChangeFurnace",burnProgress:tags.burnProgress,progress:tags.progress})
blockData[blockIds.furnace].update(containerData.x,containerData.y,containerData.z,containerData.dimension,world)
}
p.inventory.containerData.data = tags
}else if(p.inventory.currentContainer === "commandBlock" || p.inventory.currentContainer === "sign"){
let containerData = p.inventory.containerData
let tags = world.getTags(containerData.x,containerData.y,containerData.z,containerData.dimension)
let block = world.getBlock(containerData.x, containerData.y, containerData.z,containerData.dimension)
let {currentContainer} = p.inventory
if(currentContainer === "commandBlock" && blockData[block].commandBlock){
if(!tags || !tags.commandBlock){
tags = {commandBlock:true,data:"",output:""}
world.setTags(containerData.x, containerData.y, containerData.z,tags,false,containerData.dimension)
}
}else if(currentContainer === "sign" && blockData[block].sign && tags && tags.sign){
}else{
p.inventory.currentContainer = null
c.send({type:"closeContainer"})
return
}
p.inventory.containerData.data = tags
}
let len = p.inventory.slotMapPlace.size
let prevSlots = p.inventory.prevSlots
if(redoAll) prevSlots.length = 0
let changeData, changeIdx
for(let i=0; i<len; i++){//check for changes
let slot = getSlot(i)
if(slot){
if(redoAll || slot.id !== prevSlots[i] || slot.amount !== prevSlots[i+len] || slot.customName !== prevSlots[i+len*2] || slot.durability !== prevSlots[i+len*3]){
prevSlots[i] = slot.id
prevSlots[i+len] = slot.amount
prevSlots[i+len*2] = slot.customName
prevSlots[i+len*3] = slot.durability
if(!changeData) changeData = [], changeIdx = []
changeData.push(slot), changeIdx.push(i)
}
}else if(redoAll || prevSlots[i] !== null){
prevSlots[i] = null
if(!changeData) changeData = [], changeIdx = []
changeData.push(slot), changeIdx.push(i)
}
}
if(changeData) c.send({type:"containerChange",data:changeData,idxs:changeIdx})
}
}
sendAll(msg){
for(let p of this.players) p.connection.send(msg)
}
sendPlayerName(msg, to){
for(var p of this.players){
if(p.username === to){
p.connection.send(msg)
}
}
}
sendPlayer(msg, to){
for(var p of this.players){
if(p.id === to){
p.connection.send(msg)
}
}
}
sendAllInChunk(msg,x,z,dimension){
for(let p of this.players){
if(p.dimension === dimension && maxDist(x,z,round(p.x/16),round(p.z/16)) <= p.loadDistance){
p.connection.send(msg)
}
}
}
/*requestAllInvs(){
let promises = []
for(let p of this.players){
promises.push(new Promise(resolve => p.connection.onGetInv = resolve))
p.connection.send({type:"shouldSendInv"})
}
return Promise.all(promises)
}*/
close(){
sendAllWorkers({deleteSeed:this.worldSeed})
for(let p of this.players) p.connection.close()
clearInterval(this.pos)
if(this.modContainer){
this.modContainer.contentWindow.postMessage({close:true})
this.modContainer.remove()
}
}
}
win.ServerWorld = World
function initServerEverything(logInitialized){
initBlockData()
logInitialized("Initialized server block data.")
initShapes()
logInitialized("Initialized server shapes.")
sendAllWorkers({blockIds:generateBlockIds,biomeIds,blockStates:{CROSS,LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,isCube}})
}
win.initServerEverything = initServerEverything
}